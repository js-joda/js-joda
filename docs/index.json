[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "packages/core/src/Clock.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail, requireNonNull } from './assert';\nimport { Instant } from './Instant';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\n\n/**\n * A clock providing access to the current instant, date and time using a time-zone.\n *\n * Instances of this class are used to find the current instant, which can be\n * interpreted using the stored time-zone to find the current date and time.\n * As such, a clock can be used instead of {@link System#currentTimeMillis}\n * and {@link TimeZone#getDefault}.\n *\n * Use of a {@link Clock} is optional. All key date-time classes also have a\n * `now()` factory method that uses the system clock in the default time zone.\n * The primary purpose of this abstraction is to allow alternate clocks to be\n * plugged in as and when required. Applications use an object to obtain the\n * current time rather than a static method. This can simplify testing.\n *\n * Best practice for applications is to pass a {@link Clock} into any method\n * that requires the current instant.\n *\n * This approach allows an alternate clock, such as {@link fixed}\n * or {@link offset} to be used during testing.\n *\n * The {@link system} factory methods provide clocks based on the best available\n * system clock This may use {@link System#currentTimeMillis}, or a higher\n * resolution clock if one is available.\n *\n * The javascript Clock implementation differs from the openjdk.\n *\n * Javascript only provides the UTC millis of epoch and the ZoneOffset in minutes of the system default time.\n * Javascript do not provide the system default ZoneId.\n *\n * the system default ZoneId is only guessable by the ZoneOffset, like moment-timezone does by returning one ZoneId\n * with the same ZoneOffset.\n *\n * Therefore we are doing a shortcut here, by defining a SystemUTCClock and a SystemDefaultClock, the Clock itself\n * is returning the ZoneOffset and not the ZoneRules as in the jdk. We should change it, when introducing the iana\n * timezone database and implementing the timezone domains.\n *\n */\n\nexport class Clock {\n    /**\n     * Obtains a clock that returns the current instant using the\n     * system clock, converting to date and time using the Date.getTime() UTC millis.\n     *\n     * This clock, rather than {@link systemDefaultZone}, should be used when\n     * you need the current instant without the date or time.\n     *\n     * @return {Clock} a clock that uses the system clock in the UTC zone, not null\n     */\n    static systemUTC() {\n        return new SystemClock(ZoneOffset.UTC);\n    }\n\n    /**\n     * Obtains a clock that returns the current instant using the best available\n     * system clock, converting to date and time using the default time-zone.\n     *\n     * This clock is based on the available system clock using the Date.getTime() UTC millis\n     *\n     * Using this method hard codes a dependency to the default time-zone into your application.\n     *\n     * The UTC clock (see {@link systemUTC}) should be used when you need the current instant\n     * without the date or time.\n     *\n     *\n     * @return {Clock} a clock that uses the system clock in the default zone, not null\n     * @see ZoneId#systemDefault()\n     */\n    static systemDefaultZone() {\n        return new SystemClock(ZoneId.systemDefault());\n    }\n\n    /**\n     *\n     * @param {ZoneId} zone\n     * @return {Clock} a clock that uses the specified time zone\n     */\n    static system(zone){\n        return new SystemClock(zone);\n    }\n\n    /**\n     * Obtains a clock that always returns the same instant.\n     *\n     * This clock simply returns the specified instant.\n     * As such, it is not a clock in the conventional sense.\n     * The main use case for this is in testing, where the fixed clock ensures\n     * tests are not dependent on the current clock.\n     *\n     * @param {Instant} fixedInstant  the instant to use as the clock, not null\n     * @param {ZoneId} zoneId  the zoneOffset to use as zone Offset, not null\n     * @return {Clock} a clock that always returns the same instant, not null\n     */\n    static fixed(fixedInstant, zoneId) {\n        return new FixedClock(fixedInstant, zoneId);\n    }\n    \n    /**\n     * Obtains a clock that returns instants from the specified clock with the\n     * specified duration added\n     * <p>\n     * This clock wraps another clock, returning instants that are later by the\n     * specified duration. If the duration is negative, the instants will be\n     * earlier than the current date and time.\n     * The main use case for this is to simulate running in the future or in the past.\n     * <p>\n     * A duration of zero would have no offsetting effect.\n     * Passing zero will return the underlying clock.\n     * <p>\n     * The returned implementation is immutable, thread-safe and {@code Serializable}\n     * providing that the base clock is.\n     *\n     * @param baseClock  the base clock to add the duration to, not null\n     * @param duration  the duration to add, not null\n     * @return a clock based on the base clock with the duration added, not null\n     */\n    static offset(baseClock, duration) {\n        return new OffsetClock(baseClock, duration);   \n    }\n\n    /**\n      * Gets the current millisecond instant of the clock.\n      *\n      * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n      * This is equivalent to the definition of {@link Date#getTime}.\n      *\n      * Most applications should avoid this method and use {@link Instant} to represent\n      * an instant on the time-line rather than a raw millisecond value.\n      * This method is provided to allow the use of the clock in high performance use cases\n      * where the creation of an object would be unacceptable.\n      *\n      * The default implementation currently calls {@link instant}.\n      *\n      * @return the current millisecond instant from this clock, measured from\n      *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n      */\n    millis(){\n        abstractMethodFail('Clock.millis');\n    }\n\n    /**\n     * Gets the current instant of the clock.\n     *\n     * This returns an instant representing the current instant as defined by the clock.\n     *\n     * @return {Instant} the current instant from this clock, not null\n     */\n    instant(){\n        abstractMethodFail('Clock.instant');\n    }\n\n    zone(){\n        abstractMethodFail('Clock.zone');\n    }\n    \n    /**\n     * Returns a copy of this clock with a different time-zone.\n     * <p>\n     * A clock will typically obtain the current instant and then convert that\n     * to a date or time using a time-zone. This method returns a clock with\n     * similar properties but using a different time-zone.\n     *\n     * @return a clock based on this clock with the specified time-zone, not null\n     */\n    withZone(){\n        abstractMethodFail('Clock.withZone');\n    }\n}\n\n/**\n * Implementation of a clock that always returns the latest time from\n * {@link Date#getTime}.\n *\n * @private\n */\nclass SystemClock extends Clock {\n    /**\n     *\n     * @param {!ZoneId} zone\n     */\n    constructor(zone){\n        requireNonNull(zone, 'zone');\n        super();\n        this._zone = zone;\n    }\n\n    /**\n     *\n     * @returns {!ZoneId}\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    millis() {\n        return new Date().getTime();\n    }\n\n    /**\n     *\n     * @returns {Instant}\n     */\n    instant() {\n        return Instant.ofEpochMilli(this.millis());\n    }\n    \n    equals(obj) {    \n        if (obj instanceof SystemClock) {            \n            return this._zone.equals(obj._zone);\n        }\n        return false;    \n    }  \n      \n    withZone(zone) {\n        if (zone.equals(this._zone)) {  // intentional NPE\n            return this;\n        }\n        return new SystemClock(zone);\n    }      \n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return `SystemClock[${this._zone.toString()}]`;\n    }\n\n}\n\n/**\n * Implementation of a clock that always returns the same instant.\n * This is typically used for testing.\n * @private\n */\nclass FixedClock extends Clock{\n    constructor(fixedInstant, zoneId) {\n        super();\n        this._instant = fixedInstant;\n        this._zoneId = zoneId;\n    }\n\n    instant() {\n        return this._instant;\n    }\n\n    millis(){\n        return this._instant.toEpochMilli();\n    }\n\n    zone() {\n        return this._zoneId;\n    }\n\n    toString(){\n        return 'FixedClock[]';\n    }\n    \n    equals(obj) {    \n        if (obj instanceof FixedClock) {            \n            return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n        }\n        return false;    \n    }\n\n    withZone(zone) {\n        if (zone.equals(this._zoneId)) {  // intentional NPE\n            return this;\n        }\n        return new FixedClock(this._instant, zone);\n    }      \n    \n}\n\n\n/**\n * Implementation of a clock that adds an offset to an underlying clock.\n */\nclass OffsetClock extends Clock {\n    constructor(baseClock, offset) {\n        super();\n        this._baseClock = baseClock;\n        this._offset = offset;\n    }\n   \n    zone() {\n        return this._baseClock.zone();\n    }\n        \n    withZone(zone) {\n        if (zone.equals(this._baseClock.zone())) {  // intentional NPE\n            return this;\n        }\n        return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n    }\n    \n    millis() {\n        return this._baseClock.millis() + this._offset.toMillis();\n    }\n    \n    instant() {\n        return this._baseClock.instant().plus(this._offset);\n    }\n        \n    equals(obj) {\n        if (obj instanceof OffsetClock) {            \n            return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n        }\n        return false;\n    }\n    \n    toString() {\n        return `OffsetClock[${this._baseClock},${this._offset}]`;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Clock.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "Clock",
    "memberof": "packages/core/src/Clock.js",
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Clock.js",
    "importStyle": "{Clock}",
    "description": "A clock providing access to the current instant, date and time using a time-zone.\n\nInstances of this class are used to find the current instant, which can be\ninterpreted using the stored time-zone to find the current date and time.\nAs such, a clock can be used instead of {@link System#currentTimeMillis}\nand {@link TimeZone#getDefault}.\n\nUse of a {@link Clock} is optional. All key date-time classes also have a\n`now()` factory method that uses the system clock in the default time zone.\nThe primary purpose of this abstraction is to allow alternate clocks to be\nplugged in as and when required. Applications use an object to obtain the\ncurrent time rather than a static method. This can simplify testing.\n\nBest practice for applications is to pass a {@link Clock} into any method\nthat requires the current instant.\n\nThis approach allows an alternate clock, such as {@link fixed}\nor {@link offset} to be used during testing.\n\nThe {@link system} factory methods provide clocks based on the best available\nsystem clock This may use {@link System#currentTimeMillis}, or a higher\nresolution clock if one is available.\n\nThe javascript Clock implementation differs from the openjdk.\n\nJavascript only provides the UTC millis of epoch and the ZoneOffset in minutes of the system default time.\nJavascript do not provide the system default ZoneId.\n\nthe system default ZoneId is only guessable by the ZoneOffset, like moment-timezone does by returning one ZoneId\nwith the same ZoneOffset.\n\nTherefore we are doing a shortcut here, by defining a SystemUTCClock and a SystemDefaultClock, the Clock itself\nis returning the ZoneOffset and not the ZoneRules as in the jdk. We should change it, when introducing the iana\ntimezone database and implementing the timezone domains.",
    "lineNumber": 50,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "method",
    "name": "systemUTC",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock.systemUTC",
    "access": "public",
    "description": "Obtains a clock that returns the current instant using the\nsystem clock, converting to date and time using the Date.getTime() UTC millis.\n\nThis clock, rather than {@link systemDefaultZone}, should be used when\nyou need the current instant without the date or time.",
    "lineNumber": 60,
    "return": {
      "nullable": null,
      "types": [
        "Clock"
      ],
      "spread": false,
      "description": "a clock that uses the system clock in the UTC zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 3,
    "kind": "method",
    "name": "systemDefaultZone",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock.systemDefaultZone",
    "access": "public",
    "description": "Obtains a clock that returns the current instant using the best available\nsystem clock, converting to date and time using the default time-zone.\n\nThis clock is based on the available system clock using the Date.getTime() UTC millis\n\nUsing this method hard codes a dependency to the default time-zone into your application.\n\nThe UTC clock (see {@link systemUTC}) should be used when you need the current instant\nwithout the date or time.",
    "see": [
      "ZoneId#systemDefault()"
    ],
    "lineNumber": 79,
    "return": {
      "nullable": null,
      "types": [
        "Clock"
      ],
      "spread": false,
      "description": "a clock that uses the system clock in the default zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 4,
    "kind": "method",
    "name": "system",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock.system",
    "access": "public",
    "description": "",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Clock"
      ],
      "spread": false,
      "description": "a clock that uses the specified time zone"
    }
  },
  {
    "__docId__": 5,
    "kind": "method",
    "name": "fixed",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock.fixed",
    "access": "public",
    "description": "Obtains a clock that always returns the same instant.\n\nThis clock simply returns the specified instant.\nAs such, it is not a clock in the conventional sense.\nThe main use case for this is in testing, where the fixed clock ensures\ntests are not dependent on the current clock.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "fixedInstant",
        "description": "the instant to use as the clock, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": "the zoneOffset to use as zone Offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Clock"
      ],
      "spread": false,
      "description": "a clock that always returns the same instant, not null"
    }
  },
  {
    "__docId__": 6,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Clock.js~Clock.offset",
    "access": "public",
    "description": "Obtains a clock that returns instants from the specified clock with the\nspecified duration added\n<p>\nThis clock wraps another clock, returning instants that are later by the\nspecified duration. If the duration is negative, the instants will be\nearlier than the current date and time.\nThe main use case for this is to simulate running in the future or in the past.\n<p>\nA duration of zero would have no offsetting effect.\nPassing zero will return the underlying clock.\n<p>\nThe returned implementation is immutable, thread-safe and {@code Serializable}\nproviding that the base clock is.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "baseClock",
        "description": "the base clock to add the duration to, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the duration to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a clock based on the base clock with the duration added, not null"
    }
  },
  {
    "__docId__": 7,
    "kind": "method",
    "name": "millis",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~Clock#millis",
    "access": "public",
    "description": "Gets the current millisecond instant of the clock.\n\nThis returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\nThis is equivalent to the definition of {@link Date#getTime}.\n\nMost applications should avoid this method and use {@link Instant} to represent\nan instant on the time-line rather than a raw millisecond value.\nThis method is provided to allow the use of the clock in high performance use cases\nwhere the creation of an object would be unacceptable.\n\nThe default implementation currently calls {@link instant}.",
    "lineNumber": 147,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the current millisecond instant from this clock, measured from\n the Java epoch of 1970-01-01T00:00Z (UTC), not null"
    },
    "params": []
  },
  {
    "__docId__": 8,
    "kind": "method",
    "name": "instant",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~Clock#instant",
    "access": "public",
    "description": "Gets the current instant of the clock.\n\nThis returns an instant representing the current instant as defined by the clock.",
    "lineNumber": 158,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the current instant from this clock, not null"
    },
    "params": []
  },
  {
    "__docId__": 9,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~Clock#zone",
    "access": "public",
    "description": null,
    "lineNumber": 162,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 10,
    "kind": "method",
    "name": "withZone",
    "memberof": "packages/core/src/Clock.js~Clock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~Clock#withZone",
    "access": "public",
    "description": "Returns a copy of this clock with a different time-zone.\n<p>\nA clock will typically obtain the current instant and then convert that\nto a date or time using a time-zone. This method returns a clock with\nsimilar properties but using a different time-zone.",
    "lineNumber": 175,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a clock based on this clock with the specified time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 11,
    "kind": "class",
    "name": "SystemClock",
    "memberof": "packages/core/src/Clock.js",
    "static": true,
    "longname": "packages/core/src/Clock.js~SystemClock",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/Clock.js",
    "importStyle": null,
    "description": "Implementation of a clock that always returns the latest time from\n{@link Date#getTime}.",
    "lineNumber": 186,
    "interface": false,
    "extends": [
      "Clock"
    ],
    "ignore": true
  },
  {
    "__docId__": 12,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 191,
    "params": [
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 13,
    "kind": "member",
    "name": "_zone",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#_zone",
    "access": "private",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#zone",
    "access": "public",
    "description": "",
    "lineNumber": 201,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{!ZoneId}"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 15,
    "kind": "method",
    "name": "millis",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#millis",
    "access": "public",
    "description": "",
    "lineNumber": 209,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "instant",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#instant",
    "access": "public",
    "description": "",
    "lineNumber": 217,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Instant}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 17,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#equals",
    "access": "public",
    "description": null,
    "lineNumber": 221,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 18,
    "kind": "method",
    "name": "withZone",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#withZone",
    "access": "public",
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "params": [
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 19,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Clock.js~SystemClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~SystemClock#toString",
    "access": "public",
    "description": "",
    "lineNumber": 239,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 20,
    "kind": "class",
    "name": "FixedClock",
    "memberof": "packages/core/src/Clock.js",
    "static": true,
    "longname": "packages/core/src/Clock.js~FixedClock",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/Clock.js",
    "importStyle": null,
    "description": "Implementation of a clock that always returns the same instant.\nThis is typically used for testing.",
    "lineNumber": 250,
    "interface": false,
    "extends": [
      "Clock"
    ],
    "ignore": true
  },
  {
    "__docId__": 21,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 251,
    "undocument": true
  },
  {
    "__docId__": 22,
    "kind": "member",
    "name": "_instant",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#_instant",
    "access": "private",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "_zoneId",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#_zoneId",
    "access": "private",
    "description": null,
    "lineNumber": 254,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 24,
    "kind": "method",
    "name": "instant",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#instant",
    "access": "public",
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "method",
    "name": "millis",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#millis",
    "access": "public",
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#zone",
    "access": "public",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#toString",
    "access": "public",
    "description": null,
    "lineNumber": 269,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#equals",
    "access": "public",
    "description": null,
    "lineNumber": 273,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "withZone",
    "memberof": "packages/core/src/Clock.js~FixedClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~FixedClock#withZone",
    "access": "public",
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 30,
    "kind": "class",
    "name": "OffsetClock",
    "memberof": "packages/core/src/Clock.js",
    "static": true,
    "longname": "packages/core/src/Clock.js~OffsetClock",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/Clock.js",
    "importStyle": null,
    "description": "Implementation of a clock that adds an offset to an underlying clock.",
    "lineNumber": 293,
    "interface": false,
    "extends": [
      "Clock"
    ],
    "ignore": true
  },
  {
    "__docId__": 31,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true
  },
  {
    "__docId__": 32,
    "kind": "member",
    "name": "_baseClock",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#_baseClock",
    "access": "private",
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#_offset",
    "access": "private",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 34,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#zone",
    "access": "public",
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 35,
    "kind": "method",
    "name": "withZone",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#withZone",
    "access": "public",
    "description": null,
    "lineNumber": 304,
    "undocument": true,
    "params": [
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "method",
    "name": "millis",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#millis",
    "access": "public",
    "description": null,
    "lineNumber": 311,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 37,
    "kind": "method",
    "name": "instant",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#instant",
    "access": "public",
    "description": null,
    "lineNumber": 315,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#equals",
    "access": "public",
    "description": null,
    "lineNumber": 319,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 39,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Clock.js~OffsetClock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Clock.js~OffsetClock#toString",
    "access": "public",
    "description": null,
    "lineNumber": 326,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "file",
    "name": "packages/core/src/DayOfWeek.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeException, UnsupportedTemporalTypeException, NullPointerException } from './errors';\nimport { MathUtil } from './MathUtil';\nimport { assert, requireNonNull, requireInstance } from './assert';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { IllegalArgumentException } from './errors';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\n\n/**\n * ### Static properties of Class {@link DayOfWeek}\n *\n * DayOfWeek.MONDAY,\n * DayOfWeek.TUESDAY,\n * DayOfWeek.WEDNESDAY,\n * DayOfWeek.THURSDAY,\n * DayOfWeek.FRIDAY,\n * DayOfWeek.SATURDAY,\n * DayOfWeek.SUNDAY\n *\n */\nexport class DayOfWeek extends TemporalAccessor {\n\n    /**\n     *\n     * @param {number} ordinal\n     * @param {string} name\n     * @private\n     */\n    constructor(ordinal, name){\n        super();\n        this._ordinal = ordinal;\n        this._name = name;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    ordinal(){\n        return this._ordinal;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     *\n     * @returns {DayOfWeek[]}\n     */\n    static values() {\n        return ENUMS.slice();\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @returns {DayOfWeek}\n     */\n    static valueOf(name) {\n        let ordinal = 0;\n        for(ordinal; ordinal < ENUMS.length; ordinal++){\n            if(ENUMS[ordinal].name() === name){\n                break;\n            }\n        }\n        return DayOfWeek.of(ordinal+1);\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from an `int` value.\n     *\n     * {@link DayOfWeek} is an enum representing the 7 days of the week.\n     * This factory allows the enum to be obtained from the `int` value.\n     * The `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     *\n     * @param {!number} dayOfWeek  the day-of-week to represent, from 1 (Monday) to 7 (Sunday)\n     * @return {DayOfWeek} the day-of-week singleton, not null\n     * @throws DateTimeException if the day-of-week is invalid\n     */\n    static of(dayOfWeek) {\n        if (dayOfWeek < 1 || dayOfWeek > 7) {\n            throw new DateTimeException(`Invalid value for DayOfWeek: ${dayOfWeek}`);\n        }\n        return ENUMS[dayOfWeek - 1];\n    }\n\n    /**\n     * Obtains an instance of {@link DayOfWeek} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link DayOfWeek}.\n     *\n     * The conversion extracts the {@link ChronoField#DAY_OF_WEEK} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link DayOfWeek::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {DayOfWeek} the day-of-week, not null\n     * @throws DateTimeException if unable to convert to a {@link DayOfWeek}\n     */\n    static from(temporal) {\n        assert(temporal != null, 'temporal', NullPointerException);\n        if (temporal instanceof DayOfWeek) {\n            return temporal;\n        }\n        try {\n            return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n        } catch (ex) {\n            if(ex instanceof DateTimeException) {\n                throw new DateTimeException(`Unable to obtain DayOfWeek from TemporalAccessor: ${ \n                    temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`, ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * Gets the day-of-week `int` value.\n     *\n     * The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\n     * See {@link WeekFields#dayOfWeek} for localized week-numbering.\n     *\n     * @return {number} the day-of-week, from 1 (Monday) to 7 (Sunday)\n     */\n    value() {\n        return this._ordinal + 1;\n    }\n\n    /**\n     * Gets the textual representation, such as 'Mon' or 'Friday'.\n     *\n     * This returns the textual name used to identify the day-of-week.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    displayName(style, locale) {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n        // return new DateTimeFormatterBuilder().appendText(ChronoField.DAY_OF_WEEK, style).toFormatter(locale).format(this);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this day-of-week can be queried for the specified field.\n     * If false, then calling the {@link range} and\n     * {@link get} methods will throw an exception.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-week, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_WEEK;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-week is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * range of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as an `int`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-week as a `long`.\n     *\n     * This queries this day-of-week for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link ChronoField#DAY_OF_WEEK} then the\n     * value of the day-of-week, from 1 to 7, will be returned.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the day-of-week that is the specified number of days after this one.\n     *\n     * The calculation rolls around the end of the week from Sunday to Monday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    plus(days) {\n        const amount = MathUtil.floorMod(days, 7);\n        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n    }\n\n    /**\n     * Returns the day-of-week that is the specified number of days before this one.\n     *\n     * The calculation rolls around the start of the year from Monday to Sunday.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, positive or negative\n     * @return {DayOfWeek} the resulting day-of-week, not null\n     */\n    minus(days) {\n        return this.plus(-1 * MathUtil.floorMod(days, 7));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-week using the specified query.\n     *\n     * This queries this day-of-week using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() || query === TemporalQueries.chronology() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        assert(query != null, 'query', NullPointerException);\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-week.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-week changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#DAY_OF_WEEK} as the field.\n     * Note that this adjusts forwards or backwards within a Monday to Sunday week.\n     * See {@link WeekFields#dayOfWeek} for localized week start days.\n     * See {@link TemporalAdjusters} for other adjusters\n     * with more control, such as `next(MONDAY)`.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDayOfWeek.adjustInto(temporal);\n     *   temporal = temporal.with(thisDayOfWeek);\n     * </pre>\n     *\n     * For example, given a date that is a Wednesday, the following are output:\n     * <pre>\n     *   dateOnWed.with(MONDAY);     // two days earlier\n     *   dateOnWed.with(TUESDAY);    // one day earlier\n     *   dateOnWed.with(WEDNESDAY);  // same date\n     *   dateOnWed.with(THURSDAY);   // one day later\n     *   dateOnWed.with(FRIDAY);     // two days later\n     *   dateOnWed.with(SATURDAY);   // three days later\n     *   dateOnWed.with(SUNDAY);     // four days later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjusters} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    equals(other){ \n        return this === other;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._name;\n    }\n\n    /**\n     * Compares this DayOfWeek to another DayOfWeek.\n     *\n     * The comparison is based on the value of the DayOfWeek.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {DayOfWeek} other  the other year to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */    \n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, DayOfWeek, 'other');\n        return this._ordinal - other._ordinal;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nlet ENUMS;\n\nexport function _init() {\n    DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n    DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n    DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n    DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n    DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n    DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n    DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n\n    DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', (temporal) => {\n        return DayOfWeek.from(temporal);\n    });\n\n    ENUMS = [\n        DayOfWeek.MONDAY,\n        DayOfWeek.TUESDAY,\n        DayOfWeek.WEDNESDAY,\n        DayOfWeek.THURSDAY,\n        DayOfWeek.FRIDAY,\n        DayOfWeek.SATURDAY,\n        DayOfWeek.SUNDAY\n    ];\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/DayOfWeek.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 41,
    "kind": "class",
    "name": "DayOfWeek",
    "memberof": "packages/core/src/DayOfWeek.js",
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/DayOfWeek.js",
    "importStyle": "{DayOfWeek}",
    "description": "### Static properties of Class {@link DayOfWeek}\n\nDayOfWeek.MONDAY,\nDayOfWeek.TUESDAY,\nDayOfWeek.WEDNESDAY,\nDayOfWeek.THURSDAY,\nDayOfWeek.FRIDAY,\nDayOfWeek.SATURDAY,\nDayOfWeek.SUNDAY",
    "lineNumber": 30,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor"
    ]
  },
  {
    "__docId__": 42,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ordinal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 43,
    "kind": "member",
    "name": "_ordinal",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#_ordinal",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 44,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#_name",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 45,
    "kind": "method",
    "name": "ordinal",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#ordinal",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 46,
    "kind": "method",
    "name": "name",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#name",
    "access": "public",
    "description": "",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 47,
    "kind": "method",
    "name": "values",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek.values",
    "access": "public",
    "description": "",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{DayOfWeek[]}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 48,
    "kind": "method",
    "name": "valueOf",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek.valueOf",
    "access": "public",
    "description": "",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{DayOfWeek}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 49,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek.of",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfWeek} from an `int` value.\n\n{@link DayOfWeek} is an enum representing the 7 days of the week.\nThis factory allows the enum to be obtained from the `int` value.\nThe `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).",
    "lineNumber": 94,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to represent, from 1 (Monday) to 7 (Sunday)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week singleton, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-week is invalid"
      }
    ]
  },
  {
    "__docId__": 50,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek.from",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfWeek} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link DayOfWeek}.\n\nThe conversion extracts the {@link ChronoField#DAY_OF_WEEK} field.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used as a query via method reference, {@link DayOfWeek::from}.",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link DayOfWeek}"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "method",
    "name": "value",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#value",
    "access": "public",
    "description": "Gets the day-of-week `int` value.\n\nThe values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\nSee {@link WeekFields#dayOfWeek} for localized week-numbering.",
    "lineNumber": 141,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-week, from 1 (Monday) to 7 (Sunday)"
    },
    "params": []
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#displayName",
    "access": "public",
    "description": "Gets the textual representation, such as 'Mon' or 'Friday'.\n\nThis returns the textual name used to identify the day-of-week.\nThe parameters control the length of the returned text and the locale.\n\nIf no textual mapping is found then the numeric value (see {@link getValue}) is returned.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "the length of the text required, not null"
      },
      {
        "nullable": null,
        "types": [
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the locale to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the text value of the day-of-week, not null"
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this day-of-week can be queried for the specified field.\nIf false, then calling the {@link range} and\n{@link get} methods will throw an exception.\n\nIf the field is {@link ChronoField#DAY_OF_WEEK} then\nthis method returns true.\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this day-of-week, false if not"
    }
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis day-of-week is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link ChronoField#DAY_OF_WEEK} then the\nrange of the day-of-week, from 1 to 7, will be returned.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#get",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-week as an `int`.\n\nThis queries this day-of-week for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link ChronoField#DAY_OF_WEEK} then the\nvalue of the day-of-week, from 1 to 7, will be returned.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field, within the valid range of values"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range of valid values for the field exceeds an `int`"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-week as a `long`.\n\nThis queries this day-of-week for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link ChronoField#DAY_OF_WEEK} then the\nvalue of the day-of-week, from 1 to 7, will be returned.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#plus",
    "access": "public",
    "description": "Returns the day-of-week that is the specified number of days after this one.\n\nThe calculation rolls around the end of the week from Sunday to Monday.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 292,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the resulting day-of-week, not null"
    }
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#minus",
    "access": "public",
    "description": "Returns the day-of-week that is the specified number of days before this one.\n\nThe calculation rolls around the start of the year from Monday to Sunday.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 308,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the resulting day-of-week, not null"
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#query",
    "access": "public",
    "description": "Queries this day-of-week using the specified query.\n\nThis queries this day-of-week using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 330,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this day-of-week.\n\nThis returns a temporal object of the same observable type as the input\nwith the day-of-week changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField#DAY_OF_WEEK} as the field.\nNote that this adjusts forwards or backwards within a Monday to Sunday week.\nSee {@link WeekFields#dayOfWeek} for localized week start days.\nSee {@link TemporalAdjusters} for other adjusters\nwith more control, such as `next(MONDAY)`.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisDayOfWeek.adjustInto(temporal);\n  temporal = temporal.with(thisDayOfWeek);\n</pre>\n\nFor example, given a date that is a Wednesday, the following are output:\n<pre>\n  dateOnWed.with(MONDAY);     // two days earlier\n  dateOnWed.with(TUESDAY);    // one day earlier\n  dateOnWed.with(WEDNESDAY);  // same date\n  dateOnWed.with(THURSDAY);   // one day later\n  dateOnWed.with(FRIDAY);     // two days later\n  dateOnWed.with(SATURDAY);   // three days later\n  dateOnWed.with(SUNDAY);     // four days later\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 380,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjusters"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#equals",
    "access": "public",
    "description": "",
    "lineNumber": 389,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#toString",
    "access": "public",
    "description": "",
    "lineNumber": 397,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#compareTo",
    "access": "public",
    "description": "Compares this DayOfWeek to another DayOfWeek.\n\nThe comparison is based on the value of the DayOfWeek.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/DayOfWeek.js~DayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/DayOfWeek.js~DayOfWeek#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 422,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 65,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/DayOfWeek.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/DayOfWeek.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/DayOfWeek.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 429,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "file",
    "name": "packages/core/src/Duration.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { requireNonNull, requireInstance } from './assert';\nimport { ArithmeticException, DateTimeParseException, UnsupportedTemporalTypeException } from './errors';\nimport { MathUtil, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { TemporalAmount } from './temporal/TemporalAmount';\nimport { TemporalUnit } from './temporal/TemporalUnit';\n\nimport { LocalTime } from './LocalTime';\n\n/**\n * A time-based amount of time, such as '34.5 seconds'.\n *\n * This class models a quantity or amount of time in terms of seconds and nanoseconds.\n * It can be accessed using other duration-based units, such as minutes and hours.\n * In addition, the {@link ChronoUnit#DAYS} unit can be used and is treated as\n * exactly equal to 24 hours, thus ignoring daylight savings effects.\n * See {@link Period} for the date-based equivalent to this class.\n *\n * A physical duration could be of infinite length.\n * For practicality, the duration is stored with constraints similar to {@link Instant}.\n * The duration uses nanosecond resolution with a maximum value of the seconds that can\n * be held in a `long`. This is greater than the current estimated age of the universe.\n *\n * The range of a duration requires the storage of a number larger than a `long`.\n * To achieve this, the class stores a `long` representing seconds and an `int`\n * representing nanosecond-of-second, which will always be between 0 and 999,999,999.\n *\n * The duration is measured in \"seconds\", but these are not necessarily identical to\n * the scientific \"SI second\" definition based on atomic clocks.\n * This difference only impacts durations measured near a leap-second and should not affect\n * most applications.\n * See {@link Instant} for a discussion as to the meaning of the second and time-scales.\n *\n * ### Static properties of Class {@link Duration}\n *\n * Duration.ZERO\n *\n * Constant for a duration of zero.\n *\n */\nexport class Duration extends TemporalAmount /*implements TemporalAmount, Comparable<Duration>, Serializable */ {\n\n    /**\n     * Constructs an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanos - the nanoseconds within the second, from 0 to 999,999,999\n     * @private\n     */\n    constructor(seconds, nanos) {\n        super();\n        this._seconds = MathUtil.safeToInt(seconds);\n        this._nanos = MathUtil.safeToInt(nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n     *\n     * The seconds are calculated based on the standard definition of a day,\n     * where each day is 86400 seconds which implies a 24 hour day.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} days - the number of days, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input days exceeds the capacity of {@link Duration}\n     */\n    static ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard hours.\n     *\n     * The seconds are calculated based on the standard definition of an hour,\n     * where each hour is 3600 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} hours - the number of hours, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input hours exceeds the capacity of {@link Duration}\n     */\n    static ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} from a number of standard minutes.\n     *\n     * The seconds are calculated based on the standard definition of a minute,\n     * where each minute is 60 seconds.\n     * The nanosecond in second field is set to zero.\n     *\n     * @param {Number} minutes - the number of minutes, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the input minutes exceeds the capacity of {@link Duration}\n     */\n    static ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of seconds\n     * and an adjustment in nanoseconds.\n     *\n     * This method allows an arbitrary number of nanoseconds to be passed in.\n     * The factory will alter the values of the second and nanosecond in order\n     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.\n     * For example, the following will result in the exactly the same duration:\n     * <pre>\n     *  Duration.ofSeconds(3, 1);\n     *  Duration.ofSeconds(4, -999_999_999);\n     *  Duration.ofSeconds(2, 1000_000_001);\n     * </pre>\n     *\n     * @param {Number} seconds - the number of seconds, positive or negative\n     * @param {Number} nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative\n     * @return {!Duration}\n     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}\n     */\n    static ofSeconds(seconds, nanoAdjustment = 0) {\n        const secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of milliseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {Number} millis - the number of milliseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofMillis(millis) {\n        let secs = MathUtil.intDiv(millis, 1000);\n        let mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a number of nanoseconds.\n     *\n     * The seconds and nanoseconds are extracted from the specified nanoseconds.\n     *\n     * @param {Number} nanos - the number of nanoseconds, positive or negative\n     * @return {!Duration}\n     */\n    static ofNanos(nanos) {\n        let secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from a duration in the specified unit.\n     *\n     * The parameters represent the two parts of a phrase like '6 Hours'. For example:\n     * <pre>\n     *  Duration.of(3, SECONDS);\n     *  Duration.of(465, HOURS);\n     * </pre>\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * @param {Number} amount - the amount of the duration, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the duration is measured in, must have an exact duration, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the period unit has an estimated duration\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Duration} from an amount.\n     *\n     * This obtains a duration based on the specified amount.\n     * A TemporalAmount represents an amount of time, which may be date-based\n     * or time-based, which this factory extracts to a duration.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the duration of the unit to calculate the total Duration.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration or be ChronoUnit.DAYS which\n     * is treated as 24 hours. If any other units are found then an exception is thrown.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Duration} the resulting duration, not null\n     * @throws DateTimeException if the amount cannot be converted\n     * @throws ArithmeticException if a numeric overflow occurs\n     */\n    static from(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount);\n        let duration = Duration.ZERO;\n        amount.units().forEach((unit) => {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} representing the duration between two instants.\n     *\n     * Obtains a {@link Duration} representing the duration between two instants.\n     * This calculates the duration between two temporal objects of the same type.\n     * The difference in seconds is calculated using {@link Temporal#until}.\n     * The difference in nanoseconds is calculated using by querying the\n     * {@link ChronoField#NANO_OF_SECOND} field.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * To guarantee to obtain a positive duration call abs() on the result.\n     *\n     * @param {Temporal} startInclusive - the start instant, inclusive, not null\n     * @param {Temporal} endExclusive - the end instant, exclusive, not null\n     * @return {!Duration}\n     * @throws DateTimeException if the seconds between the temporals cannot be obtained\n     * @throws ArithmeticException if the calculation exceeds the capacity of {@link Duration}\n     */\n    static between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        let secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        let nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                const startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    // two possible meanings for result, so recalculate secs\n                    const adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {\n                // ignore and only use seconds\n            }\n        }\n        return this.ofSeconds(secs, nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Duration} from a text string such as {@link PnDTnHnMn.nS}.\n     *\n     * This will parse a textual representation of a duration, including the\n     * string produced by {@link toString}. The formats accepted are based\n     * on the ISO-8601 duration format {@link PnDTnHnMn.nS} with days\n     * considered to be exactly 24 hours.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter \"P\" is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * The sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\n     * days, hours, minutes and seconds, accepted in upper or lower case.\n     * The suffixes must occur in order. The ASCII letter \"T\" must occur before\n     * the first occurrence, if any, of an hour, minute or second section.\n     * At least one of the four sections must be present, and if \"T\" is present\n     * there must be at least one section after the \"T\".\n     * The number part of each section must consist of one or more ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number of days, hours and minutes must parse to a `long`.\n     * The number of seconds must parse to a `long` with optional fraction.\n     * The decimal point may be either a dot or a comma.\n     * The fractional part may have from zero to 9 digits.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard.\n     *\n     * Examples:\n     * <pre>\n     *    \"PT20.345S\" -> parses as \"20.345 seconds\"\n     *    \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n     *    \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n     *    \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n     *    \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n     *    \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n     *    \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n     *    \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n     * </pre>\n     *\n     * @param {String} text - the text to parse, not null\n     * @return {Duration} the parsed duration, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a duration\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        /**\n         * The pattern for parsing.\n         */\n        const PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n        const matches = PATTERN.exec(text);\n        if (matches !== null) {\n            // check for letter T but no time sections\n            if ('T' === matches[3] === false) {\n                const negate = '-' === matches[1];\n                const dayMatch = matches[2];\n                const hourMatch = matches[4];\n                const minuteMatch = matches[5];\n                const secondMatch = matches[6];\n                const fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    const daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n                    const hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n                    const minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n                    const seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n                    const negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n                    const nanos = Duration._parseFraction(text,  fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n    }\n\n    static _parseNumber(text, parsed, multiplier, errorText) {\n        // regex limits to [-+]?[0-9]+\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === '+') {\n                parsed = parsed.substring(1);\n            }\n            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException(`Text cannot be parsed to a Duration: ${errorText}`, text, 0, ex);\n        }\n    }\n\n    static _parseFraction(text, parsed, negate) {\n        // regex limits to [0-9]{0,9}\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        parsed = (`${parsed}000000000`).substring(0, 9);\n        return parseFloat(parsed) * negate;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate\n     * function\n     *\n     * @return {Duration}\n     */\n    static _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    }\n\n    static _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        const seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    }\n\n    /**\n     * Obtains an instance of {@link Duration} using seconds and nanoseconds.\n     *\n     * @param {Number} seconds - the length of the duration in seconds, positive or negative\n     * @param {Number} nanoAdjustment - the nanosecond adjustment within the second, from 0 to 999,999,999\n     */\n    static _createSecondsNanos(seconds = 0, nanoAdjustment = 0) {\n        if (seconds === 0 && nanoAdjustment === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value of the requested unit.\n     *\n     * This returns a value for each of the two supported units,\n     * {@link ChronoUnit#SECONDS} and {@link ChronoUnit#NANOS}.\n     * All other units throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the const value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n    }\n\n    units() {\n        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is zero length.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is zero.\n     *\n     * @return {boolean} true if this duration has a total length equal to zero\n     */\n    isZero() {\n        return this._seconds === 0 && this._nanos === 0;\n    }\n\n    /**\n     * Checks if this duration is negative, excluding zero.\n     *\n     * A {@link Duration} represents a directed distance between two points on\n     * the time-line and can therefore be positive, zero or negative.\n     * This method checks whether the length is less than zero.\n     *\n     * @return {boolean} true if this duration has a total length less than zero\n     */\n    isNegative() {\n        return this._seconds < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of seconds in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getNano}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the whole seconds part of the length of the duration, positive or negative\n     */\n    seconds() {\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds within the second in this duration.\n     *\n     * The length of the duration is stored using two fields - seconds and nanoseconds.\n     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\n     * the length in seconds.\n     * The total duration is defined by calling this method and {@link getSeconds}.\n     *\n     * A {@link Duration} represents a directed distance between two points on the time-line.\n     * A negative duration is expressed by the negative sign of the seconds part.\n     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.\n     *\n     * @return {number} the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified amount of seconds.\n     *\n     * This returns a duration with the specified seconds, retaining the\n     * nano-of-second part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} seconds - the seconds to represent, may be negative\n     * @return {Duration} based on this period with the requested seconds, not null\n     */\n    withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified nano-of-second.\n     *\n     * This returns a duration with the specified nano-of-second, retaining the\n     * seconds part of this duration.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {Duration} based on this period with the requested nano-of-second, not null\n     * @throws DateTimeException if the nano-of-second is invalid\n     */\n    withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to add, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        return this.plus(duration.seconds(), duration.nano());\n    }\n\n\n    /**\n     * function overloading for {@link Duration.plus}\n     *\n     * if called with 1 arguments, then {@link Duration.plusDuration} is executed.\n     *\n     * if called with 2 arguments and second argument is an instance of TemporalUnit, then {@link Duration.plusAmountUnit} is executed.\n     *\n     * Otherwise {@link Duration.plusSecondsNanos} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {!TemporalUnit|number} unitOrNumber\n     * @returns {Duration}\n     */\n    plus(durationOrNumber, unitOrNumber) {\n        if (arguments.length === 1) {\n            return this.plusDuration(durationOrNumber);\n        }\n        else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n            return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n        } else {\n            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToAdd - the amount to add, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration added, not null\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, (1000000 * 1000)) * 1000, MathUtil.intMod(amountToAdd, (1000000 * 1000)) * 1000);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        const duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToAdd - the days to add, positive or negative\n     * @return {Duration} based on this duration with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToAdd - the hours to add, positive or negative\n     * @return {Duration} based on this duration with the specified hours added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToAdd - the minutes to add, positive or negative\n     * @return {Duration} based on this duration with the specified minutes added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToAdd - the seconds to add, positive or negative\n     * @param {Number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Duration} based on this duration with the specified seconds added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        requireNonNull(secondsToAdd, 'secondsToAdd');\n        requireNonNull(nanosToAdd, 'nanosToAdd');\n        if (secondsToAdd === 0 && nanosToAdd === 0) {\n            return this;\n        }\n        let epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);  // safe int+LocalTime.NANOS_PER_SECOND\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Duration.minus}\n     *\n     * if called with 1 arguments and first argument is an instance of Duration, then {@link Duration.minusDuration} is executed.\n     *\n     * Otherwise {@link Duration.minusAmountUnit} is executed.\n     *\n     * @param {!(Duration|number)} durationOrNumber\n     * @param {?TemporalUnit} unit\n     * @return {Duration}\n     */\n    minus(durationOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusDuration(durationOrNumber);\n        } else {\n            return this.minusAmountUnit(durationOrNumber, unit);\n        }\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Duration} duration - the duration to subtract, positive or negative, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDuration(duration) {\n        requireNonNull(duration, 'duration');\n        const secsToSubtract = duration.seconds();\n        const nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration subtracted.\n     *\n     * The duration amount is measured in terms of the specified unit.\n     * Only a subset of units are accepted by this method.\n     * The unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\n     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} amountToSubtract - the amount to subtract, measured in terms of the unit, positive or negative\n     * @param {TemporalUnit} unit - the unit that the amount is measured in, must have an exact duration, not null\n     * @return {Duration} based on this duration with the specified duration subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusAmountUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return (amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} daysToSubtract - the days to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return (daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} hoursToSubtract - the hours to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified hours subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusHours(hoursToSubtract) {\n        return (hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in minutes subtracted.\n     *\n     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} minutesToSubtract - the minutes to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified minutes subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMinutes(minutesToSubtract) {\n        return (minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified seconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusSeconds(secondsToSubtract) {\n        return (secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified milliseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return (millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract));\n    }\n\n    /**\n     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanosToSubtract - the nanoseconds to subtract, positive or negative\n     * @return {Duration} based on this duration with the specified nanoseconds subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return (nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration multiplied by the scalar.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} multiplicand - the value to multiply the duration by, positive or negative\n     * @return {Duration} based on this duration multiplied by the specified scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        let secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        let nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    /**\n     * Returns a copy of this duration divided by the specified value.\n     *\n     * In opposite to the threeten implementation the division is realized by floating point not by\n     * fixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.\n     *\n     * @param {Number} divisor - the value to divide the duration by, positive or negative, not zero\n     * @return {Duration} based on this duration divided by the specified divisor, not null\n     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs\n     */\n    dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException('Cannot divide by zero');\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        const secs = MathUtil.intDiv(this._seconds, divisor);\n        const secsMod = MathUtil.roundDown(((this._seconds/ divisor) - secs) * LocalTime.NANOS_PER_SECOND);\n        let nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this duration with the length negated.\n     *\n     * This method swaps the sign of the total length of this duration.\n     * For example, {@link PT1.3S} will be returned as {@link PT-1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with the amount negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    /**\n     * Returns a copy of this duration with a positive length.\n     *\n     * This method returns a positive duration by effectively removing the sign from any negative total length.\n     * For example, {@link PT-1.3S} will be returned as {@link PT1.3S}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Duration} based on this duration with an absolute length, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    abs() {\n        return this.isNegative() ? this.negated() : this;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this duration to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisDuration);\n     * </pre>\n     *\n     * The calculation will add the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this duration from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this duration subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisDuration.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisDuration);\n     * </pre>\n     *\n     * The calculation will subtract the seconds, then nanos.\n     * Only non-zero amounts will be added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of days in this duration.\n     *\n     * This returns the total number of days in the duration by dividing the\n     * number of seconds by 86400.\n     * This is based on the standard definition of a day as 24 hours.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of days in the duration, may be negative\n     */\n    toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    }\n\n    /**\n     * Gets the number of hours in this duration.\n     *\n     * This returns the total number of hours in the duration by dividing the\n     * number of seconds by 3600.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of hours in the duration, may be negative\n     */\n    toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    }\n\n    /**\n     * Gets the number of minutes in this duration.\n     *\n     * This returns the total number of minutes in the duration by dividing the\n     * number of seconds by 60.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the number of minutes in the duration, may be negative\n     */\n    toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    }\n\n    /**\n     * Converts this duration to the total length in milliseconds.\n     *\n     * If this duration is too large to fit in a `long` milliseconds, then an\n     * exception is thrown.\n     *\n     * If this duration has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the total length of the duration in milliseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toMillis() {\n        let millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    }\n\n    /**\n     * Converts this duration to the total length in nanoseconds expressed as a `long`.\n     *\n     * If this duration is too large to fit in a `long` nanoseconds, then an\n     * exception is thrown.\n     *\n     * @return {number} the total length of the duration in nanoseconds\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toNanos() {\n        let totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this duration to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {Duration} otherDuration - the other duration to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(otherDuration) {\n        requireNonNull(otherDuration, 'otherDuration');\n        requireInstance(otherDuration, Duration, 'otherDuration');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this duration is equal to the specified {@link Duration}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {*} otherDuration - the other duration, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() &&\n                   this.nano() === otherDuration.nano();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this duration using ISO-8601 seconds\n     * based representation, such as {@link PT8H6M12.345S}.\n     *\n     * The format of the returned string will be {@link PTnHnMnS}, where n is\n     * the relevant hours, minutes or seconds part of the duration.\n     * Any fractional seconds are placed after a decimal point in the seconds section.\n     * If a section has a zero value, it is omitted.\n     * The hours, minutes and seconds will all have the same sign.\n     *\n     * Examples:\n     * <pre>\n     *    \"20.345 seconds\"                 -> \"PT20.345S\n     *    \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n     *    \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n     *    \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n     * </pre>\n     * Note that multiples of 24 hours are not output as days to avoid confusion\n     * with {@link Period}.\n     *\n     * @return {string} an ISO-8601 representation of this duration, not null\n     */\n    toString() {\n        if (this === Duration.ZERO) {\n            return 'PT0S';\n        }\n        const hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        const minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        const secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        let rval = 'PT';\n        if (hours !== 0) {\n            rval += `${hours}H`;\n        }\n        if (minutes !== 0) {\n            rval += `${minutes}M`;\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += '-0';\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += '.';\n            let nanoString;\n            if (secs < 0) {\n                nanoString = `${2 * LocalTime.NANOS_PER_SECOND - this._nanos}`;\n            } else {\n                nanoString = `${LocalTime.NANOS_PER_SECOND + this._nanos}`;\n            }\n            // remove the leading '1'\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while (rval.charAt(rval.length - 1) === '0') {\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += 'S';\n        return rval;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Duration.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Constant for a duration of zero.\n     */\n    Duration.ZERO = new Duration(0, 0);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Duration.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 67,
    "kind": "class",
    "name": "Duration",
    "memberof": "packages/core/src/Duration.js",
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Duration.js",
    "importStyle": "{Duration}",
    "description": "A time-based amount of time, such as '34.5 seconds'.\n\nThis class models a quantity or amount of time in terms of seconds and nanoseconds.\nIt can be accessed using other duration-based units, such as minutes and hours.\nIn addition, the {@link ChronoUnit#DAYS} unit can be used and is treated as\nexactly equal to 24 hours, thus ignoring daylight savings effects.\nSee {@link Period} for the date-based equivalent to this class.\n\nA physical duration could be of infinite length.\nFor practicality, the duration is stored with constraints similar to {@link Instant}.\nThe duration uses nanosecond resolution with a maximum value of the seconds that can\nbe held in a `long`. This is greater than the current estimated age of the universe.\n\nThe range of a duration requires the storage of a number larger than a `long`.\nTo achieve this, the class stores a `long` representing seconds and an `int`\nrepresenting nanosecond-of-second, which will always be between 0 and 999,999,999.\n\nThe duration is measured in \"seconds\", but these are not necessarily identical to\nthe scientific \"SI second\" definition based on atomic clocks.\nThis difference only impacts durations measured near a leap-second and should not affect\nmost applications.\nSee {@link Instant} for a discussion as to the meaning of the second and time-scales.\n\n### Static properties of Class {@link Duration}\n\nDuration.ZERO\n\nConstant for a duration of zero.",
    "lineNumber": 48,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAmount.js~TemporalAmount"
    ]
  },
  {
    "__docId__": 68,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#constructor",
    "access": "private",
    "description": "Constructs an instance of {@link Duration} using seconds and nanoseconds.",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the length of the duration in seconds, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanoseconds within the second, from 0 to 999,999,999"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "_seconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#_seconds",
    "access": "private",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "_nanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#_nanos",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "ofDays",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofDays",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of standard 24 hour days.\n\nThe seconds are calculated based on the standard definition of a day,\nwhere each day is 86400 seconds which implies a 24 hour day.\nThe nanosecond in second field is set to zero.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the number of days, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the input days exceeds the capacity of {@link Duration}"
      }
    ]
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "ofHours",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofHours",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of standard hours.\n\nThe seconds are calculated based on the standard definition of an hour,\nwhere each hour is 3600 seconds.\nThe nanosecond in second field is set to zero.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the number of hours, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the input hours exceeds the capacity of {@link Duration}"
      }
    ]
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "ofMinutes",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofMinutes",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of standard minutes.\n\nThe seconds are calculated based on the standard definition of a minute,\nwhere each minute is 60 seconds.\nThe nanosecond in second field is set to zero.",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the number of minutes, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the input minutes exceeds the capacity of {@link Duration}"
      }
    ]
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "ofSeconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofSeconds",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of seconds\nand an adjustment in nanoseconds.\n\nThis method allows an arbitrary number of nanoseconds to be passed in.\nThe factory will alter the values of the second and nanosecond in order\nto ensure that the stored nanosecond is in the range 0 to 999,999,999.\nFor example, the following will result in the exactly the same duration:\n<pre>\n Duration.ofSeconds(3, 1);\n Duration.ofSeconds(4, -999_999_999);\n Duration.ofSeconds(2, 1000_000_001);\n</pre>",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the number of seconds, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoAdjustment",
        "description": "the nanosecond adjustment to the number of seconds, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@link Duration}"
      }
    ]
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "ofMillis",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofMillis",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of milliseconds.\n\nThe seconds and nanoseconds are extracted from the specified milliseconds.",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "millis",
        "description": "the number of milliseconds, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "ofNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.ofNanos",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a number of nanoseconds.\n\nThe seconds and nanoseconds are extracted from the specified nanoseconds.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the number of nanoseconds, positive or negative"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.of",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from a duration in the specified unit.\n\nThe parameters represent the two parts of a phrase like '6 Hours'. For example:\n<pre>\n Duration.of(3, SECONDS);\n Duration.of(465, HOURS);\n</pre>\nOnly a subset of units are accepted by this method.\nThe unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\nbe {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the amount of the duration, measured in terms of the unit, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit that the duration is measured in, must have an exact duration, not null"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period unit has an estimated duration"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if a numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.from",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} from an amount.\n\nThis obtains a duration based on the specified amount.\nA TemporalAmount represents an amount of time, which may be date-based\nor time-based, which this factory extracts to a duration.\n\nThe conversion loops around the set of units from the amount and uses\nthe duration of the unit to calculate the total Duration.\nOnly a subset of units are accepted by this method.\nThe unit must either have an exact duration or be ChronoUnit.DAYS which\nis treated as 24 hours. If any other units are found then an exception is thrown.",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the temporal amount to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the resulting duration, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the amount cannot be converted"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if a numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "between",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.between",
    "access": "public",
    "description": "Obtains an instance of {@link Duration} representing the duration between two instants.\n\nObtains a {@link Duration} representing the duration between two instants.\nThis calculates the duration between two temporal objects of the same type.\nThe difference in seconds is calculated using {@link Temporal#until}.\nThe difference in nanoseconds is calculated using by querying the\n{@link ChronoField#NANO_OF_SECOND} field.\n\nThe result of this method can be a negative period if the end is before the start.\nTo guarantee to obtain a positive duration call abs() on the result.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the start instant, inclusive, not null"
      },
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end instant, exclusive, not null"
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the seconds between the temporals cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the calculation exceeds the capacity of {@link Duration}"
      }
    ]
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration.parse",
    "access": "public",
    "description": "Obtains a {@link Duration} from a text string such as {@link PnDTnHnMn.nS}.\n\nThis will parse a textual representation of a duration, including the\nstring produced by {@link toString}. The formats accepted are based\non the ISO-8601 duration format {@link PnDTnHnMn.nS} with days\nconsidered to be exactly 24 hours.\n\nThe string starts with an optional sign, denoted by the ASCII negative\nor positive symbol. If negative, the whole period is negated.\nThe ASCII letter \"P\" is next in upper or lower case.\nThere are then four sections, each consisting of a number and a suffix.\nThe sections have suffixes in ASCII of \"D\", \"H\", \"M\" and \"S\" for\ndays, hours, minutes and seconds, accepted in upper or lower case.\nThe suffixes must occur in order. The ASCII letter \"T\" must occur before\nthe first occurrence, if any, of an hour, minute or second section.\nAt least one of the four sections must be present, and if \"T\" is present\nthere must be at least one section after the \"T\".\nThe number part of each section must consist of one or more ASCII digits.\nThe number may be prefixed by the ASCII negative or positive symbol.\nThe number of days, hours and minutes must parse to a `long`.\nThe number of seconds must parse to a `long` with optional fraction.\nThe decimal point may be either a dot or a comma.\nThe fractional part may have from zero to 9 digits.\n\nThe leading plus/minus sign, and negative values for other units are\nnot part of the ISO-8601 standard.\n\nExamples:\n<pre>\n   \"PT20.345S\" -> parses as \"20.345 seconds\"\n   \"PT15M\"     -> parses as \"15 minutes\" (where a minute is 60 seconds)\n   \"PT10H\"     -> parses as \"10 hours\" (where an hour is 3600 seconds)\n   \"P2D\"       -> parses as \"2 days\" (where a day is 24 hours or 86400 seconds)\n   \"P2DT3H4M\"  -> parses as \"2 days, 3 hours and 4 minutes\"\n   \"P-6H3M\"    -> parses as \"-6 hours and +3 minutes\"\n   \"-P6H3M\"    -> parses as \"-6 hours and -3 minutes\"\n   \"-P-6H+3M\"  -> parses as \"+6 hours and -3 minutes\"\n</pre>",
    "lineNumber": 313,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the parsed duration, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed to a duration"
      }
    ]
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "_parseNumber",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration._parseNumber",
    "access": "private",
    "description": null,
    "lineNumber": 347,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsed",
        "types": [
          "*"
        ]
      },
      {
        "name": "multiplier",
        "types": [
          "*"
        ]
      },
      {
        "name": "errorText",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "_parseFraction",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration._parseFraction",
    "access": "private",
    "description": null,
    "lineNumber": 362,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsed",
        "types": [
          "*"
        ]
      },
      {
        "name": "negate",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "_create",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration._create",
    "access": "private",
    "description": "to handle function overriding this function accepts any number of arguments, checks their type and delegates to the appropriate\nfunction",
    "lineNumber": 378,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "_createNegateDaysHoursMinutesSecondsNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration._createNegateDaysHoursMinutesSecondsNanos",
    "access": "private",
    "description": null,
    "lineNumber": 386,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "negate",
        "types": [
          "*"
        ]
      },
      {
        "name": "daysAsSecs",
        "types": [
          "*"
        ]
      },
      {
        "name": "hoursAsSecs",
        "types": [
          "*"
        ]
      },
      {
        "name": "minsAsSecs",
        "types": [
          "*"
        ]
      },
      {
        "name": "secs",
        "types": [
          "*"
        ]
      },
      {
        "name": "nanos",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "_createSecondsNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~Duration._createSecondsNanos",
    "access": "private",
    "description": "Obtains an instance of {@link Duration} using seconds and nanoseconds.",
    "lineNumber": 400,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the length of the duration in seconds, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoAdjustment",
        "description": "the nanosecond adjustment within the second, from 0 to 999,999,999"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#get",
    "access": "public",
    "description": "Gets the value of the requested unit.\n\nThis returns a value for each of the two supported units,\n{@link ChronoUnit#SECONDS} and {@link ChronoUnit#NANOS}.\nAll other units throw an exception.",
    "lineNumber": 420,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the {@link TemporalUnit} for which to return the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the const value of the unit"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the unit is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the unit is not supported"
      }
    ]
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "units",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#units",
    "access": "public",
    "description": null,
    "lineNumber": 430,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "isZero",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#isZero",
    "access": "public",
    "description": "Checks if this duration is zero length.\n\nA {@link Duration} represents a directed distance between two points on\nthe time-line and can therefore be positive, zero or negative.\nThis method checks whether the length is zero.",
    "lineNumber": 444,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this duration has a total length equal to zero"
    },
    "params": []
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "isNegative",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#isNegative",
    "access": "public",
    "description": "Checks if this duration is negative, excluding zero.\n\nA {@link Duration} represents a directed distance between two points on\nthe time-line and can therefore be positive, zero or negative.\nThis method checks whether the length is less than zero.",
    "lineNumber": 457,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this duration has a total length less than zero"
    },
    "params": []
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "seconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#seconds",
    "access": "public",
    "description": "Gets the number of seconds in this duration.\n\nThe length of the duration is stored using two fields - seconds and nanoseconds.\nThe nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\nthe length in seconds.\nThe total duration is defined by calling this method and {@link getNano}.\n\nA {@link Duration} represents a directed distance between two points on the time-line.\nA negative duration is expressed by the negative sign of the seconds part.\nA duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.",
    "lineNumber": 476,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the whole seconds part of the length of the duration, positive or negative"
    },
    "params": []
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#nano",
    "access": "public",
    "description": "Gets the number of nanoseconds within the second in this duration.\n\nThe length of the duration is stored using two fields - seconds and nanoseconds.\nThe nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to\nthe length in seconds.\nThe total duration is defined by calling this method and {@link getSeconds}.\n\nA {@link Duration} represents a directed distance between two points on the time-line.\nA negative duration is expressed by the negative sign of the seconds part.\nA duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.",
    "lineNumber": 494,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "withSeconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#withSeconds",
    "access": "public",
    "description": "Returns a copy of this duration with the specified amount of seconds.\n\nThis returns a duration with the specified seconds, retaining the\nnano-of-second part of this duration.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 510,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to represent, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this period with the requested seconds, not null"
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "withNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#withNanos",
    "access": "public",
    "description": "Returns a copy of this duration with the specified nano-of-second.\n\nThis returns a duration with the specified nano-of-second, retaining the\nseconds part of this duration.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 526,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this period with the requested nano-of-second, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the nano-of-second is invalid"
      }
    ]
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "plusDuration",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusDuration",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 541,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the duration to add, positive or negative, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified duration added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plus",
    "access": "public",
    "description": "function overloading for {@link Duration.plus}\n\nif called with 1 arguments, then {@link Duration.plusDuration} is executed.\n\nif called with 2 arguments and second argument is an instance of TemporalUnit, then {@link Duration.plusAmountUnit} is executed.\n\nOtherwise {@link Duration.plusSecondsNanos} is executed.",
    "lineNumber": 560,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Duration}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "Duration",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "durationOrNumber",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "unitOrNumber",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "plusAmountUnit",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusAmountUnit",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration added.\n\nThe duration amount is measured in terms of the specified unit.\nOnly a subset of units are accepted by this method.\nThe unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\nbe {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 587,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount to add, measured in terms of the unit, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit that the amount is measured in, must have an exact duration, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified duration added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the unit is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusDays",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in 24 hour days added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 622,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "daysToAdd",
        "description": "the days to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified days added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusHours",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in hours added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 635,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "hoursToAdd",
        "description": "the hours to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified hours added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusMinutes",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in minutes added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 648,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutesToAdd",
        "description": "the minutes to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified minutes added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusSeconds",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in seconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 661,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToAdd",
        "description": "the seconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "plusMillis",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusMillis",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in milliseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 674,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "millisToAdd",
        "description": "the milliseconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified milliseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusNanos",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in nanoseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 687,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToAdd",
        "description": "the nanoseconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified nanoseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "plusSecondsNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#plusSecondsNanos",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 701,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToAdd",
        "description": "the seconds to add, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToAdd",
        "description": "the nanos to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minus",
    "access": "public",
    "description": "function overloading for {@link Duration.minus}\n\nif called with 1 arguments and first argument is an instance of Duration, then {@link Duration.minusDuration} is executed.\n\nOtherwise {@link Duration.minusAmountUnit} is executed.",
    "lineNumber": 726,
    "params": [
      {
        "nullable": false,
        "types": [
          "Duration",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "durationOrNumber",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "minusDuration",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusDuration",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 743,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the duration to subtract, positive or negative, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified duration subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "minusAmountUnit",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusAmountUnit",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration subtracted.\n\nThe duration amount is measured in terms of the specified unit.\nOnly a subset of units are accepted by this method.\nThe unit must either have an exact duration (see {@link TemporalUnit#isDurationEstimated}) or\nbe {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 768,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount to subtract, measured in terms of the unit, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit that the amount is measured in, must have an exact duration, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified duration subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusDays",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in 24 hour days subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 784,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "daysToSubtract",
        "description": "the days to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified days subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusHours",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in hours subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 797,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "hoursToSubtract",
        "description": "the hours to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified hours subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusMinutes",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in minutes subtracted.\n\nThe number of hours is multiplied by 60 to obtain the number of seconds to subtract.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 812,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutesToSubtract",
        "description": "the minutes to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified minutes subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusSeconds",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in seconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 825,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToSubtract",
        "description": "the seconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified seconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "minusMillis",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusMillis",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in milliseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 838,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "millisToSubtract",
        "description": "the milliseconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified milliseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#minusNanos",
    "access": "public",
    "description": "Returns a copy of this duration with the specified duration in nanoseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 851,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToSubtract",
        "description": "the nanoseconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the specified nanoseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "multipliedBy",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#multipliedBy",
    "access": "public",
    "description": "Returns a copy of this duration multiplied by the scalar.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 865,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "multiplicand",
        "description": "the value to multiply the duration by, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration multiplied by the specified scalar, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "dividedBy",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#dividedBy",
    "access": "public",
    "description": "Returns a copy of this duration divided by the specified value.\n\nIn opposite to the threeten implementation the division is realized by floating point not by\nfixed point arithmetic. Expect floating point rounding errors for {@link Duration.dividedBy}.",
    "lineNumber": 889,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "divisor",
        "description": "the value to divide the duration by, positive or negative, not zero"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration divided by the specified divisor, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the divisor is zero or if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "negated",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#negated",
    "access": "public",
    "description": "Returns a copy of this duration with the length negated.\n\nThis method swaps the sign of the total length of this duration.\nFor example, {@link PT1.3S} will be returned as {@link PT-1.3S}.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 915,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with the amount negated, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "abs",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#abs",
    "access": "public",
    "description": "Returns a copy of this duration with a positive length.\n\nThis method returns a positive duration by effectively removing the sign from any negative total length.\nFor example, {@link PT-1.3S} will be returned as {@link PT1.3S}.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 930,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "based on this duration with an absolute length, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#addTo",
    "access": "public",
    "description": "Adds this duration to the specified temporal object.\n\nThis returns a temporal object of the same observable type as the input\nwith this duration added.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#plus}.\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = thisDuration.addTo(dateTime);\n  dateTime = dateTime.plus(thisDuration);\n</pre>\n\nThe calculation will add the seconds, then nanos.\nOnly non-zero amounts will be added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 959,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to add"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "subtractFrom",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#subtractFrom",
    "access": "public",
    "description": "Subtracts this duration from the specified temporal object.\n\nThis returns a temporal object of the same observable type as the input\nwith this duration subtracted.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#minus}.\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = thisDuration.subtractFrom(dateTime);\n  dateTime = dateTime.minus(thisDuration);\n</pre>\n\nThe calculation will subtract the seconds, then nanos.\nOnly non-zero amounts will be added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 994,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to subtract"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "toDays",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toDays",
    "access": "public",
    "description": "Gets the number of days in this duration.\n\nThis returns the total number of days in the duration by dividing the\nnumber of seconds by 86400.\nThis is based on the standard definition of a day as 24 hours.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1017,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of days in the duration, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "toHours",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toHours",
    "access": "public",
    "description": "Gets the number of hours in this duration.\n\nThis returns the total number of hours in the duration by dividing the\nnumber of seconds by 3600.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1031,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of hours in the duration, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "toMinutes",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toMinutes",
    "access": "public",
    "description": "Gets the number of minutes in this duration.\n\nThis returns the total number of minutes in the duration by dividing the\nnumber of seconds by 60.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1045,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of minutes in the duration, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "toMillis",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toMillis",
    "access": "public",
    "description": "Converts this duration to the total length in milliseconds.\n\nIf this duration is too large to fit in a `long` milliseconds, then an\nexception is thrown.\n\nIf this duration has greater than millisecond precision, then the conversion\nwill drop any excess precision information as though the amount in nanoseconds\nwas subject to integer division by one million.",
    "lineNumber": 1062,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the total length of the duration in milliseconds"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "toNanos",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toNanos",
    "access": "public",
    "description": "Converts this duration to the total length in nanoseconds expressed as a `long`.\n\nIf this duration is too large to fit in a `long` nanoseconds, then an\nexception is thrown.",
    "lineNumber": 1077,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the total length of the duration in nanoseconds"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#compareTo",
    "access": "public",
    "description": "Compares this duration to the specified {@link Duration}.\n\nThe comparison is based on the total length of the durations.",
    "lineNumber": 1092,
    "params": [
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDuration",
        "description": "the other duration to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#equals",
    "access": "public",
    "description": "Checks if this duration is equal to the specified {@link Duration}.\n\nThe comparison is based on the total length of the durations.",
    "lineNumber": 1111,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDuration",
        "description": "the other duration, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the other duration is equal to this one"
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toString",
    "access": "public",
    "description": "A string representation of this duration using ISO-8601 seconds\nbased representation, such as {@link PT8H6M12.345S}.\n\nThe format of the returned string will be {@link PTnHnMnS}, where n is\nthe relevant hours, minutes or seconds part of the duration.\nAny fractional seconds are placed after a decimal point in the seconds section.\nIf a section has a zero value, it is omitted.\nThe hours, minutes and seconds will all have the same sign.\n\nExamples:\n<pre>\n   \"20.345 seconds\"                 -> \"PT20.345S\n   \"15 minutes\" (15 * 60 seconds)   -> \"PT15M\"\n   \"10 hours\" (10 * 3600 seconds)   -> \"PT10H\"\n   \"2 days\" (2 * 86400 seconds)     -> \"PT48H\"\n</pre>\nNote that multiples of 24 hours are not output as days to avoid confusion\nwith {@link Period}.",
    "lineNumber": 1145,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "an ISO-8601 representation of this duration, not null"
    },
    "params": []
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Duration.js~Duration",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Duration.js~Duration#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1194,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link Duration.toString}"
    },
    "params": []
  },
  {
    "__docId__": 128,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/Duration.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Duration.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Duration.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1200,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "file",
    "name": "packages/core/src/Enum.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n/***\n * Base class for a pseudo enum\n */\nexport class Enum {\n    constructor(name){\n        this._name = name;\n    }\n\n    equals(other){\n        return this === other;\n    }\n\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Enum.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 130,
    "kind": "class",
    "name": "Enum",
    "memberof": "packages/core/src/Enum.js",
    "static": true,
    "longname": "packages/core/src/Enum.js~Enum",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Enum.js",
    "importStyle": "{Enum}",
    "description": "Base class for a pseudo enum",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 131,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Enum.js~Enum",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Enum.js~Enum#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/Enum.js~Enum",
    "static": false,
    "longname": "packages/core/src/Enum.js~Enum#_name",
    "access": "private",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Enum.js~Enum",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Enum.js~Enum#equals",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Enum.js~Enum",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Enum.js~Enum#toString",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Enum.js~Enum",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Enum.js~Enum#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 27,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "packages/core/src/Instant.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\n\nimport { Clock } from './Clock';\nimport { LocalTime } from './LocalTime';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { MathUtil } from './MathUtil';\nimport { OffsetDateTime } from './OffsetDateTime';\n\nimport { Temporal } from './temporal/Temporal';\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { TemporalUnit } from './temporal/TemporalUnit';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\n\nconst NANOS_PER_MILLI = 1000000;\n\n/**\n * An instantaneous point on the time-line.\n *\n * This class models a single instantaneous point on the time-line.\n * This might be used to record event time-stamps in the application.\n *\n * Time-scale\n *\n * The length of the solar day is the standard way that humans measure time.\n * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,\n * forming a 86400 second day.\n *\n * Modern timekeeping is based on atomic clocks which precisely define an SI second\n * relative to the transitions of a Caesium atom. The length of an SI second was defined\n * to be very close to the 86400th fraction of a day.\n *\n * Unfortunately, as the Earth rotates the length of the day varies.\n * In addition, over time the average length of the day is getting longer as the Earth slows.\n * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.\n * The actual length of any given day and the amount by which the Earth is slowing\n * are not predictable and can only be determined by measurement.\n * The UT1 time-scale captures the accurate length of day, but is only available some\n * time after the day has completed.\n *\n * The UTC time-scale is a standard approach to bundle up all the additional fractions\n * of a second from UT1 into whole seconds, known as *leap-seconds*.\n * A leap-second may be added or removed depending on the Earth's rotational changes.\n * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where\n * necessary in order to keep the day aligned with the Sun.\n *\n * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.\n * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and\n * alterations to the length of the notional second. As of 2012, discussions are underway\n * to change the definition of UTC again, with the potential to remove leap seconds or\n * introduce other changes.\n *\n * Given the complexity of accurate timekeeping described above, this Java API defines\n * its own time-scale, the *Java Time-Scale*.\n *\n * The Java Time-Scale divides each calendar day into exactly 86400\n * subdivisions, known as seconds.  These seconds may differ from the\n * SI second.  It closely matches the de facto international civil time\n * scale, the definition of which changes from time to time.\n *\n * The Java Time-Scale has slightly different definitions for different\n * segments of the time-line, each based on the consensus international\n * time scale that is used as the basis for civil time. Whenever the\n * internationally-agreed time scale is modified or replaced, a new\n * segment of the Java Time-Scale must be defined for it.  Each segment\n * must meet these requirements:\n *\n * * the Java Time-Scale shall closely match the underlying international\n *   civil time scale;\n * * the Java Time-Scale shall exactly match the international civil\n *   time scale at noon each day;\n * * the Java Time-Scale shall have a precisely-defined relationship to\n *   the international civil time scale.\n *\n * There are currently, as of 2013, two segments in the Java time-scale.\n *\n * For the segment from 1972-11-03 (exact boundary discussed below) until\n * further notice, the consensus international time scale is UTC (with\n * leap seconds).  In this segment, the Java Time-Scale is identical to\n * [UTC-SLS](http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/).\n * This is identical to UTC on days that do not have a leap second.\n * On days that do have a leap second, the leap second is spread equally\n * over the last 1000 seconds of the day, maintaining the appearance of\n * exactly 86400 seconds per day.\n *\n * For the segment prior to 1972-11-03, extending back arbitrarily far,\n * the consensus international time scale is defined to be UT1, applied\n * proleptically, which is equivalent to the (mean) solar time on the\n * prime meridian (Greenwich). In this segment, the Java Time-Scale is\n * identical to the consensus international time scale. The exact\n * boundary between the two segments is the instant where UT1 = UTC\n * between 1972-11-03T00:00 and 1972-11-04T12:00.\n *\n * Implementations of the Java time-scale using the JSR-310 API are not\n * required to provide any clock that is sub-second accurate, or that\n * progresses monotonically or smoothly. Implementations are therefore\n * not required to actually perform the UTC-SLS slew or to otherwise be\n * aware of leap seconds. JSR-310 does, however, require that\n * implementations must document the approach they use when defining a\n * clock representing the current instant.\n * See {@link Clock} for details on the available clocks.\n *\n * The Java time-scale is used for all date-time classes.\n * This includes {@link Instant}, {@link LocalDate}, {@link LocalTime}, {@link OffsetDateTime},\n * {@link ZonedDateTime} and {@link Duration}.\n *\n * ### Static properties of Class {@link Instant}\n *\n * Instant.EPOCH\n *\n * Instant.MIN\n *\n * Instant.MAX\n *\n * Instant.MIN_SECONDS\n *\n * Instant.MAX_SECONDS\n *\n */\nexport class Instant extends Temporal {\n\n    /**\n     * Obtains the current instant from the system clock, or if specified\n     * the current instant from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     *\n     * @param {Clock} [clock=Clock.systemUTC()] - the clock to use, defaults to the system clock\n     * @return {Instant} the current instant, not null\n     */\n    static now(clock = Clock.systemUTC()){\n        return clock.instant();\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from 1970-01-01T00:00:00Z\n     * @param {number} nanoAdjustment nanoseconds start from the start of epochSecond, if null the nanosecond field is set to zero.\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochSecond(epochSecond, nanoAdjustment=0){\n        const secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        const nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Instant._create(secs, nos);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using milliseconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * The seconds and nanoseconds are extracted from the specified milliseconds.\n     *\n     * @param {number} epochMilli - the number of milliseconds from 1970-01-01T00:00:00Z\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochMilli(epochMilli) {\n        const secs = MathUtil.floorDiv(epochMilli, 1000);\n        const mos = MathUtil.floorMod(epochMilli, 1000);\n        return Instant._create(secs, mos * 1000000);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} using microseconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochMicro - the number of microseconds from 1970-01-01T00:00:00Z\n     * @return {Instant} an instant, not null\n     * @throws DateTimeException if the instant exceeds the maximum or minimum instant\n     */\n    static ofEpochMicro(epochMicro) {\n        const secs = MathUtil.floorDiv(epochMicro, 1000000);\n        const mos = MathUtil.floorMod(epochMicro, 1000000);\n        return Instant._create(secs, mos * 1000);\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Instant}.\n     *\n     * The conversion extracts the {@link ChronoField#INSTANT_SECONDS}\n     * and {@link ChronoField#NANO_OF_SECOND} fields.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link Instant::from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {Instant} the instant, not null\n     * @throws DateTimeException if unable to convert to an {@link Instant}\n     */\n    static from(temporal) {\n        try {\n            const instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n            const nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n            return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain Instant from TemporalAccessor: ${ \n                temporal}, type ${typeof temporal}`, ex);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Instant} from a text string such as\n     * `2007-12-03T10:15:30.000Z`.\n     *\n     * The string must represent a valid instant in UTC and is parsed using\n     * {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Instant} the parsed instant, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text) {\n        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @returns {Instant}\n     * @private\n     */\n    static _create(seconds, nanoOfSecond){\n        if(seconds === 0 && nanoOfSecond === 0){\n            return Instant.EPOCH;\n        }\n        return new Instant(seconds, nanoOfSecond);\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    static _validate(seconds, nanoOfSecond){\n        if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n            throw new DateTimeException('Instant exceeds minimum or maximum instant');\n        }\n    }\n\n    /**\n     *\n     * @param {number} seconds\n     * @param {number} nanoOfSecond\n     * @private\n     */\n    constructor(seconds, nanoOfSecond){\n        super();\n        Instant._validate(seconds, nanoOfSecond);\n        this._seconds = MathUtil.safeToInt(seconds);\n        this._nanos = MathUtil.safeToInt(nanoOfSecond);\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this instant can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link INSTANT_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this instant, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This instant is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as an `int`.\n     *\n     * This queries this instant for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link INSTANT_SECONDS} which is too\n     * large to fit in an `int` and throws a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this instant as a `long`.\n     *\n     * This queries this instant for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this._nanos;\n                case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nanos, 1000);\n                case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n                case ChronoField.INSTANT_SECONDS: return this._seconds;\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n     *\n     * The epoch second count is a simple incrementing count of seconds where\n     * second 0 is 1970-01-01T00:00:00Z.\n     * The nanosecond part of the day is returned by {@link getNanosOfSecond}.\n     *\n     * @return {number} the seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    epochSecond(){\n        return this._seconds;\n    }\n\n    /**\n     * Gets the number of nanoseconds, later along the time-line, from the start\n     * of the second.\n     *\n     * The nanosecond-of-second value measures the total number of nanoseconds from\n     * the second returned by {@link getEpochSecond}.\n     *\n     * @return {number} the nanoseconds within the second, always positive, never exceeds 999,999,999\n     */\n    nano(){\n        return this._nanos;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this instant with the specified field set to a new value.\n     *\n     * This returns a new {@link Instant}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link NANO_OF_SECOND} -\n     *  Returns an {@link Instant} with the specified nano-of-second.\n     *  The epoch-second will be unchanged.\n     * * {@link MICRO_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n     * * {@link MILLI_OF_SECOND} -\n     *  Returns an {@link Instant} with the nano-of-second replaced by the specified\n     *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n     * * {@link INSTANT_SECONDS} -\n     *  Returns an {@link Instant} with the specified epoch-second.\n     *  The nano-of-second will be unchanged.\n     *\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {Instant} an {@link Instant} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.MILLI_OF_SECOND: {\n                    const nval = newValue * NANOS_PER_MILLI;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.MICRO_OF_SECOND: {\n                    const nval = newValue * 1000;\n                    return (nval !== this._nanos? Instant._create(this._seconds, nval) : this);\n                }\n                case ChronoField.NANO_OF_SECOND: return (newValue !== this._nanos? Instant._create(this._seconds, newValue) : this);\n                case ChronoField.INSTANT_SECONDS: return (newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link Instant} truncated to the specified unit.\n     *\n     * Truncating the instant returns a copy of the original with fields\n     * smaller than the specified unit set to zero.\n     * The fields are calculated on the basis of using a UTC offset as seen\n     * in {@link toString}.\n     * For example, truncating with {@link ChronoUnit#MINUTES} will\n     * round down to the nearest minute, setting the seconds and nanoseconds to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalUnit} unit - the unit to truncate to, not null\n     * @return {Instant} an {@link Instant} based on this instant with the time truncated, not null\n     * @throws DateTimeException if the unit is invalid for truncation\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        const unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        const dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        const nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n        const result = MathUtil.intDiv(nod, dur) * dur;\n        return this.plusNanos(result - nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param {!number} amountToAdd\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusMicros(amountToAdd);\n                case ChronoUnit.MILLIS: return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n                case ChronoUnit.HOURS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.HALF_DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n                case ChronoUnit.DAYS: return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd  the seconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusSeconds(secondsToAdd) {\n        return this._plus(secondsToAdd, 0);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToAdd - the milliseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMillis(millisToAdd) {\n        return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanoseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusNanos(nanosToAdd) {\n        return this._plus(0, nanosToAdd);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in microseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} microsToAdd - the microseconds to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified microseconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    plusMicros(microsToAdd) {\n        return this._plus(MathUtil.intDiv(microsToAdd, 1000000), MathUtil.intMod(microsToAdd, 1000000) * 1000);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd - the seconds to add, positive or negative\n     * @param {number} nanosToAdd - the nanos to add, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds added, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    _plus(secondsToAdd, nanosToAdd) {\n        if (secondsToAdd === 0 && nanosToAdd === 0) {\n            return this;\n        }\n        let epochSec = this._seconds + secondsToAdd;\n        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        const nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n        return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * @param {!number} amountToSubtract\n     * @param {!TemporalUnit} unit\n     * @return {Instant}\n     * @throws DateTimeException\n     * @throws ArithmeticException\n     */\n    _minusUnit(amountToSubtract, unit) {\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(secondsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in milliseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} millisToSubtract - the milliseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified milliseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMillis(millisToSubtract) {\n        return this.plusMillis(-1 * millisToSubtract);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract  the nanoseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * nanosToSubtract);\n    }\n\n    /**\n     * Returns a copy of this instant with the specified duration in microseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} microsToSubtract  the microseconds to subtract, positive or negative\n     * @return {Instant} an {@link Instant} based on this instant with the specified microseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the maximum or minimum instant\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMicros(microsToSubtract) {\n        return this.plusMicros(-1 * microsToSubtract);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Queries this instant using the specified query.\n     *\n     * This queries this instant using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {!TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this instant.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the instant changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#INSTANT_SECONDS} and\n     * {@link ChronoField#NANO_OF_SECOND} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisInstant.adjustInto(temporal);\n     *   temporal = temporal.with(thisInstant);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n    }\n\n    /**\n     * Calculates the period between this instant and another instant in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two instants in terms of a single unit.\n     * The start and end points are `this` and the specified instant.\n     * The result will be negative if the end is before the start.\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two instants.\n     * The {@link Temporal} passed to this method is converted to a\n     * {@link Instant} using {@link from}.\n     * For example, the period in days between two dates can be calculated\n     * using `startInstant.until(endInstant, SECONDS)`.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, SECONDS);   // this method\n     *   dateTime.plus(SECONDS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS}, {@link HALF_DAYS} and {@link DAYS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, which is converted to an {@link Instant}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = Instant.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this._nanosUntil(end);\n                case ChronoUnit.MICROS: return this._microsUntil(end);\n                case ChronoUnit.MILLIS: return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n                case ChronoUnit.SECONDS: return this._secondsUntil(end);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(this._secondsUntil(end), (12 * LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.DAYS: return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _microsUntil(end) {\n        const secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        const totalMicros = MathUtil.safeMultiply(secsDiff, 1000000);\n        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1000));\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _nanosUntil(end) {\n        const secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        const totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n    }\n\n    /**\n     *\n     * @param {Temporal} end\n     * @returns {number}\n     * @private\n     */\n    _secondsUntil(end) {\n        let secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        const nanosDiff = end.nano() - this.nano();\n        if (secsDiff > 0 && nanosDiff < 0) {\n            secsDiff--;\n        } else if (secsDiff < 0 && nanosDiff > 0) {\n            secsDiff++;\n        }\n        return secsDiff;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this instant with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this instant at the\n     * specified offset from UTC/Greenwich. An exception will be thrown if the\n     * instant is too large to fit into an offset date-time.\n     *\n     * This method is equivalent to {@link OffsetDateTime#ofInstant}.\n     *\n     * @param {ZoneOffset} offset - the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this instant and the specified offset, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    atOffset(offset) {\n        return OffsetDateTime.ofInstant(this, offset);\n    }\n\n    /**\n     * Combines this instant with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns an {@link ZonedDateTime} formed from this instant at the\n     * specified time-zone. An exception will be thrown if the instant is too\n     * large to fit into a zoned date-time.\n     *\n     * This method is equivalent to {@link ZonedDateTime#ofInstant}.\n     *\n     * @param {ZoneId} zone - the zone to combine with, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this instant and the specified zone, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    atZone(zone) {\n        return ZonedDateTime.ofInstant(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this instant to the number of milliseconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * If this instant represents a point on the time-line too far in the future\n     * or past to fit in a `long` milliseconds, then an exception is thrown.\n     *\n     * If this instant has greater than millisecond precision, then the conversion\n     * will drop any excess precision information as though the amount in nanoseconds\n     * was subject to integer division by one million.\n     *\n     * @return {number} the number of milliseconds since the epoch of 1970-01-01T00:00:00Z\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    toEpochMilli() {\n        const millis = MathUtil.safeMultiply(this._seconds, 1000);\n        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this instant to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws NullPointerException if otherInstant is null\n     */\n    compareTo(otherInstant) {\n        requireNonNull(otherInstant, 'otherInstant');\n        requireInstance(otherInstant, Instant, 'otherInstant');\n        const cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherInstant._nanos;\n    }\n\n    /**\n     * Checks if this instant is after the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isAfter(otherInstant) {\n        return this.compareTo(otherInstant) > 0;\n    }\n\n    /**\n     * Checks if this instant is before the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {Instant} otherInstant  the other instant to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     * @throws NullPointerException if otherInstant is null\n     */\n    isBefore(otherInstant) {\n        return this.compareTo(otherInstant) < 0;\n    }\n\n    /**\n     * Checks if this instant is equal to the specified instant.\n     *\n     * The comparison is based on the time-line position of the instants.\n     *\n     * @param {*} other - the other instant, null/ undefined returns false\n     * @return {boolean} true if the other instant is equal to this one\n     */\n    equals(other) {\n        if(this === other){\n            return true;\n        }\n        if(other instanceof Instant){\n            return this.epochSecond() === other.epochSecond() &&\n                this.nano() === other.nano();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this instant.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._seconds, this._nanos);\n    }\n\n    /**\n     * A string representation of this instant using ISO-8601 representation.\n     *\n     * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.\n     *\n     * @return {string} an ISO-8601 representation of this instant, not null\n     */\n    toString(){\n        return DateTimeFormatter.ISO_INSTANT.format(this);\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDate.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nexport function _init() {\n    Instant.MIN_SECONDS = -31619119219200; // -1000000-01-01T00:00:00Z\n    Instant.MAX_SECONDS = 31494816403199; // +1000000-12-31T23:59:59.999999999Z\n    Instant.EPOCH = new Instant(0, 0);\n    Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n    Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n    Instant.FROM = createTemporalQuery('Instant.FROM', (temporal) => {\n        return Instant.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Instant.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "NANOS_PER_MILLI",
    "memberof": "packages/core/src/Instant.js",
    "static": true,
    "longname": "packages/core/src/Instant.js~NANOS_PER_MILLI",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/Instant.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "Instant",
    "memberof": "packages/core/src/Instant.js",
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Instant.js",
    "importStyle": "{Instant}",
    "description": "An instantaneous point on the time-line.\n\nThis class models a single instantaneous point on the time-line.\nThis might be used to record event time-stamps in the application.\n\nTime-scale\n\nThe length of the solar day is the standard way that humans measure time.\nThis has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,\nforming a 86400 second day.\n\nModern timekeeping is based on atomic clocks which precisely define an SI second\nrelative to the transitions of a Caesium atom. The length of an SI second was defined\nto be very close to the 86400th fraction of a day.\n\nUnfortunately, as the Earth rotates the length of the day varies.\nIn addition, over time the average length of the day is getting longer as the Earth slows.\nAs a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.\nThe actual length of any given day and the amount by which the Earth is slowing\nare not predictable and can only be determined by measurement.\nThe UT1 time-scale captures the accurate length of day, but is only available some\ntime after the day has completed.\n\nThe UTC time-scale is a standard approach to bundle up all the additional fractions\nof a second from UT1 into whole seconds, known as *leap-seconds*.\nA leap-second may be added or removed depending on the Earth's rotational changes.\nAs such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where\nnecessary in order to keep the day aligned with the Sun.\n\nThe modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.\nBetween 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and\nalterations to the length of the notional second. As of 2012, discussions are underway\nto change the definition of UTC again, with the potential to remove leap seconds or\nintroduce other changes.\n\nGiven the complexity of accurate timekeeping described above, this Java API defines\nits own time-scale, the *Java Time-Scale*.\n\nThe Java Time-Scale divides each calendar day into exactly 86400\nsubdivisions, known as seconds.  These seconds may differ from the\nSI second.  It closely matches the de facto international civil time\nscale, the definition of which changes from time to time.\n\nThe Java Time-Scale has slightly different definitions for different\nsegments of the time-line, each based on the consensus international\ntime scale that is used as the basis for civil time. Whenever the\ninternationally-agreed time scale is modified or replaced, a new\nsegment of the Java Time-Scale must be defined for it.  Each segment\nmust meet these requirements:\n\n* the Java Time-Scale shall closely match the underlying international\n  civil time scale;\n* the Java Time-Scale shall exactly match the international civil\n  time scale at noon each day;\n* the Java Time-Scale shall have a precisely-defined relationship to\n  the international civil time scale.\n\nThere are currently, as of 2013, two segments in the Java time-scale.\n\nFor the segment from 1972-11-03 (exact boundary discussed below) until\nfurther notice, the consensus international time scale is UTC (with\nleap seconds).  In this segment, the Java Time-Scale is identical to\n[UTC-SLS](http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/).\nThis is identical to UTC on days that do not have a leap second.\nOn days that do have a leap second, the leap second is spread equally\nover the last 1000 seconds of the day, maintaining the appearance of\nexactly 86400 seconds per day.\n\nFor the segment prior to 1972-11-03, extending back arbitrarily far,\nthe consensus international time scale is defined to be UT1, applied\nproleptically, which is equivalent to the (mean) solar time on the\nprime meridian (Greenwich). In this segment, the Java Time-Scale is\nidentical to the consensus international time scale. The exact\nboundary between the two segments is the instant where UT1 = UTC\nbetween 1972-11-03T00:00 and 1972-11-04T12:00.\n\nImplementations of the Java time-scale using the JSR-310 API are not\nrequired to provide any clock that is sub-second accurate, or that\nprogresses monotonically or smoothly. Implementations are therefore\nnot required to actually perform the UTC-SLS slew or to otherwise be\naware of leap seconds. JSR-310 does, however, require that\nimplementations must document the approach they use when defining a\nclock representing the current instant.\nSee {@link Clock} for details on the available clocks.\n\nThe Java time-scale is used for all date-time classes.\nThis includes {@link Instant}, {@link LocalDate}, {@link LocalTime}, {@link OffsetDateTime},\n{@link ZonedDateTime} and {@link Duration}.\n\n### Static properties of Class {@link Instant}\n\nInstant.EPOCH\n\nInstant.MIN\n\nInstant.MAX\n\nInstant.MIN_SECONDS\n\nInstant.MAX_SECONDS",
    "lineNumber": 129,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.now",
    "access": "public",
    "description": "Obtains the current instant from the system clock, or if specified\nthe current instant from the specified clock.\n\nThis will query the specified clock to obtain the current time.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Clock.systemUTC()",
        "defaultRaw": "Clock.systemUTC()",
        "name": "clock",
        "description": "the clock to use, defaults to the system clock"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the current instant, not null"
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "ofEpochSecond",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.ofEpochSecond",
    "access": "public",
    "description": "Obtains an instance of {@link Instant} using seconds from the\nepoch of 1970-01-01T00:00:00Z.",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochSecond",
        "description": "the number of seconds from 1970-01-01T00:00:00Z"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoAdjustment",
        "description": "nanoseconds start from the start of epochSecond, if null the nanosecond field is set to zero."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an instant, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the instant exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "ofEpochMilli",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.ofEpochMilli",
    "access": "public",
    "description": "Obtains an instance of {@link Instant} using milliseconds from the\nepoch of 1970-01-01T00:00:00Z.\n\nThe seconds and nanoseconds are extracted from the specified milliseconds.",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMilli",
        "description": "the number of milliseconds from 1970-01-01T00:00:00Z"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an instant, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the instant exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "ofEpochMicro",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.ofEpochMicro",
    "access": "public",
    "description": "Obtains an instance of {@link Instant} using microseconds from the\nepoch of 1970-01-01T00:00:00Z.",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMicro",
        "description": "the number of microseconds from 1970-01-01T00:00:00Z"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an instant, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the instant exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.from",
    "access": "public",
    "description": "Obtains an instance of {@link Instant} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link Instant}.\n\nThe conversion extracts the {@link ChronoField#INSTANT_SECONDS}\nand {@link ChronoField#NANO_OF_SECOND} fields.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used as a query via method reference, {@link Instant::from}.",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the instant, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to an {@link Instant}"
      }
    ]
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant.parse",
    "access": "public",
    "description": "Obtains an instance of {@link Instant} from a text string such as\n`2007-12-03T10:15:30.000Z`.\n\nThe string must represent a valid instant in UTC and is parsed using\n{@link DateTimeFormatter#ISO_INSTANT}.",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the parsed instant, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "_create",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant._create",
    "access": "private",
    "description": "",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Instant}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "_validate",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~Instant._validate",
    "access": "private",
    "description": "",
    "lineNumber": 251,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 147,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 266,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "_seconds",
    "memberof": "packages/core/src/Instant.js~Instant",
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_seconds",
    "access": "private",
    "description": null,
    "lineNumber": 269,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "_nanos",
    "memberof": "packages/core/src/Instant.js~Instant",
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_nanos",
    "access": "private",
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this instant can be queried for the specified field.\nIf false, then calling {@link range} and {@link get} will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n* {@link NANO_OF_SECOND}\n* {@link MICRO_OF_SECOND}\n* {@link MILLI_OF_SECOND}\n* {@link INSTANT_SECONDS}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 297,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this instant, false if not"
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis instant is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 329,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#get",
    "access": "public",
    "description": "Gets the value of the specified field from this instant as an `int`.\n\nThis queries this instant for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time, except {@link INSTANT_SECONDS} which is too\nlarge to fit in an `int` and throws a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 357,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this instant as a `long`.\n\nThis queries this instant for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "epochSecond",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#epochSecond",
    "access": "public",
    "description": "Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.\n\nThe epoch second count is a simple incrementing count of seconds where\nsecond 0 is 1970-01-01T00:00:00Z.\nThe nanosecond part of the day is returned by {@link getNanosOfSecond}.",
    "lineNumber": 405,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the seconds from the epoch of 1970-01-01T00:00:00Z"
    },
    "params": []
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#nano",
    "access": "public",
    "description": "Gets the number of nanoseconds, later along the time-line, from the start\nof the second.\n\nThe nanosecond-of-second value measures the total number of nanoseconds from\nthe second returned by {@link getEpochSecond}.",
    "lineNumber": 418,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nanoseconds within the second, always positive, never exceeds 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_withField",
    "access": "private",
    "description": "Returns a copy of this instant with the specified field set to a new value.\n\nThis returns a new {@link Instant}, based on this one, with the value\nfor the specified field changed.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n\n* {@link NANO_OF_SECOND} -\n Returns an {@link Instant} with the specified nano-of-second.\n The epoch-second will be unchanged.\n* {@link MICRO_OF_SECOND} -\n Returns an {@link Instant} with the nano-of-second replaced by the specified\n micro-of-second multiplied by 1,000. The epoch-second will be unchanged.\n* {@link MILLI_OF_SECOND} -\n Returns an {@link Instant} with the nano-of-second replaced by the specified\n milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.\n* {@link INSTANT_SECONDS} -\n Returns an {@link Instant} with the specified epoch-second.\n The nano-of-second will be unchanged.\n\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a {@link DateTimeException} will be thrown.\n\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 466,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field cannot be set"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#truncatedTo",
    "access": "public",
    "description": "Returns a copy of this {@link Instant} truncated to the specified unit.\n\nTruncating the instant returns a copy of the original with fields\nsmaller than the specified unit set to zero.\nThe fields are calculated on the basis of using a UTC offset as seen\nin {@link toString}.\nFor example, truncating with {@link ChronoUnit#MINUTES} will\nround down to the nearest minute, setting the seconds and nanoseconds to zero.\n\nThe unit must have a duration (see {@link TemporalUnit#getDuration})\nthat divides into the length of a standard day without remainder.\nThis includes all supplied time units on {@link ChronoUnit} and\n{@link ChronoUnit#DAYS}. Other units throw an exception.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 509,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to truncate to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the time truncated, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the unit is invalid for truncation"
      }
    ]
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_plusUnit",
    "access": "private",
    "description": "",
    "lineNumber": 535,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#plusSeconds",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in seconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 564,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToAdd",
        "description": "the seconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "plusMillis",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#plusMillis",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in milliseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 578,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "millisToAdd",
        "description": "the milliseconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified milliseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#plusNanos",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in nanoseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 591,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToAdd",
        "description": "the nanoseconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified nanoseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "plusMicros",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#plusMicros",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in microseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 604,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "microsToAdd",
        "description": "the microseconds to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified microseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_plus",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_plus",
    "access": "private",
    "description": "Returns a copy of this instant with the specified duration added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 618,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToAdd",
        "description": "the seconds to add, positive or negative"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToAdd",
        "description": "the nanos to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_minusUnit",
    "access": "private",
    "description": "",
    "lineNumber": 637,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#minusSeconds",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in seconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 650,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToSubtract",
        "description": "the seconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified seconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      }
    ]
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "minusMillis",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#minusMillis",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in milliseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 664,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "millisToSubtract",
        "description": "the milliseconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified milliseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#minusNanos",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in nanoseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 678,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToSubtract",
        "description": "the nanoseconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified nanoseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "minusMicros",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#minusMicros",
    "access": "public",
    "description": "Returns a copy of this instant with the specified duration in microseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 692,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "microsToSubtract",
        "description": "the microseconds to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} based on this instant with the specified microseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the maximum or minimum instant"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#query",
    "access": "public",
    "description": "Queries this instant using the specified query.\n\nThis queries this instant using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 714,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this instant.\n\nThis returns a temporal object of the same observable type as the input\nwith the instant changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\ntwice, passing {@link ChronoField#INSTANT_SECONDS} and\n{@link ChronoField#NANO_OF_SECOND} as the fields.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisInstant.adjustInto(temporal);\n  temporal = temporal.with(thisInstant);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 753,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#until",
    "access": "public",
    "description": "Calculates the period between this instant and another instant in\nterms of the specified unit.\n\nThis calculates the period between two instants in terms of a single unit.\nThe start and end points are `this` and the specified instant.\nThe result will be negative if the end is before the start.\nThe calculation returns a whole number, representing the number of\ncomplete units between the two instants.\nThe {@link Temporal} passed to this method is converted to a\n{@link Instant} using {@link from}.\nFor example, the period in days between two dates can be calculated\nusing `startInstant.until(endInstant, SECONDS)`.\n\nThis method operates in association with {@link TemporalUnit#between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, SECONDS);   // this method\n  dateTime.plus(SECONDS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n{@link MINUTES}, {@link HOURS}, {@link HALF_DAYS} and {@link DAYS}\nare supported. Other {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing `this` as the first argument and the input temporal as\nthe second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 799,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date, which is converted to an {@link Instant}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this date and the end date"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be calculated"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "_microsUntil",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_microsUntil",
    "access": "private",
    "description": "",
    "lineNumber": 825,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "_nanosUntil",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_nanosUntil",
    "access": "private",
    "description": "",
    "lineNumber": 837,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "_secondsUntil",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#_secondsUntil",
    "access": "private",
    "description": "",
    "lineNumber": 849,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "atOffset",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#atOffset",
    "access": "public",
    "description": "Combines this instant with an offset to create an {@link OffsetDateTime}.\n\nThis returns an {@link OffsetDateTime} formed from this instant at the\nspecified offset from UTC/Greenwich. An exception will be thrown if the\ninstant is too large to fit into an offset date-time.\n\nThis method is equivalent to {@link OffsetDateTime#ofInstant}.",
    "lineNumber": 874,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the offset date-time formed from this instant and the specified offset, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "atZone",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#atZone",
    "access": "public",
    "description": "Combines this instant with a time-zone to create a {@link ZonedDateTime}.\n\nThis returns an {@link ZonedDateTime} formed from this instant at the\nspecified time-zone. An exception will be thrown if the instant is too\nlarge to fit into a zoned date-time.\n\nThis method is equivalent to {@link ZonedDateTime#ofInstant}.",
    "lineNumber": 891,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time formed from this instant and the specified zone, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "toEpochMilli",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#toEpochMilli",
    "access": "public",
    "description": "Converts this instant to the number of milliseconds from the epoch\nof 1970-01-01T00:00:00Z.\n\nIf this instant represents a point on the time-line too far in the future\nor past to fit in a `long` milliseconds, then an exception is thrown.\n\nIf this instant has greater than millisecond precision, then the conversion\nwill drop any excess precision information as though the amount in nanoseconds\nwas subject to integer division by one million.",
    "lineNumber": 910,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of milliseconds since the epoch of 1970-01-01T00:00:00Z"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#compareTo",
    "access": "public",
    "description": "Compares this instant to the specified instant.\n\nThe comparison is based on the time-line position of the instants.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 926,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "otherInstant",
        "description": "the other instant to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NullPointerException if otherInstant is null"
      }
    ]
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#isAfter",
    "access": "public",
    "description": "Checks if this instant is after the specified instant.\n\nThe comparison is based on the time-line position of the instants.",
    "lineNumber": 945,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "otherInstant",
        "description": "the other instant to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this instant is after the specified instant"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NullPointerException if otherInstant is null"
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#isBefore",
    "access": "public",
    "description": "Checks if this instant is before the specified instant.\n\nThe comparison is based on the time-line position of the instants.",
    "lineNumber": 958,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "otherInstant",
        "description": "the other instant to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this instant is before the specified instant"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NullPointerException if otherInstant is null"
      }
    ]
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#equals",
    "access": "public",
    "description": "Checks if this instant is equal to the specified instant.\n\nThe comparison is based on the time-line position of the instants.",
    "lineNumber": 970,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other instant, null/ undefined returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the other instant is equal to this one"
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#hashCode",
    "access": "public",
    "description": "Returns a hash code for this instant.",
    "lineNumber": 986,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#toString",
    "access": "public",
    "description": "A string representation of this instant using ISO-8601 representation.\n\nThe format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.",
    "lineNumber": 997,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "an ISO-8601 representation of this instant, not null"
    },
    "params": []
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Instant.js~Instant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Instant.js~Instant#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1005,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalDate.toString}"
    },
    "params": []
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/Instant.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Instant.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Instant.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1010,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "packages/core/src/LocalDate.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, requireNonNull, requireInstance } from './assert';\n\nimport { MathUtil } from './MathUtil';\nimport { DateTimeException, UnsupportedTemporalTypeException, NullPointerException, IllegalArgumentException } from './errors';\n\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { ChronoLocalDate } from './chrono/ChronoLocalDate';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { ValueRange } from './temporal/ValueRange';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\n\nimport { Clock } from './Clock';\nimport { DayOfWeek } from './DayOfWeek';\nimport { OffsetDateTime } from './OffsetDateTime';\nimport { OffsetTime } from './OffsetTime';\nimport { Month } from './Month';\nimport { Period } from './Period';\nimport { YearConstants } from './YearConstants';\nimport { LocalTime } from './LocalTime';\nimport { LocalDateTime } from './LocalDateTime';\nimport { Year } from './Year';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\nimport { ZonedDateTime } from './ZonedDateTime';\n\n/**\n * The number of days in a 400 year cycle.\n */\nconst  DAYS_PER_CYCLE = 146097;\n\n/**\n* The number of days from year zero to year 1970.\n* There are five 400 year cycles from year zero to 2000.\n* There are 7 leap years from 1970 to 2000.\n*/\nconst  DAYS_0000_TO_1970 = (DAYS_PER_CYCLE * 5) - (30 * 365 + 7);\n\n/**\n * A date without a time-zone in the ISO-8601 calendar system,\n * such as 2007-12-03.\n *\n * LocalDate is an immutable date-time object that represents a date,\n * often viewed as year-month-day. Other date fields, such as day-of-year,\n * day-of-week and week-of-year, can also be accessed.\n * For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n *\n * This class does not store or represent a time or time-zone.\n * Instead, it is a description of the date, as used for birthdays.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * LocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n *\n * The minimum supported {@link LocalDate}\n * This could be used by an application as a \"far past\" date.\n *\n * LocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n *\n * The maximum supported {@link LocalDate}\n * This could be used by an application as a \"far future\" date.\n *\n * LocalDate.EPOCH_0\n *\n * The date at epoch day 0, that is 1970-01-01.\n */\n\nexport class LocalDate extends ChronoLocalDate{\n\n    /**\n     * Obtains the current date from the system clock in the default time-zone or\n     * if specified, the current date from the specified clock or\n     * if argument is a ZoneId this will query a clock with the specified ZoneId.\n     *\n     * This will query the specified clock to obtain the current date - today.\n     * Using this method allows the use of an alternate clock for testing.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()] - the clock or zone to use,\n     * if null, the system clock and default time-zone is used.\n     * @return {LocalDate} the current date, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone == null){\n            clock = Clock.systemDefaultZone();\n        } else if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone;\n        }\n        return LocalDate.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalDate from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalDate} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        requireNonNull(instant, 'instant');\n        const offset = zone.rules().offset(instant);\n        const epochSec = instant.epochSecond() + offset.totalSeconds();\n        const epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n        return LocalDate.ofEpochDay(epochDay);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year, month and day.\n     *\n     * This returns a {@link LocalDate} with the specified year, month and day-of-month.\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!(Month|Number)} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {!number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    static of(year, month, dayOfMonth) {\n        return new LocalDate(year, month, dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a year and day-of-year.\n     *\n     * This returns a {@link LocalDate} with the specified year and day-of-year.\n     * The day-of-year must be valid for the year, otherwise an exception will be thrown.\n     *\n     * @param {!number} year - the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} dayOfYear - the day-of-year to represent, from 1 to 366\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if the value of any field is out of range,\n     *  or if the day-of-year is invalid for the year\n     */\n    static ofYearDay(year, dayOfYear) {\n        ChronoField.YEAR.checkValidValue(year);\n        //TODO: ChronoField.DAY_OF_YEAR.checkValidValue(dayOfYear);\n        const leap = IsoChronology.isLeapYear(year);\n        if (dayOfYear === 366 && leap === false) {\n            assert(false, `Invalid date 'DayOfYear 366' as '${year}' is not a leap year`, DateTimeException);\n        }\n        let moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n        const monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear > monthEnd) {\n            moy = moy.plus(1);\n        }\n        const dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.value(), dom);\n    }\n\n    /**\n     * Obtains an instance of LocalDate from the epoch day count.\n     *\n     * This returns a LocalDate with the specified epoch-day.\n     * The {@link ChronoField.EPOCH_DAY} is a simple incrementing count\n     * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.\n     *\n     * @param {number} [epochDay=0] - the Epoch Day to convert, based on the epoch 1970-01-01\n     * @return {LocalDate} the local date, not null\n     * @throws {AssertionError} if the epoch days exceeds the supported date range\n     */\n    static ofEpochDay(epochDay=0) {\n        let adjust, adjustCycles, doyEst, yearEst, zeroDay;\n        zeroDay = epochDay + DAYS_0000_TO_1970;\n        zeroDay -= 60;\n        adjust = 0;\n        if (zeroDay < 0) {\n            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n            adjust = adjustCycles * 400;\n            zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n        }\n        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        if (doyEst < 0) {\n            yearEst--;\n            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        }\n        yearEst += adjust;\n        const marchDoy0 = doyEst;\n        const marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n        const month = (marchMonth0 + 2) % 12 + 1;\n        const dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n        yearEst += MathUtil.intDiv(marchMonth0, 10);\n        const year = yearEst;\n        return new LocalDate(year, month, dom);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDate}.\n     *\n     * The conversion uses the {@link TemporalQueries.localDate} query, which relies\n     * on extracting the {@link ChronoField.EPOCH_DAY} field.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDate::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDate} the local date, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDate}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const date = temporal.query(TemporalQueries.localDate());\n        if (date == null) {\n            throw new DateTimeException(\n                `Unable to obtain LocalDate from TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return date;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDate} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE] - the formatter to use, default is\n     * {@link DateTimeFormatter.ISO_LOCAL_DATE}\n     * @return {LocalDate} the parsed local date, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE){\n        assert(formatter != null, 'formatter', NullPointerException);\n        return formatter.parse(text, LocalDate.FROM);\n    }\n\n    /**\n     * Resolves the date, resolving days past the end of month.\n     *\n     * @param {!number} year - the year to represent, validated from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @param {!number} month - the month-of-year to represent, validated from 1 to 12\n     * @param {!number} day - the day-of-month to represent, validated from 1 to 31\n     * @return {LocalDate} resolved date, not null\n     */\n    static _resolvePreviousValid(year, month, day) {\n        switch (month) {\n            case 2:\n                day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day = Math.min(day, 30);\n                break;\n        }\n        return LocalDate.of(year, month, day);\n    }\n\n    /**\n     * Do not call the constructor directly, use the of*() factories instead like {@link LocalDate.of}\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} month\n     * @param {!number} dayOfMonth\n     * @private\n     */\n    constructor(year, month, dayOfMonth){\n        super();\n        requireNonNull(year, 'year');\n        requireNonNull(month, 'month');\n        requireNonNull(dayOfMonth, 'dayOfMonth');\n\n        if (month instanceof Month) {\n            month = month.value();\n        }\n        this._year = MathUtil.safeToInt(year);\n        this._month = MathUtil.safeToInt(month);\n        this._day = MathUtil.safeToInt(dayOfMonth);\n        LocalDate._validate(this._year, this._month, this._day);\n    }\n\n\n    /**\n     *\n     * @param {!number} year\n     * @param {!number} month\n     * @param {!number} dayOfMonth\n     * @throws {DateTimeException} if date values are invalid\n     * @private\n     */\n    static _validate(year, month, dayOfMonth) {\n        let dom;\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n        if (dayOfMonth > 28) {\n            dom = 31;\n            switch (month) {\n                case 2:\n                    dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom = 30;\n            }\n            if (dayOfMonth > dom) {\n                if (dayOfMonth === 29) {\n                    assert(false, `Invalid date 'February 29' as '${year}' is not a leap year`, DateTimeException);\n                } else {\n                    assert(false, `Invalid date '${year}' '${month}' '${dayOfMonth}'`, DateTimeException);\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link LocalDate.range} range and\n     * {@link LocalDate.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date, false if not\n     */\n    isSupported(field) {\n        return super.isSupported(field);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field.isDateBased()) {\n                switch (field) {\n                    case ChronoField.DAY_OF_MONTH: return ValueRange.of(1, this.lengthOfMonth());\n                    case ChronoField.DAY_OF_YEAR: return ValueRange.of(1, this.lengthOfYear());\n                    case ChronoField.ALIGNED_WEEK_OF_MONTH: return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n                    case ChronoField.YEAR_OF_ERA:\n                        return (this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an `int`.\n     *\n     * This queries this date for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link LocalDate.isSupported} supported fields will return valid\n     * values based on this date, except {@link ChronoField.EPOCH_DAY} and {@link ChronoField.EPOCH_MONTH}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * see {LocalDate.get}, get and getLong are identical in javascript, because we are only limited by\n     * {@link MathUtil.MIN_SAFE_INTEGER}/ {@link MathUtil.MAX_SAFE_INTEGER}\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     */\n    getLong(field) {\n        assert(field != null, '', NullPointerException);\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * TODO tests are missing for the ALIGNED_* ChronoFields\n     *\n     * @param {!TemporalField} field\n     * @returns {*}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.DAY_OF_WEEK: return this.dayOfWeek().value();\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return MathUtil.intMod((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return MathUtil.intMod((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.DAY_OF_MONTH: return this._day;\n            case ChronoField.DAY_OF_YEAR: return this.dayOfYear();\n            case ChronoField.EPOCH_DAY: return this.toEpochDay();\n            case ChronoField.ALIGNED_WEEK_OF_MONTH: return MathUtil.intDiv((this._day - 1), 7) + 1;\n            case ChronoField.ALIGNED_WEEK_OF_YEAR: return MathUtil.intDiv((this.dayOfYear() - 1), 7) + 1;\n            case ChronoField.MONTH_OF_YEAR: return this._month;\n            case ChronoField.PROLEPTIC_MONTH: return this._prolepticMonth();\n            case ChronoField.YEAR_OF_ERA: return (this._year >= 1 ? this._year : 1 - this._year);\n            case ChronoField.YEAR: return this._year;\n            case ChronoField.ERA: return (this._year >= 1 ? 1 : 0);\n        }\n        throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n    }\n\n    /**\n     *\n     * @return {number}\n     * @private\n     */\n    _prolepticMonth() {\n        return (this._year * 12) + (this._month - 1);\n    }\n\n    /**\n     * Gets the chronology of this date, which is the ISO calendar system.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The ISO-8601 calendar system is the modern civil calendar system used today\n     * in most of the world. It is equivalent to the proleptic Gregorian calendar\n     * system, in which today's rules for leap years are applied for all time.\n     *\n     * @return {Chronology} the ISO chronology, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     *\n     * @return {number} gets the year\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     *\n     * @return {number} gets the month value\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     *\n     * @returns {Month} month\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     *\n     * @return {number} gets the day of month\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    /**\n      * Gets the day-of-year field.\n      *\n      * This method returns the primitive int value for the day-of-year.\n      *\n      * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n      */\n    dayOfYear() {\n        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link DayOfWeek.value} int value.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        const dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    }\n\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Returns the length of the month represented by this date.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days\n     */\n    lengthOfMonth() {\n        switch (this._month) {\n            case 2:\n                return (this.isLeapYear() ? 29 : 28);\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Returns the length of the year represented by this date.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * Returns an adjusted copy of this date.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDate.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * @param {!TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDate}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link DAY_OF_WEEK} -\n     *   Returns a {@link LocalDate} with the specified day-of-week.\n     *   The date is adjusted up to 6 days forward or backward within the boundary\n     *   of a Monday to Sunday week.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified month-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This may cause the date to be moved up to 6 days into the following month.\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-day-of-week.\n     *   The date is adjusted to the specified year-based aligned-day-of-week.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This may cause the date to be moved up to 6 days into the following year.\n     * * {@link DAY_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified day-of-month.\n     *   The month and year will be unchanged. If the day-of-month is invalid for the\n     *   year and month, then a {@link DateTimeException} is thrown.\n     * * {@link DAY_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified day-of-year.\n     *   The year will be unchanged. If the day-of-year is invalid for the\n     *   year, then a {@link DateTimeException} is thrown.\n     * * {@link EPOCH_DAY} -\n     *   Returns a {@link LocalDate} with the specified epoch-day.\n     *   This completely replaces the date and is equivalent to {@link ofEpochDay}.\n     * * {@link ALIGNED_WEEK_OF_MONTH} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-month.\n     *   Aligned weeks are counted such that the first week of a given month starts\n     *   on the first day of that month.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following month.\n     * * {@link ALIGNED_WEEK_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified aligned-week-of-year.\n     *   Aligned weeks are counted such that the first week of a given year starts\n     *   on the first day of that year.\n     *   This adjustment moves the date in whole week chunks to match the specified week.\n     *   The result will have the same day-of-week as this date.\n     *   This may cause the date to be moved into the following year.\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link LocalDate} with the specified month-of-year.\n     *   The year will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link LocalDate} with the specified proleptic-month.\n     *   The day-of-month will be unchanged, unless it would be invalid for the new month\n     *   and year. In that case, the day-of-month is adjusted to the maximum valid value\n     *   for the new month and year.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link LocalDate} with the specified year-of-era.\n     *   The era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link YEAR} -\n     *   Returns a {@link LocalDate} with the specified year.\n     *   The month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     * * {@link ERA} -\n     *   Returns a {@link LocalDate} with the specified era.\n     *   The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n     *   unless it would be invalid for the new month and year. In that case, the\n     *   day-of-month is adjusted to the maximum valid value for the new month and year.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDate} a {@link LocalDate} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        assert(field != null, 'field', NullPointerException);\n        if (field instanceof ChronoField) {\n            const f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.DAY_OF_WEEK: return this.plusDays(newValue - this.dayOfWeek().value());\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR: return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case ChronoField.DAY_OF_MONTH: return this.withDayOfMonth(newValue);\n                case ChronoField.DAY_OF_YEAR: return this.withDayOfYear(newValue);\n                case ChronoField.EPOCH_DAY: return LocalDate.ofEpochDay(newValue);\n                case ChronoField.ALIGNED_WEEK_OF_MONTH: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n                case ChronoField.ALIGNED_WEEK_OF_YEAR: return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year >= 1 ? newValue : 1 - newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * Returns a copy of this date with the year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!number} year  the year to set in the result, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        if (this._year === year) {\n            return this;\n        }\n        ChronoField.YEAR.checkValidValue(year);\n        return LocalDate._resolvePreviousValid(year, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this date with the month-of-year altered.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * @param {!(Month|number)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        const m = (month instanceof Month) ? month.value() : month;\n        if (this._month === m) {\n            return this;\n        }\n        ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n        return LocalDate._resolvePreviousValid(this._year, m, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the day-of-month altered.\n     *\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param {!number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (this._day === dayOfMonth) {\n            return this;\n        }\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a copy of this date with the day-of-year altered.\n     * If the resulting date is invalid, an exception is thrown.\n     *\n     * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDate} a {@link LocalDate} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        if (this.dayOfYear() === dayOfYear) {\n            return this;\n        }\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period added.\n     *\n     * This method returns a new date based on this date with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.plusDays(amountToAdd);\n                case ChronoUnit.WEEKS: return this.plusWeeks(amountToAdd);\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * @param {!number} yearsToAdd - the years to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * @param {number} monthsToAdd - the months to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        const monthCount = this._year * 12 + (this._month - 1);\n        const calcMonths = monthCount + monthsToAdd;  // safe overflow\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        const newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * @param {!number} weeksToAdd - the weeks to add, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeksToAdd) {\n        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n    }\n\n\n    /**\n     * Returns a copy of this LocalDate with the specified number of days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * @param {number} daysToAdd - the days to add, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days added, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        const mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    }\n\n    /**\n     * Returns a copy of this date with the specified period subtracted.\n     *\n     * This method returns a new date based on this date with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * @param {!number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {!TemporalUnit} unit  the unit of the period to subtract, not null\n     * @return {LocalDate} a {@link LocalDate} based on this date with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _minusUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2007-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} yearsToSubtract - the years to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(yearsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-02-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-02-28, is selected instead.\n     *\n     * @param {!number} monthsToSubtract - the months to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(monthsToSubtract * -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDate} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * @param {!number} weeksToSubtract - the weeks to subtract, may be negative\n     * @return {LocalDate} a {@link LocalDate} based on this date with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeksToSubtract) {\n        return this.plusWeeks(weeksToSubtract * -1);\n    }\n\n    /*\n     * Returns a copy of this LocalDate with the specified number of days subtracted.\n     *\n     * This method subtracts the specified amount from the days field decrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * @param {number} daysToSubtract - the days to subtract, may be negative\n     * @return {LocalDate} a LocalDate based on this date with the days subtracted, not null\n     * @throws AssertionError if the result exceeds the supported date range\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(daysToSubtract * -1);\n    }\n\n    /**\n     * Queries this date using the specified query.\n     *\n     * This queries this date using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField.EPOCH_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDate);\n     * </pre>\n     *\n     * @param {!TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * function overloading for {@link LocalDate.until}\n     *\n     * called with 1 (or less) arguments {{@link LocalDate.until1}} is called\n     * otherwise {@link LocalDate.until2}\n     *\n     * @param {!TemporalAccessor} p1\n     * @param {TemporalUnit} p2 - not null if called with 2 arguments\n     * @return {number|Period}\n     */\n    until(p1, p2){\n        if(arguments.length < 2){\n            return this.until1(p1);\n        } else {\n            return this.until2(p1, p2);\n        }\n    }\n\n    /**\n     * Calculates the period between this date and another date in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two dates in terms of a single unit.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDate}.\n     * For example, the period in days between two dates can be calculated\n     * using {@link startDate.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the period in months between 2012-06-15 and 2012-08-14\n     * will only be one month as it is one day short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link DAYS}, {@link WEEKS}, {@link MONTHS}, {@link YEARS},\n     * {@link DECADES}, {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS}\n     * are supported. Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * @param {!TemporalAccessor} endExclusive - the end date, which is converted to a {@link LocalDate}, not null\n     * @param {!TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date and the end date\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until2(endExclusive, unit) {\n        const end = LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.DAYS: return this.daysUntil(end);\n                case ChronoUnit.WEEKS: return MathUtil.intDiv(this.daysUntil(end), 7);\n                case ChronoUnit.MONTHS: return this._monthsUntil(end);\n                case ChronoUnit.YEARS: return MathUtil.intDiv(this._monthsUntil(end), 12);\n                case ChronoUnit.DECADES: return MathUtil.intDiv(this._monthsUntil(end), 120);\n                case ChronoUnit.CENTURIES: return MathUtil.intDiv(this._monthsUntil(end), 1200);\n                case ChronoUnit.MILLENNIA: return MathUtil.intDiv(this._monthsUntil(end), 12000);\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @protected\n     */\n    daysUntil(end) {\n        return end.toEpochDay() - this.toEpochDay();  // no overflow\n    }\n\n    /**\n     *\n     * @param {!LocalDate} end\n     * @returns {number}\n     * @private\n     */\n    _monthsUntil(end) {\n        const packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();  // no overflow\n        const packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();  // no overflow\n        return MathUtil.intDiv((packed2 - packed1), 32);\n    }\n\n    /**\n     * Calculates the period between this date and another date as a {@link Period}.\n     *\n     * This calculates the period between two dates in terms of years, months and days.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     *\n     * The calculation is performed using the ISO calendar system.\n     * If necessary, the input date will be converted to ISO.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then normalized into years and months based on a 12 month year.\n     * A month is considered to be complete if the end day-of-month is greater\n     * than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is \"1 year, 2 months and 3 days\".\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link Period#between}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   period = start.until(end);\n     *   period = Period.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * @param {!TemporalAccessor} endDate - the end date, exclusive, which may be in any chronology, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    until1(endDate) {\n        const end = LocalDate.from(endDate);\n        let totalMonths = end._prolepticMonth() - this._prolepticMonth();  // safe\n        let days = end._day - this._day;\n        if (totalMonths > 0 && days < 0) {\n            totalMonths--;\n            const calcDate = this.plusMonths(totalMonths);\n            days = (end.toEpochDay() - calcDate.toEpochDay());  // safe\n        } else if (totalMonths < 0 && days > 0) {\n            totalMonths++;\n            days -= end.lengthOfMonth();\n        }\n        const years = MathUtil.intDiv(totalMonths, 12);  // safe\n        const months = MathUtil.intMod(totalMonths, 12);  // safe\n        return Period.of(years, months, days);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDate.atTime}\n     *\n     * if called with 1 argument {@link LocalDate.atTime1} is called\n     * otherwise {@link LocalDate.atTime4}\n     *\n     * @return {LocalDateTime|OffsetDateTime} the local date-time formed from this date and the specified params\n     */\n    atTime(){\n        if(arguments.length===1){\n            return this.atTime1.apply(this, arguments);\n        } else {\n            return this.atTime4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalTime} time - the time to combine with, not null\n     * @return {LocalDateTime|OffsetDateTime} the date-time formed from this date and the specified time, not null\n     */\n    atTime1(time) {\n        requireNonNull(time, 'time');\n        if (time instanceof LocalTime) {\n            return LocalDateTime.of(this, time);\n        } else if (time instanceof OffsetTime) {\n            return this._atTimeOffsetTime(time);\n        } else {\n            throw new IllegalArgumentException(`time must be an instance of LocalTime or OffsetTime${ \n                time && time.constructor && time.constructor.name ? `, but is ${time.constructor.name}` : ''}`);\n        }\n    }\n\n    /**\n     * Combines this date with a time to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the\n     * specified hour, minute, second and nanosecond.\n     * The individual time fields must be within their valid range.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {!number} hour - the hour-of-day to use, from 0 to 23\n     * @param {!number} minute - the minute-of-hour to use, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time formed from this date and the specified time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    atTime4(hour, minute, second=0, nanoOfSecond=0) {\n        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n    }\n\n    /**\n     * Combines this date with an offset time to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {OffsetTime} time - the time to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date and the specified time, not null\n     */\n    _atTimeOffsetTime(time) { // atTime(offsetTime)\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());\n    }\n\n    /**\n     * Combines this date with the time of midnight to create a {@link LocalDateTime}\n     * at the start of this date.\n     *\n     * This returns a {@link LocalDateTime} formed from this date at the time of\n     * midnight, 00:00, at the start of this date.\n     *\n     * If zone is not null, this returns a {@link ZonedDateTime} formed from this date at the\n     * specified zone, with the time set to be the earliest valid time according\n     * to the rules in the time-zone.\n     *\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     *\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     *\n     * To convert to a specific time in a given time-zone call {@link atTime}\n     * followed by {@link LocalDateTime#atZone}.\n     *\n     * @param {ZoneId} zone - optional ZoneId or ZoneOffset\n     * @return {LocalDateTime|ZonedDateTime} the local date-time of midnight at the start of this date, not null\n     */\n    atStartOfDay(zone) {\n        if(zone != null){\n            return this._atStartOfDayWithZone(zone);\n        } else {\n            return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n        }\n    }\n\n    /**\n     * Combines this date with a time-zone to create a {@link ZonedDateTime}\n     * at the start of the day\n     *\n     * This returns a {@link ZonedDateTime} formed from this date at the\n     * specified zone, with the time set to be the earliest valid time according\n     * to the rules in the time-zone.\n     *\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may not be midnight.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, there are two valid offsets, and the earlier one is used,\n     * corresponding to the first occurrence of midnight on the date.\n     * In the case of a gap, the zoned date-time will represent the instant just after the gap.\n     *\n     * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n     *\n     * To convert to a specific time in a given time-zone call {@link atTime}\n     * followed by {@link LocalDateTime#atZone}.\n     *\n     * @param {!ZoneId} zone - the zone ID to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    _atStartOfDayWithZone(zone) {\n        requireNonNull(zone, 'zone');\n        let ldt = this.atTime(LocalTime.MIDNIGHT);\n        // need to handle case where there is a gap from 11:30 to 00:30\n        // standard ZDT factory would result in 01:00 rather than 00:30\n        if (zone instanceof ZoneOffset === false) {\n            const trans = zone.rules().transition(ldt);\n            if (trans != null && trans.isGap()) {\n                ldt = trans.dateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    }\n\n\n    /**\n     * Converts this date to the Epoch Day.\n     *\n     * The Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 (ISO).\n     * This definition is the same for all chronologies, enabling conversion.\n     *\n     * @return {number} the Epoch Day equivalent to this date\n     */\n    toEpochDay() {\n        const y = this._year;\n        const m = this._month;\n        let total = 0;\n        total += 365 * y;\n        if (y >= 0) {\n            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n        } else {\n            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n        }\n        total += MathUtil.intDiv(367 * m - 362, 12);\n        total += this.dayOfMonth() - 1;\n        if (m > 2) {\n            total--;\n            if (!IsoChronology.isLeapYear(y)) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    }\n\n    /**\n     * Compares this date to another date.\n     *\n     * The comparison is primarily based on the date, from earliest to latest.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * If all the dates being compared are instances of {@link LocalDate},\n     * then the comparison will be entirely based on the date.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDate.compareTo}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDate, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other);  if not instanceof LocalDate\n    }\n\n    /**\n     *\n     * @param {!LocalDate} otherDate\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(otherDate) {\n        let cmp = (this._year - otherDate._year);\n        if (cmp === 0) {\n            cmp = (this._month - otherDate._month);\n            if (cmp === 0) {\n                cmp = (this._day - otherDate._day);\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date is after the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line after the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is after the specified date\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is before the specified date.\n     *\n     * This checks to see if this date represents a point on the\n     * local time-line before the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is before the specified date\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to the specified date.\n     *\n     * This checks to see if this date represents the same point on the\n     * local time-line as the other date.\n     * <pre>\n     *   LocalDate a = LocalDate.of(2012, 6, 30);\n     *   LocalDate b = LocalDate.of(2012, 7, 1);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two dates on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo}\n     * but is the same approach as {@link DATE_COMPARATOR}.\n     *\n     * @param {!LocalDate} other - the other date to compare to, not null\n     * @return {boolean} true if this date is equal to the specified date\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other) if not instanceof LocalDate\n    }\n\n    /**\n     * Checks if this date is equal to another date.\n     *\n     * Compares this LocalDate with another ensuring that the date is the same.\n     *\n     * Only objects of type LocalDate are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDate) {\n            return this._compareTo0(other) === 0;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n        return MathUtil.hash((yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue)));\n    }\n\n    /**\n     * Outputs this date as a String, such as 2007-12-03.\n     * The output will be in the ISO-8601 format uuuu-MM-dd.\n     *\n     * @return {string} a string representation of this date, not null\n     */\n    toString() {\n        let dayString, monthString, yearString;\n\n        const yearValue = this._year;\n        const monthValue = this._month;\n        const dayValue = this._day;\n\n        const absYear = Math.abs(yearValue);\n\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = `-${(`${yearValue - 10000}`).slice(-4)}`;\n            } else {\n                yearString = (`${yearValue + 10000}`).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = `+${yearValue}`;\n            } else {\n                yearString = `${yearValue}`;\n            }\n        }\n\n        if (monthValue < 10) {\n            monthString = `-0${monthValue}`;\n        } else {\n            monthString = `-${monthValue}`;\n        }\n\n        if (dayValue < 10) {\n            dayString = `-0${dayValue}`;\n        } else {\n            dayString = `-${dayValue}`;\n        }\n\n        return yearString + monthString + dayString;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDate.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return super.format(formatter);\n    }\n}\n\nexport function _init() {\n    /**\n     * The minimum supported {@link LocalDate}\n     * This could be used by an application as a \"far past\" date.\n     */\n    LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n    /**\n     * The maximum supported {@link LocalDate}\n     * This could be used by an application as a \"far future\" date.\n     */\n    LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n    /**\n     * The date at epoch day 0, that is 1970-01-01.\n     */\n    LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n\n    LocalDate.FROM = createTemporalQuery('LocalDate.FROM', (temporal) => {\n        return LocalDate.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/LocalDate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "variable",
    "name": "DAYS_PER_CYCLE",
    "memberof": "packages/core/src/LocalDate.js",
    "static": true,
    "longname": "packages/core/src/LocalDate.js~DAYS_PER_CYCLE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/LocalDate.js",
    "importStyle": null,
    "description": "The number of days in a 400 year cycle.",
    "lineNumber": 38,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "variable",
    "name": "DAYS_0000_TO_1970",
    "memberof": "packages/core/src/LocalDate.js",
    "static": true,
    "longname": "packages/core/src/LocalDate.js~DAYS_0000_TO_1970",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/LocalDate.js",
    "importStyle": null,
    "description": "The number of days from year zero to year 1970.\nThere are five 400 year cycles from year zero to 2000.\nThere are 7 leap years from 1970 to 2000.",
    "lineNumber": 45,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "class",
    "name": "LocalDate",
    "memberof": "packages/core/src/LocalDate.js",
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalDate.js",
    "importStyle": "{LocalDate}",
    "description": "A date without a time-zone in the ISO-8601 calendar system,\nsuch as 2007-12-03.\n\nLocalDate is an immutable date-time object that represents a date,\noften viewed as year-month-day. Other date fields, such as day-of-year,\nday-of-week and week-of-year, can also be accessed.\nFor example, the value \"2nd October 2007\" can be stored in a LocalDate.\n\nThis class does not store or represent a time or time-zone.\nInstead, it is a description of the date, as used for birthdays.\nIt cannot represent an instant on the time-line without additional information\nsuch as an offset or time-zone.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\n### Static properties of Class {@link LocalDate}\n\nLocalDate.MIN = LocalDate.of(Year.MIN_VALUE, 1, 1);\n\nThe minimum supported {@link LocalDate}\nThis could be used by an application as a \"far past\" date.\n\nLocalDate.MAX = LocalDate.of(Year.MAX_VALUE, 12, 31);\n\nThe maximum supported {@link LocalDate}\nThis could be used by an application as a \"far future\" date.\n\nLocalDate.EPOCH_0\n\nThe date at epoch day 0, that is 1970-01-01.",
    "lineNumber": 85,
    "interface": false,
    "extends": [
      "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate"
    ]
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.now",
    "access": "public",
    "description": "Obtains the current date from the system clock in the default time-zone or\nif specified, the current date from the specified clock or\nif argument is a ZoneId this will query a clock with the specified ZoneId.\n\nThis will query the specified clock to obtain the current date - today.\nUsing this method allows the use of an alternate clock for testing.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Clock.systemDefaultZone()",
        "defaultRaw": "Clock.systemDefaultZone()",
        "name": "clockOrZone",
        "description": "the clock or zone to use,\nif null, the system clock and default time-zone is used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the current date, not null"
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.ofInstant",
    "access": "public",
    "description": "obtain a LocalDate from an Instant in the specified time-zone or, if null\nin the system default time-zone",
    "lineNumber": 119,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{LocalDate} the current date, not null"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "ZoneId.systemDefault()",
        "defaultRaw": "ZoneId.systemDefault()",
        "name": "zone",
        "description": ", defaults to ZoneId.systemDefault()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the current date, not null"
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.of",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDate} from a year, month and day.\n\nThis returns a {@link LocalDate} with the specified year, month and day-of-month.\nThe day must be valid for the year and month, otherwise an exception will be thrown.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}"
      },
      {
        "nullable": false,
        "types": [
          "Month",
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, from 1 (January) to 12 (December)"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range,\n or if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "ofYearDay",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.ofYearDay",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDate} from a year and day-of-year.\n\nThis returns a {@link LocalDate} with the specified year and day-of-year.\nThe day-of-year must be valid for the year, otherwise an exception will be thrown.",
    "lineNumber": 156,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to represent, from 1 to 366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range,\n or if the day-of-year is invalid for the year"
      }
    ]
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "ofEpochDay",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.ofEpochDay",
    "access": "public",
    "description": "Obtains an instance of LocalDate from the epoch day count.\n\nThis returns a LocalDate with the specified epoch-day.\nThe {@link ChronoField.EPOCH_DAY} is a simple incrementing count\nof days where day 0 is 1970-01-01. Negative numbers represent earlier days.",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "epochDay",
        "description": "the Epoch Day to convert, based on the epoch 1970-01-01"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date, not null"
    },
    "throws": [
      {
        "types": [
          "AssertionError"
        ],
        "description": "if the epoch days exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.from",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDate} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link LocalDate}.\n\nThe conversion uses the {@link TemporalQueries.localDate} query, which relies\non extracting the {@link ChronoField.EPOCH_DAY} field.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used as a query via method reference, {@link LocalDate::from}.",
    "lineNumber": 225,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link LocalDate}"
      }
    ]
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate.parse",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDate} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a date.",
    "lineNumber": 246,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTimeFormatter.ISO_LOCAL_DATE",
        "defaultRaw": "DateTimeFormatter.ISO_LOCAL_DATE",
        "name": "formatter",
        "description": "the formatter to use, default is\n{@link DateTimeFormatter.ISO_LOCAL_DATE}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the parsed local date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "_resolvePreviousValid",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate._resolvePreviousValid",
    "access": "private",
    "description": "Resolves the date, resolving days past the end of month.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, validated from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, validated from 1 to 12"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "day",
        "description": "the day-of-month to represent, validated from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "resolved date, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#constructor",
    "access": "private",
    "description": "Do not call the constructor directly, use the of*() factories instead like {@link LocalDate.of}",
    "lineNumber": 282,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "Month",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "_year",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_year",
    "access": "private",
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "_month",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_month",
    "access": "private",
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "_day",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_day",
    "access": "private",
    "description": null,
    "lineNumber": 293,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "_validate",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~LocalDate._validate",
    "access": "private",
    "description": "",
    "lineNumber": 306,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": ""
      }
    ],
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if date values are invalid"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this date can be queried for the specified field.\nIf false, then calling the {@link LocalDate.range} range and\n{@link LocalDate.get} get methods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link LocalDate.isSupported} supported fields will return valid\nvalues based on this date-time.\nThe supported fields are:\n\n* {@link ChronoField.DAY_OF_WEEK}\n* {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n* {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n* {@link ChronoField.DAY_OF_MONTH}\n* {@link ChronoField.DAY_OF_YEAR}\n* {@link ChronoField.EPOCH_DAY}\n* {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n* {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n* {@link ChronoField.MONTH_OF_YEAR}\n* {@link ChronoField.EPOCH_MONTH}\n* {@link ChronoField.YEAR_OF_ERA}\n* {@link ChronoField.YEAR}\n* {@link ChronoField.ERA}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing this as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 370,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this date, false if not"
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis date is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link LocalDate.isSupported} supported fields will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing this as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 396,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#get",
    "access": "public",
    "description": "Gets the value of the specified field from this date as an `int`.\n\nThis queries this date for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link LocalDate.isSupported} supported fields will return valid\nvalues based on this date, except {@link ChronoField.EPOCH_DAY} and {@link ChronoField.EPOCH_MONTH}\nwhich are too large to fit in an `int` and throw a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 437,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#getLong",
    "access": "public",
    "description": "see {LocalDate.get}, get and getLong are identical in javascript, because we are only limited by\n{@link MathUtil.MIN_SAFE_INTEGER}/ {@link MathUtil.MAX_SAFE_INTEGER}",
    "lineNumber": 448,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "_get0",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_get0",
    "access": "private",
    "description": "TODO tests are missing for the ALIGNED_* ChronoFields",
    "lineNumber": 463,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "_prolepticMonth",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_prolepticMonth",
    "access": "private",
    "description": "",
    "lineNumber": 487,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "chronology",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#chronology",
    "access": "public",
    "description": "Gets the chronology of this date, which is the ISO calendar system.\n\nThe {@link Chronology} represents the calendar system in use.\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.",
    "lineNumber": 501,
    "return": {
      "nullable": null,
      "types": [
        "Chronology"
      ],
      "spread": false,
      "description": "the ISO chronology, not null"
    },
    "params": []
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "year",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#year",
    "access": "public",
    "description": "",
    "lineNumber": 509,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "gets the year"
    },
    "params": []
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#monthValue",
    "access": "public",
    "description": "",
    "lineNumber": 517,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "gets the month value"
    },
    "params": []
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#month",
    "access": "public",
    "description": "",
    "lineNumber": 525,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Month} month"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "month"
    },
    "params": []
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#dayOfMonth",
    "access": "public",
    "description": "",
    "lineNumber": 533,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "gets the day of month"
    },
    "params": []
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "dayOfYear",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#dayOfYear",
    "access": "public",
    "description": "Gets the day-of-year field.\n\nThis method returns the primitive int value for the day-of-year.",
    "lineNumber": 544,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 365, or 366 in a leap year"
    },
    "params": []
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#dayOfWeek",
    "access": "public",
    "description": "Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n\nThis method returns the enum {@link DayOfWeek} for the day-of-week.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value then the enum\nprovides the {@link DayOfWeek.value} int value.\n\nAdditional information can be obtained from the {@link DayOfWeek}.\nThis includes textual names of the values.",
    "lineNumber": 561,
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "isLeapYear",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#isLeapYear",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 584,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    },
    "params": []
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "lengthOfMonth",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#lengthOfMonth",
    "access": "public",
    "description": "Returns the length of the month represented by this date.\n\nThis returns the length of the month in days.\nFor example, a date in January would return 31.",
    "lineNumber": 596,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of the month in days"
    },
    "params": []
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "lengthOfYear",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#lengthOfYear",
    "access": "public",
    "description": "Returns the length of the year represented by this date.\n\nThis returns the length of the year in days, either 365 or 366.",
    "lineNumber": 617,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "366 if the year is leap, 365 otherwise"
    },
    "params": []
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this date.\n\nThis returns a new {@link LocalDate}, based on this one, with the date adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the year field.\nA more complex adjuster might set the date to the last day of the month.\nA selection of common adjustments is provided in {@link TemporalAdjusters}.\nThese include finding the \"last day of the month\" and \"next Wednesday\".\nKey date-time classes also implement the {@link TemporalAdjuster} interface,\nsuch as {@link Month} and {@link MonthDay}.\nThe adjuster is responsible for handling special cases, such as the varying\nlengths of month and leap years.\n\nFor example this code returns a date on the last day of July:\n<pre>\n import static org.threeten.bp.Month.*;\n import static org.threeten.bp.temporal.Adjusters.*;\n\n result = localDate.with(JULY).with(lastDayOfMonth());\n</pre>\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster.adjustInto} method on the\nspecified adjuster passing `this` as the argument.",
    "lineNumber": 654,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on `this` with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_withField",
    "access": "private",
    "description": "Returns a copy of this date with the specified field set to a new value.\n\nThis returns a new {@link LocalDate}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year, month or day-of-month.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIn some cases, changing the specified field can cause the resulting date to become invalid,\nsuch as changing the month from 31st January to February would make the day-of-month invalid.\nIn cases like this, the field is responsible for resolving the date. Typically it will choose\nthe previous valid date, which would be the last valid day of February in this example.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n\n* {@link DAY_OF_WEEK} -\n  Returns a {@link LocalDate} with the specified day-of-week.\n  The date is adjusted up to 6 days forward or backward within the boundary\n  of a Monday to Sunday week.\n* {@link ALIGNED_DAY_OF_WEEK_IN_MONTH} -\n  Returns a {@link LocalDate} with the specified aligned-day-of-week.\n  The date is adjusted to the specified month-based aligned-day-of-week.\n  Aligned weeks are counted such that the first week of a given month starts\n  on the first day of that month.\n  This may cause the date to be moved up to 6 days into the following month.\n* {@link ALIGNED_DAY_OF_WEEK_IN_YEAR} -\n  Returns a {@link LocalDate} with the specified aligned-day-of-week.\n  The date is adjusted to the specified year-based aligned-day-of-week.\n  Aligned weeks are counted such that the first week of a given year starts\n  on the first day of that year.\n  This may cause the date to be moved up to 6 days into the following year.\n* {@link DAY_OF_MONTH} -\n  Returns a {@link LocalDate} with the specified day-of-month.\n  The month and year will be unchanged. If the day-of-month is invalid for the\n  year and month, then a {@link DateTimeException} is thrown.\n* {@link DAY_OF_YEAR} -\n  Returns a {@link LocalDate} with the specified day-of-year.\n  The year will be unchanged. If the day-of-year is invalid for the\n  year, then a {@link DateTimeException} is thrown.\n* {@link EPOCH_DAY} -\n  Returns a {@link LocalDate} with the specified epoch-day.\n  This completely replaces the date and is equivalent to {@link ofEpochDay}.\n* {@link ALIGNED_WEEK_OF_MONTH} -\n  Returns a {@link LocalDate} with the specified aligned-week-of-month.\n  Aligned weeks are counted such that the first week of a given month starts\n  on the first day of that month.\n  This adjustment moves the date in whole week chunks to match the specified week.\n  The result will have the same day-of-week as this date.\n  This may cause the date to be moved into the following month.\n* {@link ALIGNED_WEEK_OF_YEAR} -\n  Returns a {@link LocalDate} with the specified aligned-week-of-year.\n  Aligned weeks are counted such that the first week of a given year starts\n  on the first day of that year.\n  This adjustment moves the date in whole week chunks to match the specified week.\n  The result will have the same day-of-week as this date.\n  This may cause the date to be moved into the following year.\n* {@link MONTH_OF_YEAR} -\n  Returns a {@link LocalDate} with the specified month-of-year.\n  The year will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n* {@link PROLEPTIC_MONTH} -\n  Returns a {@link LocalDate} with the specified proleptic-month.\n  The day-of-month will be unchanged, unless it would be invalid for the new month\n  and year. In that case, the day-of-month is adjusted to the maximum valid value\n  for the new month and year.\n* {@link YEAR_OF_ERA} -\n  Returns a {@link LocalDate} with the specified year-of-era.\n  The era and month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n* {@link YEAR} -\n  Returns a {@link LocalDate} with the specified year.\n  The month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n* {@link ERA} -\n  Returns a {@link LocalDate} with the specified era.\n  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,\n  unless it would be invalid for the new month and year. In that case, the\n  day-of-month is adjusted to the maximum valid value for the new month and year.\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a {@link DateTimeException} will be thrown.\n\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.",
    "lineNumber": 763,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#withYear",
    "access": "public",
    "description": "Returns a copy of this date with the year altered.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.",
    "lineNumber": 796,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the result, from {@link Year.MIN_VALUE} to {@link Year.MAX_VALUE}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#withMonth",
    "access": "public",
    "description": "Returns a copy of this date with the month-of-year altered.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.",
    "lineNumber": 812,
    "params": [
      {
        "nullable": false,
        "types": [
          "Month",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the result, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#withDayOfMonth",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the day-of-month altered.\n\nIf the resulting date is invalid, an exception is thrown.",
    "lineNumber": 831,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to set in the result, from 1 to 28-31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month value is invalid,\n or if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "withDayOfYear",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#withDayOfYear",
    "access": "public",
    "description": "Returns a copy of this date with the day-of-year altered.\nIf the resulting date is invalid, an exception is thrown.",
    "lineNumber": 847,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to set in the result, from 1 to 365-366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year value is invalid"
      },
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year is invalid for the year"
      }
    ]
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this date with the specified period added.\n\nThis method returns a new date based on this date with the specified period added.\nThis can be used to add any period that is defined by a unit, for example to add years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.",
    "lineNumber": 867,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the specified period added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#plusYears",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in years added.\n\nThis method adds the specified amount to the years field in three steps:\n\n1. Add the input years to the year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2008-02-29 (leap year) plus one year would result in the\ninvalid date 2009-02-29 (standard year). Instead of returning an invalid\nresult, the last valid day of the month, 2009-02-28, is selected instead.",
    "lineNumber": 903,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#plusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in months added.\n\nThis method adds the specified amount to the months field in three steps:\n\n1. Add the input months to the month-of-year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2007-03-31 plus one month would result in the invalid date\n2007-04-31. Instead of returning an invalid result, the last valid day\nof the month, 2007-04-30, is selected instead.",
    "lineNumber": 928,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToAdd",
        "description": "the months to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the months added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#plusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in weeks added.\n\nThis method adds the specified amount in weeks to the days field incrementing\nthe month and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2008-12-31 plus one week would result in 2009-01-07.",
    "lineNumber": 952,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeksToAdd",
        "description": "the weeks to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the weeks added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#plusDays",
    "access": "public",
    "description": "Returns a copy of this LocalDate with the specified number of days added.\n\nThis method adds the specified amount to the days field incrementing the\nmonth and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2008-12-31 plus one day would result in 2009-01-01.",
    "lineNumber": 970,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "daysToAdd",
        "description": "the days to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a LocalDate based on this date with the days added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "AssertionError if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_minusUnit",
    "access": "private",
    "description": "Returns a copy of this date with the specified period subtracted.\n\nThis method returns a new date based on this date with the specified period subtracted.\nThis can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.",
    "lineNumber": 991,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the unit to subtract from the result, may be negative"
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the specified period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#minusYears",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in years subtracted.\n\nThis method subtracts the specified amount from the years field in three steps:\n\n1. Subtract the input years to the year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2008-02-29 (leap year) minus one year would result in the\ninvalid date 2007-02-29 (standard year). Instead of returning an invalid\nresult, the last valid day of the month, 2007-02-28, is selected instead.",
    "lineNumber": 1014,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#minusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in months subtracted.\n\nThis method subtracts the specified amount from the months field in three steps:\n\n1. Subtract the input months to the month-of-year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2007-03-31 minus one month would result in the invalid date\n2007-02-31. Instead of returning an invalid result, the last valid day\nof the month, 2007-02-28, is selected instead.",
    "lineNumber": 1035,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToSubtract",
        "description": "the months to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#minusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDate} with the specified period in weeks subtracted.\n\nThis method subtracts the specified amount in weeks from the days field decrementing\nthe month and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2009-01-07 minus one week would result in 2008-12-31.",
    "lineNumber": 1052,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeksToSubtract",
        "description": "the weeks to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "a {@link LocalDate} based on this date with the weeks subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#minusDays",
    "access": "public",
    "description": null,
    "lineNumber": 1069,
    "undocument": true,
    "params": [
      {
        "name": "daysToSubtract",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#query",
    "access": "public",
    "description": "Queries this date using the specified query.\n\nThis queries this date using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 1090,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have the same date as this object.\n\nThis returns a temporal object of the same observable type as the input\nwith the date changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField.EPOCH_DAY} as the field.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisLocalDate.adjustInto(temporal);\n  temporal = temporal.with(thisLocalDate);\n</pre>",
    "lineNumber": 1120,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#until",
    "access": "public",
    "description": "function overloading for {@link LocalDate.until}\n\ncalled with 1 (or less) arguments {{@link LocalDate.until1}} is called\notherwise {@link LocalDate.until2}",
    "lineNumber": 1134,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": "not null if called with 2 arguments"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number",
        "Period"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "until2",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#until2",
    "access": "public",
    "description": "Calculates the period between this date and another date in\nterms of the specified unit.\n\nThis calculates the period between two dates in terms of a single unit.\nThe start and end points are `this` and the specified date.\nThe result will be negative if the end is before the start.\nThe {@link Temporal} passed to this method must be a {@link LocalDate}.\nFor example, the period in days between two dates can be calculated\nusing {@link startDate.until}.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two dates.\nFor example, the period in months between 2012-06-15 and 2012-08-14\nwill only be one month as it is one day short of two months.\n\nThis method operates in association with {@link TemporalUnit#between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, MONTHS);   // this method\n  dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link DAYS}, {@link WEEKS}, {@link MONTHS}, {@link YEARS},\n{@link DECADES}, {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS}\nare supported. Other {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing `this` as the first argument and the input temporal as\nthe second argument.",
    "lineNumber": 1183,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date, which is converted to a {@link LocalDate}, not null"
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this date and the end date"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the period cannot be calculated"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "daysUntil",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#daysUntil",
    "access": "protected",
    "description": "",
    "lineNumber": 1207,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "_monthsUntil",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_monthsUntil",
    "access": "private",
    "description": "",
    "lineNumber": 1217,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "until1",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#until1",
    "access": "public",
    "description": "Calculates the period between this date and another date as a {@link Period}.\n\nThis calculates the period between two dates in terms of years, months and days.\nThe start and end points are `this` and the specified date.\nThe result will be negative if the end is before the start.\n\nThe calculation is performed using the ISO calendar system.\nIf necessary, the input date will be converted to ISO.\n\nThe start date is included, but the end date is not.\nThe period is calculated by removing complete months, then calculating\nthe remaining number of days, adjusting to ensure that both have the same sign.\nThe number of months is then normalized into years and months based on a 12 month year.\nA month is considered to be complete if the end day-of-month is greater\nthan or equal to the start day-of-month.\nFor example, from `2010-01-15` to `2011-03-18` is \"1 year, 2 months and 3 days\".\n\nThe result of this method can be a negative period if the end is before the start.\nThe negative sign will be the same in each of year, month and day.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method.\nThe second is to use {@link Period#between}:\n<pre>\n  // these two lines are equivalent\n  period = start.until(end);\n  period = Period.between(start, end);\n</pre>\nThe choice should be made based on which makes the code more readable.",
    "lineNumber": 1257,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "endDate",
        "description": "the end date, exclusive, which may be in any chronology, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period between this date and the end date, not null"
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "atTime",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#atTime",
    "access": "public",
    "description": "function overloading for {@link LocalDate.atTime}\n\nif called with 1 argument {@link LocalDate.atTime1} is called\notherwise {@link LocalDate.atTime4}",
    "lineNumber": 1284,
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime",
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the local date-time formed from this date and the specified params"
    },
    "params": []
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "atTime1",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#atTime1",
    "access": "public",
    "description": "Combines this date with a time to create a {@link LocalDateTime}.\n\nThis returns a {@link LocalDateTime} formed from this date at the specified time.\nAll possible combinations of date and time are valid.",
    "lineNumber": 1301,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the time to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime",
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the date-time formed from this date and the specified time, not null"
    }
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "atTime4",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#atTime4",
    "access": "public",
    "description": "Combines this date with a time to create a {@link LocalDateTime}.\n\nThis returns a {@link LocalDateTime} formed from this date at the\nspecified hour, minute, second and nanosecond.\nThe individual time fields must be within their valid range.\nAll possible combinations of date and time are valid.",
    "lineNumber": 1328,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": "the hour-of-day to use, from 0 to 23"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": "the minute-of-hour to use, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "the second-of-minute to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time formed from this date and the specified time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range"
      }
    ]
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "_atTimeOffsetTime",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_atTimeOffsetTime",
    "access": "private",
    "description": "Combines this date with an offset time to create an {@link OffsetDateTime}.\n\nThis returns an {@link OffsetDateTime} formed from this date at the specified time.\nAll possible combinations of date and time are valid.",
    "lineNumber": 1341,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the time to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the offset date-time formed from this date and the specified time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "atStartOfDay",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#atStartOfDay",
    "access": "public",
    "description": "Combines this date with the time of midnight to create a {@link LocalDateTime}\nat the start of this date.\n\nThis returns a {@link LocalDateTime} formed from this date at the time of\nmidnight, 00:00, at the start of this date.\n\nIf zone is not null, this returns a {@link ZonedDateTime} formed from this date at the\nspecified zone, with the time set to be the earliest valid time according\nto the rules in the time-zone.\n\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may not be midnight.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, there are two valid offsets, and the earlier one is used,\ncorresponding to the first occurrence of midnight on the date.\nIn the case of a gap, the zoned date-time will represent the instant just after the gap.\n\nIf the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n\nTo convert to a specific time in a given time-zone call {@link atTime}\nfollowed by {@link LocalDateTime#atZone}.",
    "lineNumber": 1372,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "optional ZoneId or ZoneOffset"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime",
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the local date-time of midnight at the start of this date, not null"
    }
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "_atStartOfDayWithZone",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_atStartOfDayWithZone",
    "access": "private",
    "description": "Combines this date with a time-zone to create a {@link ZonedDateTime}\nat the start of the day\n\nThis returns a {@link ZonedDateTime} formed from this date at the\nspecified zone, with the time set to be the earliest valid time according\nto the rules in the time-zone.\n\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may not be midnight.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, there are two valid offsets, and the earlier one is used,\ncorresponding to the first occurrence of midnight on the date.\nIn the case of a gap, the zoned date-time will represent the instant just after the gap.\n\nIf the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.\n\nTo convert to a specific time in a given time-zone call {@link atTime}\nfollowed by {@link LocalDateTime#atZone}.",
    "lineNumber": 1404,
    "params": [
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time formed from this date and the earliest valid time for the zone, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "toEpochDay",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#toEpochDay",
    "access": "public",
    "description": "Converts this date to the Epoch Day.\n\nThe Epoch Day count is a simple incrementing count of days where day 0 is 1970-01-01 (ISO).\nThis definition is the same for all chronologies, enabling conversion.",
    "lineNumber": 1427,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the Epoch Day equivalent to this date"
    },
    "params": []
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#compareTo",
    "access": "public",
    "description": "Compares this date to another date.\n\nThe comparison is primarily based on the date, from earliest to latest.\nIt is \"consistent with equals\", as defined by {@link Comparable}.\n\nIf all the dates being compared are instances of {@link LocalDate},\nthen the comparison will be entirely based on the date.\nIf some dates being compared are in different chronologies, then the\nchronology is also considered, see {@link ChronoLocalDate.compareTo}.",
    "lineNumber": 1462,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "_compareTo0",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#_compareTo0",
    "access": "private",
    "description": "",
    "lineNumber": 1475,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "otherDate",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#isAfter",
    "access": "public",
    "description": "Checks if this date is after the specified date.\n\nThis checks to see if this date represents a point on the\nlocal time-line after the other date.\n<pre>\n  LocalDate a = LocalDate.of(2012, 6, 30);\n  LocalDate b = LocalDate.of(2012, 7, 1);\n  a.isAfter(b) == false\n  a.isAfter(a) == false\n  b.isAfter(a) == true\n</pre>\n\nThis method only considers the position of the two dates on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo},\nbut is the same approach as {@link DATE_COMPARATOR}.",
    "lineNumber": 1507,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date is after the specified date"
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#isBefore",
    "access": "public",
    "description": "Checks if this date is before the specified date.\n\nThis checks to see if this date represents a point on the\nlocal time-line before the other date.\n<pre>\n  LocalDate a = LocalDate.of(2012, 6, 30);\n  LocalDate b = LocalDate.of(2012, 7, 1);\n  a.isBefore(b) == true\n  a.isBefore(a) == false\n  b.isBefore(a) == false\n</pre>\n\nThis method only considers the position of the two dates on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo},\nbut is the same approach as {@link DATE_COMPARATOR}.",
    "lineNumber": 1533,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date is before the specified date"
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#isEqual",
    "access": "public",
    "description": "Checks if this date is equal to the specified date.\n\nThis checks to see if this date represents the same point on the\nlocal time-line as the other date.\n<pre>\n  LocalDate a = LocalDate.of(2012, 6, 30);\n  LocalDate b = LocalDate.of(2012, 7, 1);\n  a.isEqual(b) == false\n  a.isEqual(a) == true\n  b.isEqual(a) == false\n</pre>\n\nThis method only considers the position of the two dates on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo}\nbut is the same approach as {@link DATE_COMPARATOR}.",
    "lineNumber": 1559,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date is equal to the specified date"
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#equals",
    "access": "public",
    "description": "Checks if this date is equal to another date.\n\nCompares this LocalDate with another ensuring that the date is the same.\n\nOnly objects of type LocalDate are compared, other types return false.",
    "lineNumber": 1574,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other date"
    }
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#hashCode",
    "access": "public",
    "description": "A hash code for this date.",
    "lineNumber": 1589,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#toString",
    "access": "public",
    "description": "Outputs this date as a String, such as 2007-12-03.\nThe output will be in the ISO-8601 format uuuu-MM-dd.",
    "lineNumber": 1602,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this date, not null"
    },
    "params": []
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1644,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalDate.toString}"
    },
    "params": []
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/LocalDate.js~LocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDate.js~LocalDate#format",
    "access": "public",
    "description": "Outputs this date as a string using the formatter.",
    "lineNumber": 1655,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted date string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/LocalDate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDate.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalDate.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1662,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 260,
    "kind": "file",
    "name": "packages/core/src/LocalDateTime.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MathUtil } from './MathUtil';\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\n\nimport { Clock } from './Clock';\nimport { Instant } from './Instant';\nimport { LocalDate } from './LocalDate';\nimport { LocalTime } from './LocalTime';\nimport { OffsetDateTime } from './OffsetDateTime';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\n\n\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\n\nimport { ChronoLocalDateTime } from './chrono/ChronoLocalDateTime';\n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30`.\n *\n * {@link LocalDateTime} is an immutable date-time object that represents a date-time,\n * often viewed as year-month-day-hour-minute-second. Other date and time fields,\n * such as day-of-year, day-of-week and week-of-year, can also be accessed.\n * Time is represented to nanosecond precision.\n * For example, the value '2nd October 2007 at 13:45.30.123456789' can be\n * stored in a {@link LocalDateTime}.\n *\n * This class does not store or represent a time-zone.\n * Instead, it is a description of the date, as used for birthdays, combined with\n * the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalDateTime.MIN\n *\n * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n * This is the local date-time of midnight at the start of the minimum date.\n * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n * This could be used by an application as a 'far past' date-time.\n *\n * LocalDateTime.MAX\n *\n * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n * This is the local date-time just before midnight at the end of the maximum date.\n * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n * This could be used by an application as a 'far future' date-time.\n *\n */\nexport class LocalDateTime extends ChronoLocalDateTime\n/** extends ChronoLocalDateTime<LocalDate>\nimplements Temporal, TemporalAdjuster, Serializable */ {\n\n\n    /**\n     * Obtains the current date-time from from the specified clock or the system clock in the specified time-zone.\n     *\n     * If the argument is an instance of Clock this will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * If the argument is an instance of ZoneId this will query the system clock (see {@link Clock#system}) to obtain the current date-time.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * If nor argument is applied, the system default time zone is used to obtain the current date-time.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalDateTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalDateTime._now(clockOrZone);\n        } else {\n            return LocalDateTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current date-time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current date-time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, defaults to Clock.systemDefaultZone()\n     * @return {LocalDateTime} the current date-time, not null\n     */\n    static _now(clock) {\n        requireNonNull(clock, 'clock');\n        return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n\n        // this is an alternative implementation with better performance.\n        // const epochMilli = clock.millis();\n        // const offset = clock.zone().rules().offsetOfEpochMilli(epochMilli);\n        // return LocalDateTime._ofEpochMillis(epochMilli, offset);\n\n    }\n\n    /**\n     * @see comment at {LocalDateTime._now}\n     * @param {number} epochMilli\n     * @param {ZoneOffset} offset\n     * @return {LocalDateTime} the  date-time, not null\n     *\n     */\n    static _ofEpochMillis(epochMilli, offset){\n        const localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link LocalDateTime.of}\n     *\n     * if called with 2 arguments and first argument is an instance of LocalDate and second is an\n     * instance of LocalTime, then {@link LocalDateTime.ofDateAndTime} is executed.\n     *\n     * Otherwise {@link LocalDateTime.ofNumbers} is executed.\n     *\n     * @returns {LocalDateTime}\n     */\n    static of(){\n        if (arguments.length <= 2){\n            return LocalDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return LocalDateTime.ofNumbers.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link LocalDateTime} from year, month,\n     * day, hour, minute, second and nanosecond.\n     *\n     * The day must be valid for the year and month, otherwise an exception will be thrown.\n     *\n     * @param {number} [year] - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} [month] - the month-of-year to represent, from 1 to 12 or from a Month\n     * @param {number} [dayOfMonth] - the day-of-month to represent, from 1 to 31\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    static ofNumbers(year, month, dayOfMonth, hour=0, minute=0, second=0, nanoOfSecond=0) {\n        const date = LocalDate.of(year, month, dayOfMonth);\n        const time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a date and time.\n     *\n     * @param {!LocalDate} date - the local date, not null\n     * @param {!LocalTime} time - the local time, not null\n     * @return {LocalDateTime} the local date-time, not null\n     */\n    static ofDateAndTime(date, time) {\n        requireNonNull(date, 'date');\n        requireNonNull(time, 'time');\n        return new LocalDateTime(date, time);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from an {@link Instant} and zone ID.\n     *\n     * This creates a local date-time based on the specified instant.\n     * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,\n     * which is simple as there is only one valid offset for each instant.\n     * Then, the instant and offset are used to calculate the local date-time.\n     *\n     * @param {!Instant} instant  the instant to create the date-time from, not null\n     * @param {!ZoneId} [zone=ZoneId.systemDefault()]  the time-zone, which may be an offset, defaults to ZoneId.systemDefault()\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        requireNonNull(zone, 'zone');\n        const offset = zone.rules().offset(instant);\n        return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * This allows the {@link ChronoField.INSTANT_SECONDS} epoch-second field\n     * to be converted to a local date-time. This is primarily intended for\n     * low-level conversions rather than general application usage.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number|!ZoneOffset} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneOffset} offset - the zone offset, not null if called with 3 arguments\n     * @return {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    static ofEpochSecond(epochSecond=0, nanoOfSecond=0, offset) {\n        if(arguments.length === 2 && nanoOfSecond instanceof ZoneOffset){\n            offset = nanoOfSecond;\n            nanoOfSecond = 0;\n        }\n        requireNonNull(offset, 'offset');\n        const localSecond = epochSecond + offset.totalSeconds();  // overflow caught later\n        const localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        const secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        const date = LocalDate.ofEpochDay(localEpochDay);\n        const time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalDateTime}.\n     *\n     * The conversion extracts and combines {@link LocalDate} and {@link LocalTime}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@link LocalDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalDateTime} {LocalDateTime} the local date-time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof LocalDateTime) {\n            return temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return temporal.toLocalDateTime();\n        }\n        try {\n            const date = LocalDate.from(temporal);\n            const time = LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain LocalDateTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalDateTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a date-time.\n     *\n     * @param {!string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_DATE_TIME] - the formatter to use,\n     * defaults to DateTimeFormatter.ISO_LOCAL_DATE_TIME\n     * @return {LocalDateTime} the parsed local date-time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} date - the date part of the date-time, validated not null\n     * @param {LocalTime} time - the time part of the date-time, validated not null\n     * @private\n     */\n    constructor(date, time) {\n        super();\n        requireInstance(date, LocalDate, 'date');\n        requireInstance(time, LocalTime, 'time');\n        this._date = date;\n        this._time = time;\n    }\n\n    /**\n     * Returns a copy of this date-time with the new date and time, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {LocalDate} newDate - the date of the new date-time, not null\n     * @param {LocalTime} newTime - the time of the new date-time, not null\n     * @return {LocalDateTime} the date-time, not null\n     */\n    _withDateTime(newDate, newTime) {\n        if (this._date.equals(newDate) && this._time.equals(newTime)) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling the {@link LocalDateTime.range} range and\n     * {@link LocalDateTime.get} get methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     * * {@link ChronoField.DAY_OF_WEEK}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link ChronoField.DAY_OF_MONTH}\n     * * {@link ChronoField.DAY_OF_YEAR}\n     * * {@link ChronoField.EPOCH_DAY}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n     * * {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n     * * {@link ChronoField.MONTH_OF_YEAR}\n     * * {@link ChronoField.EPOCH_MONTH}\n     * * {@link ChronoField.YEAR_OF_ERA}\n     * * {@link ChronoField.YEAR}\n     * * {@link ChronoField.ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.range(field) : this._date.range(field));\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY} and {@link EPOCH_MONTH} which are too large to fit in\n     * an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.get(field) : this._date.get(field));\n        }\n        return super.get(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return (field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field));\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per `get(YEAR)`.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._date.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._date.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._date.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._date.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._date.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use\n     * {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._date.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._time.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._time.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._time.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._time.nano();\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = localDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = localDateTime.with(date);\n     *  result = localDateTime.with(time);\n     * </pre>\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster the adjuster to use, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._withDateTime(adjuster, this._time);\n        } else if (adjuster instanceof LocalTime) {\n            return this._withDateTime(this._date, adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields (see {@link isSupported}) will behave as in\n     * {@link LocalDate#with} or {@link LocalTime#with}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalDateTime} a {@link LocalDateTime} based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            if (field.isTimeBased()) {\n                return this._withDateTime(this._date, this._time.with(field, newValue));\n            } else {\n                return this._withDateTime(this._date.with(field, newValue), this._time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        return this._withDateTime(this._date.withYear(year), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the month-of-year altered.\n     * The time does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!(number|Month)} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._withDateTime(this._date.withMonth(month), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-month altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     * The time does not affect the calculation and will be the same in the result.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid\n     * @throws {DateTimeException} if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the day-of-year altered.\n     * If the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid\n     * @throws {DateTimeException} if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour) {\n        const newTime = this._time.withHour(hour);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute) {\n        const newTime = this._time.withMinute(minute);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second) {\n        const newTime = this._time.withSecond(second);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        const newTime = this._time.withNano(nanoOfSecond);\n        return this._withDateTime(this._date, newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._withDateTime(this._date, this._time.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {!TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);  // no overflow (256 is multiple of 2)\n            }\n            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years added.\n     *\n     * This method adds the specified amount to the years field in three steps:\n     *\n     * 1. Add the input years to the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) plus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        const newDate = this._date.plusYears(years);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months added.\n     *\n     * This method adds the specified amount to the months field in three steps:\n     *\n     * 1. Add the input months to the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 plus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        const newDate = this._date.plusMonths(months);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks added.\n     *\n     * This method adds the specified amount in weeks to the days field incrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one week would result in 2009-01-07.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        const newDate = this._date.plusWeeks(weeks);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days added.\n     *\n     * This method adds the specified amount to the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2008-12-31 plus one day would result in 2009-01-01.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        const newDate = this._date.plusDays(days);\n        return this._withDateTime(newDate, this._time);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _minusUnit(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in years subtracted.\n     *\n     * This method subtracts the specified amount from the years field in three steps:\n     *\n     * 1. Subtract the input years from the year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2008-02-29 (leap year) minus one year would result in the\n     * invalid date 2009-02-29 (standard year). Instead of returning an invalid\n     * result, the last valid day of the month, 2009-02-28, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in months subtracted.\n     *\n     * This method subtracts the specified amount from the months field in three steps:\n     *\n     * 1. Subtract the input months from the month-of-year field\n     * 2. Check if the resulting date would be invalid\n     * 3. Adjust the day-of-month to the last valid day if necessary\n     *\n     * For example, 2007-03-31 minus one month would result in the invalid date\n     * 2007-04-31. Instead of returning an invalid result, the last valid day\n     * of the month, 2007-04-30, is selected instead.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in weeks subtracted.\n     *\n     * This method subtracts the specified amount in weeks from the days field decrementing\n     * the month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-07 minus one week would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in days subtracted.\n     *\n     * This method subtracts the specified amount from the days field incrementing the\n     * month and year fields as necessary to ensure the result remains valid.\n     * The result is only invalid if the maximum/minimum year is exceeded.\n     *\n     * For example, 2009-01-01 minus one day would result in 2008-12-31.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the days subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in hours subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the hours subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in minutes subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in seconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {LocalDateTime} a {@link LocalDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Number} nanos - the nanos to subtract, may be negative\n     * @return {LocalDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalDateTime} with the specified period added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {LocalDate} newDate  the new date to base the calculation on, not null\n     * @param {Number} hours - the hours to add, may be negative\n     * @param {Number} minutes - the minutes to add, may be negative\n     * @param {Number} seconds - the seconds to add, may be negative\n     * @param {Number} nanos - the nanos to add, may be negative\n     * @param {Number} sign - the sign to determine add or subtract\n     * @return {LocalDateTime} the combined result, not null\n     */\n    _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n        // 9223372036854775808 long, 2147483648 int\n        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {\n            return this._withDateTime(newDate, this._time);\n        }\n        let totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) +             //   max/24*60*60*1B\n                MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) +                //   max/24*60*60\n                MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) +                //   max/24*60\n                MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);                     //   max/24\n        totDays *= sign;                                   // total max*0.4237...\n        let totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) +                    //   max  86400000000000\n                (MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY)) * LocalTime.NANOS_PER_SECOND +   //   max  86400000000000\n                (MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY)) * LocalTime.NANOS_PER_MINUTE +   //   max  86400000000000\n                (MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY)) * LocalTime.NANOS_PER_HOUR;          //   max  86400000000000\n        const curNoD = this._time.toNanoOfDay();                       //   max  86400000000000\n        totNanos = totNanos * sign + curNoD;                    // total 432000000000000\n        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n        const newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n        const newTime = (newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD));\n        return this._withDateTime(newDate.plusDays(totDays), newTime);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same date and time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the date and time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#EPOCH_DAY} and\n     * {@link ChronoField#NANO_OF_DAY} as the fields.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDateTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDateTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {LocalDateTime} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return super.adjustInto(temporal);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalDateTime}.\n     * For example, the period in days between two date-times can be calculated\n     * using `startDateTime.until(endDateTime, DAYS)`.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00 and 2012-08-14T23:59\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date-time, which is converted to a {@link LocalDateTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                let daysUntil = this._date.daysUntil(end._date);\n                let timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n                if (daysUntil > 0 && timeUntil < 0) {\n                    daysUntil--;\n                    timeUntil += LocalTime.NANOS_PER_DAY;\n                } else if (daysUntil < 0 && timeUntil > 0) {\n                    daysUntil++;\n                    timeUntil -= LocalTime.NANOS_PER_DAY;\n                }\n                let amount = daysUntil;\n                switch (unit) {\n                    case ChronoUnit.NANOS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n                        return MathUtil.safeAdd(amount, timeUntil);\n                    case ChronoUnit.MICROS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n                    case ChronoUnit.MILLIS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n                    case ChronoUnit.SECONDS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n                    case ChronoUnit.MINUTES:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n                    case ChronoUnit.HOURS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n                    case ChronoUnit.HALF_DAYS:\n                        amount = MathUtil.safeMultiply(amount, 2);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, (LocalTime.NANOS_PER_HOUR * 12)));\n                }\n                throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n            }\n            let endDate = end._date;\n            const endTime = end._time;\n            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n                endDate = endDate.minusDays(1);\n            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n                endDate = endDate.plusDays(1);\n            }\n            return this._date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with an offset to create an {@link OffsetDateTime}.\n     *\n     * This returns an {@link OffsetDateTime} formed from this date-time at the specified offset.\n     * All possible combinations of date-time and offset are valid.\n     *\n     * @param {ZoneOffset} offset  the offset to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date-time and the specified offset, not null\n     */\n    atOffset(offset) {\n        return OffsetDateTime.of(this, offset);\n    }\n\n    /**\n     * Combines this date-time with a time-zone to create a {@link ZonedDateTime}.\n     *\n     * This returns a {@link ZonedDateTime} formed from this date-time at the\n     * specified time-zone. The result will match this date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * To obtain the later offset during an overlap, call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap} on the result of this method.\n     * To throw an exception when there is a gap or overlap, use\n     * {@link ZonedDateTime#ofStrict}.\n     *\n     * @param {ZoneId} zone  the time-zone to use, not null\n     * @return {ZonedDateTime} the zoned date-time formed from this date-time, not null\n     */\n    atZone(zone) {\n        return ZonedDateTime.of(this, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._date;\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._time;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     *\n     * The comparison is primarily based on the date-time, from earliest to latest.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * If all the date-times being compared are instances of {@link LocalDateTime},\n     * then the comparison will be entirely based on the date-time.\n     * If some dates being compared are in different chronologies, then the\n     * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.\n     *\n     * @param {!LocalDateTime} other - the other date-time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalDateTime, 'other');\n        return this._compareTo0(other);\n        // return super.compareTo(other); if not instance of  LocalDateTime\n    }\n\n    /**\n     *\n     * @param {!LocalDateTime} other\n     * @returns {number}\n     * @private\n     */\n    _compareTo0(other) {\n        let cmp = this._date.compareTo(other.toLocalDate());\n        if (cmp === 0) {\n            cmp = this._time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this date-time is after the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line after the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isAfter(b) == false\n     *   a.isAfter(a) == false\n     *   b.isAfter(a) == true\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is after the specified date-time\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n        // return super.isAfter(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is before the specified date-time.\n     *\n     * This checks to see if this date-time represents a point on the\n     * local time-line before the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isBefore(b) == true\n     *   a.isBefore(a) == false\n     *   b.isBefore(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is before the specified date-time\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n        // return super.isBefore(other);  if not instance of LocalDateTime\n    }\n\n    /**\n     * Checks if this date-time is equal to the specified date-time.\n     *\n     * This checks to see if this date-time represents the same point on the\n     * local time-line as the other date-time.\n     * <pre>\n     *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n     *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n     *   a.isEqual(b) == false\n     *   a.isEqual(a) == true\n     *   b.isEqual(a) == false\n     * </pre>\n     *\n     * This method only considers the position of the two date-times on the local time-line.\n     * It does not take into account the chronology, or calendar system.\n     * This is different from the comparison in {@link compareTo},\n     * but is the same approach as {@link DATE_TIME_COMPARATOR}.\n     *\n     * @param {LocalDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this date-time is equal to the specified date-time\n     */\n    isEqual(other) {\n        return this.compareTo(other) === 0;\n        // return super.isEqual(other); if not instance of LocalDateTime\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * Compares this {@link LocalDateTime} with another ensuring that the date-time is the same.\n     * Only objects of type {@link LocalDateTime} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDateTime) {\n            return this._date.equals(other._date) && this._time.equals(other._time);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._date.hashCode() ^ this._time.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as `2007-12-03T10:15:30`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * `yyyy-MM-dd'T'HH:mm`\n     * * `yyyy-MM-dd'T'HH:mm:ss`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSS`\n     * * `yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS`\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        return `${this._date.toString()}T${this._time.toString()}`;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {!DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date-time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nexport function _init(){\n    /**\n     * The minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\n     * This is the local date-time of midnight at the start of the minimum date.\n     * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\n     * This could be used by an application as a 'far past' date-time.\n     */\n    LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n\n    /**\n     * The maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\n     * This is the local date-time just before midnight at the end of the maximum date.\n     * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\n     * This could be used by an application as a 'far future' date-time.\n     */\n    LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n\n    LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', (temporal) => {\n        return LocalDateTime.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/LocalDateTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 261,
    "kind": "class",
    "name": "LocalDateTime",
    "memberof": "packages/core/src/LocalDateTime.js",
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalDateTime.js",
    "importStyle": "{LocalDateTime}",
    "description": "A date-time without a time-zone in the ISO-8601 calendar system,\nsuch as `2007-12-03T10:15:30`.\n\n{@link LocalDateTime} is an immutable date-time object that represents a date-time,\noften viewed as year-month-day-hour-minute-second. Other date and time fields,\nsuch as day-of-year, day-of-week and week-of-year, can also be accessed.\nTime is represented to nanosecond precision.\nFor example, the value '2nd October 2007 at 13:45.30.123456789' can be\nstored in a {@link LocalDateTime}.\n\nThis class does not store or represent a time-zone.\nInstead, it is a description of the date, as used for birthdays, combined with\nthe local time as seen on a wall clock.\nIt cannot represent an instant on the time-line without additional information\nsuch as an offset or time-zone.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\n### Static properties of Class {@link LocalTime}\n\nLocalDateTime.MIN\n\nThe minimum supported {@link LocalDateTime}, '-999999999-01-01T00:00:00'.\nThis is the local date-time of midnight at the start of the minimum date.\nThis combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.\nThis could be used by an application as a 'far past' date-time.\n\nLocalDateTime.MAX\n\nThe maximum supported {@link LocalDateTime}, '+999999999-12-31T23:59:59.999999999'.\nThis is the local date-time just before midnight at the end of the maximum date.\nThis combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.\nThis could be used by an application as a 'far future' date-time.",
    "lineNumber": 70,
    "interface": false,
    "extends": [
      "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime"
    ]
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.now",
    "access": "public",
    "description": "Obtains the current date-time from from the specified clock or the system clock in the specified time-zone.\n\nIf the argument is an instance of Clock this will query the specified clock to obtain the current date-time.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection.\n\nIf the argument is an instance of ZoneId this will query the system clock (see {@link Clock#system}) to obtain the current date-time.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nIf nor argument is applied, the system default time zone is used to obtain the current date-time.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "clockOrZone",
        "description": "the zone ID or clock to use, if null Clock.systemDefaultZone() is used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the current date-time using the system clock, not null"
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "_now",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime._now",
    "access": "private",
    "description": "Obtains the current date-time from the specified clock.\n\nThis will query the specified clock to obtain the current date-time.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection.",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, defaults to Clock.systemDefaultZone()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the current date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "_ofEpochMillis",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime._ofEpochMillis",
    "access": "private",
    "description": "",
    "see": [
      "comment at {LocalDateTime._now}"
    ],
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMilli",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the  date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.of",
    "access": "public",
    "description": "function overloading for {@link LocalDateTime.of}\n\nif called with 2 arguments and first argument is an instance of LocalDate and second is an\ninstance of LocalTime, then {@link LocalDateTime.ofDateAndTime} is executed.\n\nOtherwise {@link LocalDateTime.ofNumbers} is executed.",
    "lineNumber": 153,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{LocalDateTime}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "ofNumbers",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.ofNumbers",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} from year, month,\nday, hour, minute, second and nanosecond.\n\nThe day must be valid for the year and month, otherwise an exception will be thrown.",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "month",
        "description": "the month-of-year to represent, from 1 to 12 or from a Month"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "the hour-of-day to represent, from 0 to 23"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "the minute-of-hour to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "the second-of-minute to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range"
      },
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "ofDateAndTime",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.ofDateAndTime",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} from a date and time.",
    "lineNumber": 190,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the local date, not null"
      },
      {
        "nullable": false,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the local time, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time, not null"
    }
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.ofInstant",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} from an {@link Instant} and zone ID.\n\nThis creates a local date-time based on the specified instant.\nFirst, the offset from UTC/Greenwich is obtained using the zone ID and instant,\nwhich is simple as there is only one valid offset for each instant.\nThen, the instant and offset are used to calculate the local date-time.",
    "lineNumber": 210,
    "params": [
      {
        "nullable": false,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to create the date-time from, not null"
      },
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "ZoneId.systemDefault()",
        "defaultRaw": "ZoneId.systemDefault()",
        "name": "zone",
        "description": "the time-zone, which may be an offset, defaults to ZoneId.systemDefault()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "ofEpochSecond",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.ofEpochSecond",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} using seconds from the\nepoch of 1970-01-01T00:00:00Z.\n\nThis allows the {@link ChronoField.INSTANT_SECONDS} epoch-second field\nto be converted to a local date-time. This is primarily intended for\nlow-level conversions rather than general application usage.",
    "lineNumber": 232,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochSecond",
        "description": "the number of seconds from the epoch of 1970-01-01T00:00:00Z"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "!ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nanosecond within the second, from 0 to 999,999,999"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null if called with 3 arguments"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.from",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link LocalDateTime}.\n\nThe conversion extracts and combines {@link LocalDate} and {@link LocalTime}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used as a query via method reference, {@link LocalDateTime::from}.",
    "lineNumber": 262,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "{LocalDateTime} the local date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link LocalDateTime}"
      }
    ]
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime.parse",
    "access": "public",
    "description": "Obtains an instance of {@link LocalDateTime} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a date-time.",
    "lineNumber": 290,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTimeFormatter.ISO_LOCAL_DATE_TIME",
        "defaultRaw": "DateTimeFormatter.ISO_LOCAL_DATE_TIME",
        "name": "formatter",
        "description": "the formatter to use,\ndefaults to DateTimeFormatter.ISO_LOCAL_DATE_TIME"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the parsed local date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 272,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 303,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date part of the date-time, validated not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the time part of the date-time, validated not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "_date",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_date",
    "access": "private",
    "description": null,
    "lineNumber": 307,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "_time",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_time",
    "access": "private",
    "description": null,
    "lineNumber": 308,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "_withDateTime",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_withDateTime",
    "access": "private",
    "description": "Returns a copy of this date-time with the new date and time, checking\nto see if a new object is in fact required.",
    "lineNumber": 319,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "newDate",
        "description": "the date of the new date-time, not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "newTime",
        "description": "the time of the new date-time, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this date-time can be queried for the specified field.\nIf false, then calling the {@link LocalDateTime.range} range and\n{@link LocalDateTime.get} get methods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n* {@link ChronoField.NANO_OF_SECOND}\n* {@link ChronoField.NANO_OF_DAY}\n* {@link ChronoField.MICRO_OF_SECOND}\n* {@link ChronoField.MICRO_OF_DAY}\n* {@link ChronoField.MILLI_OF_SECOND}\n* {@link ChronoField.MILLI_OF_DAY}\n* {@link ChronoField.SECOND_OF_MINUTE}\n* {@link ChronoField.SECOND_OF_DAY}\n* {@link ChronoField.MINUTE_OF_HOUR}\n* {@link ChronoField.MINUTE_OF_DAY}\n* {@link ChronoField.HOUR_OF_AMPM}\n* {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n* {@link ChronoField.HOUR_OF_DAY}\n* {@link ChronoField.CLOCK_HOUR_OF_DAY}\n* {@link ChronoField.AMPM_OF_DAY}\n* {@link ChronoField.DAY_OF_WEEK}\n* {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH}\n* {@link ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR}\n* {@link ChronoField.DAY_OF_MONTH}\n* {@link ChronoField.DAY_OF_YEAR}\n* {@link ChronoField.EPOCH_DAY}\n* {@link ChronoField.ALIGNED_WEEK_OF_MONTH}\n* {@link ChronoField.ALIGNED_WEEK_OF_YEAR}\n* {@link ChronoField.MONTH_OF_YEAR}\n* {@link ChronoField.EPOCH_MONTH}\n* {@link ChronoField.YEAR_OF_ERA}\n* {@link ChronoField.YEAR}\n* {@link ChronoField.ERA}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this date-time, false if not"
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis date-time is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 407,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#get",
    "access": "public",
    "description": "Gets the value of the specified field from this date-time as an `int`.\n\nThis queries this date-time for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n{@link EPOCH_DAY} and {@link EPOCH_MONTH} which are too large to fit in\nan `int` and throw a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 439,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this date-time as a `long`.\n\nThis queries this date-time for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 468,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "year",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#year",
    "access": "public",
    "description": "Gets the year field.\n\nThis method returns the primitive `int` value for the year.\n\nThe year returned by this method is proleptic as per `get(YEAR)`.\nTo obtain the year-of-era, use `get(YEAR_OF_ERA)`.",
    "lineNumber": 487,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#monthValue",
    "access": "public",
    "description": "Gets the month-of-year field from 1 to 12.\n\nThis method returns the month as an `int` from 1 to 12.\nApplication code is frequently clearer if the enum {@link Month}\nis used by calling {@link getMonth}.",
    "see": [
      "#getMonth()"
    ],
    "lineNumber": 501,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#month",
    "access": "public",
    "description": "Gets the month-of-year field using the {@link Month} enum.\n\nThis method returns the enum {@link Month} for the month.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value, use\n{@link Month#getValue}.",
    "see": [
      "#getMonthValue()"
    ],
    "lineNumber": 516,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#dayOfMonth",
    "access": "public",
    "description": "Gets the day-of-month field.\n\nThis method returns the primitive `int` value for the day-of-month.",
    "lineNumber": 527,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "dayOfYear",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#dayOfYear",
    "access": "public",
    "description": "Gets the day-of-year field.\n\nThis method returns the primitive `int` value for the day-of-year.",
    "lineNumber": 538,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 365, or 366 in a leap year"
    },
    "params": []
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#dayOfWeek",
    "access": "public",
    "description": "Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n\nThis method returns the enum {@link DayOfWeek} for the day-of-week.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value, use\n{@link DayOfWeek#getValue}.\n\nAdditional information can be obtained from the {@link DayOfWeek}.\nThis includes textual names of the values.",
    "lineNumber": 555,
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "hour",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#hour",
    "access": "public",
    "description": "Gets the hour-of-day field.",
    "lineNumber": 565,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the hour-of-day, from 0 to 23"
    },
    "params": []
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "minute",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minute",
    "access": "public",
    "description": "Gets the minute-of-hour field.",
    "lineNumber": 574,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minute-of-hour, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "second",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#second",
    "access": "public",
    "description": "Gets the second-of-minute field.",
    "lineNumber": 583,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the second-of-minute, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#nano",
    "access": "public",
    "description": "Gets the nano-of-second field.",
    "lineNumber": 592,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nano-of-second, from 0 to 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this date-time.\n\nThis returns a new {@link LocalDateTime}, based on this one, with the date-time adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the year field.\nA more complex adjuster might set the date to the last day of the month.\nA selection of common adjustments is provided in {@link TemporalAdjusters}.\nThese include finding the 'last day of the month' and 'next Wednesday'.\nKey date-time classes also implement the {@link TemporalAdjuster} interface,\nsuch as {@link Month} and {@link MonthDay}.\nThe adjuster is responsible for handling special cases, such as the varying\nlengths of month and leap years.\n\nFor example this code returns a date on the last day of July:\n<pre>\n import static org.threeten.bp.Month.*;\n import static org.threeten.bp.temporal.Adjusters.*;\n\n result = localDateTime.with(JULY).with(lastDayOfMonth());\n</pre>\n\nThe classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\nthus this method can be used to change the date, time or offset:\n<pre>\n result = localDateTime.with(date);\n result = localDateTime.with(time);\n</pre>\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster#adjustInto} method on the\nspecified adjuster passing `this` as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 640,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on `this` with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_withField",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified field set to a new value.\n\nThis returns a new {@link LocalDateTime}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year, month or day-of-month.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIn some cases, changing the specified field can cause the resulting date-time to become invalid,\nsuch as changing the month from 31st January to February would make the day-of-month invalid.\nIn cases like this, the field is responsible for resolving the date. Typically it will choose\nthe previous valid date, which would be the last valid day of February in this example.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields (see {@link isSupported}) will behave as in\n{@link LocalDate#with} or {@link LocalTime#with}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 685,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withYear",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the year altered.\nThe time does not affect the calculation and will be the same in the result.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 709,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the result, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withMonth",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the month-of-year altered.\nThe time does not affect the calculation and will be the same in the result.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 724,
    "params": [
      {
        "nullable": false,
        "types": [
          "number",
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the result, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withDayOfMonth",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the day-of-month altered.\nIf the resulting {@link LocalDateTime} is invalid, an exception is thrown.\nThe time does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 740,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to set in the result, from 1 to 28-31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month value is invalid"
      },
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "withDayOfYear",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withDayOfYear",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the day-of-year altered.\nIf the resulting {@link LocalDateTime} is invalid, an exception is thrown.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 755,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to set in the result, from 1 to 365-366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year value is invalid"
      },
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year is invalid for the year"
      }
    ]
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "withHour",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withHour",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the hour-of-day value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 769,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": "the hour-of-day to set in the result, from 0 to 23"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested hour, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the hour value is invalid"
      }
    ]
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "withMinute",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withMinute",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the minute-of-hour value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 783,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": "the minute-of-hour to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested minute, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the minute value is invalid"
      }
    ]
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "withSecond",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withSecond",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the second-of-minute value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 797,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": "the second-of-minute to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested second, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the second value is invalid"
      }
    ]
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "withNano",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#withNano",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the nano-of-second value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 811,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to set in the result, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the requested nanosecond, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the nano value is invalid"
      }
    ]
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#truncatedTo",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the time truncated.\n\nTruncation returns a copy of the original date-time with fields\nsmaller than the specified unit set to zero.\nFor example, truncating with {@link ChronoUnit#MINUTES}\nwill set the second-of-minute and nano-of-second field to zero.\n\nThe unit must have a duration (see {@link TemporalUnit#getDuration})\nthat divides into the length of a standard day without remainder.\nThis includes all supplied time units on {@link ChronoUnit} and\n{@link ChronoUnit#DAYS}. Other units throw an exception.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 836,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to truncate to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the time truncated, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to truncate"
      }
    ]
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified period added.\n\nThis method returns a new date-time based on this date-time with the specified period added.\nThis can be used to add any period that is defined by a unit, for example to add years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 857,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the specified period added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusYears",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in years added.\n\nThis method adds the specified amount to the years field in three steps:\n\n1. Add the input years to the year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2008-02-29 (leap year) plus one year would result in the\ninvalid date 2009-02-29 (standard year). Instead of returning an invalid\nresult, the last valid day of the month, 2009-02-28, is selected instead.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 894,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in months added.\n\nThis method adds the specified amount to the months field in three steps:\n\n1. Add the input months to the month-of-year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2007-03-31 plus one month would result in the invalid date\n2007-04-31. Instead of returning an invalid result, the last valid day\nof the month, 2007-04-30, is selected instead.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 918,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the months added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in weeks added.\n\nThis method adds the specified amount in weeks to the days field incrementing\nthe month and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2008-12-31 plus one week would result in 2009-01-07.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 938,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the weeks added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusDays",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in days added.\n\nThis method adds the specified amount to the days field incrementing the\nmonth and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2008-12-31 plus one day would result in 2009-01-01.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 958,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the days added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusHours",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in hours added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 973,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the hours to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the hours added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in minutes added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 986,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the minutes to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the minutes added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in seconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 999,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#plusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1012,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanos to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the nanoseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_minusUnit",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified period subtracted.\n\nThis method returns a new date-time based on this date-time with the specified period subtracted.\nThis can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1033,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the unit to subtract from the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the specified period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusYears",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in years subtracted.\n\nThis method subtracts the specified amount from the years field in three steps:\n\n1. Subtract the input years from the year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2008-02-29 (leap year) minus one year would result in the\ninvalid date 2009-02-29 (standard year). Instead of returning an invalid\nresult, the last valid day of the month, 2009-02-28, is selected instead.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1058,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in months subtracted.\n\nThis method subtracts the specified amount from the months field in three steps:\n\n1. Subtract the input months from the month-of-year field\n2. Check if the resulting date would be invalid\n3. Adjust the day-of-month to the last valid day if necessary\n\nFor example, 2007-03-31 minus one month would result in the invalid date\n2007-04-31. Instead of returning an invalid result, the last valid day\nof the month, 2007-04-30, is selected instead.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1081,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in weeks subtracted.\n\nThis method subtracts the specified amount in weeks from the days field decrementing\nthe month and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2009-01-07 minus one week would result in 2008-12-31.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1100,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the weeks subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusDays",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in days subtracted.\n\nThis method subtracts the specified amount from the days field incrementing the\nmonth and year fields as necessary to ensure the result remains valid.\nThe result is only invalid if the maximum/minimum year is exceeded.\n\nFor example, 2009-01-01 minus one day would result in 2008-12-31.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1119,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the days subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusHours",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in hours subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the hours to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the hours subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in minutes subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1146,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the minutes to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the minutes subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in seconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1159,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "a {@link LocalDateTime} based on this date-time with the seconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#minusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period in nanoseconds subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1172,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanos to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "based on this date-time with the nanoseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "_plusWithOverflow",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_plusWithOverflow",
    "access": "private",
    "description": "Returns a copy of this {@link LocalDateTime} with the specified period added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1190,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "newDate",
        "description": "the new date to base the calculation on, not null"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the hours to add, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the minutes to add, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to add, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanos to add, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "sign",
        "description": "the sign to determine add or subtract"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the combined result, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#query",
    "access": "public",
    "description": "Queries this date-time using the specified query.\n\nThis queries this date-time using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 1230,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have the same date and time as this object.\n\nThis returns a temporal object of the same observable type as the input\nwith the date and time changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\ntwice, passing {@link ChronoField#EPOCH_DAY} and\n{@link ChronoField#NANO_OF_DAY} as the fields.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisLocalDateTime.adjustInto(temporal);\n  temporal = temporal.with(thisLocalDateTime);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1263,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#until",
    "access": "public",
    "description": "Calculates the period between this date-time and another date-time in\nterms of the specified unit.\n\nThis calculates the period between two date-times in terms of a single unit.\nThe start and end points are `this` and the specified date-time.\nThe result will be negative if the end is before the start.\nThe {@link Temporal} passed to this method must be a {@link LocalDateTime}.\nFor example, the period in days between two date-times can be calculated\nusing `startDateTime.until(endDateTime, DAYS)`.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two date-times.\nFor example, the period in months between 2012-06-15T00:00 and 2012-08-14T23:59\nwill only be one month as it is one minute short of two months.\n\nThis method operates in association with {@link TemporalUnit#between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, MONTHS);   // this method\n  dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n{@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n{@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n{@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\nOther {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing `this` as the first argument and the input temporal as\nthe second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1312,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date-time, which is converted to a {@link LocalDateTime}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this date-time and the end date-time"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the period cannot be calculated"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "atOffset",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#atOffset",
    "access": "public",
    "description": "Combines this date-time with an offset to create an {@link OffsetDateTime}.\n\nThis returns an {@link OffsetDateTime} formed from this date-time at the specified offset.\nAll possible combinations of date-time and offset are valid.",
    "lineNumber": 1375,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the offset date-time formed from this date-time and the specified offset, not null"
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "atZone",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#atZone",
    "access": "public",
    "description": "Combines this date-time with a time-zone to create a {@link ZonedDateTime}.\n\nThis returns a {@link ZonedDateTime} formed from this date-time at the\nspecified time-zone. The result will match this date-time as closely as possible.\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may be adjusted.\n\nThe local date-time is resolved to a single instant on the time-line.\nThis is achieved by finding a valid offset from UTC/Greenwich for the local\ndate-time as defined by the {@link ZoneRules} of the zone ID.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, where clocks are set back, there are two valid offsets.\nThis method uses the earlier offset typically corresponding to 'summer'.\n\nIn the case of a gap, where clocks jump forward, there is no valid offset.\nInstead, the local date-time is adjusted to be later by the length of the gap.\nFor a typical one hour daylight savings change, the local date-time will be\nmoved one hour later into the offset typically corresponding to 'summer'.\n\nTo obtain the later offset during an overlap, call\n{@link ZonedDateTime#withLaterOffsetAtOverlap} on the result of this method.\nTo throw an exception when there is a gap or overlap, use\n{@link ZonedDateTime#ofStrict}.",
    "lineNumber": 1408,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time formed from this date-time, not null"
    }
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "toLocalDate",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#toLocalDate",
    "access": "public",
    "description": "Gets the {@link LocalDate} part of this date-time.\n\nThis returns a {@link LocalDate} with the same year, month and day\nas this date-time.",
    "lineNumber": 1421,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "toLocalTime",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#toLocalTime",
    "access": "public",
    "description": "Gets the {@link LocalTime} part of this date-time.\n\nThis returns a {@link LocalTime} with the same hour, minute, second and\nnanosecond as this date-time.",
    "lineNumber": 1433,
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the time part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#compareTo",
    "access": "public",
    "description": "Compares this date-time to another date-time.\n\nThe comparison is primarily based on the date-time, from earliest to latest.\nIt is 'consistent with equals', as defined by {@link Comparable}.\n\nIf all the date-times being compared are instances of {@link LocalDateTime},\nthen the comparison will be entirely based on the date-time.\nIf some dates being compared are in different chronologies, then the\nchronology is also considered, see {@link ChronoLocalDateTime#compareTo}.",
    "lineNumber": 1452,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "_compareTo0",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#_compareTo0",
    "access": "private",
    "description": "",
    "lineNumber": 1465,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#isAfter",
    "access": "public",
    "description": "Checks if this date-time is after the specified date-time.\n\nThis checks to see if this date-time represents a point on the\nlocal time-line after the other date-time.\n<pre>\n  LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n  LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n  a.isAfter(b) == false\n  a.isAfter(a) == false\n  b.isAfter(a) == true\n</pre>\n\nThis method only considers the position of the two date-times on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo},\nbut is the same approach as {@link DATE_TIME_COMPARATOR}.",
    "lineNumber": 1494,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date-time is after the specified date-time"
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#isBefore",
    "access": "public",
    "description": "Checks if this date-time is before the specified date-time.\n\nThis checks to see if this date-time represents a point on the\nlocal time-line before the other date-time.\n<pre>\n  LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n  LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n  a.isBefore(b) == true\n  a.isBefore(a) == false\n  b.isBefore(a) == false\n</pre>\n\nThis method only considers the position of the two date-times on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo},\nbut is the same approach as {@link DATE_TIME_COMPARATOR}.",
    "lineNumber": 1520,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date-time is before the specified date-time"
    }
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#isEqual",
    "access": "public",
    "description": "Checks if this date-time is equal to the specified date-time.\n\nThis checks to see if this date-time represents the same point on the\nlocal time-line as the other date-time.\n<pre>\n  LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);\n  LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);\n  a.isEqual(b) == false\n  a.isEqual(a) == true\n  b.isEqual(a) == false\n</pre>\n\nThis method only considers the position of the two date-times on the local time-line.\nIt does not take into account the chronology, or calendar system.\nThis is different from the comparison in {@link compareTo},\nbut is the same approach as {@link DATE_TIME_COMPARATOR}.",
    "lineNumber": 1546,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date-time is equal to the specified date-time"
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#equals",
    "access": "public",
    "description": "Checks if this date-time is equal to another date-time.\n\nCompares this {@link LocalDateTime} with another ensuring that the date-time is the same.\nOnly objects of type {@link LocalDateTime} are compared, other types return false.",
    "lineNumber": 1561,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other date-time"
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#hashCode",
    "access": "public",
    "description": "A hash code for this date-time.",
    "lineNumber": 1576,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#toString",
    "access": "public",
    "description": "Outputs this date-time as a string, such as `2007-12-03T10:15:30`.\n\nThe output will be one of the following ISO-8601 formats:\n\n* `yyyy-MM-dd'T'HH:mm`\n* `yyyy-MM-dd'T'HH:mm:ss`\n* `yyyy-MM-dd'T'HH:mm:ss.SSS`\n* `yyyy-MM-dd'T'HH:mm:ss.SSSSSS`\n* `yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS`\n\nThe format used will be the shortest that outputs the full value of\nthe time where the omitted parts are implied to be zero.",
    "lineNumber": 1597,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1605,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalDateTime.toString}"
    },
    "params": []
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/LocalDateTime.js~LocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalDateTime.js~LocalDateTime#format",
    "access": "public",
    "description": "Outputs this date-time as a string using the formatter.",
    "lineNumber": 1616,
    "params": [
      {
        "nullable": false,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted date-time string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 337,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/LocalDateTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalDateTime.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalDateTime.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1623,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 338,
    "kind": "file",
    "name": "packages/core/src/LocalTime.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport { MathUtil } from './MathUtil';\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\n\nimport { Clock } from './Clock';\nimport { LocalDateTime } from './LocalDateTime';\nimport { ZoneId } from './ZoneId';\nimport { OffsetTime } from './OffsetTime';\n\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { Temporal } from './temporal/Temporal';\nimport { TemporalField } from './temporal/TemporalField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\n\n/**\n * A time without time-zone in the ISO-8601 calendar system,\n * such as `10:15:30`.\n *\n * {@link LocalTime} is an immutable date-time object that represents a time,\n * often viewed as hour-minute-second.\n * Time is represented to nanosecond precision.\n * For example, the value '13:45.30.123456789' can be stored in a {@link LocalTime}.\n *\n * It does not store or represent a date or time-zone.\n * Instead, it is a description of the local time as seen on a wall clock.\n * It cannot represent an instant on the time-line without additional information\n * such as an offset or time-zone.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. This API assumes that all calendar systems use the same\n * representation, this class, for time-of-day.\n *\n * ### Static properties of Class {@link LocalTime}\n *\n * LocalTime.MIN\n *\n * The minimum supported {@link LocalTime}, '00:00'.\n * This is the time of midnight at the start of the day.\n *\n * LocalTime.MAX\n *\n * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n * This is the time just before midnight at the end of the day.\n *\n * LocalTime.MIDNIGHT\n *\n * The time of midnight at the start of the day, '00:00'.\n *\n * LocalTime.NOON\n *\n * The time of noon in the middle of the day, '12:00'.\n *\n * LocalTime.HOURS_PER_DAY\n *\n * Hours per day.\n *\n * LocalTime.MINUTES_PER_HOUR\n *\n * Minutes per hour.\n *\n * LocalTime.MINUTES_PER_DAY\n *\n * Minutes per day.\n *\n * LocalTime.SECONDS_PER_MINUTE\n *\n * Seconds per minute.\n *\n * LocalTime.SECONDS_PER_HOUR\n *\n * Seconds per hour.\n *\n * LocalTime.SECONDS_PER_DAY\n *\n * Seconds per day.\n *\n * LocalTime.MILLIS_PER_DAY\n *\n * Milliseconds per day.\n *\n * LocalTime.MICROS_PER_DAY\n *\n * Microseconds per day.\n *\n * LocalTime.NANOS_PER_SECOND\n *\n * Nanos per second.\n *\n * LocalTime.NANOS_PER_MINUTE\n *\n * Nanos per minute.\n *\n * LocalTime.NANOS_PER_HOUR\n *\n * Nanos per hour.\n *\n * LocalTime.NANOS_PER_DAY\n *\n * Nanos per day.\n *\n */\nexport class LocalTime extends Temporal /** implements Temporal, TemporalAdjuster */ {\n    /**\n     * Obtains the current time from the specified clock.\n     * If no argument is specified the system default clock is queried,\n     * if a zone-id is passed a system clock with the specified zone is queried.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock|ZoneId} clockOrZone - the zone ID or clock to use, if null Clock.systemDefaultZone() is used.\n     * @return {LocalTime} the current time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        if (clockOrZone == null){\n            return LocalTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return LocalTime._now(clockOrZone);\n        } else {\n            return LocalTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * Obtains the current time from the specified clock.\n     *\n     * This will query the specified clock to obtain the current time.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} [clock=Clock.systemDefaultZone()] - the clock to use, not null\n     * @return {LocalTime} the current time, not null\n     */\n    static _now(clock = Clock.systemDefaultZone()) {\n        requireNonNull(clock, 'clock');// inline OffsetTime factory to avoid creating object and InstantProvider checks\n        return LocalTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    /**\n     * obtain a LocalTime from an Instant in the specified time-zone or, if null\n     * in the system default time-zone\n     *\n     * @param {!Instant} instant\n     * @param {ZoneId} [zone=ZoneId.systemDefault()], defaults to ZoneId.systemDefault()\n     * @returns {LocalTime} the current date, not null\n     */\n    static ofInstant(instant, zone=ZoneId.systemDefault()){\n        const offset = zone.rules().offset(instant);\n        let secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n        secsOfDay = MathUtil.intMod((secsOfDay + offset.totalSeconds()), LocalTime.SECONDS_PER_DAY);\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from an hour, minute, second and nanosecond.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, from 0 to 999,999,999\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the value of any field is out of range\n     */\n    static of(hour, minute, second, nanoOfSecond) {\n        return new LocalTime(hour, minute, second, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a second-of-day value, with\n     * associated nanos of second.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [secondOfDay=0] - the second-of-day, from `0` to `24 * 60 * 60 - 1`\n     * @param {number} [nanoOfSecond=0] - the nano-of-second, from `0` to `999,999,999`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the either input value is invalid\n     */\n    static ofSecondOfDay(secondOfDay=0, nanoOfSecond=0) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        const hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n        secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n        const minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n        secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n        return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a nanos-of-day value.\n     *\n     * This factory may return a cached value, but applications must not rely on this.\n     *\n     * @param {number} [nanoOfDay=0] - the nano of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if the nanos of day value is invalid\n     */\n    static ofNanoOfDay(nanoOfDay=0) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n        const hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n        nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n        const minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n        nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n        const seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n        nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n        return new LocalTime(hours, minutes, seconds, nanoOfDay);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link LocalTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link LocalTime}.\n     *\n     * The conversion uses the {@link TemporalQueries#localTime} query, which relies\n     * on extracting {@link ChronoField#NANO_OF_DAY}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link LocalTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {LocalTime} the local time, not null\n     * @throws {DateTimeException} if unable to convert to a {@link LocalTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const time = temporal.query(TemporalQueries.localTime());\n        if (time == null) {\n            throw new DateTimeException(`Unable to obtain LocalTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return time;\n    }\n\n    /**\n     * Obtains an instance of {@link LocalTime} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a time.\n     *\n     * @param {!String} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=DateTimeFormatter.ISO_LOCAL_TIME] - the formatter to use, default is\n     * {@link DateTimeFormatter.ISO_LOCAL_TIME}\n     * @return {LocalTime} the parsed local time, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter=DateTimeFormatter.ISO_LOCAL_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, LocalTime.FROM);\n    }\n\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} [hour=0] - the hour-of-day to represent, validated from 0 to 23\n     * @param {number} [minute=0] - the minute-of-hour to represent, validated from 0 to 59\n     * @param {number} [second=0] - the second-of-minute to represent, validated from 0 to 59\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to represent, validated from 0 to 999,999,999\n     * @private\n     */\n    constructor(hour=0, minute=0, second=0, nanoOfSecond=0) {\n        super();\n        const _hour = MathUtil.safeToInt(hour);\n        const _minute = MathUtil.safeToInt(minute);\n        const _second = MathUtil.safeToInt(second);\n        const _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n        LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {\n            if (!LocalTime.HOURS[_hour]) {\n                this._hour = _hour;\n                this._minute = _minute;\n                this._second = _second;\n                this._nano = _nanoOfSecond;\n                LocalTime.HOURS[_hour] = this;\n            }\n            return LocalTime.HOURS[_hour];\n        }\n        this._hour = _hour;\n        this._minute = _minute;\n        this._second = _second;\n        this._nano = _nanoOfSecond;\n    }\n\n    static _validate(hour, minute, second, nanoOfSecond){\n        ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND}\n     * * {@link ChronoField.NANO_OF_DAY}\n     * * {@link ChronoField.MICRO_OF_SECOND}\n     * * {@link ChronoField.MICRO_OF_DAY}\n     * * {@link ChronoField.MILLI_OF_SECOND}\n     * * {@link ChronoField.MILLI_OF_DAY}\n     * * {@link ChronoField.SECOND_OF_MINUTE}\n     * * {@link ChronoField.SECOND_OF_DAY}\n     * * {@link ChronoField.MINUTE_OF_HOUR}\n     * * {@link ChronoField.MINUTE_OF_DAY}\n     * * {@link ChronoField.HOUR_OF_AMPM}\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n     * * {@link ChronoField.HOUR_OF_DAY}\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY}\n     * * {@link ChronoField.AMPM_OF_DAY}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {ChronoField|ChronoUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {ChronoField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        requireNonNull(field);\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as an `int`.\n     *\n     * This queries this time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time, except {@link ChronoField.NANO_OF_DAY} and {@link ChronoField.MICRO_OF_DAY}\n     * which are too large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this time as a `long`.\n     *\n     * This queries this time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.from}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {ChronoField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     *\n     * @param {ChronoField} field\n     * @returns {number}\n     * @private\n     */\n    _get0(field) {\n        switch (field) {\n            case ChronoField.NANO_OF_SECOND: return this._nano;\n            case ChronoField.NANO_OF_DAY: return this.toNanoOfDay();\n            case ChronoField.MICRO_OF_SECOND: return MathUtil.intDiv(this._nano, 1000);\n            case ChronoField.MICRO_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n            case ChronoField.MILLI_OF_SECOND: return MathUtil.intDiv(this._nano, 1000000);\n            case ChronoField.MILLI_OF_DAY: return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n            case ChronoField.SECOND_OF_MINUTE: return this._second;\n            case ChronoField.SECOND_OF_DAY: return this.toSecondOfDay();\n            case ChronoField.MINUTE_OF_HOUR: return this._minute;\n            case ChronoField.MINUTE_OF_DAY: return this._hour * 60 + this._minute;\n            case ChronoField.HOUR_OF_AMPM: return MathUtil.intMod(this._hour, 12);\n            case ChronoField.CLOCK_HOUR_OF_AMPM: {\n                const ham = MathUtil.intMod(this._hour, 12);\n                return (ham % 12 === 0 ? 12 : ham);\n            }\n            case ChronoField.HOUR_OF_DAY: return this._hour;\n            case ChronoField.CLOCK_HOUR_OF_DAY: return (this._hour === 0 ? 24 : this._hour);\n            case ChronoField.AMPM_OF_DAY: return MathUtil.intDiv(this._hour, 12);\n        }\n        throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._hour;\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._minute;\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._second;\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._nano;\n    }\n\n    /**\n     * Returns an adjusted copy of this time.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the hour field.\n     * A more complex adjuster might set the time to the last hour of the day.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing this as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalTime} a {@link LocalTime} based on this with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalTime) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this time with the specified field set to a new value.\n     *\n     * This returns a new {@link LocalTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the hour, minute or second.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link ChronoField.NANO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the specified nano-of-second.\n     *  The hour, minute and second will be unchanged.\n     * * {@link ChronoField.NANO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified nano-of-day.\n     *   This completely replaces the time and is equivalent to {@link ofNanoOfDay}.\n     * * {@link ChronoField.MICRO_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   micro-of-second multiplied by 1,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MICRO_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified micro-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the micro-of-day multiplied by 1,000.\n     * * {@link ChronoField.MILLI_OF_SECOND} -\n     *   Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n     *   milli-of-second multiplied by 1,000,000.\n     *   The hour, minute and second will be unchanged.\n     * * {@link ChronoField.MILLI_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified milli-of-day.\n     *   This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n     *   with the milli-of-day multiplied by 1,000,000.\n     * * {@link ChronoField.SECOND_OF_MINUTE} -\n     *   Returns a {@link LocalTime} with the specified second-of-minute.\n     *   The hour, minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.SECOND_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified second-of-day.\n     *   The nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_HOUR} -\n     *   Returns a {@link LocalTime} with the specified minute-of-hour.\n     *   The hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.MINUTE_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified minute-of-day.\n     *   The second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_AMPM} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-am-pm.\n     *   The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.CLOCK_HOUR_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified clock-hour-of-day.\n     *   The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     * * {@link ChronoField.AMPM_OF_DAY} -\n     *   Returns a {@link LocalTime} with the specified AM/PM.\n     *   The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing this as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {LocalTime} a {@link LocalTime} based on this with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.NANO_OF_SECOND: return this.withNano(newValue);\n                case ChronoField.NANO_OF_DAY: return LocalTime.ofNanoOfDay(newValue);\n                case ChronoField.MICRO_OF_SECOND: return this.withNano(newValue * 1000);\n                case ChronoField.MICRO_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000);\n                case ChronoField.MILLI_OF_SECOND: return this.withNano( newValue * 1000000);\n                case ChronoField.MILLI_OF_DAY: return LocalTime.ofNanoOfDay(newValue * 1000000);\n                case ChronoField.SECOND_OF_MINUTE: return this.withSecond(newValue);\n                case ChronoField.SECOND_OF_DAY: return this.plusSeconds(newValue - this.toSecondOfDay());\n                case ChronoField.MINUTE_OF_HOUR: return this.withMinute(newValue);\n                case ChronoField.MINUTE_OF_DAY: return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n                case ChronoField.HOUR_OF_AMPM: return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n                case ChronoField.CLOCK_HOUR_OF_AMPM: return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n                case ChronoField.HOUR_OF_DAY: return this.withHour(newValue);\n                case ChronoField.CLOCK_HOUR_OF_DAY: return this.withHour((newValue === 24 ? 0 : newValue));\n                case ChronoField.AMPM_OF_DAY: return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the hour-of-day value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [hour=0] - the hour-of-day to set in the result, from 0 to 23\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested hour, not null\n     * @throws {DateTimeException} if the hour value is invalid\n     */\n    withHour(hour=0) {\n        if (this._hour === hour) {\n            return this;\n        }\n        return new LocalTime(hour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the minute-of-hour value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [minute=0] - the minute-of-hour to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested minute, not null\n     * @throws {DateTimeException} if the minute value is invalid\n     */\n    withMinute(minute=0) {\n        if (this._minute === minute) {\n            return this;\n        }\n        return new LocalTime(this._hour, minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the second-of-minute value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [second=0] - the second-of-minute to set in the result, from 0 to 59\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested second, not null\n     * @throws {DateTimeException} if the second value is invalid\n     */\n    withSecond(second=0) {\n        if (this._second === second) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the nano-of-second value altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} [nanoOfSecond=0] - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {LocalTime} a {@link LocalTime} based on this time with the requested nanosecond, not null\n     * @throws {DateTimeException} if the nanos value is invalid\n     */\n    withNano(nanoOfSecond=0) {\n        if (this._nano === nanoOfSecond) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the time truncated.\n     *\n     * Truncating the time returns a copy of the original time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with the {@link ChronoUnit.MINUTES} minutes unit\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit.DAYS}. Other units throw an exception.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!ChronoUnit} unit - the unit to truncate to, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        requireNonNull(unit, 'unit');\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        const unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException('Unit is too large to be used for truncation');\n        }\n        const dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException('Unit must divide into a standard day without remainder');\n        }\n        const nod = this.toNanoOfDay();\n        return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this time with the specified period added.\n     *\n     * This method returns a new time based on this time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period added, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.NANOS: return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS: return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS: return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES: return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS: return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS: return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours added.\n     *\n     * This adds the specified number of hours to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToAdd - the hours to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours added, not null\n     */\n    plusHours(hoursToAdd) {\n        if (hoursToAdd === 0) {\n            return this;\n        }\n\n        const newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n        return new LocalTime(newHour, this._minute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes added.\n     *\n     * This adds the specified number of minutes to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToAdd - the minutes to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes added, not null\n     */\n    plusMinutes(minutesToAdd) {\n        if (minutesToAdd === 0) {\n            return this;\n        }\n        const mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n        const newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n        if (mofd === newMofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n        const newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n        return new LocalTime(newHour, newMinute, this._second, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds added.\n     *\n     * This adds the specified number of seconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToAdd - the seconds to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds added, not null\n     */\n    plusSeconds(secondsToAdd) {\n        if (secondsToAdd === 0) {\n            return this;\n        }\n        const sofd = this._hour * LocalTime.SECONDS_PER_HOUR +\n                    this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n        const newSofd = MathUtil.intMod((MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY), LocalTime.SECONDS_PER_DAY);\n        if (sofd === newSofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n        return new LocalTime(newHour, newMinute, newSecond, this._nano);\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds added.\n     *\n     * This adds the specified number of nanoseconds to this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToAdd - the nanos to add, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds added, not null\n     */\n    plusNanos(nanosToAdd) {\n        if (nanosToAdd === 0) {\n            return this;\n        }\n        const nofd = this.toNanoOfDay();\n        const newNofd = MathUtil.intMod((MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY), LocalTime.NANOS_PER_DAY);\n        if (nofd === newNofd) {\n            return this;\n        }\n        const newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n        const newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        const newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n        const newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n        return new LocalTime(newHour, newMinute, newSecond, newNano);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this time with the specified period subtracted.\n     *\n     * This method returns a new time based on this time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract hours, minutes or seconds.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {ChronoUnit} unit - the unit of the period to subtract, not null\n     * @return {LocalTime} a {@link LocalTime} based on this time with the specified period subtracted, not null\n     * @throws {DateTimeException} if the unit cannot be added to this type\n     */\n    _minusUnit(amountToSubtract, unit) {\n        requireNonNull(unit, 'unit');\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in hours subtracted.\n     *\n     * This subtracts the specified number of hours from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hoursToSubtract - the hours to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the hours subtracted, not null\n     */\n    minusHours(hoursToSubtract) {\n        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in minutes subtracted.\n     *\n     * This subtracts the specified number of minutes from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutesToSubtract - the minutes to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the minutes subtracted, not null\n     */\n    minusMinutes(minutesToSubtract) {\n        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in seconds subtracted.\n     *\n     * This subtracts the specified number of seconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} secondsToSubtract - the seconds to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the seconds subtracted, not null\n     */\n    minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n    }\n\n    /**\n     * Returns a copy of this {@link LocalTime} with the specified period in nanoseconds subtracted.\n     *\n     * This subtracts the specified number of nanoseconds from this time, returning a new time.\n     * The calculation wraps around midnight.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanosToSubtract - the nanos to subtract, may be negative\n     * @return {LocalTime} a {@link LocalTime} based on this time with the nanoseconds subtracted, not null\n     */\n    minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this time using the specified query.\n     *\n     * This queries this time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localTime()) {\n            return this;\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        if (query === TemporalQueries.chronology() || query === TemporalQueries.zoneId() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.offset() ||\n                query === TemporalQueries.localDate()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same time as this object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the time changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.NANO_OF_DAY} as the field.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalTime.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalTime);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n    }\n\n    /**\n     * Calculates the period between this time and another time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two times in terms of a single unit.\n     * The start and end points are this and the specified time.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link LocalTime}.\n     * For example, the period in hours between two times can be calculated\n     * using {@link startTime.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two times.\n     * For example, the period in hours between 11:30 and 13:29 will only\n     * be one hour as it is one minute short of two hours.\n     *\n     * This method operates in association with {@link TemporalUnit.between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, HOURS);   // this method\n     *   dateTime.plus(HOURS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link ChronoUnit.NANOS}, {@link ChronoUnit.MICROS}, {@link ChronoUnit.MILLIS}, {@link ChronoUnit.SECONDS},\n     * {@link ChronoUnit.MINUTES}, {@link ChronoUnit.HOURS} and {@link ChronoUnit.HALF_DAYS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing this as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAccessor} endExclusive - the end time, which is converted to a {@link LocalTime}, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this time and the end time\n     * @throws {DateTimeException} if the period cannot be calculated\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = LocalTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();  // no overflow\n            switch (unit) {\n                case ChronoUnit.NANOS: return nanosUntil;\n                case ChronoUnit.MICROS: return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS: return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(nanosUntil, (12 * LocalTime.NANOS_PER_HOUR));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this time with a date to create a {@link LocalDateTime}.\n     *\n     * This returns a {@link LocalDateTime} formed from this time at the specified date.\n     * All possible combinations of date and time are valid.\n     *\n     * @param {LocalDate} date - the date to combine with, not null\n     * @return {LocalDateTime} the local date-time formed from this time and the specified date, not null\n     */\n    atDate(date) {\n        return LocalDateTime.of(date, this);\n    }\n\n    /**\n     * Combines this time with an offset to create an {@link OffsetTime}.\n     *\n     * This returns an {@link OffsetTime} formed from this time at the specified offset.\n     * All possible combinations of time and offset are valid.\n     *\n     * @param {OffsetTime} offset - the offset to combine with, not null\n     * @return {OffsetTime} the offset time formed from this time and the specified offset, not null\n     */\n    atOffset(offset) {\n        return OffsetTime.of(this, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts the time as seconds of day, from `0` to `24 * 60 * 60 - 1`.\n     *\n     * @return {number} the second-of-day equivalent to this time\n     */\n    toSecondOfDay() {\n        let total = this._hour * LocalTime.SECONDS_PER_HOUR;\n        total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n        total += this._second;\n        return total;\n    }\n\n    /**\n     * Extracts the time as nanos of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`.\n     *\n     * @return {number} the nano of day equivalent to this time\n     */\n    toNanoOfDay() {\n        let total = this._hour * LocalTime.NANOS_PER_HOUR;\n        total += this._minute * LocalTime.NANOS_PER_MINUTE;\n        total += this._second * LocalTime.NANOS_PER_SECOND;\n        total += this._nano;\n        return total;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this {@link LocalTime} to another time.\n     *\n     * The comparison is based on the time-line position of the local times within a day.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws {NullPointerException} if `other` is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, LocalTime, 'other');\n        let cmp = MathUtil.compareNumbers(this._hour, other._hour);\n        if (cmp === 0) {\n            cmp = MathUtil.compareNumbers(this._minute, other._minute);\n            if (cmp === 0) {\n                cmp = MathUtil.compareNumbers(this._second, other._second);\n                if (cmp === 0) {\n                    cmp = MathUtil.compareNumbers(this._nano, other._nano);\n                }\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is after the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean} true if this is after the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Checks if this {@link LocalTime} is before the specified time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * @param {LocalTime} other - the other time to compare to, not null\n     * @return {boolean} true if this point is before the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this time is equal to another time.\n     *\n     * The comparison is based on the time-line position of the time within a day.\n     *\n     * Only objects of type {@link LocalTime} are compared, other types return false.\n     * To compare the date of two {@link TemporalAccessor} instances, use\n     * {@link ChronoField#NANO_OF_DAY} as a comparator.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalTime) {\n            return this._hour === other._hour && this._minute === other._minute &&\n                this._second === other._second && this._nano === other._nano;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        const nod = this.toNanoOfDay();\n        return MathUtil.hash(nod);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this time as a string, such as `10:15`.\n     *\n     * The output will be one of the following ISO-8601 formats:\n     *\n     * * {@link HH:mm}\n     * * {@link HH:mm:ss}\n     * * {@link HH:mm:ss.SSS}\n     * * {@link HH:mm:ss.SSSSSS}\n     * * {@link HH:mm:ss.SSSSSSSSS}\n     *\n     * The format used will be the shortest that outputs the full value of\n     * the time where the omitted parts are implied to be zero.\n     *\n     * @return {string} a string representation of this time, not null\n     */\n    toString() {\n        let buf = '';\n        const hourValue = this._hour;\n        const minuteValue = this._minute;\n        const secondValue = this._second;\n        const nanoValue = this._nano;\n        buf += hourValue < 10 ? '0' : '';\n        buf += hourValue;\n        buf += minuteValue < 10 ? ':0' : ':';\n        buf += minuteValue;\n        if (secondValue > 0 || nanoValue > 0) {\n            buf += secondValue < 10 ? ':0' : ':';\n            buf += secondValue;\n            if (nanoValue > 0) {\n                buf += '.';\n                if(MathUtil.intMod(nanoValue, 1000000) === 0) {\n                    buf += (`${MathUtil.intDiv(nanoValue, 1000000) + 1000}`).substring(1);\n                } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n                    buf += (`${MathUtil.intDiv(nanoValue, 1000) + 1000000}`).substring(1);\n                } else {\n                    buf += (`${nanoValue + 1000000000}`).substring(1);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\nexport function _init() {\n    /**\n     * Constants for the local time of each hour.\n     */\n    LocalTime.HOURS = [];\n    for (let hour = 0; hour < 24; hour++) {\n        LocalTime.of(hour, 0, 0, 0);\n    }\n\n    /**\n     * The minimum supported {@link LocalTime}, '00:00'.\n     * This is the time of midnight at the start of the day.\n     */\n    LocalTime.MIN = LocalTime.HOURS[0];\n    /**\n     * The maximum supported {@link LocalTime}, '23:59:59.999999999'.\n     * This is the time just before midnight at the end of the day.\n     */\n    LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n    /**\n     * The time of midnight at the start of the day, '00:00'.\n     */\n    LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n    /**\n     * The time of noon in the middle of the day, '12:00'.\n     */\n    LocalTime.NOON = LocalTime.HOURS[12];\n\n    LocalTime.FROM = createTemporalQuery('LocalTime.FROM', (temporal) => {\n        return LocalTime.from(temporal);\n    });\n}\n\n/**\n * Hours per day.\n */\nLocalTime.HOURS_PER_DAY = 24;\n/**\n * Minutes per hour.\n */\nLocalTime.MINUTES_PER_HOUR = 60;\n/**\n * Minutes per day.\n */\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\n/**\n * Seconds per minute.\n */\nLocalTime.SECONDS_PER_MINUTE = 60;\n/**\n * Seconds per hour.\n */\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n/**\n * Seconds per day.\n */\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n/**\n * Milliseconds per day.\n */\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\n/**\n * Microseconds per day.\n */\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\n/**\n * Nanos per second.\n */\nLocalTime.NANOS_PER_SECOND = 1000000000;\n/**\n * Nanos per minute.\n */\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\n/**\n * Nanos per hour.\n */\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\n/**\n * Nanos per day.\n */\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/LocalTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "LocalTime",
    "memberof": "packages/core/src/LocalTime.js",
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalTime.js",
    "importStyle": "{LocalTime}",
    "description": "A time without time-zone in the ISO-8601 calendar system,\nsuch as `10:15:30`.\n\n{@link LocalTime} is an immutable date-time object that represents a time,\noften viewed as hour-minute-second.\nTime is represented to nanosecond precision.\nFor example, the value '13:45.30.123456789' can be stored in a {@link LocalTime}.\n\nIt does not store or represent a date or time-zone.\nInstead, it is a description of the local time as seen on a wall clock.\nIt cannot represent an instant on the time-line without additional information\nsuch as an offset or time-zone.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. This API assumes that all calendar systems use the same\nrepresentation, this class, for time-of-day.\n\n### Static properties of Class {@link LocalTime}\n\nLocalTime.MIN\n\nThe minimum supported {@link LocalTime}, '00:00'.\nThis is the time of midnight at the start of the day.\n\nLocalTime.MAX\n\nThe maximum supported {@link LocalTime}, '23:59:59.999999999'.\nThis is the time just before midnight at the end of the day.\n\nLocalTime.MIDNIGHT\n\nThe time of midnight at the start of the day, '00:00'.\n\nLocalTime.NOON\n\nThe time of noon in the middle of the day, '12:00'.\n\nLocalTime.HOURS_PER_DAY\n\nHours per day.\n\nLocalTime.MINUTES_PER_HOUR\n\nMinutes per hour.\n\nLocalTime.MINUTES_PER_DAY\n\nMinutes per day.\n\nLocalTime.SECONDS_PER_MINUTE\n\nSeconds per minute.\n\nLocalTime.SECONDS_PER_HOUR\n\nSeconds per hour.\n\nLocalTime.SECONDS_PER_DAY\n\nSeconds per day.\n\nLocalTime.MILLIS_PER_DAY\n\nMilliseconds per day.\n\nLocalTime.MICROS_PER_DAY\n\nMicroseconds per day.\n\nLocalTime.NANOS_PER_SECOND\n\nNanos per second.\n\nLocalTime.NANOS_PER_MINUTE\n\nNanos per minute.\n\nLocalTime.NANOS_PER_HOUR\n\nNanos per hour.\n\nLocalTime.NANOS_PER_DAY\n\nNanos per day.",
    "lineNumber": 113,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.now",
    "access": "public",
    "description": "Obtains the current time from the specified clock.\nIf no argument is specified the system default clock is queried,\nif a zone-id is passed a system clock with the specified zone is queried.\n\nThis will query the specified clock to obtain the current time.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "clockOrZone",
        "description": "the zone ID or clock to use, if null Clock.systemDefaultZone() is used."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the current time using the system clock, not null"
    }
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "_now",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime._now",
    "access": "private",
    "description": "Obtains the current time from the specified clock.\n\nThis will query the specified clock to obtain the current time.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection (see {@link Clock}).",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Clock.systemDefaultZone()",
        "defaultRaw": "Clock.systemDefaultZone()",
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the current time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.ofInstant",
    "access": "public",
    "description": "obtain a LocalTime from an Instant in the specified time-zone or, if null\nin the system default time-zone",
    "lineNumber": 159,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{LocalTime} the current date, not null"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "ZoneId.systemDefault()",
        "defaultRaw": "ZoneId.systemDefault()",
        "name": "zone",
        "description": ", defaults to ZoneId.systemDefault()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the current date, not null"
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.of",
    "access": "public",
    "description": "Obtains an instance of {@link LocalTime} from an hour, minute, second and nanosecond.\n\nThis factory may return a cached value, but applications must not rely on this.",
    "lineNumber": 181,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "the hour-of-day to represent, from 0 to 23"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "the minute-of-hour to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "the second-of-minute to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the local time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range"
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "ofSecondOfDay",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.ofSecondOfDay",
    "access": "public",
    "description": "Obtains an instance of {@link LocalTime} from a second-of-day value, with\nassociated nanos of second.\n\nThis factory may return a cached value, but applications must not rely on this.",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "secondOfDay",
        "description": "the second-of-day, from `0` to `24 * 60 * 60 - 1`"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second, from `0` to `999,999,999`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the local time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the either input value is invalid"
      }
    ]
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "ofNanoOfDay",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.ofNanoOfDay",
    "access": "public",
    "description": "Obtains an instance of {@link LocalTime} from a nanos-of-day value.\n\nThis factory may return a cached value, but applications must not rely on this.",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfDay",
        "description": "the nano of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the local time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the nanos of day value is invalid"
      }
    ]
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.from",
    "access": "public",
    "description": "Obtains an instance of {@link LocalTime} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link LocalTime}.\n\nThe conversion uses the {@link TemporalQueries#localTime} query, which relies\non extracting {@link ChronoField#NANO_OF_DAY}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link LocalTime::from}.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the local time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link LocalTime}"
      }
    ]
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime.parse",
    "access": "public",
    "description": "Obtains an instance of {@link LocalTime} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a time.",
    "lineNumber": 263,
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTimeFormatter.ISO_LOCAL_TIME",
        "defaultRaw": "DateTimeFormatter.ISO_LOCAL_TIME",
        "name": "formatter",
        "description": "the formatter to use, default is\n{@link DateTimeFormatter.ISO_LOCAL_TIME}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the parsed local time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 348,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#constructor",
    "access": "private",
    "description": "Constructor, previously validated.",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "the hour-of-day to represent, validated from 0 to 23"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "the minute-of-hour to represent, validated from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "the second-of-minute to represent, validated from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, validated from 0 to 999,999,999"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "_hour",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_hour",
    "access": "private",
    "description": null,
    "lineNumber": 286,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "_minute",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_minute",
    "access": "private",
    "description": null,
    "lineNumber": 287,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "member",
    "name": "_second",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_second",
    "access": "private",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "member",
    "name": "_nano",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_nano",
    "access": "private",
    "description": null,
    "lineNumber": 289,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "method",
    "name": "_validate",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~LocalTime._validate",
    "access": "private",
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "hour",
        "types": [
          "*"
        ]
      },
      {
        "name": "minute",
        "types": [
          "*"
        ]
      },
      {
        "name": "second",
        "types": [
          "*"
        ]
      },
      {
        "name": "nanoOfSecond",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 358,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this time can be queried for the specified field.\nIf false, then calling {@link range} and {@link get} will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n* {@link ChronoField.NANO_OF_SECOND}\n* {@link ChronoField.NANO_OF_DAY}\n* {@link ChronoField.MICRO_OF_SECOND}\n* {@link ChronoField.MICRO_OF_DAY}\n* {@link ChronoField.MILLI_OF_SECOND}\n* {@link ChronoField.MILLI_OF_DAY}\n* {@link ChronoField.SECOND_OF_MINUTE}\n* {@link ChronoField.SECOND_OF_DAY}\n* {@link ChronoField.MINUTE_OF_HOUR}\n* {@link ChronoField.MINUTE_OF_DAY}\n* {@link ChronoField.HOUR_OF_AMPM}\n* {@link ChronoField.CLOCK_HOUR_OF_AMPM}\n* {@link ChronoField.HOUR_OF_DAY}\n* {@link ChronoField.CLOCK_HOUR_OF_DAY}\n* {@link ChronoField.AMPM_OF_DAY}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing this as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoField",
          "ChronoUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this time, false if not"
    }
  },
  {
    "__docId__": 359,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis time is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing this as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 374,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 360,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#get",
    "access": "public",
    "description": "Gets the value of the specified field from this time as an `int`.\n\nThis queries this time for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this time, except {@link ChronoField.NANO_OF_DAY} and {@link ChronoField.MICRO_OF_DAY}\nwhich are too large to fit in an `int` and throw a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 403,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 361,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this time as a `long`.\n\nThis queries this time for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this time.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.from}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 429,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "_get0",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_get0",
    "access": "private",
    "description": "",
    "lineNumber": 443,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "hour",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#hour",
    "access": "public",
    "description": "Gets the hour-of-day field.",
    "lineNumber": 473,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the hour-of-day, from 0 to 23"
    },
    "params": []
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "minute",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#minute",
    "access": "public",
    "description": "Gets the minute-of-hour field.",
    "lineNumber": 482,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minute-of-hour, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "second",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#second",
    "access": "public",
    "description": "Gets the second-of-minute field.",
    "lineNumber": 491,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the second-of-minute, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#nano",
    "access": "public",
    "description": "Gets the nano-of-second field.",
    "lineNumber": 500,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nano-of-second, from 0 to 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this time.\n\nThis returns a new {@link LocalTime}, based on this one, with the time adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the hour field.\nA more complex adjuster might set the time to the last hour of the day.\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster.adjustInto} method on the\nspecified adjuster passing this as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 525,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_withField",
    "access": "private",
    "description": "Returns a copy of this time with the specified field set to a new value.\n\nThis returns a new {@link LocalTime}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the hour, minute or second.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n\n* {@link ChronoField.NANO_OF_SECOND} -\n  Returns a {@link LocalTime} with the specified nano-of-second.\n The hour, minute and second will be unchanged.\n* {@link ChronoField.NANO_OF_DAY} -\n  Returns a {@link LocalTime} with the specified nano-of-day.\n  This completely replaces the time and is equivalent to {@link ofNanoOfDay}.\n* {@link ChronoField.MICRO_OF_SECOND} -\n  Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n  micro-of-second multiplied by 1,000.\n  The hour, minute and second will be unchanged.\n* {@link ChronoField.MICRO_OF_DAY} -\n  Returns a {@link LocalTime} with the specified micro-of-day.\n  This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n  with the micro-of-day multiplied by 1,000.\n* {@link ChronoField.MILLI_OF_SECOND} -\n  Returns a {@link LocalTime} with the nano-of-second replaced by the specified\n  milli-of-second multiplied by 1,000,000.\n  The hour, minute and second will be unchanged.\n* {@link ChronoField.MILLI_OF_DAY} -\n  Returns a {@link LocalTime} with the specified milli-of-day.\n  This completely replaces the time and is equivalent to using {@link ofNanoOfDay}\n  with the milli-of-day multiplied by 1,000,000.\n* {@link ChronoField.SECOND_OF_MINUTE} -\n  Returns a {@link LocalTime} with the specified second-of-minute.\n  The hour, minute and nano-of-second will be unchanged.\n* {@link ChronoField.SECOND_OF_DAY} -\n  Returns a {@link LocalTime} with the specified second-of-day.\n  The nano-of-second will be unchanged.\n* {@link ChronoField.MINUTE_OF_HOUR} -\n  Returns a {@link LocalTime} with the specified minute-of-hour.\n  The hour, second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.MINUTE_OF_DAY} -\n  Returns a {@link LocalTime} with the specified minute-of-day.\n  The second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.HOUR_OF_AMPM} -\n  Returns a {@link LocalTime} with the specified hour-of-am-pm.\n  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.CLOCK_HOUR_OF_AMPM} -\n  Returns a {@link LocalTime} with the specified clock-hour-of-am-pm.\n  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.HOUR_OF_DAY} -\n  Returns a {@link LocalTime} with the specified hour-of-day.\n  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.CLOCK_HOUR_OF_DAY} -\n  Returns a {@link LocalTime} with the specified clock-hour-of-day.\n  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n* {@link ChronoField.AMPM_OF_DAY} -\n  Returns a {@link LocalTime} with the specified AM/PM.\n  The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a {@link DateTimeException} will be thrown.\n\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing this as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 614,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "withHour",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#withHour",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the hour-of-day value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 651,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "hour",
        "description": "the hour-of-day to set in the result, from 0 to 23"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the requested hour, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the hour value is invalid"
      }
    ]
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "withMinute",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#withMinute",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the minute-of-hour value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 667,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "minute",
        "description": "the minute-of-hour to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the requested minute, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the minute value is invalid"
      }
    ]
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "withSecond",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#withSecond",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the second-of-minute value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 683,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "second",
        "description": "the second-of-minute to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the requested second, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the second value is invalid"
      }
    ]
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "withNano",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#withNano",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the nano-of-second value altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 699,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to set in the result, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the requested nanosecond, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the nanos value is invalid"
      }
    ]
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#truncatedTo",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the time truncated.\n\nTruncating the time returns a copy of the original time with fields\nsmaller than the specified unit set to zero.\nFor example, truncating with the {@link ChronoUnit.MINUTES} minutes unit\nwill set the second-of-minute and nano-of-second field to zero.\n\nThe unit must have a duration (see {@link TemporalUnit#getDuration})\nthat divides into the length of a standard day without remainder.\nThis includes all supplied time units on {@link ChronoUnit} and\n{@link ChronoUnit.DAYS}. Other units throw an exception.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 726,
    "params": [
      {
        "nullable": false,
        "types": [
          "ChronoUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to truncate to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the time truncated, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to truncate"
      }
    ]
  },
  {
    "__docId__": 374,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this time with the specified period added.\n\nThis method returns a new time based on this time with the specified period added.\nThis can be used to add any period that is defined by a unit, for example to add hours, minutes or seconds.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 760,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the specified period added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#plusHours",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in hours added.\n\nThis adds the specified number of hours to this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 789,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hoursToAdd",
        "description": "the hours to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the hours added, not null"
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#plusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in minutes added.\n\nThis adds the specified number of minutes to this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 809,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutesToAdd",
        "description": "the minutes to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the minutes added, not null"
    }
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#plusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in seconds added.\n\nThis adds the specified number of seconds to this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 834,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToAdd",
        "description": "the seconds to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the seconds added, not null"
    }
  },
  {
    "__docId__": 378,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#plusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in nanoseconds added.\n\nThis adds the specified number of nanoseconds to this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 861,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToAdd",
        "description": "the nanos to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the nanoseconds added, not null"
    }
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#_minusUnit",
    "access": "private",
    "description": "Returns a copy of this time with the specified period subtracted.\n\nThis method returns a new time based on this time with the specified period subtracted.\nThis can be used to subtract any period that is defined by a unit, for example to subtract hours, minutes or seconds.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 894,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the unit to subtract from the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "ChronoUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the specified period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#minusHours",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in hours subtracted.\n\nThis subtracts the specified number of hours from this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 911,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hoursToSubtract",
        "description": "the hours to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the hours subtracted, not null"
    }
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#minusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in minutes subtracted.\n\nThis subtracts the specified number of minutes from this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 926,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutesToSubtract",
        "description": "the minutes to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the minutes subtracted, not null"
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#minusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in seconds subtracted.\n\nThis subtracts the specified number of seconds from this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 941,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "secondsToSubtract",
        "description": "the seconds to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the seconds subtracted, not null"
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#minusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link LocalTime} with the specified period in nanoseconds subtracted.\n\nThis subtracts the specified number of nanoseconds from this time, returning a new time.\nThe calculation wraps around midnight.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 956,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanosToSubtract",
        "description": "the nanos to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the nanoseconds subtracted, not null"
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#query",
    "access": "public",
    "description": "Queries this time using the specified query.\n\nThis queries this time using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing this as the argument.",
    "lineNumber": 978,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have the same time as this object.\n\nThis returns a temporal object of the same observable type as the input\nwith the time changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\npassing {@link ChronoField.NANO_OF_DAY} as the field.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisLocalTime.adjustInto(temporal);\n  temporal = temporal.with(thisLocalTime);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1018,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#until",
    "access": "public",
    "description": "Calculates the period between this time and another time in\nterms of the specified unit.\n\nThis calculates the period between two times in terms of a single unit.\nThe start and end points are this and the specified time.\nThe result will be negative if the end is before the start.\nThe {@link Temporal} passed to this method must be a {@link LocalTime}.\nFor example, the period in hours between two times can be calculated\nusing {@link startTime.until}.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two times.\nFor example, the period in hours between 11:30 and 13:29 will only\nbe one hour as it is one minute short of two hours.\n\nThis method operates in association with {@link TemporalUnit.between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, HOURS);   // this method\n  dateTime.plus(HOURS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link ChronoUnit.NANOS}, {@link ChronoUnit.MICROS}, {@link ChronoUnit.MILLIS}, {@link ChronoUnit.SECONDS},\n{@link ChronoUnit.MINUTES}, {@link ChronoUnit.HOURS} and {@link ChronoUnit.HALF_DAYS} are supported.\nOther {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing this as the first argument and the input temporal as\nthe second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1065,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end time, which is converted to a {@link LocalTime}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this time and the end time"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the period cannot be calculated"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "atDate",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#atDate",
    "access": "public",
    "description": "Combines this time with a date to create a {@link LocalDateTime}.\n\nThis returns a {@link LocalDateTime} formed from this time at the specified date.\nAll possible combinations of date and time are valid.",
    "lineNumber": 1095,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time formed from this time and the specified date, not null"
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "atOffset",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#atOffset",
    "access": "public",
    "description": "Combines this time with an offset to create an {@link OffsetTime}.\n\nThis returns an {@link OffsetTime} formed from this time at the specified offset.\nAll possible combinations of time and offset are valid.",
    "lineNumber": 1108,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": "the offset time formed from this time and the specified offset, not null"
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "toSecondOfDay",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#toSecondOfDay",
    "access": "public",
    "description": "Extracts the time as seconds of day, from `0` to `24 * 60 * 60 - 1`.",
    "lineNumber": 1118,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the second-of-day equivalent to this time"
    },
    "params": []
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "toNanoOfDay",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#toNanoOfDay",
    "access": "public",
    "description": "Extracts the time as nanos of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`.",
    "lineNumber": 1130,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nano of day equivalent to this time"
    },
    "params": []
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#compareTo",
    "access": "public",
    "description": "Compares this {@link LocalTime} to another time.\n\nThe comparison is based on the time-line position of the local times within a day.\nIt is 'consistent with equals', as defined by {@link Comparable}.",
    "lineNumber": 1149,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#isAfter",
    "access": "public",
    "description": "Checks if this {@link LocalTime} is after the specified time.\n\nThe comparison is based on the time-line position of the time within a day.",
    "lineNumber": 1174,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified time"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#isBefore",
    "access": "public",
    "description": "Checks if this {@link LocalTime} is before the specified time.\n\nThe comparison is based on the time-line position of the time within a day.",
    "lineNumber": 1187,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified time"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#equals",
    "access": "public",
    "description": "Checks if this time is equal to another time.\n\nThe comparison is based on the time-line position of the time within a day.\n\nOnly objects of type {@link LocalTime} are compared, other types return false.\nTo compare the date of two {@link TemporalAccessor} instances, use\n{@link ChronoField#NANO_OF_DAY} as a comparator.",
    "lineNumber": 1204,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other time"
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#hashCode",
    "access": "public",
    "description": "A hash code for this time.",
    "lineNumber": 1220,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#toString",
    "access": "public",
    "description": "Outputs this time as a string, such as `10:15`.\n\nThe output will be one of the following ISO-8601 formats:\n\n* {@link HH:mm}\n* {@link HH:mm:ss}\n* {@link HH:mm:ss.SSS}\n* {@link HH:mm:ss.SSSSSS}\n* {@link HH:mm:ss.SSSSSSSSS}\n\nThe format used will be the shortest that outputs the full value of\nthe time where the omitted parts are implied to be zero.",
    "lineNumber": 1242,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this time, not null"
    },
    "params": []
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1273,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalTime.toString}"
    },
    "params": []
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/LocalTime.js~LocalTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/LocalTime.js~LocalTime#format",
    "access": "public",
    "description": "Outputs this time as a string using the formatter.",
    "lineNumber": 1284,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted time string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 399,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/LocalTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/LocalTime.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/LocalTime.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1290,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 400,
    "kind": "file",
    "name": "packages/core/src/MathUtil.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { ArithmeticException } from './errors';\n\nexport const MAX_SAFE_INTEGER = 9007199254740991;\nexport const MIN_SAFE_INTEGER = -9007199254740991;\n\n/**\n * Math helper with static function for integer operations\n */\nexport class MathUtil {\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intDiv(x, y) {\n        let r = x/y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static intMod(x, y) {\n        let r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} r\n     * @returns {number}\n     */\n    static roundDown(r){\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorDiv(x, y){\n        const r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static floorMod(x, y){\n        const r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        const r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        const r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || (x === MIN_SAFE_INTEGER && y === -1) || (y === MIN_SAFE_INTEGER && x === -1)) {\n            throw new ArithmeticException(`Multiplication overflows: ${x} * ${y}`);\n        }\n        return r;\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static parseInt(value) {\n        const r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    }\n\n    /**\n     *\n     * @param {number} value\n     */\n    static verifyInt(value){\n        if (value == null) {\n            throw new ArithmeticException(`Invalid value: '${value}', using null or undefined as argument`);\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException('Invalid int value, using NaN as argument');\n        }\n        if ((value % 1) !== 0) {\n            throw new ArithmeticException(`Invalid value: '${value}' is a float`);\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException(`Calculation overflows an int: ${value}`);\n        }\n    }\n\n    /**\n     * convert -0 to 0 and int as string to a number ( '1' -> 1 )\n     *\n     * @param {number} value\n     * @returns {number}\n     */\n    static safeZero(value){\n        return value === 0 ? 0 : +value;\n    }\n\n    /**\n     * Compares two Numbers.\n     *\n     * @param {number} a  the first value\n     * @param {number} b  the second value\n     * @return {number} the result\n     */\n    static compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n\n    // convert to small integer for v8 optimisation\n    static smi(int) {\n        return ((int >>> 1) & 0x40000000) | (int & 0xBFFFFFFF);\n    }\n\n    // calculate 32 bit hash of a number and convert to SMI\n    static hash(number) {\n        if (number !== number || number === Infinity) {\n            return 0;\n        }\n        let result = number;\n        while (number > 0xFFFFFFFF) {\n            number /= 0xFFFFFFFF;\n            result ^= number;\n        }\n        return MathUtil.smi(result);\n    }\n\n    // default hashCode calculation for a number sequence as mentioned by Joshua Bloch\n    static hashCode(...numbers) {\n        let result = 17;\n        for (const n of numbers) {\n            result = (result << 5) - result + MathUtil.hash(n);\n        }\n        return MathUtil.hash(result);\n    }\n}\n\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/MathUtil.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 401,
    "kind": "variable",
    "name": "MAX_SAFE_INTEGER",
    "memberof": "packages/core/src/MathUtil.js",
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MAX_SAFE_INTEGER",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/MathUtil.js",
    "importStyle": "{MAX_SAFE_INTEGER}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "variable",
    "name": "MIN_SAFE_INTEGER",
    "memberof": "packages/core/src/MathUtil.js",
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MIN_SAFE_INTEGER",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/MathUtil.js",
    "importStyle": "{MIN_SAFE_INTEGER}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "class",
    "name": "MathUtil",
    "memberof": "packages/core/src/MathUtil.js",
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/MathUtil.js",
    "importStyle": "{MathUtil}",
    "description": "Math helper with static function for integer operations",
    "lineNumber": 14,
    "interface": false
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "intDiv",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.intDiv",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "intMod",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.intMod",
    "access": "public",
    "description": "",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "roundDown",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.roundDown",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "r",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "floorDiv",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.floorDiv",
    "access": "public",
    "description": "",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "floorMod",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.floorMod",
    "access": "public",
    "description": "",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "safeAdd",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.safeAdd",
    "access": "public",
    "description": "",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "safeSubtract",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.safeSubtract",
    "access": "public",
    "description": "",
    "lineNumber": 102,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "safeMultiply",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.safeMultiply",
    "access": "public",
    "description": "",
    "lineNumber": 121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "x",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "y",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "parseInt",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.parseInt",
    "access": "public",
    "description": "",
    "lineNumber": 145,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "safeToInt",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.safeToInt",
    "access": "public",
    "description": "",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "verifyInt",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.verifyInt",
    "access": "public",
    "description": "",
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "safeZero",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.safeZero",
    "access": "public",
    "description": "convert -0 to 0 and int as string to a number ( '1' -> 1 )",
    "lineNumber": 185,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "compareNumbers",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.compareNumbers",
    "access": "public",
    "description": "Compares two Numbers.",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "the first value"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "the second value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the result"
    }
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "smi",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.smi",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [
      {
        "name": "int",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "hash",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.hash",
    "access": "public",
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "params": [
      {
        "name": "number",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/MathUtil.js~MathUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MathUtil.js~MathUtil.hashCode",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "params": [
      {
        "name": "numbers",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 420,
    "kind": "file",
    "name": "packages/core/src/Month.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, requireNonNull, requireInstance } from './assert';\nimport { MathUtil } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { DateTimeException, IllegalArgumentException, UnsupportedTemporalTypeException } from './errors';\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalQueries } from './temporal/TemporalQueries';\n\n/**\n * A month-of-year, such as 'July'.\n *\n * {@link Month} is representing the 12 months of the year -\n * January, February, March, April, May, June, July, August, September, October,\n * November and December.\n *\n * In addition to the textual name, each month-of-year has an `int` value.\n * The `int` value follows normal usage and the ISO-8601 standard,\n * from 1 (January) to 12 (December). It is recommended that applications use the static values defined by this class\n * rather than the `int` value to ensure code clarity.\n *\n * This class represents a common concept that is found in many calendar systems.\n * As such, this class may be used by any calendar system that has the month-of-year\n * concept defined exactly equivalent to the ISO-8601 calendar system.\n *\n * ### Static properties of Class {@link Month}\n *\n * Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n * Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n *\n */\nexport class Month extends TemporalAccessor {\n\n    /**\n     *\n     * @param {number} ordinal\n     * @param {string} name\n     * @private\n     */\n    constructor(value, name){\n        super();\n        this._value = MathUtil.safeToInt(value);\n        this._name = name;\n    }    \n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._value;\n    }\n    \n    /**\n     *\n     * @returns {number}\n     */\n    ordinal(){\n        return this._value - 1;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    name(){\n        return this._name;\n    }  \n\n    /**\n     * Gets the textual representation, such as 'Jan' or 'December'.\n     *\n     * This returns the textual name used to identify the month-of-year.\n     * The parameters control the length of the returned text and the locale.\n     *\n     * If no textual mapping is found then the numeric value (see {@link getValue}) is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    displayName(style, locale) {\n        // TODO:\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-of-year can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then\n     * this method returns true.\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-of-year, false if not\n     */\n    isSupported(field) {\n        if (null === field) {\n            return false;\n        }\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as an `int`.\n     *\n     * This queries this month for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an `int`\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-of-year as a `long`.\n     *\n     * This queries this month for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\n     * value of the month-of-year, from 1 to 12, will be returned.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {Number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months after this one.\n     *\n     * The calculation rolls around the end of the year from December to January.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    plus(months) {\n        const amount = MathUtil.intMod(months, 12) + 12; // + 12 to make sure negative arguments are positive, the total is \"corrected\" by the next % 12\n        let newMonthVal = MathUtil.intMod((this.value() + amount), 12);\n        /* December is 12, not 0, but 12 % 12 = 0 */\n        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n        return Month.of(newMonthVal);\n    }\n\n    /**\n     * Returns the month-of-year that is the specified number of months before this one.\n     *\n     * The calculation rolls around the start of the year from January to December.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, positive or negative\n     * @return {Month} the resulting month, not null\n     */\n    minus(months) {\n        return this.plus(-1 * MathUtil.intMod(months, 12));\n    }\n\n    /**\n     * Gets the length of this month in days.\n     *\n     * This takes a flag to determine whether to return the length for a leap year or not.\n     *\n     * February has 28 days in a standard year and 29 days in a leap year.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the length of this month in days, from 28 to 31\n     */\n    length(leapYear) {\n        switch (this) {\n            case Month.FEBRUARY:\n                return (leapYear ? 29 : 28);\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the minimum length of this month in days.\n     *\n     * February has a minimum length of 28 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the minimum length of this month in days, from 28 to 31\n     */\n    minLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the maximum length of this month in days.\n     *\n     * February has a maximum length of 29 days.\n     * April, June, September and November have 30 days.\n     * All other months have 31 days.\n     *\n     * @return {number} the maximum length of this month in days, from 29 to 31\n     */\n    maxLength() {\n        switch (this) {\n            case Month.FEBRUARY:\n                return 29;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    }\n\n    /**\n     * Gets the day-of-year corresponding to the first day of this month.\n     *\n     * This returns the day-of-year that this month begins on, using the leap\n     * year flag to determine the length of February.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the day of year corresponding to the first day of this month, from 1 to 336\n     */\n    firstDayOfYear(leapYear) {\n        const leap = leapYear ? 1 : 0;\n        switch (this) {\n            case Month.JANUARY:\n                return 1;\n            case Month.FEBRUARY:\n                return 32;\n            case Month.MARCH:\n                return 60 + leap;\n            case Month.APRIL:\n                return 91 + leap;\n            case Month.MAY:\n                return 121 + leap;\n            case Month.JUNE:\n                return 152 + leap;\n            case Month.JULY:\n                return 182 + leap;\n            case Month.AUGUST:\n                return 213 + leap;\n            case Month.SEPTEMBER:\n                return 244 + leap;\n            case Month.OCTOBER:\n                return 274 + leap;\n            case Month.NOVEMBER:\n                return 305 + leap;\n            case Month.DECEMBER:\n            default:\n                return 335 + leap;\n        }\n    }\n\n    /**\n     * Gets the month corresponding to the first month of this quarter.\n     *\n     * The year can be divided into four quarters.\n     * This method returns the first month of the quarter for the base month.\n     * January, February and March return January.\n     * April, May and June return April.\n     * July, August and September return July.\n     * October, November and December return October.\n     *\n     * @return {Month} the first month of the quarter corresponding to this month, not null\n     */\n    firstMonthOfQuarter() {\n        switch (this) {\n            case Month.JANUARY:\n            case Month.FEBRUARY:\n            case Month.MARCH:\n                return Month.JANUARY;\n            case Month.APRIL:\n            case Month.MAY:\n            case Month.JUNE:\n                return Month.APRIL;\n            case Month.JULY:\n            case Month.AUGUST:\n            case Month.SEPTEMBER:\n                return Month.JULY;\n            case Month.OCTOBER:\n            case Month.NOVEMBER:\n            case Month.DECEMBER:\n            default:\n                return Month.OCTOBER;\n        }\n    }\n\n    /**\n     * Queries this month-of-year using the specified query.\n     *\n     * This queries this month-of-year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        assert(query != null, 'query() parameter must not be null', DateTimeException);\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        }\n        return super.query(query);\n    }\n\n\n\n    /**\n     * toString implementation... in JDK this is inherited from the Enum class\n     *\n     * @return {String}\n     */\n    toString() {\n        switch (this) {\n            case Month.JANUARY:\n                return 'JANUARY';\n            case Month.FEBRUARY:\n                return 'FEBRUARY';\n            case Month.MARCH:\n                return 'MARCH';\n            case Month.APRIL:\n                return 'APRIL';\n            case Month.MAY:\n                return 'MAY';\n            case Month.JUNE:\n                return 'JUNE';\n            case Month.JULY:\n                return 'JULY';\n            case Month.AUGUST:\n                return 'AUGUST';\n            case Month.SEPTEMBER:\n                return 'SEPTEMBER';\n            case Month.OCTOBER:\n                return 'OCTOBER';\n            case Month.NOVEMBER:\n                return 'NOVEMBER';\n            case Month.DECEMBER:\n                return 'DECEMBER';\n            default:\n                return `unknown Month, value: ${this.value()}`;\n        }\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-of-year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month-of-year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#MONTH_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonth);\n     * </pre>\n     *\n     * For example, given a date in May, the following are output:\n     * <pre>\n     *   dateInMay.with(JANUARY);    // four months earlier\n     *   dateInMay.with(APRIL);      // one months earlier\n     *   dateInMay.with(MAY);        // same date\n     *   dateInMay.with(JUNE);       // one month later\n     *   dateInMay.with(DECEMBER);   // seven months later\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        /* we support only ISO for now\n            if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n                throw new DateTimeException('Adjustment only supported on ISO date-time');\n            }\n        */\n        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n    }\n    \n    /**\n     * Compares this Month to another Month.\n     *\n     * The comparison is based on the value of the Month.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Month} other  the other year to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */    \n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Month, 'other');\n        return this._value - other._value;\n    }    \n    \n    /**\n     *\n     * @returns {boolean}\n     */\n    equals(other){    \n        return this === other;\n    }\n\n    /**\n     *\n     * @param {string} name\n     * @returns {Month}\n     */\n    static valueOf(name) {\n        let ordinal = 0;\n        for(ordinal; ordinal < MONTHS.length; ordinal++){\n            if(MONTHS[ordinal].name() === name){\n                break;\n            }\n        }\n        return Month.of(ordinal+1);\n    }\n    \n\n    /**\n     * replacement for enum values\n     * @return {Month[]}\n     */\n    static values(){\n        return MONTHS.slice();\n    }\n\n    /**\n     *\n     * @param {number} month\n     * @return {Month} not null\n     **/\n    static of(month) {\n        if (month < 1 || month > 12) {\n            assert(false, `Invalid value for MonthOfYear: ${month}`, DateTimeException);\n        }\n        return MONTHS[month-1];\n    }\n\n    /**\n     * Obtains an instance of {@link Month} from a temporal object.\n     *\n     * This obtains a month based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link Month}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Month::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Month} the month-of-year, not null\n     * @throws DateTimeException if unable to convert to a {@link Month}\n     */\n    static from(temporal) {\n        if (temporal instanceof Month) {\n            return temporal;\n        }\n        try {\n            /* only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain Month from TemporalAccessor: ${ \n                temporal} of type ${temporal && temporal.constructor != null ? temporal.constructor.name : ''}`, ex);\n        }\n    }\n}\n\nlet MONTHS;\n\nexport function _init() {\n    Month.JANUARY = new Month(1, 'JANUARY');\n    Month.FEBRUARY = new Month(2, 'FEBRUARY');\n    Month.MARCH = new Month(3, 'MARCH');\n    Month.APRIL = new Month(4, 'APRIL');\n    Month.MAY = new Month(5, 'MAY');\n    Month.JUNE = new Month(6, 'JUNE');\n    Month.JULY = new Month(7, 'JULY');\n    Month.AUGUST = new Month(8, 'AUGUST');\n    Month.SEPTEMBER = new Month(9, 'SEPTEMBER');\n    Month.OCTOBER = new Month(10, 'OCTOBER');\n    Month.NOVEMBER = new Month(11, 'NOVEMBER');\n    Month.DECEMBER = new Month(12, 'DECEMBER');\n\n    MONTHS = [\n        Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\n        Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER\n    ];\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Month.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 421,
    "kind": "class",
    "name": "Month",
    "memberof": "packages/core/src/Month.js",
    "static": true,
    "longname": "packages/core/src/Month.js~Month",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Month.js",
    "importStyle": "{Month}",
    "description": "A month-of-year, such as 'July'.\n\n{@link Month} is representing the 12 months of the year -\nJanuary, February, March, April, May, June, July, August, September, October,\nNovember and December.\n\nIn addition to the textual name, each month-of-year has an `int` value.\nThe `int` value follows normal usage and the ISO-8601 standard,\nfrom 1 (January) to 12 (December). It is recommended that applications use the static values defined by this class\nrather than the `int` value to ensure code clarity.\n\nThis class represents a common concept that is found in many calendar systems.\nAs such, this class may be used by any calendar system that has the month-of-year\nconcept defined exactly equivalent to the ISO-8601 calendar system.\n\n### Static properties of Class {@link Month}\n\nMonth.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,\nMonth.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER",
    "lineNumber": 39,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor"
    ]
  },
  {
    "__docId__": 422,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ordinal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 423,
    "kind": "member",
    "name": "_value",
    "memberof": "packages/core/src/Month.js~Month",
    "static": false,
    "longname": "packages/core/src/Month.js~Month#_value",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/Month.js~Month",
    "static": false,
    "longname": "packages/core/src/Month.js~Month#_name",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "value",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#value",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "gets the value"
    },
    "params": []
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "ordinal",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#ordinal",
    "access": "public",
    "description": "",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "name",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#name",
    "access": "public",
    "description": "",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#displayName",
    "access": "public",
    "description": "Gets the textual representation, such as 'Jan' or 'December'.\n\nThis returns the textual name used to identify the month-of-year.\nThe parameters control the length of the returned text and the locale.\n\nIf no textual mapping is found then the numeric value (see {@link getValue}) is returned.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "the length of the text required, not null"
      },
      {
        "nullable": null,
        "types": [
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the locale to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the text value of the day-of-week, not null"
    }
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this month-of-year can be queried for the specified field.\nIf false, then calling the range (see {@link range}) and\nget (see {@link get}) methods will throw an exception.\n\nIf the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then\nthis method returns true.\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this month-of-year, false if not"
    }
  },
  {
    "__docId__": 430,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#get",
    "access": "public",
    "description": "Gets the value of the specified field from this month-of-year as an `int`.\n\nThis queries this month for the value of the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\nvalue of the month-of-year, from 1 to 12, will be returned.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "the value for the field, within the valid range of values"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained or\n        the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the field is not supported or\n        the range of values exceeds an `int`"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this month-of-year as a `long`.\n\nThis queries this month for the value of the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) then the\nvalue of the month-of-year, from 1 to 12, will be returned.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the field is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 432,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#plus",
    "access": "public",
    "description": "Returns the month-of-year that is the specified number of months after this one.\n\nThe calculation rolls around the end of the year from December to January.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the resulting month, not null"
    }
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#minus",
    "access": "public",
    "description": "Returns the month-of-year that is the specified number of months before this one.\n\nThe calculation rolls around the start of the year from January to December.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the resulting month, not null"
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "length",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#length",
    "access": "public",
    "description": "Gets the length of this month in days.\n\nThis takes a flag to determine whether to return the length for a leap year or not.\n\nFebruary has 28 days in a standard year and 29 days in a leap year.\nApril, June, September and November have 30 days.\nAll other months have 31 days.",
    "lineNumber": 233,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "leapYear",
        "description": "true if the length is required for a leap year"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of this month in days, from 28 to 31"
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "minLength",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#minLength",
    "access": "public",
    "description": "Gets the minimum length of this month in days.\n\nFebruary has a minimum length of 28 days.\nApril, June, September and November have 30 days.\nAll other months have 31 days.",
    "lineNumber": 256,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minimum length of this month in days, from 28 to 31"
    },
    "params": []
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "maxLength",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#maxLength",
    "access": "public",
    "description": "Gets the maximum length of this month in days.\n\nFebruary has a maximum length of 29 days.\nApril, June, September and November have 30 days.\nAll other months have 31 days.",
    "lineNumber": 279,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the maximum length of this month in days, from 29 to 31"
    },
    "params": []
  },
  {
    "__docId__": 437,
    "kind": "method",
    "name": "firstDayOfYear",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#firstDayOfYear",
    "access": "public",
    "description": "Gets the day-of-year corresponding to the first day of this month.\n\nThis returns the day-of-year that this month begins on, using the leap\nyear flag to determine the length of February.",
    "lineNumber": 302,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "leapYear",
        "description": "true if the length is required for a leap year"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day of year corresponding to the first day of this month, from 1 to 336"
    }
  },
  {
    "__docId__": 438,
    "kind": "method",
    "name": "firstMonthOfQuarter",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#firstMonthOfQuarter",
    "access": "public",
    "description": "Gets the month corresponding to the first month of this quarter.\n\nThe year can be divided into four quarters.\nThis method returns the first month of the quarter for the base month.\nJanuary, February and March return January.\nApril, May and June return April.\nJuly, August and September return July.\nOctober, November and December return October.",
    "lineNumber": 345,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the first month of the quarter corresponding to this month, not null"
    },
    "params": []
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#query",
    "access": "public",
    "description": "Queries this month-of-year using the specified query.\n\nThis queries this month-of-year using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 384,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#toString",
    "access": "public",
    "description": "toString implementation... in JDK this is inherited from the Enum class",
    "lineNumber": 401,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 438,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 442,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this month-of-year.\n\nThis returns a temporal object of the same observable type as the input\nwith the month-of-year changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField#MONTH_OF_YEAR} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisMonth.adjustInto(temporal);\n  temporal = temporal.with(thisMonth);\n</pre>\n\nFor example, given a date in May, the following are output:\n<pre>\n  dateInMay.with(JANUARY);    // four months earlier\n  dateInMay.with(APRIL);      // one months earlier\n  dateInMay.with(MAY);        // same date\n  dateInMay.with(JUNE);       // one month later\n  dateInMay.with(DECEMBER);   // seven months later\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 477,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#compareTo",
    "access": "public",
    "description": "Compares this Month to another Month.\n\nThe comparison is based on the value of the Month.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 495,
    "params": [
      {
        "nullable": null,
        "types": [
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Month.js~Month#equals",
    "access": "public",
    "description": "",
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "valueOf",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Month.js~Month.valueOf",
    "access": "public",
    "description": "",
    "lineNumber": 514,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Month}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "values",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Month.js~Month.values",
    "access": "public",
    "description": "replacement for enum values",
    "lineNumber": 529,
    "return": {
      "nullable": null,
      "types": [
        "Month[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Month.js~Month.of",
    "access": "public",
    "description": "",
    "lineNumber": 538,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "not null"
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/Month.js~Month",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Month.js~Month.from",
    "access": "public",
    "description": "Obtains an instance of {@link Month} from a temporal object.\n\nThis obtains a month based on the specified temporal.\nA {@link TemporalAccessor} represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of {@link Month}.\n\nThe conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) field.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link Month::from}.",
    "lineNumber": 563,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link Month}"
      }
    ]
  },
  {
    "__docId__": 449,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/Month.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Month.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Month.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 582,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 450,
    "kind": "file",
    "name": "packages/core/src/MonthDay.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\nimport { MathUtil } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { Clock } from './Clock';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { DateTimeFormatterBuilder } from './format/DateTimeFormatterBuilder';\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { LocalDate } from './LocalDate';\nimport { Month } from './Month';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalQuery, createTemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { ValueRange } from './temporal/ValueRange';\nimport { Year } from './Year';\nimport { ZoneId } from './ZoneId';\n\n/**\n * A month-day in the ISO-8601 calendar system, such as `--12-03`.\n *\n * {@link MonthDay} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a month and day, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a year, time or time-zone.\n * For example, the value \"December 3rd\" can be stored in a {@link MonthDay}.\n *\n * Since a {@link MonthDay} does not possess a year, the leap day of\n * February 29th is considered valid.\n *\n * This class implements {@link TemporalAccessor} rather than {@link Temporal}.\n * This is because it is not possible to define whether February 29th is valid or not\n * without external information, preventing the implementation of plus/minus.\n * Related to this, {@link MonthDay} only provides access to query and set the fields\n * {@link MONTH_OF_YEAR} and {@link DAY_OF_MONTH}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class MonthDay extends TemporalAccessor {\n    /**\n     * function overloading for {@link MonthDay.now}\n     *\n     * if called with 0 argument {@link MonthDay.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link MonthDay.nowZoneId} is executed,\n     *\n     * otherwise {@link MonthDay.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {MonthDay}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return MonthDay.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return MonthDay.nowZoneId(zoneIdOrClock);\n        } else {\n            return MonthDay.nowClock(zoneIdOrClock);\n        }\n    }\n    /**\n     * Obtains the current month-day from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current month-day.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {MonthDay} the current month-day using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return this.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current month-day from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current month-day.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {MonthDay} the current month-day using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        return this.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current month-day from the specified clock.\n     *\n     * This will query the specified clock to obtain the current month-day.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection (see {@link Clock}).\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {MonthDay} the current month-day, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        const now = LocalDate.now(clock);  // called once\n        return MonthDay.of(now.month(), now.dayOfMonth());\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link MonthDay.ofMonthNumber} is executed,\n     *\n     * otherwise {@link MonthDay.ofNumberNumber} is executed\n     *\n     * @param {!(Month|number)} monthOrNumber\n     * @param {?number} number\n     * @returns {MonthDay}\n     */\n    static of(monthOrNumber, number) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return MonthDay.ofMonthNumber(monthOrNumber, number);\n        } else {\n            return MonthDay.ofNumberNumber(monthOrNumber, number);\n        }\n    }\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for February, day 29 is valid.\n     *\n     * For example, passing in April and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {Month} month  the month-of-year to represent, not null\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofMonthNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > month.maxLength()) {\n            throw new DateTimeException(`Illegal value for DayOfMonth field, value ${dayOfMonth \n            } is not valid for month ${month.toString()}`);\n        }\n        return new MonthDay(month.value(), dayOfMonth);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay}.\n     *\n     * The day-of-month must be valid for the month within a leap year.\n     * Hence, for month 2 (February), day 29 is valid.\n     *\n     * For example, passing in month 4 (April) and day 31 will throw an exception, as\n     * there can never be April 31st in any year. By contrast, passing in\n     * February 29th is permitted, as that month-day can sometimes be valid.\n     *\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth  the day-of-month to represent, from 1 to 31\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if the value of any field is out of range\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    static ofNumberNumber(month, dayOfMonth) {\n        requireNonNull(month, 'month');\n        requireNonNull(dayOfMonth, 'dayOfMonth');\n        return MonthDay.of(Month.of(month), dayOfMonth);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link MonthDay} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link MonthDay}.\n     *\n     * The conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) and\n     * DAY_OF_MONTH (see {@link ChronoField#DAY_OF_MONTH}) fields.\n     * The extraction is only permitted if the date-time has an ISO chronology.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link MonthDay::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {MonthDay} the month-day, not null\n     * @throws DateTimeException if unable to convert to a {@link MonthDay}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof MonthDay) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain MonthDay from TemporalAccessor: ${ \n                temporal}, type ${temporal && temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link MonthDay.parse}\n     *\n     * if called with 1 argument, then {@link MonthDay.parseString} is executed,\n     *\n     * otherwise {@link MonthDay.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {MonthDay}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return MonthDay.parseString(text);\n        } else {\n            return MonthDay.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string such as `--12-03`.\n     *\n     * The string must represent a valid month-day.\n     * The format is `--MM-dd`.\n     *\n     * @param {String} text  the text to parse such as \"--12-03\", not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return MonthDay.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link MonthDay} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a month-day.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {MonthDay} the parsed month-day, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, MonthDay.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} month  the month-of-year to represent, validated from 1 to 12\n     * @param {number} dayOfMonth  the day-of-month to represent, validated from 1 to 29-31\n     * @private\n     */\n    constructor(month, dayOfMonth) {\n        super();\n        this._month = MathUtil.safeToInt(month);\n        this._day = MathUtil.safeToInt(dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the int value (see {@link Month#getValue}).\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this month-day can be queried for the specified field.\n     * If false, then calling the range (see {@link range}) and\n     * get (see {@link get}) methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link YEAR}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this month-day, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This month-day is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return field.range();\n        } else if (field === ChronoField.DAY_OF_MONTH) {\n            return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as an `int`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this month-day as a `long`.\n     *\n     * This queries this month-day for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this month-day.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                // alignedDOW and alignedWOM not supported because they cannot be set in with()\n                case ChronoField.DAY_OF_MONTH: return this._day;\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is valid for this month-day.\n     *\n     * This method checks whether this month and day and the input year form\n     * a valid date. This can only return false for February 29th.\n     *\n     * @param {number} year  the year to validate, an out of range value returns false\n     * @return {boolean} true if the year is valid for this month-day\n     * @see Year#isValidMonthDay(MonthDay)\n     */\n    isValidYear(year) {\n        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n     *\n     * This returns a month-day with the specified month.\n     * If the day-of-month is invalid for the specified month, the day will\n     * be adjusted to the last valid day-of-month.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned month-day, from 1 (January) to 12 (December)\n     * @return {MonthDay} based on this month-day with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this.with(Month.of(month));\n    }\n\n    /**\n    * Returns a copy of this {@link MonthDay} with the month-of-year altered.\n    *\n    * This returns a month-day with the specified month.\n    * If the day-of-month is invalid for the specified month, the day will\n    * be adjusted to the last valid day-of-month.\n    *\n    * This instance is immutable and unaffected by this method call.\n    *\n    * @param {Month} month  the month-of-year to set in the returned month-day, not null\n    * @return {MonthDay} based on this month-day with the requested month, not null\n    */\n    with(month) {\n        requireNonNull(month, 'month');\n        if (month.value() === this._month) {\n            return this;\n        }\n        const day = Math.min(this._day, month.maxLength());\n        return new MonthDay(month.value(), day);\n    }\n\n    /**\n     * Returns a copy of this {@link MonthDay} with the day-of-month altered.\n     *\n     * This returns a month-day with the specified day-of-month.\n     * If the day-of-month is invalid for the month, an exception is thrown.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth  the day-of-month to set in the return month-day, from 1 to 31\n     * @return {MonthDay} based on this month-day with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month\n     */\n    withDayOfMonth(dayOfMonth) {\n        if (dayOfMonth === this._day) {\n            return this;\n        }\n        return MonthDay.of(this._month, dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this month-day using the specified query.\n     *\n     * This queries this month-day using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this month-day.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the month and day-of-month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * twice, passing {@link ChronoField#MONTH_OF_YEAR} and\n     * {@link ChronoField#DAY_OF_MONTH} as the fields.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisMonthDay.adjustInto(temporal);\n     *   temporal = temporal.with(thisMonthDay);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this month-day with a year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this month-day and the specified year.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to use, from MIN_YEAR to MAX_YEAR\n     * @return {LocalDate} the local date formed from this month-day and the specified year, not null\n     * @throws DateTimeException if the year is outside the valid range of years\n     */\n    atYear(year) {\n        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this month-day to another month-day.\n     *\n     * The comparison is based first on value of the month, then on the value of the day.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        let cmp = (this._month - other.monthValue());\n        if (cmp === 0) {\n            cmp = (this._day - other.dayOfMonth());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this month-day after the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this is after the specified month-day\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this month-day before the specified month-day.\n     *\n     * @param {MonthDay} other  the other month-day to compare to, not null\n     * @return {boolean} true if this point is before the specified month-day\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, MonthDay, 'other');\n        return this.compareTo(other) < 0;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this month-day is equal to another month-day.\n     *\n     * The comparison is based on the time-line position of the month-day within a year.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other month-day\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof MonthDay) {\n            const other = obj;\n            return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n        }\n        return false;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this month-day as a string, such as `--12-03`.\n     *\n     * The output will be in the format `--MM-dd`:\n     *\n     * @return {String} a string representation of this month-day, not null\n     */\n    toString() {\n        return `--${\n            this._month < 10 ? '0' : ''}${this._month\n        }${this._day < 10 ? '-0' : '-'}${this._day}`;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this month-day as a string using the formatter.\n     *\n     * This month-day will be passed to the formatter\n     * print method (see {@link DateTimeFormatter#format}).\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted month-day string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n    PARSER = new DateTimeFormatterBuilder()\n        .appendLiteral('--')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter();\n\n    MonthDay.FROM = createTemporalQuery('MonthDay.FROM', (temporal) => {\n        return MonthDay.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/MonthDay.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 451,
    "kind": "class",
    "name": "MonthDay",
    "memberof": "packages/core/src/MonthDay.js",
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/MonthDay.js",
    "importStyle": "{MonthDay}",
    "description": "A month-day in the ISO-8601 calendar system, such as `--12-03`.\n\n{@link MonthDay} is an immutable date-time object that represents the combination\nof a year and month. Any field that can be derived from a month and day, such as\nquarter-of-year, can be obtained.\n\nThis class does not store or represent a year, time or time-zone.\nFor example, the value \"December 3rd\" can be stored in a {@link MonthDay}.\n\nSince a {@link MonthDay} does not possess a year, the leap day of\nFebruary 29th is considered valid.\n\nThis class implements {@link TemporalAccessor} rather than {@link Temporal}.\nThis is because it is not possible to define whether February 29th is valid or not\nwithout external information, preventing the implementation of plus/minus.\nRelated to this, {@link MonthDay} only provides access to query and set the fields\n{@link MONTH_OF_YEAR} and {@link DAY_OF_MONTH}.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\n### Specification for implementors\n\nThis class is immutable and thread-safe.",
    "lineNumber": 54,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor"
    ]
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.now",
    "access": "public",
    "description": "function overloading for {@link MonthDay.now}\n\nif called with 0 argument {@link MonthDay.now0} is executed,\n\nif called with 1 argument and first argument is an instance of ZoneId, then {@link MonthDay.nowZoneId} is executed,\n\notherwise {@link MonthDay.nowClock} is executed",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{MonthDay}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "now0",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.now0",
    "access": "public",
    "description": "Obtains the current month-day from the system clock in the default time-zone.\n\nThis will query the system clock (see {@link Clock#systemDefaultZone}) in the default\ntime-zone to obtain the current month-day.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 87,
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the current month-day using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "nowZoneId",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.nowZoneId",
    "access": "public",
    "description": "Obtains the current month-day from the system clock in the specified time-zone.\n\nThis will query the system clock (see {@link Clock#system}) to obtain the current month-day.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the current month-day using the system clock, not null"
    }
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "nowClock",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.nowClock",
    "access": "public",
    "description": "Obtains the current month-day from the specified clock.\n\nThis will query the specified clock to obtain the current month-day.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection (see {@link Clock}).",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the current month-day, not null"
    }
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.of",
    "access": "public",
    "description": "function overloading for {@link MonthDay.of}\n\nif called with 2 argument and first argument is an instance of Month, then {@link MonthDay.ofMonthNumber} is executed,\n\notherwise {@link MonthDay.ofNumberNumber} is executed",
    "lineNumber": 135,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{MonthDay}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "Month",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthOrNumber",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "number",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "ofMonthNumber",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.ofMonthNumber",
    "access": "public",
    "description": "Obtains an instance of {@link MonthDay}.\n\nThe day-of-month must be valid for the month within a leap year.\nHence, for February, day 29 is valid.\n\nFor example, passing in April and day 31 will throw an exception, as\nthere can never be April 31st in any year. By contrast, passing in\nFebruary 29th is permitted, as that month-day can sometimes be valid.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the month-day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value of any field is out of range"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month is invalid for the month"
      }
    ]
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "ofNumberNumber",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.ofNumberNumber",
    "access": "public",
    "description": "Obtains an instance of {@link MonthDay}.\n\nThe day-of-month must be valid for the month within a leap year.\nHence, for month 2 (February), day 29 is valid.\n\nFor example, passing in month 4 (April) and day 31 will throw an exception, as\nthere can never be April 31st in any year. By contrast, passing in\nFebruary 29th is permitted, as that month-day can sometimes be valid.",
    "lineNumber": 184,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, from 1 (January) to 12 (December)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the month-day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value of any field is out of range"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month is invalid for the month"
      }
    ]
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.from",
    "access": "public",
    "description": "Obtains an instance of {@link MonthDay} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link MonthDay}.\n\nThe conversion extracts the MONTH_OF_YEAR (see {@link ChronoField#MONTH_OF_YEAR}) and\nDAY_OF_MONTH (see {@link ChronoField#DAY_OF_MONTH}) fields.\nThe extraction is only permitted if the date-time has an ISO chronology.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link MonthDay::from}.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the month-day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link MonthDay}"
      }
    ]
  },
  {
    "__docId__": 460,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.parse",
    "access": "public",
    "description": "function overloading for {@link MonthDay.parse}\n\nif called with 1 argument, then {@link MonthDay.parseString} is executed,\n\notherwise {@link MonthDay.parseStringFormatter} is executed",
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{MonthDay}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 461,
    "kind": "method",
    "name": "parseString",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.parseString",
    "access": "public",
    "description": "Obtains an instance of {@link MonthDay} from a text string such as `--12-03`.\n\nThe string must represent a valid month-day.\nThe format is `--MM-dd`.",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse such as \"--12-03\", not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the parsed month-day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "parseStringFormatter",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~MonthDay.parseStringFormatter",
    "access": "public",
    "description": "Obtains an instance of {@link MonthDay} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a month-day.",
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the parsed month-day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 463,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#constructor",
    "access": "private",
    "description": "Constructor, previously validated.",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, validated from 1 to 12"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, validated from 1 to 29-31"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 464,
    "kind": "member",
    "name": "_month",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#_month",
    "access": "private",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 465,
    "kind": "member",
    "name": "_day",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#_day",
    "access": "private",
    "description": null,
    "lineNumber": 286,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#monthValue",
    "access": "public",
    "description": "Gets the month-of-year field from 1 to 12.\n\nThis method returns the month as an `int` from 1 to 12.\nApplication code is frequently clearer if the enum {@link Month}\nis used by calling {@link getMonth}.",
    "see": [
      "#month()"
    ],
    "lineNumber": 300,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 467,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#month",
    "access": "public",
    "description": "Gets the month-of-year field using the {@link Month} enum.\n\nThis method returns the enum {@link Month} for the month.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value then the enum\nprovides the int value (see {@link Month#getValue}).",
    "see": [
      "#getMonthValue()"
    ],
    "lineNumber": 315,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 468,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#dayOfMonth",
    "access": "public",
    "description": "Gets the day-of-month field.\n\nThis method returns the primitive `int` value for the day-of-month.",
    "lineNumber": 326,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 469,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this month-day can be queried for the specified field.\nIf false, then calling the range (see {@link range}) and\nget (see {@link get}) methods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nThe supported fields are:\n\n* {@link MONTH_OF_YEAR}\n* {@link YEAR}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 356,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this month-day, false if not"
    }
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis month-day is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 385,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#get",
    "access": "public",
    "description": "Gets the value of the specified field from this month-day as an `int`.\n\nThis queries this month-day for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this month-day.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 417,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this month-day as a `long`.\n\nThis queries this month-day for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this month-day.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 443,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "isValidYear",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#isValidYear",
    "access": "public",
    "description": "Checks if the year is valid for this month-day.\n\nThis method checks whether this month and day and the input year form\na valid date. This can only return false for February 29th.",
    "see": [
      "Year#isValidMonthDay(MonthDay)"
    ],
    "lineNumber": 466,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to validate, an out of range value returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is valid for this month-day"
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#withMonth",
    "access": "public",
    "description": "Returns a copy of this {@link MonthDay} with the month-of-year altered.\n\nThis returns a month-day with the specified month.\nIf the day-of-month is invalid for the specified month, the day will\nbe adjusted to the last valid day-of-month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 484,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the returned month-day, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "based on this month-day with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "with",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#with",
    "access": "public",
    "description": "Returns a copy of this {@link MonthDay} with the month-of-year altered.\n\nThis returns a month-day with the specified month.\nIf the day-of-month is invalid for the specified month, the day will\nbe adjusted to the last valid day-of-month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 500,
    "params": [
      {
        "nullable": null,
        "types": [
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the returned month-day, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "based on this month-day with the requested month, not null"
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#withDayOfMonth",
    "access": "public",
    "description": "Returns a copy of this {@link MonthDay} with the day-of-month altered.\n\nThis returns a month-day with the specified day-of-month.\nIf the day-of-month is invalid for the month, an exception is thrown.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 522,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to set in the return month-day, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "based on this month-day with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month value is invalid"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month is invalid for the month"
      }
    ]
  },
  {
    "__docId__": 477,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#query",
    "access": "public",
    "description": "Queries this month-day using the specified query.\n\nThis queries this month-day using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 547,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 478,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this month-day.\n\nThis returns a temporal object of the same observable type as the input\nwith the month and day-of-month changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\ntwice, passing {@link ChronoField#MONTH_OF_YEAR} and\n{@link ChronoField#DAY_OF_MONTH} as the fields.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisMonthDay.adjustInto(temporal);\n  temporal = temporal.with(thisMonthDay);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 583,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "atYear",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#atYear",
    "access": "public",
    "description": "Combines this month-day with a year to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this month-day and the specified year.\n\nA month-day of February 29th will be adjusted to February 28th in the resulting\ndate if the year is not a leap year.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 608,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to use, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date formed from this month-day and the specified year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the year is outside the valid range of years"
      }
    ]
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#compareTo",
    "access": "public",
    "description": "Compares this month-day to another month-day.\n\nThe comparison is based first on value of the month, then on the value of the day.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 621,
    "params": [
      {
        "nullable": null,
        "types": [
          "MonthDay"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other month-day to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#isAfter",
    "access": "public",
    "description": "Is this month-day after the specified month-day.",
    "lineNumber": 637,
    "params": [
      {
        "nullable": null,
        "types": [
          "MonthDay"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other month-day to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified month-day"
    }
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#isBefore",
    "access": "public",
    "description": "Is this month-day before the specified month-day.",
    "lineNumber": 649,
    "params": [
      {
        "nullable": null,
        "types": [
          "MonthDay"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other month-day to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified month-day"
    }
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#equals",
    "access": "public",
    "description": "Checks if this month-day is equal to another month-day.\n\nThe comparison is based on the time-line position of the month-day within a year.",
    "lineNumber": 665,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other month-day"
    }
  },
  {
    "__docId__": 484,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#toString",
    "access": "public",
    "description": "Outputs this month-day as a string, such as `--12-03`.\n\nThe output will be in the format `--MM-dd`:",
    "lineNumber": 683,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "a string representation of this month-day, not null"
    },
    "params": []
  },
  {
    "__docId__": 485,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 695,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 486,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/MonthDay.js~MonthDay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/MonthDay.js~MonthDay#format",
    "access": "public",
    "description": "Outputs this month-day as a string using the formatter.\n\nThis month-day will be passed to the formatter\nprint method (see {@link DateTimeFormatter#format}).",
    "lineNumber": 709,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted month-day string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 487,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/MonthDay.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/MonthDay.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/MonthDay.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 719,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 488,
    "kind": "file",
    "name": "packages/core/src/OffsetDateTime.js",
    "content": "/**\n * @copyright (c) 2016-present, Philipp Thürwächter & Pattrick Hüper  & js-joda contributors\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { Temporal } from './temporal/Temporal';\nimport { Clock } from './Clock';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { Instant } from './Instant';\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { LocalDateTime } from './LocalDateTime';\nimport { LocalDate } from './LocalDate';\nimport { LocalTime } from './LocalTime';\nimport { MathUtil } from './MathUtil';\nimport { OffsetTime } from './OffsetTime';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\nimport { DateTimeException, IllegalArgumentException } from './errors';\n\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { requireInstance, requireNonNull } from './assert';\n\n/**\n * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as 2007-12-23T10:15:30+01:00.\n */\nexport class OffsetDateTime extends Temporal {\n    /**\n     * @param {TemporaroAccessor} temporal\n     * @return {OffsetDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof OffsetDateTime) {\n            return temporal;\n        }\n        try {\n            const offset = ZoneOffset.from(temporal);\n            try {\n                const ldt = LocalDateTime.from(temporal);\n                return OffsetDateTime.of(ldt, offset);\n            } catch (_) {\n                const instant = Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain OffsetDateTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    /**\n     * @param {Clock|ZoneId|null} clockOrZone\n     * @return {OffsetDateTime}\n     */\n    static now(clockOrZone) {\n        if (arguments.length === 0) {\n            return OffsetDateTime.now(Clock.systemDefaultZone());\n        } else {\n            requireNonNull(clockOrZone, 'clockOrZone');\n            if (clockOrZone instanceof ZoneId) {\n                return OffsetDateTime.now(Clock.system(clockOrZone));\n            } else if (clockOrZone instanceof Clock) {\n                const now = clockOrZone.instant(); // called once\n                return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));\n            } else {\n                throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');\n            }\n        }\n    }\n\n    /**\n     * @return {OffsetDateTime}\n     */\n    static of() {\n        if (arguments.length <= 2) {\n            return OffsetDateTime.ofDateTime.apply(this, arguments);\n        } else if (arguments.length === 3) {\n            return OffsetDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return OffsetDateTime.ofNumbers.apply(this, arguments);\n        }\n    }\n\n    static ofDateTime(dateTime, offset) {\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    static ofDateAndTime(date, time, offset) {\n        const dt = LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    static ofNumbers(year, month, dayOfMonth, hour=0, minute=0, second=0, nanoOfSecond=0, offset) {\n        const dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    }\n\n    /**\n     * @param {Instant} instant\n     * @param {ZoneId} zone\n     * @return {OffsetDateTime}\n     */\n    static ofInstant(instant,  zone){\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        const rules = zone.rules();\n        const offset = rules.offset(instant);\n        const ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    }\n\n    /**\n     * @param {string} text\n     * @param {DateTimeFormatter|undefined} formatter\n     * @return {OffsetTime}\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME){\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, OffsetDateTime.FROM);\n    }\n\n    // TODO: Need java.util.Comparater interface.\n    // static timeLineOrder() {\n    //\n    // }\n\n    //-----------------------------------------------------------------------\n\n\n    /**\n     * @param {LocalDateTime} dateTime\n     * @param {ZoneOffset} offset\n     * @private\n     */\n    constructor(dateTime, offset) {\n        super();\n        requireNonNull(dateTime, 'dateTime');\n        requireInstance(dateTime, LocalDateTime, 'dateTime');\n        requireNonNull(offset, 'offset');\n        requireInstance(offset, ZoneOffset, 'offset');\n        this._dateTime = dateTime;\n        this._offset = offset;\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @return {Temporal}\n     */\n    adjustInto(temporal) {\n        return temporal\n            .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay())\n            .with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay())\n            .with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n    }\n\n    until(endExclusive, unit) {\n        let end = OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withOffsetSameInstant(this._offset);\n            return this._dateTime.until(end._dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * @param {ZoneId} zone\n     * @return {ZonedDateTime}\n     */\n    atZoneSameInstant(zone) {\n        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);\n    }\n\n    /**\n     * @param {ZoneId} zone\n     * @return {ZonedDateTime}\n     */\n    atZoneSimilarLocal(zone) {\n        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    }\n\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    get(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: throw new DateTimeException(`Field too large for an int: ${field}`);\n                case ChronoField.OFFSET_SECONDS: return this.offset().totalSeconds();\n            }\n            return this._dateTime.get(field);\n        }\n        return super.get(field);\n    }\n\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS: return this.offset().totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * @return {ZoneOffset}\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._dateTime.year();\n    }\n\n    /**\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._dateTime.monthValue();\n    }\n\n    /**\n     * @return {{number} }the month-of-year, not null\n     * @see #monthValue()\n     */\n    month() {\n        return this._dateTime.month();\n    }\n\n    /**\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    }\n\n    /**\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._dateTime.dayOfYear();\n    }\n\n    /**\n     * @return {number} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    }\n\n    /**\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._dateTime.hour();\n    }\n\n    /**\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._dateTime.minute();\n    }\n\n    /**\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._dateTime.second();\n    }\n\n    /**\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._dateTime.nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @return {LocalDateTime}the local date-time part of this date-time, not null\n     */\n    toLocalDateTime() {\n        return this._dateTime;\n    }\n\n    /**\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._dateTime.toLocalDate();\n    }\n\n    /**\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._dateTime.toLocalTime();\n    }\n\n    /**\n     * @return {OffsetTime} an OffsetTime representing the time and offset, not null\n     */\n    toOffsetTime() {\n        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);\n    }\n\n    /**\n     * @return {ZonedDateTime}a zoned date-time representing the same local date-time and offset, not null\n     */\n    toZonedDateTime() {\n        return ZonedDateTime.of(this._dateTime, this._offset);\n    }\n\n    /**\n     * @return {Instant} an {@code Instant} representing the same instant, not null\n     */\n    toInstant() {\n        return this._dateTime.toInstant(this._offset);\n    }\n\n    /**\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond() {\n        return this._dateTime.toEpochSecond(this._offset);\n    }\n\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster);\n        // optimizations\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);\n        } else if (adjuster instanceof Instant) {\n            return OffsetDateTime.ofInstant(adjuster, this._offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._withDateTimeOffset(this._dateTime, adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return adjuster;\n        }\n        return adjuster.adjustInto(this);\n    }\n\n    _withField(field, newValue) {\n        requireNonNull(field);\n        if (field instanceof ChronoField) {\n            const f = field;\n            switch (f) {\n                case ChronoField.INSTANT_SECONDS: return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);\n                case ChronoField.OFFSET_SECONDS: {\n                    return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                }\n            }\n            return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    _withDateTimeOffset(dateTime, offset) {\n        if (this._dateTime === dateTime && this._offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    }\n\n    /**\n     * @param {int} year\n     * @return {OffsetDateTime}\n     */\n    withYear(year) {\n        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);\n    }\n\n    /**\n     * @param {int} month\n     * @return {OffsetDateTime}\n     */\n    withMonth(month) {\n        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);\n    }\n\n    /**\n     * @param {int} dayOfMonth\n     * @return {OffsetDateTime}\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);\n    }\n\n    /**\n     * @param {int} dayOfYear\n     * @return {OffsetDateTime}\n     */\n    withDayOfYear(dayOfYear) {\n        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);\n    }\n\n    /**\n     * @param {int} hour\n     * @return {OffsetDateTime}\n     */\n    withHour(hour) {\n        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);\n    }\n\n    /**\n     * @param {int} minute\n     * @return {OffsetDateTime}\n     */\n    withMinute(minute) {\n        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);\n    }\n\n    /**\n     * @param {int} second\n     * @return {OffsetDateTime}\n     */\n    withSecond(second) {\n        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);\n    }\n\n    /**\n     * @param {int} nanoOfSecond\n     * @return {OffsetDateTime}\n     */\n    withNano(nanoOfSecond) {\n        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);\n    }\n\n    /**\n     * @param {ZoneOffset} offset\n     * @return {OffsetDateTime}\n     */\n    withOffsetSameLocal(offset) {\n        requireNonNull(offset, 'offset');\n        return this._withDateTimeOffset(this._dateTime, offset);\n    }\n\n    /**\n     * @param {ZoneOffset} offset\n     * @return {OffsetDateTime}\n     */\n    withOffsetSameInstant(offset) {\n        requireNonNull(offset, 'offset');\n        if (offset.equals(this._offset)) {\n            return this;\n        }\n        const difference = offset.totalSeconds() - this._offset.totalSeconds();\n        const adjusted = this._dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    }\n\n    /**\n     * @param {TemporalUnit} unit\n     * @return {OffsetDateTime}\n     */\n    truncatedTo(unit) {\n        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);\n    }\n\n    _plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        return amount.addTo(this);\n    }\n\n    _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * @param {int} years\n     * @return {OffsetTime}\n     */\n    plusYears(years) {\n        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);\n    }\n\n    /**\n     * @param {int} months\n     * @return {OffsetTime}\n     */\n    plusMonths(months) {\n        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);\n    }\n\n    /**\n     * @param {int} weeks\n     * @return {OffsetTime}\n     */\n    plusWeeks(weeks) {\n        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);\n    }\n\n    /**\n     * @param {int} days\n     * @return {OffsetTime}\n     */\n    plusDays(days) {\n        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);\n    }\n\n    /**\n     * @param {int} hours\n     * @return {OffsetTime}\n     */\n    plusHours(hours) {\n        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);\n    }\n\n    /**\n     * @param {int} minutes\n     * @return {OffsetTime}\n     */\n    plusMinutes(minutes) {\n        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);\n    }\n\n    /**\n     * @param {int} seconds\n     * @return {OffsetTime}\n     */\n    plusSeconds(seconds) {\n        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);\n    }\n\n    /**\n     * @param {int} nanos\n     * @return {OffsetTime}\n     */\n    plusNanos(nanos) {\n        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);\n    }\n\n    _minusAmount(amount) {\n        requireNonNull(amount);\n        return amount.subtractFrom(this);\n    }\n\n    _minusUnit(amountToSubtract, unit) {\n        return this.plus(-1 * amountToSubtract, unit);\n    }\n\n    /**\n     * @param {int} years\n     * @return {OffsetTime}\n     */\n    minusYears(years) {\n        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);\n    }\n\n    /**\n     * @param {int} months\n     * @return {OffsetTime}\n     */\n    minusMonths(months) {\n        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);\n    }\n\n    /**\n     * @param {int} weeks\n     * @return {OffsetTime}\n     */\n    minusWeeks(weeks) {\n        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);\n    }\n\n    /**\n     * @param {int} days\n     * @return {OffsetTime}\n     */\n    minusDays(days) {\n        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);\n    }\n\n    /**\n     * @param {int} hours\n     * @return {OffsetTime}\n     */\n    minusHours(hours) {\n        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);\n    }\n\n    /**\n     * @param {int} minutes\n     * @return {OffsetTime}\n     */\n    minusMinutes(minutes) {\n        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);\n    }\n\n    /**\n     * @param {int} seconds\n     * @return {OffsetTime}\n     */\n    minusSeconds(seconds) {\n        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);\n    }\n\n    /**\n     * @param {int} nanos\n     * @return {OffsetTime}\n     */\n    minusNanos(nanos) {\n        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);\n    }\n\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetDateTime, 'other');\n        if (this.offset().equals(other.offset())) {\n            return this.toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        let cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n            }\n        }\n        return cmp;\n    }\n\n    /**\n     * @param {OffsetDateTime} other\n     * @return {boolean}\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec || (thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano());\n    }\n\n    /**\n     * @param {OffsetDateTime} other\n     * @return {boolean}\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec || (thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano());\n    }\n\n    /**\n     * @param {OffsetDateTime} other\n     * @return {boolean}\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param other\n     * @return {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof OffsetDateTime) {\n            return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode() {\n        return this._dateTime.hashCode() ^ this._offset.hashCode();\n    }\n\n    toString() {\n        return this._dateTime.toString() + this._offset.toString();\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * @param {DateTimeFormatter} formatter\n     * @return {string}\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n\n\nexport function _init() {\n    OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n\n    OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n\n    OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', (temporal) => {\n        return OffsetDateTime.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/OffsetDateTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 489,
    "kind": "class",
    "name": "OffsetDateTime",
    "memberof": "packages/core/src/OffsetDateTime.js",
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/OffsetDateTime.js",
    "importStyle": "{OffsetDateTime}",
    "description": "A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,\nsuch as 2007-12-23T10:15:30+01:00.",
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 490,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.from",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporaroAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 491,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.now",
    "access": "public",
    "description": "",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId",
          "null"
        ],
        "spread": false,
        "optional": false,
        "name": "clockOrZone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 492,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.of",
    "access": "public",
    "description": "",
    "lineNumber": 79,
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 493,
    "kind": "method",
    "name": "ofDateTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.ofDateTime",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "params": [
      {
        "name": "dateTime",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 494,
    "kind": "method",
    "name": "ofDateAndTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.ofDateAndTime",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      },
      {
        "name": "time",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 495,
    "kind": "method",
    "name": "ofNumbers",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.ofNumbers",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "year",
        "types": [
          "*"
        ]
      },
      {
        "name": "month",
        "types": [
          "*"
        ]
      },
      {
        "name": "dayOfMonth",
        "types": [
          "*"
        ]
      },
      {
        "name": "hour",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "minute",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "second",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "nanoOfSecond",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 496,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.ofInstant",
    "access": "public",
    "description": "",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 497,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime.parse",
    "access": "public",
    "description": "",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter",
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 498,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 499,
    "kind": "member",
    "name": "_dateTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_dateTime",
    "access": "private",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_offset",
    "access": "private",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 502,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#until",
    "access": "public",
    "description": null,
    "lineNumber": 162,
    "undocument": true,
    "params": [
      {
        "name": "endExclusive",
        "types": [
          "*"
        ]
      },
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 503,
    "kind": "method",
    "name": "atZoneSameInstant",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#atZoneSameInstant",
    "access": "public",
    "description": "",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 504,
    "kind": "method",
    "name": "atZoneSimilarLocal",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#atZoneSimilarLocal",
    "access": "public",
    "description": "",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#query",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#get",
    "access": "public",
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 507,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#getLong",
    "access": "public",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#offset",
    "access": "public",
    "description": "",
    "lineNumber": 230,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 509,
    "kind": "method",
    "name": "year",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#year",
    "access": "public",
    "description": "",
    "lineNumber": 237,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#monthValue",
    "access": "public",
    "description": "",
    "see": [
      "#month()"
    ],
    "lineNumber": 245,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#month",
    "access": "public",
    "description": "",
    "see": [
      "#monthValue()"
    ],
    "lineNumber": 253,
    "return": {
      "nullable": null,
      "types": [
        "{number"
      ],
      "spread": false,
      "description": "}the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#dayOfMonth",
    "access": "public",
    "description": "",
    "lineNumber": 260,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "dayOfYear",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#dayOfYear",
    "access": "public",
    "description": "",
    "lineNumber": 267,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 365, or 366 in a leap year"
    },
    "params": []
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#dayOfWeek",
    "access": "public",
    "description": "",
    "lineNumber": 274,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "hour",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#hour",
    "access": "public",
    "description": "",
    "lineNumber": 281,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the hour-of-day, from 0 to 23"
    },
    "params": []
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "minute",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minute",
    "access": "public",
    "description": "",
    "lineNumber": 288,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minute-of-hour, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "second",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#second",
    "access": "public",
    "description": "",
    "lineNumber": 295,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the second-of-minute, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 518,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#nano",
    "access": "public",
    "description": "",
    "lineNumber": 302,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nano-of-second, from 0 to 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "toLocalDateTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toLocalDateTime",
    "access": "public",
    "description": "",
    "lineNumber": 310,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{LocalDateTime}the local date-time part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "toLocalDate",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toLocalDate",
    "access": "public",
    "description": "",
    "lineNumber": 317,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 521,
    "kind": "method",
    "name": "toLocalTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toLocalTime",
    "access": "public",
    "description": "",
    "lineNumber": 324,
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the time part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "toOffsetTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toOffsetTime",
    "access": "public",
    "description": "",
    "lineNumber": 331,
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": "an OffsetTime representing the time and offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 523,
    "kind": "method",
    "name": "toZonedDateTime",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toZonedDateTime",
    "access": "public",
    "description": "",
    "lineNumber": 338,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{ZonedDateTime}a zoned date-time representing the same local date-time and offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "toInstant",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toInstant",
    "access": "public",
    "description": "",
    "lineNumber": 345,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@code Instant} representing the same instant, not null"
    },
    "params": []
  },
  {
    "__docId__": 525,
    "kind": "method",
    "name": "toEpochSecond",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toEpochSecond",
    "access": "public",
    "description": "",
    "lineNumber": 352,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of seconds from the epoch of 1970-01-01T00:00:00Z"
    },
    "params": []
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#isSupported",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "params": [
      {
        "name": "fieldOrUnit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 527,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#range",
    "access": "public",
    "description": null,
    "lineNumber": 366,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 528,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_withAdjuster",
    "access": "private",
    "description": null,
    "lineNumber": 376,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "adjuster",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_withField",
    "access": "private",
    "description": null,
    "lineNumber": 391,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "newValue",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "_withDateTimeOffset",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_withDateTimeOffset",
    "access": "private",
    "description": null,
    "lineNumber": 406,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "dateTime",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withYear",
    "access": "public",
    "description": "",
    "lineNumber": 417,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withMonth",
    "access": "public",
    "description": "",
    "lineNumber": 425,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withDayOfMonth",
    "access": "public",
    "description": "",
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "withDayOfYear",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withDayOfYear",
    "access": "public",
    "description": "",
    "lineNumber": 441,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "withHour",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withHour",
    "access": "public",
    "description": "",
    "lineNumber": 449,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 536,
    "kind": "method",
    "name": "withMinute",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withMinute",
    "access": "public",
    "description": "",
    "lineNumber": 457,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "withSecond",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withSecond",
    "access": "public",
    "description": "",
    "lineNumber": 465,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "withNano",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withNano",
    "access": "public",
    "description": "",
    "lineNumber": 473,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "withOffsetSameLocal",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withOffsetSameLocal",
    "access": "public",
    "description": "",
    "lineNumber": 481,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 540,
    "kind": "method",
    "name": "withOffsetSameInstant",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#withOffsetSameInstant",
    "access": "public",
    "description": "",
    "lineNumber": 490,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 541,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#truncatedTo",
    "access": "public",
    "description": "",
    "lineNumber": 504,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "_plusAmount",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_plusAmount",
    "access": "private",
    "description": null,
    "lineNumber": 508,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_plusUnit",
    "access": "private",
    "description": null,
    "lineNumber": 513,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amountToAdd",
        "types": [
          "*"
        ]
      },
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusYears",
    "access": "public",
    "description": "",
    "lineNumber": 524,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusMonths",
    "access": "public",
    "description": "",
    "lineNumber": 532,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 546,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusWeeks",
    "access": "public",
    "description": "",
    "lineNumber": 540,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusDays",
    "access": "public",
    "description": "",
    "lineNumber": 548,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusHours",
    "access": "public",
    "description": "",
    "lineNumber": 556,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 564,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 550,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 572,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#plusNanos",
    "access": "public",
    "description": "",
    "lineNumber": 580,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "_minusAmount",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_minusAmount",
    "access": "private",
    "description": null,
    "lineNumber": 584,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#_minusUnit",
    "access": "private",
    "description": null,
    "lineNumber": 589,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amountToSubtract",
        "types": [
          "*"
        ]
      },
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusYears",
    "access": "public",
    "description": "",
    "lineNumber": 597,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 555,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusMonths",
    "access": "public",
    "description": "",
    "lineNumber": 605,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 556,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusWeeks",
    "access": "public",
    "description": "",
    "lineNumber": 613,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 557,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusDays",
    "access": "public",
    "description": "",
    "lineNumber": 621,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusHours",
    "access": "public",
    "description": "",
    "lineNumber": 629,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 559,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 637,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 560,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 645,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 561,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#minusNanos",
    "access": "public",
    "description": "",
    "lineNumber": 653,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 562,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#compareTo",
    "access": "public",
    "description": null,
    "lineNumber": 657,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 563,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#isAfter",
    "access": "public",
    "description": "",
    "lineNumber": 677,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 564,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#isBefore",
    "access": "public",
    "description": "",
    "lineNumber": 688,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#isEqual",
    "access": "public",
    "description": "",
    "lineNumber": 699,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 566,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#equals",
    "access": "public",
    "description": "",
    "lineNumber": 709,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#hashCode",
    "access": "public",
    "description": "",
    "lineNumber": 722,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toString",
    "access": "public",
    "description": null,
    "lineNumber": 726,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 734,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalDateTime.toString}"
    },
    "params": []
  },
  {
    "__docId__": 570,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/OffsetDateTime.js~OffsetDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetDateTime.js~OffsetDateTime#format",
    "access": "public",
    "description": "",
    "lineNumber": 742,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 571,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/OffsetDateTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetDateTime.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/OffsetDateTime.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 749,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 572,
    "kind": "file",
    "name": "packages/core/src/OffsetTime.js",
    "content": "/**\n * @copyright (c) 2016-present, Philipp Thürwächter & Pattrick Hüper  & js-joda contributors\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { Temporal } from './temporal/Temporal';\nimport { Clock } from './Clock';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { Instant, LocalTime } from './js-joda';\nimport { MathUtil } from './MathUtil';\nimport { OffsetDateTime } from './OffsetDateTime';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\n\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { requireInstance, requireNonNull } from './assert';\n\n/**\n * A time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 10:15:30+01:00.\n */\nexport class OffsetTime extends Temporal {\n    /**\n     * @param {!TemporalAccessor} temporal\n     * @return {OffsetTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof OffsetTime) {\n            return temporal;\n        } else if (temporal instanceof OffsetDateTime) {\n            return temporal.toOffsetTime();\n        }\n        try {\n            const time = LocalTime.from(temporal);\n            const offset = ZoneOffset.from(temporal);\n            return new OffsetTime(time, offset);\n        } catch(ex) {\n            throw new DateTimeException(`Unable to obtain OffsetTime TemporalAccessor: ${temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n\n    /**\n     * @param {Clock|ZoneId} clockOrZone\n     * @return {OffsetTime}\n     */\n    static now(clockOrZone) {\n        if (arguments.length === 0){\n            return OffsetTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock){\n            return OffsetTime._now(clockOrZone);\n        } else {\n            return OffsetTime._now(Clock.system(clockOrZone));\n        }\n    }\n\n    /**\n     * @param {Clock} clock - the clock to use, defaults to Clock.systemDefaultZone()\n     * @return {OffsetTime} the current offset date-time, not null\n     */\n    static _now(clock) {\n        requireNonNull(clock, 'clock');\n        const now = clock.instant();\n        return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));\n    }\n\n    /**\n     * @return {OffsetTime}\n     */\n    static of(){\n        if (arguments.length <= 2) {\n            return OffsetTime.ofTimeAndOffset.apply(this, arguments);\n        } else {\n            return OffsetTime.ofNumbers.apply(this, arguments);\n        }\n    }\n\n    /**\n     * @param {int} hour\n     * @param {int} minute\n     * @param {int} second\n     * @param {int} nanoOfSecond\n     * @param {ZoneOffset} offset\n     * @return {OffsetTime}\n     */\n    static ofNumbers(hour, minute, second, nanoOfSecond, offset) {\n        const time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new OffsetTime(time, offset);\n    }\n\n    /**\n     * @param {LocalTime} time\n     * @param {ZoneOffset} offset\n     * @return {OffsetTime}\n     */\n    static ofTimeAndOffset(time, offset) {\n        return new OffsetTime(time, offset);\n    }\n\n    /**\n     * @param {!Instant} instant\n     * @param {!ZoneId} zone\n     * @return {!OffsetTime}\n     */\n    static ofInstant( instant,  zone){\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        requireNonNull(zone, 'zone');\n        requireInstance(zone, ZoneId, 'zone');\n\n        const rules = zone.rules();\n        const offset = rules.offset(instant);\n        let secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;\n        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        const time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n        return new OffsetTime(time, offset);\n    }\n\n    /**\n     * @param {string} text\n     * @param {DateTimeFormatter} formatter\n     * @return {OffsetTime}\n     */\n    static parse(text, formatter= DateTimeFormatter.ISO_OFFSET_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, OffsetTime.FROM);\n    }\n    //-----------------------------------------------------------------------\n\n    /**\n     * @param {LocalTime} time\n     * @param {ZoneOffset} offset\n     * @private\n     */\n    constructor(time, offset) {\n        super();\n        requireNonNull(time, 'time');\n        requireInstance(time, LocalTime, 'time');\n        requireNonNull(offset, 'offset');\n        requireInstance(offset, ZoneOffset, 'offset');\n        this._time = time;\n        this._offset = offset;\n    }\n\n\n    /**\n     * @param {TemporalAdjuster} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal\n            .with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay())\n            .with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n    }\n\n    /**\n     * @param {LocalDate} date - the date to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this time and the specified date, not null\n     */\n    atDate(date) {\n        return OffsetDateTime.of(date, this._time, this._offset);\n    }\n\n    /**\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted time string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this, OffsetTime.FROM);\n    }\n\n\n    /**\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return super.get(field);\n    }\n\n    /**\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @trhows {UnsupportedTemporalTypeException}\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return this._offset.totalSeconds();\n            }\n            return this._time.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    /**\n     * @return {int}\n     */\n    hour() {\n        return this._time.hour();\n    }\n\n    /**\n     * @return {int}\n     */\n    minute() {\n        return this._time.minute();\n    }\n\n    /**\n     * @return {int}\n     */\n    second() {\n        return this._time.second();\n    }\n\n    /**\n     * @return {int}\n     */\n    nano() {\n        return this._time.nano();\n    }\n\n    /**\n     * @return {ZoneOffset}\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * @param {OffsetTime} other - the other time to compare to, not null\n     * @return {boolean} true if this is after the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        return this._toEpochNano() > other._toEpochNano();\n    }\n\n    /**\n     * @param {OffsetTime} other - the other time to compare to, not null\n     * @return {boolean} true if this point is before the specified time\n     * @throws {NullPointerException} if `other` is null\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        return this._toEpochNano() < other._toEpochNano();\n    }\n\n    /**\n     * @param {OffsetTime} other - the other time to compare to, not null\n     * @return {boolean}\n     * @throws {NullPointerException} if `other` is null\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this._toEpochNano() === other._toEpochNano();\n    }\n\n    /**\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    /**\n     * @param {number} hours\n     * @return {OffsetTime}\n     */\n    minusHours(hours) {\n        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);\n    }\n\n    /**\n     * @param {number} minutes\n     * @return {OffsetTime}\n     */\n    minusMinutes(minutes) {\n        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);\n    }\n\n    /**\n     * @param {number} seconds\n     * @return {OffsetTime}\n     */\n    minusSeconds(seconds) {\n        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);\n    }\n\n    /**\n     * @param {number} nanos\n     * @return {OffsetTime}\n     */\n    minusNanos(nanos) {\n        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);\n    }\n\n    _minusAmount(amount) {\n        requireNonNull(amount);\n        return amount.subtractFrom(this);\n    }\n\n    _minusUnit(amountToSubtract, unit) {\n        return this.plus(-1 * amountToSubtract, unit);\n    }\n\n    _plusAmount(amount) {\n        requireNonNull(amount);\n        return amount.addTo(this);\n    }\n\n    /**\n     *\n     * @param amountToAdd\n     * @param unit\n     * @return {Temporal}\n     */\n    _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * @param {int} hours\n     * @return {OffsetTime}\n     */\n    plusHours(hours) {\n        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);\n    }\n\n    /**\n     * @param {int} minutes\n     * @return {OffsetTime}\n     */\n    plusMinutes(minutes) {\n        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);\n    }\n\n    /**\n     * @param {int} seconds\n     * @return {OffsetTime}\n     */\n    plusSeconds(seconds) {\n        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);\n    }\n\n    /**\n     * @param {int} nanos\n     * @return {OffsetTime}\n     */\n    plusNanos(nanos) {\n        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);\n    }\n\n    /**\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localTime()) {\n            return this._time;\n        } else if (query === TemporalQueries.chronology() || query === TemporalQueries.localDate() || query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._time.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * @return {LocalTime}\n     */\n    toLocalTime() {\n        return this._time;\n    }\n\n    /**\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {OffsetTime} a {@link LocalTime} based on this time with the time truncated, not null\n     * @throws {DateTimeException} if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);\n    }\n\n    /**\n    * @param {Temporal} endExclusive - the end time, which is converted to a {@link LocalTime}, not null\n    * @param {TemporalUnit} unit - the unit to measure the period in, not null\n    * @return {number} the amount of the period between this time and the end time\n    * @throws {DateTimeException} if the period cannot be calculated\n    * @throws {ArithmeticException} if numeric overflow occurs\n    */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        const end = OffsetTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const nanosUntil = end._toEpochNano() - this._toEpochNano(); // no overflow\n            switch (unit) {\n                case ChronoUnit.NANOS: return nanosUntil;\n                case ChronoUnit.MICROS: return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS: return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS: return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS: return MathUtil.intDiv(nanosUntil, (12 * LocalTime.NANOS_PER_HOUR));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * @param {int} hour\n     * @return {OffsetTime}\n     */\n    withHour(hour) {\n        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);\n    }\n\n    /**\n     * @param {int} minute\n     * @return {OffsetTime}\n     */\n    withMinute(minute) {\n        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);\n    }\n\n    /**\n     * @param {int} second\n     * @return {OffsetTime}\n     */\n    withSecond(second) {\n        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);\n    }\n\n    /**\n     * @param {int} nano\n     * @return {OffsetTime}\n     */\n    withNano(nano) {\n        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);\n    }\n\n    /**\n     * @param {ZoneOffset} offset\n     * @return {OffsetTime}\n     */\n    withOffsetSameInstant(offset) {\n        requireNonNull(offset, 'offset');\n        if (offset.equals(this._offset)) {\n            return this;\n        }\n        const difference = offset.totalSeconds() - this._offset.totalSeconds();\n        const adjusted = this._time.plusSeconds(difference);\n        return new OffsetTime(adjusted, offset);\n    }\n\n    /**\n     * @param {ZoneOffset} offset\n     * @return {OffsetTime}\n     */\n    withOffsetSameLocal(offset) {\n        return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);\n    }\n\n    _toEpochNano() {\n        const nod = this._time.toNanoOfDay();\n        const offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;\n        return nod - offsetNanos;\n    }\n\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        // optimizations\n        if (adjuster instanceof LocalTime) {\n            return this._withLocalTimeOffset(adjuster, this._offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._withLocalTimeOffset(this._time, adjuster);\n        } else if (adjuster instanceof OffsetTime) {\n            return adjuster;\n        }\n        return adjuster.adjustInto(this);\n    }\n\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));\n            }\n            return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * @private\n     * @param {LocalTime} time\n     * @param {ZoneOffset} offset\n     * @return {OffsetTime}\n     */\n    _withLocalTimeOffset(time, offset) {\n        if (this._time === time && this._offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetTime(time, offset);\n    }\n\n    //---------------------------------\n\n    /**\n     * @param {OffsetTime} other - the other time to compare to, not null\n     * @return {int} the comparator value, negative if less, positive if greater\n     * @throws {NullPointerException} if `other` is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetTime, 'other');\n        if (this._offset.equals(other._offset)) {\n            return this._time.compareTo(other._time);\n        }\n        const compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());\n        if (compare === 0) {\n            return this._time.compareTo(other._time);\n        }\n        return compare;\n    }\n\n    /**\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof OffsetTime) {\n            return this._time.equals(other._time) && this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode() {\n        return this._time.hashCode() ^ this._offset.hashCode();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this._time.toString() + this._offset.toString();\n    }\n\n    /**\n     *\n     * @return {string} same as {@link LocalDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\n\nexport function _init() {\n    OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0,0, ZoneOffset.MAX);\n\n    OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59,999999999, ZoneOffset.MIN);\n\n    OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', (temporal) => {\n        return OffsetTime.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/OffsetTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 573,
    "kind": "class",
    "name": "OffsetTime",
    "memberof": "packages/core/src/OffsetTime.js",
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/OffsetTime.js",
    "importStyle": "{OffsetTime}",
    "description": "A time with an offset from UTC/Greenwich in the ISO-8601 calendar system, such as 10:15:30+01:00.",
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 574,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.from",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 575,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.now",
    "access": "public",
    "description": "",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "clockOrZone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "_now",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime._now",
    "access": "private",
    "description": "",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, defaults to Clock.systemDefaultZone()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": "the current offset date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 577,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.of",
    "access": "public",
    "description": "",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "ofNumbers",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.ofNumbers",
    "access": "public",
    "description": "",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "ofTimeAndOffset",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.ofTimeAndOffset",
    "access": "public",
    "description": "",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.ofInstant",
    "access": "public",
    "description": "",
    "lineNumber": 109,
    "params": [
      {
        "nullable": false,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": ""
      }
    ],
    "return": {
      "nullable": false,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime.parse",
    "access": "public",
    "description": "",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 582,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 583,
    "kind": "member",
    "name": "_time",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_time",
    "access": "private",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 584,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_offset",
    "access": "private",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 586,
    "kind": "method",
    "name": "atDate",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#atDate",
    "access": "public",
    "description": "",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the offset date-time formed from this time and the specified date, not null"
    }
  },
  {
    "__docId__": 587,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#format",
    "access": "public",
    "description": "",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted time string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 588,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#get",
    "access": "public",
    "description": "",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#getLong",
    "access": "public",
    "description": "",
    "lineNumber": 201,
    "unknown": [
      {
        "tagName": "@trhows",
        "tagValue": "{UnsupportedTemporalTypeException}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "hour",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#hour",
    "access": "public",
    "description": "",
    "lineNumber": 214,
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "minute",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#minute",
    "access": "public",
    "description": "",
    "lineNumber": 221,
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "second",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#second",
    "access": "public",
    "description": "",
    "lineNumber": 228,
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#nano",
    "access": "public",
    "description": "",
    "lineNumber": 235,
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#offset",
    "access": "public",
    "description": "",
    "lineNumber": 242,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#isAfter",
    "access": "public",
    "description": "",
    "lineNumber": 251,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified time"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#isBefore",
    "access": "public",
    "description": "",
    "lineNumber": 261,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified time"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#isEqual",
    "access": "public",
    "description": "",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#isSupported",
    "access": "public",
    "description": "",
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this time, false if not"
    }
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#minusHours",
    "access": "public",
    "description": "",
    "lineNumber": 293,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#minusMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 301,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 601,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#minusSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 309,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 602,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#minusNanos",
    "access": "public",
    "description": "",
    "lineNumber": 317,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 603,
    "kind": "method",
    "name": "_minusAmount",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_minusAmount",
    "access": "private",
    "description": null,
    "lineNumber": 321,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 604,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_minusUnit",
    "access": "private",
    "description": null,
    "lineNumber": 326,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amountToSubtract",
        "types": [
          "*"
        ]
      },
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 605,
    "kind": "method",
    "name": "_plusAmount",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_plusAmount",
    "access": "private",
    "description": null,
    "lineNumber": 330,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "amount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 606,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_plusUnit",
    "access": "private",
    "description": "",
    "lineNumber": 341,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 607,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#plusHours",
    "access": "public",
    "description": "",
    "lineNumber": 352,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 608,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#plusMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 360,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#plusSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 368,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#plusNanos",
    "access": "public",
    "description": "",
    "lineNumber": 376,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#query",
    "access": "public",
    "description": "",
    "lineNumber": 386,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#range",
    "access": "public",
    "description": "",
    "lineNumber": 405,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "toLocalTime",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#toLocalTime",
    "access": "public",
    "description": "",
    "lineNumber": 418,
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#truncatedTo",
    "access": "public",
    "description": "",
    "lineNumber": 427,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to truncate to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": "a {@link LocalTime} based on this time with the time truncated, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to truncate"
      }
    ]
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#until",
    "access": "public",
    "description": "",
    "lineNumber": 438,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end time, which is converted to a {@link LocalTime}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this time and the end time"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the period cannot be calculated"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "withHour",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withHour",
    "access": "public",
    "description": "",
    "lineNumber": 462,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "withMinute",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withMinute",
    "access": "public",
    "description": "",
    "lineNumber": 470,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 618,
    "kind": "method",
    "name": "withSecond",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withSecond",
    "access": "public",
    "description": "",
    "lineNumber": 478,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 619,
    "kind": "method",
    "name": "withNano",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withNano",
    "access": "public",
    "description": "",
    "lineNumber": 486,
    "params": [
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "nano",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 620,
    "kind": "method",
    "name": "withOffsetSameInstant",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withOffsetSameInstant",
    "access": "public",
    "description": "",
    "lineNumber": 494,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 621,
    "kind": "method",
    "name": "withOffsetSameLocal",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#withOffsetSameLocal",
    "access": "public",
    "description": "",
    "lineNumber": 508,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 622,
    "kind": "method",
    "name": "_toEpochNano",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_toEpochNano",
    "access": "private",
    "description": null,
    "lineNumber": 512,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_withAdjuster",
    "access": "private",
    "description": null,
    "lineNumber": 518,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "adjuster",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 624,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_withField",
    "access": "private",
    "description": null,
    "lineNumber": 531,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "newValue",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 625,
    "kind": "method",
    "name": "_withLocalTimeOffset",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#_withLocalTimeOffset",
    "access": "private",
    "description": "",
    "lineNumber": 548,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetTime"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#compareTo",
    "access": "public",
    "description": "",
    "lineNumber": 562,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    },
    "throws": [
      {
        "types": [
          "NullPointerException"
        ],
        "description": "if `other` is null"
      }
    ]
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#equals",
    "access": "public",
    "description": "",
    "lineNumber": 579,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other time"
    }
  },
  {
    "__docId__": 628,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#hashCode",
    "access": "public",
    "description": "",
    "lineNumber": 592,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#toString",
    "access": "public",
    "description": "",
    "lineNumber": 599,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 630,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/OffsetTime.js~OffsetTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/OffsetTime.js~OffsetTime#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 607,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link LocalDateTime.toString}"
    },
    "params": []
  },
  {
    "__docId__": 631,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/OffsetTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/OffsetTime.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/OffsetTime.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 613,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 632,
    "kind": "file",
    "name": "packages/core/src/Period.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MathUtil } from './MathUtil';\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException, ArithmeticException, DateTimeParseException } from './errors';\n\nimport { IsoChronology } from './chrono/IsoChronology';\n\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { TemporalAmount } from './temporal/TemporalAmount';\n\nimport { LocalDate } from './LocalDate';\n\n/**\n * The pattern for parsing.\n */\nconst PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\n\n/**\n * A date-based amount of time, such as '2 years, 3 months and 4 days'.\n *\n * This class models a quantity or amount of time in terms of years, months and days.\n * See {@link Duration} for the time-based equivalent to this class.\n *\n * Durations and period differ in their treatment of daylight savings time\n * when added to {@link ZonedDateTime}. A {@link Duration} will add an exact\n * number of seconds, thus a duration of one day is always exactly 24 hours.\n * By contrast, a {@link Period} will add a conceptual day, trying to maintain\n * the local time.\n *\n * For example, consider adding a period of one day and a duration of one day to\n * 18:00 on the evening before a daylight savings gap. The {@link Period} will add\n * the conceptual day and result in a {@link ZonedDateTime} at 18:00 the following day.\n * By contrast, the {@link Duration} will add exactly 24 hours, resulting in a\n * {@link ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).\n *\n * The supported units of a period are {@link ChronoUnit#YEARS},\n * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n * All three fields are always present, but may be set to zero.\n *\n * The period may be used with any calendar system.\n * The meaning of a 'year' or 'month' is only applied when the object is added to a date.\n *\n * The period is modeled as a directed amount of time, meaning that individual parts of the\n * period may be negative.\n *\n * The months and years fields may be normalized (see {@link normalized}).\n * The normalization assumes a 12 month year, so is not appropriate for all calendar systems.\n *\n * ### Static properties of Class {@link Period}\n *\n * Period.ZERO\n *\n * A constant for a period of zero.\n *\n */\nexport class Period extends TemporalAmount /* extends ChronoPeriod */ {\n\n    /**\n     * do not call the constructor directly\n     * use a factory method instead\n     *\n     * @param {number} years\n     * @param {number} months\n     * @param {number} days\n     * @private\n     */\n    constructor(years, months, days){\n        super();\n        \n        const _years = MathUtil.safeToInt(years);\n        const _months =  MathUtil.safeToInt(months);\n        const _days = MathUtil.safeToInt(days);\n\n        if( _years === 0 && _months === 0 && _days === 0 ){\n            if (!Period.ZERO) {\n                this._years = _years;\n                this._months =  _months;\n                this._days = _days;\n                Period.ZERO = this;\n            }\n            return Period.ZERO;\n        }\n        \n        /**\n         * The number of years.\n         */\n        this._years = _years;\n        /**\n         * The number of months.\n         */\n        this._months =  _months;\n        /**\n         * The number of days.\n         */\n        this._days = _days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years.\n     *\n     * The resulting period will have the specified years.\n     * The months and days units will be zero.\n     *\n     * @param {number} years - the number of years, positive or negative\n     * @return {Period} the period of years, not null\n     */\n    static ofYears(years) {\n        return Period.create(years, 0, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of months.\n     *\n     * The resulting period will have the specified months.\n     * The years and days units will be zero.\n     *\n     * @param {number} months - the number of months, positive or negative\n     * @return {Period} the period of months, not null\n     */\n    static ofMonths(months) {\n        return Period.create(0, months, 0);\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of weeks.\n     *\n     * The resulting period will have days equal to the weeks multiplied by seven.\n     * The years and months units will be zero.\n     *\n     * @param {number} weeks - the number of weeks, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofWeeks(weeks) {\n        return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n    }\n\n    /**\n     * Obtains a {@link Period} representing a number of days.\n     *\n     * The resulting period will have the specified days.\n     * The years and months units will be zero.\n     *\n     * @param {number} days - the number of days, positive or negative\n     * @return {Period} the period of days, not null\n     */\n    static ofDays(days) {\n        return Period.create(0, 0, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} representing a number of years, months and days.\n     *\n     * This creates an instance based on years, months and days.\n     *\n     * @param {!number} years - the amount of years, may be negative\n     * @param {!number} months - the amount of months, may be negative\n     * @param {!number} days - the amount of days, may be negative\n     * @return {Period} the period of years, months and days, not null\n     */\n    static of(years, months, days) {\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Period} from a temporal amount.\n     *\n     * This obtains a period based on the specified amount.\n     * A {@link TemporalAmount} represents an - amount of time, which may be\n     * date-based or time-based, which this factory extracts to a {@link Period}.\n     *\n     * The conversion loops around the set of units from the amount and uses\n     * the {@link ChronoUnit#YEARS}, {@link ChronoUnit#MONTHS}\n     * and {@link ChronoUnit#DAYS} units to create a period.\n     * If any other units are found then an exception is thrown.\n     *\n     * If the amount is a {@link ChronoPeriod} then it must use the ISO chronology.\n     *\n     * @param {TemporalAmount} amount - the temporal amount to convert, not null\n     * @return {Period} the equivalent period, not null\n     * @throws DateTimeException if unable to convert to a {@link Period}\n     * @throws ArithmeticException if the amount of years, months or days exceeds an int\n     */\n    static from(amount) {\n        if (amount instanceof Period) {\n            return amount;\n        }\n        /*\n        if (amount instanceof ChronoPeriod) {\n            if (IsoChronology.INSTANCE !== amount.chronology()) {\n                throw new DateTimeException('Period requires ISO chronology: ' + amount);\n            }\n        }\n*/\n        requireNonNull(amount, 'amount');\n        let years = 0;\n        let months = 0;\n        let days = 0;\n        const units = amount.units();\n        for (let i=0; i<units.length; i++) {\n            const unit = units[i];\n            const unitAmount = amount.get(unit);\n            if (unit === ChronoUnit.YEARS) {\n                years = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.MONTHS) {\n                months = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.DAYS) {\n                days = MathUtil.safeToInt(unitAmount);\n            } else {\n                throw new DateTimeException(`Unit must be Years, Months or Days, but was ${unit}`);\n            }\n        }\n        return Period.create(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} consisting of the number of years, months,\n     * and days between two dates.\n     *\n     * The start date is included, but the end date is not.\n     * The period is calculated by removing complete months, then calculating\n     * the remaining number of days, adjusting to ensure that both have the same sign.\n     * The number of months is then split into years and months based on a 12 month year.\n     * A month is considered if the end day-of-month is greater than or equal to the start day-of-month.\n     * For example, from `2010-01-15` to `2011-03-18` is one year, two months and three days.\n     *\n     * The result of this method can be a negative period if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n\n     * see {@link ChronoLocalDate.until}\n     *\n     * @param {LocalDate} startDate - the start date, inclusive, not null\n     * @param {LocalDate} endDate - the end date, exclusive, not null\n     * @return {Period} the period between this date and the end date, not null\n     */\n    static between(startDate, endDate) {\n        requireNonNull(startDate, 'startDate');\n        requireNonNull(endDate, 'endDate');\n        requireInstance(startDate, LocalDate, 'startDate');\n        requireInstance(endDate, LocalDate, 'endDate');\n        return startDate.until(endDate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a {@link Period} from a text string such as {@link PnYnMnD}.\n     *\n     * This will parse the string produced by {@link toString} which is\n     * based on the ISO-8601 period formats {@link PnYnMnD} and {@link PnW}.\n     *\n     * The string starts with an optional sign, denoted by the ASCII negative\n     * or positive symbol. If negative, the whole period is negated.\n     * The ASCII letter 'P' is next in upper or lower case.\n     * There are then four sections, each consisting of a number and a suffix.\n     * At least one of the four sections must be present.\n     * The sections have suffixes in ASCII of 'Y', 'M', 'W' and 'D' for\n     * years, months, weeks and days, accepted in upper or lower case.\n     * The suffixes must occur in order.\n     * The number part of each section must consist of ASCII digits.\n     * The number may be prefixed by the ASCII negative or positive symbol.\n     * The number must parse to an `int`.\n     *\n     * The leading plus/minus sign, and negative values for other units are\n     * not part of the ISO-8601 standard. In addition, ISO-8601 does not\n     * permit mixing between the {@link PnYnMnD} and {@link PnW} formats.\n     * Any week-based input is multiplied by 7 and treated as a number of days.\n     *\n     * For example, the following are valid inputs:\n     * <pre>\n     *   'P2Y'             -- Period.ofYears(2)\n     *   'P3M'             -- Period.ofMonths(3)\n     *   'P4W'             -- Period.ofWeeks(4)\n     *   'P5D'             -- Period.ofDays(5)\n     *   'P1Y2M3D'         -- Period.of(1, 2, 3)\n     *   'P1Y2M3W4D'       -- Period.of(1, 2, 25)\n     *   'P-1Y2M'          -- Period.of(-1, 2, 0)\n     *   '-P1Y2M'          -- Period.of(-1, -2, 0)\n     * </pre>\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Period} the parsed period, not null\n     * @throws DateTimeParseException if the text cannot be parsed to a period\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        try {\n            return Period._parse(text);\n        } catch (ex){\n            if(ex instanceof ArithmeticException){\n                throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * because functions that containing a try/ catch block cant be optimized,\n     * we put the code in a sub function.\n     */\n    static _parse(text){\n        const matches = PATTERN.exec(text);\n        if (matches != null) {\n            const negate = '-' === matches[1] ? -1 : 1;\n            const yearMatch = matches[2];\n            const monthMatch = matches[3];\n            const weekMatch = matches[4];\n            const dayMatch = matches[5];\n            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n                const years = Period._parseNumber(text, yearMatch, negate);\n                const months = Period._parseNumber(text, monthMatch, negate);\n                const weeks = Period._parseNumber(text, weekMatch, negate);\n                let days = Period._parseNumber(text, dayMatch, negate);\n                days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n                return Period.create(years, months, days);\n            }\n        }\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n    }\n\n    static _parseNumber(text, str, negate) {\n        if (str == null) {\n            return 0;\n        }\n        const val = MathUtil.parseInt(str);\n        return MathUtil.safeMultiply(val, negate);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates an instance.\n     *\n     * @param {number} years - the amount\n     * @param {number} months - the amount\n     * @param {number} days - the amount\n     * @return {Duration}\n     */\n    static create(years, months, days) {\n        return new Period(years, months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the list of units, from largest to smallest, that fully define this amount.\n     *\n     * @returns {ChronoUnit[]} list of units\n     */\n    units() {\n        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n    }\n\n    /**\n     * Gets the chronology that defines the meaning of the supported units.\n     *\n     * The period is defined by the chronology.\n     * It controls the supported units and restricts addition/subtraction\n     * to {@link ChronoLocalDate} instances of the same chronology.\n     *\n     * @return {IsoChronology} the chronology defining the period, not null\n     */\n    chronology() {\n        return IsoChronology.INSTANCE;\n    }\n\n    /**\n     * Gets the value of the requested unit.\n     *\n     * The supported units are chronology specific.\n     * They will typically be {@link ChronoUnit#YEARS},\n     * {@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\n     * Requesting an unsupported unit will throw an exception.\n     *\n     * @param {TemporalUnit} unit the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if the unit is not supported\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     */\n    get(unit) {\n        if (unit === ChronoUnit.YEARS) {\n            return this._years;\n        }\n        if (unit === ChronoUnit.MONTHS) {\n            return this._months;\n        }\n        if (unit === ChronoUnit.DAYS) {\n            return this._days;\n        }\n        throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if all three units of this period are zero.\n     *\n     * A zero period has the value zero for the years, months and days units.\n     *\n     * @return {boolean} true if this period is zero-length\n     */\n    isZero() {\n        return (this === Period.ZERO);\n    }\n\n    /**\n     * Checks if any of the three units of this period are negative.\n     *\n     * This checks whether the years, months or days units are less than zero.\n     *\n     * @return {boolean} true if any unit of this period is negative\n     */\n    isNegative() {\n        return this._years < 0 || this._months < 0 || this._days < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the amount of years of this period.\n     *\n     * This returns the years unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of years of this period, may be negative\n     */\n    years() {\n        return this._years;\n    }\n\n    /**\n     * Gets the amount of months of this period.\n     *\n     * This returns the months unit.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * @return {number} the amount of months of this period, may be negative\n     */\n    months() {\n        return this._months;\n    }\n\n    /**\n     * Gets the amount of days of this period.\n     *\n     * This returns the days unit.\n     *\n     * @return {number} the amount of days of this period, may be negative\n     */\n    days() {\n        return this._days;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount of years.\n     *\n     * This sets the amount of the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested years, not null\n     */\n    withYears(years) {\n        if (years === this._years) {\n            return this;\n        }\n        return Period.create(years, this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of months.\n     *\n     * This sets the amount of the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     *\n     * The months unit is not normalized with the years unit.\n     * This means that a period of '15 months' is different to a period\n     * of '1 year and 3 months'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested months, not null\n     */\n    withMonths(months) {\n        if (months === this._months) {\n            return this;\n        }\n        return Period.create(this._years, months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified amount of days.\n     *\n     * This sets the amount of the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to represent, may be negative\n     * @return {Period} a {@link Period} based on this period with the requested days, not null\n     */\n    withDays(days) {\n        if (days === this._days) {\n            return this;\n        }\n        return Period.create(this._years, this._months, days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount added.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' plus '2 years, 2 months and 2 days'\n     * returns '3 years, 8 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToAdd - the period to add, not null\n     * @return {Period} a {@link Period} based on this period with the requested period added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plus(amountToAdd) {\n        const amount = Period.from(amountToAdd);\n        return Period.create(\n            MathUtil.safeAdd(this._years, amount._years),\n            MathUtil.safeAdd(this._months, amount._months),\n            MathUtil.safeAdd(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years added.\n     *\n     * This adds the amount to the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 years returns '3 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd - the years to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months added.\n     *\n     * This adds the amount to the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 months returns '1 year, 8 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd - the months to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days added.\n     *\n     * This adds the amount to the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' plus 2 days returns '1 year, 6 months and 5 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToAdd - the days to add, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days added, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the specified amount subtracted.\n     *\n     * This input amount is converted to a {@link Period} using {@link from}.\n     * This operates separately on the years, months and days.\n     *\n     * For example, '1 year, 6 months and 3 days' minus '2 years, 2 months and 2 days'\n     * returns '-1 years, 4 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAmount} amountToSubtract - the period to subtract, not null\n     * @return {Period} a {@link Period} based on this period with the requested period subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minus(amountToSubtract) {\n        const amount = Period.from(amountToSubtract);\n        return Period.create(\n            MathUtil.safeSubtract(this._years, amount._years),\n            MathUtil.safeSubtract(this._months, amount._months),\n            MathUtil.safeSubtract(this._days, amount._days));\n    }\n\n    /**\n     * Returns a copy of this period with the specified years subtracted.\n     *\n     * This subtracts the amount from the years unit in a copy of this period.\n     * The months and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 years returns '-1 years, 6 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified years subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusYears(yearsToSubtract) {\n        return this.plusYears(-1 * yearsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified months subtracted.\n     *\n     * This subtracts the amount from the months unit in a copy of this period.\n     * The years and days units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 months returns '1 year, 4 months and 3 days'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract - the years to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified months subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusMonths(monthsToSubtract) {\n        return this.plusMonths(-1 * monthsToSubtract);\n    }\n\n    /**\n     * Returns a copy of this period with the specified days subtracted.\n     *\n     * This subtracts the amount from the days unit in a copy of this period.\n     * The years and months units are unaffected.\n     * For example, '1 year, 6 months and 3 days' minus 2 days returns '1 year, 6 months and 1 day'.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} daysToSubtract - the months to subtract, positive or negative\n     * @return {Period} a {@link Period} based on this period with the specified days subtracted, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    minusDays(daysToSubtract) {\n        return this.plusDays(-1 * daysToSubtract);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a new instance with each element in this period multiplied\n     * by the specified scalar.\n     *\n     * This simply multiplies each field, years, months, days and normalized time,\n     * by the scalar. No normalization is performed.\n     *\n     * @param {number} scalar - the scalar to multiply by, not null\n     * @return {Period} a {@link Period} based on this period with the amounts multiplied by the scalar, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    multipliedBy(scalar) {\n        if (this === Period.ZERO || scalar === 1) {\n            return this;\n        }\n        return Period.create(\n            MathUtil.safeMultiply(this._years, scalar),\n            MathUtil.safeMultiply(this._months, scalar),\n            MathUtil.safeMultiply(this._days, scalar));\n    }\n\n    /**\n     * Returns a new instance with each amount in this period negated.\n     *\n     * @return {Period} a {@link Period} based on this period with the amounts negated, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    negated() {\n        return this.multipliedBy(-1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this period with the years and months normalized\n     * using a 12 month year.\n     *\n     * This normalizes the years and months units, leaving the days unit unchanged.\n     * The months unit is adjusted to have an absolute value less than 11,\n     * with the years unit being adjusted to compensate. For example, a period of\n     * '1 Year and 15 months' will be normalized to '2 years and 3 months'.\n     *\n     * The sign of the years and months units will be the same after normalization.\n     * For example, a period of '1 year and -25 months' will be normalized to\n     * '-1 year and -1 month'.\n     *\n     * This normalization uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {Period} a {@link Period} based on this period with excess months normalized to years, not null\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    normalized() {\n        const totalMonths = this.toTotalMonths();\n        const splitYears = MathUtil.intDiv(totalMonths, 12);\n        const splitMonths = MathUtil.intMod(totalMonths, 12);  // no overflow\n        if (splitYears === this._years && splitMonths === this._months) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n    }\n\n    /**\n     * Gets the total number of months in this period using a 12 month year.\n     *\n     * This returns the total number of months in the period by multiplying the\n     * number of years by 12 and adding the number of months.\n     *\n     * This uses a 12 month year which is not valid for all calendar systems.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {number} the total number of months in the period, may be negative\n     */\n    toTotalMonths() {\n        return this._years * 12 + this._months;  // no overflow\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Adds this period to the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period added.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#plus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.addTo(dateTime);\n     *   dateTime = dateTime.plus(thisPeriod);\n     * </pre>\n     *\n     * The calculation will add the years, then months, then days.\n     * Only non-zero amounts will be added.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    addTo(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    /**\n     * Subtracts this period from the specified temporal object.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with this period subtracted.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#minus}.\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = thisPeriod.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(thisPeriod);\n     * </pre>\n     *\n     * The calculation operates as follows.\n     * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.\n     * Second, if the months are zero, the years are added if non-zero, otherwise\n     * the combination of years and months is added if non-zero.\n     * Finally, any days are added.\n     *\n     * The calculation will subtract the years, then months, then days.\n     * Only non-zero amounts will be subtracted.\n     * If the date-time has a calendar system with a fixed number of months in a\n     * year, then the years and months will be combined before being subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the temporal object to adjust, not null\n     * @return {Temporal} an object of the same type with the adjustment made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    subtractFrom(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this period is equal to another period.\n     *\n     * The comparison is based on the amounts held in the period.\n     * To be equal, the years, months and days units must be individually equal.\n     * Note that this means that a period of '15 Months' is not equal to a period\n     * of '1 Year and 3 Months'.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other period\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Period) {\n            const other = obj;\n            return this._years === other._years &&\n                this._months === other._months &&\n                this._days === other._days;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this period.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._years, this._months, this._days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this period as a string, such as {@link P6Y3M1D}.\n     *\n     * The output will be in the ISO-8601 period format.\n     * A zero period will be represented as zero days, 'P0D'.\n     *\n     * @return {string} a string representation of this period, not null\n     */\n    toString() {\n        if (this === Period.ZERO) {\n            return 'P0D';\n        } else {\n            let buf = 'P';\n            if (this._years !== 0) {\n                buf += `${this._years}Y`;\n            }\n            if (this._months !== 0) {\n                buf += `${this._months}M`;\n            }\n            if (this._days !== 0) {\n                buf += `${this._days}D`;\n            }\n            return buf;\n        }\n    }\n\n    /**\n     *\n     * @return {string} same as {@link Period.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\nexport function _init() {\n    /**\n     * A constant for a period of zero.\n     */\n    Period.ofDays(0);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Period.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 633,
    "kind": "variable",
    "name": "PATTERN",
    "memberof": "packages/core/src/Period.js",
    "static": true,
    "longname": "packages/core/src/Period.js~PATTERN",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/Period.js",
    "importStyle": null,
    "description": "The pattern for parsing.",
    "lineNumber": 21,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 634,
    "kind": "class",
    "name": "Period",
    "memberof": "packages/core/src/Period.js",
    "static": true,
    "longname": "packages/core/src/Period.js~Period",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Period.js",
    "importStyle": "{Period}",
    "description": "A date-based amount of time, such as '2 years, 3 months and 4 days'.\n\nThis class models a quantity or amount of time in terms of years, months and days.\nSee {@link Duration} for the time-based equivalent to this class.\n\nDurations and period differ in their treatment of daylight savings time\nwhen added to {@link ZonedDateTime}. A {@link Duration} will add an exact\nnumber of seconds, thus a duration of one day is always exactly 24 hours.\nBy contrast, a {@link Period} will add a conceptual day, trying to maintain\nthe local time.\n\nFor example, consider adding a period of one day and a duration of one day to\n18:00 on the evening before a daylight savings gap. The {@link Period} will add\nthe conceptual day and result in a {@link ZonedDateTime} at 18:00 the following day.\nBy contrast, the {@link Duration} will add exactly 24 hours, resulting in a\n{@link ZonedDateTime} at 19:00 the following day (assuming a one hour DST gap).\n\nThe supported units of a period are {@link ChronoUnit#YEARS},\n{@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\nAll three fields are always present, but may be set to zero.\n\nThe period may be used with any calendar system.\nThe meaning of a 'year' or 'month' is only applied when the object is added to a date.\n\nThe period is modeled as a directed amount of time, meaning that individual parts of the\nperiod may be negative.\n\nThe months and years fields may be normalized (see {@link normalized}).\nThe normalization assumes a 12 month year, so is not appropriate for all calendar systems.\n\n### Static properties of Class {@link Period}\n\nPeriod.ZERO\n\nA constant for a period of zero.",
    "lineNumber": 61,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAmount.js~TemporalAmount"
    ]
  },
  {
    "__docId__": 635,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#constructor",
    "access": "private",
    "description": "do not call the constructor directly\nuse a factory method instead",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 636,
    "kind": "member",
    "name": "_years",
    "memberof": "packages/core/src/Period.js~Period",
    "static": false,
    "longname": "packages/core/src/Period.js~Period#_years",
    "access": "private",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "member",
    "name": "_months",
    "memberof": "packages/core/src/Period.js~Period",
    "static": false,
    "longname": "packages/core/src/Period.js~Period#_months",
    "access": "private",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "member",
    "name": "_days",
    "memberof": "packages/core/src/Period.js~Period",
    "static": false,
    "longname": "packages/core/src/Period.js~Period#_days",
    "access": "private",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "ofYears",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.ofYears",
    "access": "public",
    "description": "Obtains a {@link Period} representing a number of years.\n\nThe resulting period will have the specified years.\nThe months and days units will be zero.",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the number of years, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of years, not null"
    }
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "ofMonths",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.ofMonths",
    "access": "public",
    "description": "Obtains a {@link Period} representing a number of months.\n\nThe resulting period will have the specified months.\nThe years and days units will be zero.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the number of months, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of months, not null"
    }
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "ofWeeks",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.ofWeeks",
    "access": "public",
    "description": "Obtains a {@link Period} representing a number of weeks.\n\nThe resulting period will have days equal to the weeks multiplied by seven.\nThe years and months units will be zero.",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the number of weeks, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of days, not null"
    }
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "ofDays",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.ofDays",
    "access": "public",
    "description": "Obtains a {@link Period} representing a number of days.\n\nThe resulting period will have the specified days.\nThe years and months units will be zero.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the number of days, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of days, not null"
    }
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.of",
    "access": "public",
    "description": "Obtains a {@link Period} representing a number of years, months and days.\n\nThis creates an instance based on years, months and days.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the amount of years, may be negative"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the amount of months, may be negative"
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the amount of days, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of years, months and days, not null"
    }
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.from",
    "access": "public",
    "description": "Obtains an instance of {@link Period} from a temporal amount.\n\nThis obtains a period based on the specified amount.\nA {@link TemporalAmount} represents an - amount of time, which may be\ndate-based or time-based, which this factory extracts to a {@link Period}.\n\nThe conversion loops around the set of units from the amount and uses\nthe {@link ChronoUnit#YEARS}, {@link ChronoUnit#MONTHS}\nand {@link ChronoUnit#DAYS} units to create a period.\nIf any other units are found then an exception is thrown.\n\nIf the amount is a {@link ChronoPeriod} then it must use the ISO chronology.",
    "lineNumber": 191,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the temporal amount to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the equivalent period, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link Period}"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if the amount of years, months or days exceeds an int"
      }
    ]
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "between",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.between",
    "access": "public",
    "description": "Obtains a {@link Period} consisting of the number of years, months,\nand days between two dates.\n\nThe start date is included, but the end date is not.\nThe period is calculated by removing complete months, then calculating\nthe remaining number of days, adjusting to ensure that both have the same sign.\nThe number of months is then split into years and months based on a 12 month year.\nA month is considered if the end day-of-month is greater than or equal to the start day-of-month.\nFor example, from `2010-01-15` to `2011-03-18` is one year, two months and three days.\n\nThe result of this method can be a negative period if the end is before the start.\nThe negative sign will be the same in each of year, month and day.\n\nsee {@link ChronoLocalDate.until}",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startDate",
        "description": "the start date, inclusive, not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "endDate",
        "description": "the end date, exclusive, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period between this date and the end date, not null"
    }
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.parse",
    "access": "public",
    "description": "Obtains a {@link Period} from a text string such as {@link PnYnMnD}.\n\nThis will parse the string produced by {@link toString} which is\nbased on the ISO-8601 period formats {@link PnYnMnD} and {@link PnW}.\n\nThe string starts with an optional sign, denoted by the ASCII negative\nor positive symbol. If negative, the whole period is negated.\nThe ASCII letter 'P' is next in upper or lower case.\nThere are then four sections, each consisting of a number and a suffix.\nAt least one of the four sections must be present.\nThe sections have suffixes in ASCII of 'Y', 'M', 'W' and 'D' for\nyears, months, weeks and days, accepted in upper or lower case.\nThe suffixes must occur in order.\nThe number part of each section must consist of ASCII digits.\nThe number may be prefixed by the ASCII negative or positive symbol.\nThe number must parse to an `int`.\n\nThe leading plus/minus sign, and negative values for other units are\nnot part of the ISO-8601 standard. In addition, ISO-8601 does not\npermit mixing between the {@link PnYnMnD} and {@link PnW} formats.\nAny week-based input is multiplied by 7 and treated as a number of days.\n\nFor example, the following are valid inputs:\n<pre>\n  'P2Y'             -- Period.ofYears(2)\n  'P3M'             -- Period.ofMonths(3)\n  'P4W'             -- Period.ofWeeks(4)\n  'P5D'             -- Period.ofDays(5)\n  'P1Y2M3D'         -- Period.of(1, 2, 3)\n  'P1Y2M3W4D'       -- Period.of(1, 2, 25)\n  'P-1Y2M'          -- Period.of(-1, 2, 0)\n  '-P1Y2M'          -- Period.of(-1, -2, 0)\n</pre>",
    "lineNumber": 292,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the parsed period, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed to a period"
      }
    ]
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "_parse",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period._parse",
    "access": "private",
    "description": "because functions that containing a try/ catch block cant be optimized,\nwe put the code in a sub function.",
    "lineNumber": 309,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "_parseNumber",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period._parseNumber",
    "access": "private",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "negate",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "create",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~Period.create",
    "access": "public",
    "description": "Creates an instance.",
    "lineNumber": 346,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the amount"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the amount"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the amount"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "units",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#units",
    "access": "public",
    "description": "Gets the list of units, from largest to smallest, that fully define this amount.",
    "lineNumber": 356,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ChronoUnit[]} list of units"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ChronoUnit[]"
      ],
      "spread": false,
      "description": "list of units"
    },
    "params": []
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "chronology",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#chronology",
    "access": "public",
    "description": "Gets the chronology that defines the meaning of the supported units.\n\nThe period is defined by the chronology.\nIt controls the supported units and restricts addition/subtraction\nto {@link ChronoLocalDate} instances of the same chronology.",
    "lineNumber": 369,
    "return": {
      "nullable": null,
      "types": [
        "IsoChronology"
      ],
      "spread": false,
      "description": "the chronology defining the period, not null"
    },
    "params": []
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#get",
    "access": "public",
    "description": "Gets the value of the requested unit.\n\nThe supported units are chronology specific.\nThey will typically be {@link ChronoUnit#YEARS},\n{@link ChronoUnit#MONTHS} and {@link ChronoUnit#DAYS}.\nRequesting an unsupported unit will throw an exception.",
    "lineNumber": 386,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the {@link TemporalUnit} for which to return the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the long value of the unit"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the unit is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the unit is not supported"
      }
    ]
  },
  {
    "__docId__": 656,
    "kind": "method",
    "name": "isZero",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#isZero",
    "access": "public",
    "description": "Checks if all three units of this period are zero.\n\nA zero period has the value zero for the years, months and days units.",
    "lineNumber": 407,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this period is zero-length"
    },
    "params": []
  },
  {
    "__docId__": 657,
    "kind": "method",
    "name": "isNegative",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#isNegative",
    "access": "public",
    "description": "Checks if any of the three units of this period are negative.\n\nThis checks whether the years, months or days units are less than zero.",
    "lineNumber": 418,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if any unit of this period is negative"
    },
    "params": []
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "years",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#years",
    "access": "public",
    "description": "Gets the amount of years of this period.\n\nThis returns the years unit.\n\nThe months unit is not normalized with the years unit.\nThis means that a period of '15 months' is different to a period\nof '1 year and 3 months'.",
    "lineNumber": 434,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of years of this period, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "months",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#months",
    "access": "public",
    "description": "Gets the amount of months of this period.\n\nThis returns the months unit.\n\nThe months unit is not normalized with the years unit.\nThis means that a period of '15 months' is different to a period\nof '1 year and 3 months'.",
    "lineNumber": 449,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of months of this period, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 660,
    "kind": "method",
    "name": "days",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#days",
    "access": "public",
    "description": "Gets the amount of days of this period.\n\nThis returns the days unit.",
    "lineNumber": 460,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of days of this period, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "withYears",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#withYears",
    "access": "public",
    "description": "Returns a copy of this period with the specified amount of years.\n\nThis sets the amount of the years unit in a copy of this period.\nThe months and days units are unaffected.\n\nThe months unit is not normalized with the years unit.\nThis means that a period of '15 months' is different to a period\nof '1 year and 3 months'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 480,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to represent, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the requested years, not null"
    }
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "withMonths",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#withMonths",
    "access": "public",
    "description": "Returns a copy of this period with the specified amount of months.\n\nThis sets the amount of the months unit in a copy of this period.\nThe years and days units are unaffected.\n\nThe months unit is not normalized with the years unit.\nThis means that a period of '15 months' is different to a period\nof '1 year and 3 months'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 502,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to represent, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the requested months, not null"
    }
  },
  {
    "__docId__": 663,
    "kind": "method",
    "name": "withDays",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#withDays",
    "access": "public",
    "description": "Returns a copy of this period with the specified amount of days.\n\nThis sets the amount of the days unit in a copy of this period.\nThe years and months units are unaffected.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 520,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to represent, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the requested days, not null"
    }
  },
  {
    "__docId__": 664,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#plus",
    "access": "public",
    "description": "Returns a copy of this period with the specified amount added.\n\nThis input amount is converted to a {@link Period} using {@link from}.\nThis operates separately on the years, months and days.\n\nFor example, '1 year, 6 months and 3 days' plus '2 years, 2 months and 2 days'\nreturns '3 years, 8 months and 5 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 543,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the requested period added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 665,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#plusYears",
    "access": "public",
    "description": "Returns a copy of this period with the specified years added.\n\nThis adds the amount to the years unit in a copy of this period.\nThe months and days units are unaffected.\nFor example, '1 year, 6 months and 3 days' plus 2 years returns '3 years, 6 months and 3 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 564,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified years added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#plusMonths",
    "access": "public",
    "description": "Returns a copy of this period with the specified months added.\n\nThis adds the amount to the months unit in a copy of this period.\nThe years and days units are unaffected.\nFor example, '1 year, 6 months and 3 days' plus 2 months returns '1 year, 8 months and 3 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 584,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToAdd",
        "description": "the months to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified months added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#plusDays",
    "access": "public",
    "description": "Returns a copy of this period with the specified days added.\n\nThis adds the amount to the days unit in a copy of this period.\nThe years and months units are unaffected.\nFor example, '1 year, 6 months and 3 days' plus 2 days returns '1 year, 6 months and 5 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 604,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "daysToAdd",
        "description": "the days to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified days added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#minus",
    "access": "public",
    "description": "Returns a copy of this period with the specified amount subtracted.\n\nThis input amount is converted to a {@link Period} using {@link from}.\nThis operates separately on the years, months and days.\n\nFor example, '1 year, 6 months and 3 days' minus '2 years, 2 months and 2 days'\nreturns '-1 years, 4 months and 1 day'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 627,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the requested period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#minusYears",
    "access": "public",
    "description": "Returns a copy of this period with the specified years subtracted.\n\nThis subtracts the amount from the years unit in a copy of this period.\nThe months and days units are unaffected.\nFor example, '1 year, 6 months and 3 days' minus 2 years returns '-1 years, 6 months and 3 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 648,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 670,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#minusMonths",
    "access": "public",
    "description": "Returns a copy of this period with the specified months subtracted.\n\nThis subtracts the amount from the months unit in a copy of this period.\nThe years and days units are unaffected.\nFor example, '1 year, 6 months and 3 days' minus 2 months returns '1 year, 4 months and 3 days'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 665,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToSubtract",
        "description": "the years to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 671,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#minusDays",
    "access": "public",
    "description": "Returns a copy of this period with the specified days subtracted.\n\nThis subtracts the amount from the days unit in a copy of this period.\nThe years and months units are unaffected.\nFor example, '1 year, 6 months and 3 days' minus 2 days returns '1 year, 6 months and 1 day'.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 682,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "daysToSubtract",
        "description": "the months to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the specified days subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 672,
    "kind": "method",
    "name": "multipliedBy",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#multipliedBy",
    "access": "public",
    "description": "Returns a new instance with each element in this period multiplied\nby the specified scalar.\n\nThis simply multiplies each field, years, months, days and normalized time,\nby the scalar. No normalization is performed.",
    "lineNumber": 698,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "scalar",
        "description": "the scalar to multiply by, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the amounts multiplied by the scalar, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 673,
    "kind": "method",
    "name": "negated",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#negated",
    "access": "public",
    "description": "Returns a new instance with each amount in this period negated.",
    "lineNumber": 714,
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with the amounts negated, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "normalized",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#normalized",
    "access": "public",
    "description": "Returns a copy of this period with the years and months normalized\nusing a 12 month year.\n\nThis normalizes the years and months units, leaving the days unit unchanged.\nThe months unit is adjusted to have an absolute value less than 11,\nwith the years unit being adjusted to compensate. For example, a period of\n'1 Year and 15 months' will be normalized to '2 years and 3 months'.\n\nThe sign of the years and months units will be the same after normalization.\nFor example, a period of '1 year and -25 months' will be normalized to\n'-1 year and -1 month'.\n\nThis normalization uses a 12 month year which is not valid for all calendar systems.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 739,
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "a {@link Period} based on this period with excess months normalized to years, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "params": []
  },
  {
    "__docId__": 675,
    "kind": "method",
    "name": "toTotalMonths",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#toTotalMonths",
    "access": "public",
    "description": "Gets the total number of months in this period using a 12 month year.\n\nThis returns the total number of months in the period by multiplying the\nnumber of years by 12 and adding the number of months.\n\nThis uses a 12 month year which is not valid for all calendar systems.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 761,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the total number of months in the period, may be negative"
    },
    "params": []
  },
  {
    "__docId__": 676,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#addTo",
    "access": "public",
    "description": "Adds this period to the specified temporal object.\n\nThis returns a temporal object of the same observable type as the input\nwith this period added.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#plus}.\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = thisPeriod.addTo(dateTime);\n  dateTime = dateTime.plus(thisPeriod);\n</pre>\n\nThe calculation will add the years, then months, then days.\nOnly non-zero amounts will be added.\nIf the date-time has a calendar system with a fixed number of months in a\nyear, then the years and months will be combined before being added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 792,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to add"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 677,
    "kind": "method",
    "name": "subtractFrom",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#subtractFrom",
    "access": "public",
    "description": "Subtracts this period from the specified temporal object.\n\nThis returns a temporal object of the same observable type as the input\nwith this period subtracted.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#minus}.\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = thisPeriod.subtractFrom(dateTime);\n  dateTime = dateTime.minus(thisPeriod);\n</pre>\n\nThe calculation operates as follows.\nFirst, the chronology of the temporal is checked to ensure it is ISO chronology or null.\nSecond, if the months are zero, the years are added if non-zero, otherwise\nthe combination of years and months is added if non-zero.\nFinally, any days are added.\n\nThe calculation will subtract the years, then months, then days.\nOnly non-zero amounts will be subtracted.\nIf the date-time has a calendar system with a fixed number of months in a\nyear, then the years and months will be combined before being subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 841,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to subtract"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 678,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#equals",
    "access": "public",
    "description": "Checks if this period is equal to another period.\n\nThe comparison is based on the amounts held in the period.\nTo be equal, the years, months and days units must be individually equal.\nNote that this means that a period of '15 Months' is not equal to a period\nof '1 Year and 3 Months'.",
    "lineNumber": 870,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other period"
    }
  },
  {
    "__docId__": 679,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#hashCode",
    "access": "public",
    "description": "A hash code for this period.",
    "lineNumber": 888,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 680,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#toString",
    "access": "public",
    "description": "Outputs this period as a string, such as {@link P6Y3M1D}.\n\nThe output will be in the ISO-8601 period format.\nA zero period will be represented as zero days, 'P0D'.",
    "lineNumber": 901,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this period, not null"
    },
    "params": []
  },
  {
    "__docId__": 681,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Period.js~Period",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Period.js~Period#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 923,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link Period.toString}"
    },
    "params": []
  },
  {
    "__docId__": 682,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/Period.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Period.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Period.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 928,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 683,
    "kind": "file",
    "name": "packages/core/src/StringUtil.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MathUtil } from './MathUtil';\n\n/**\n * @private\n */\nexport class StringUtil {\n\n    /**\n     *\n     * @param {string} text\n     * @param {string} pattern\n     * @return {boolean}\n     */\n    static startsWith(text, pattern){\n        return text.indexOf(pattern) === 0;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    static hashCode(text) {\n        const len = text.length;\n        if (len === 0) {\n            return 0;\n        }\n\n        let hash = 0;\n        for (let i = 0; i < len; i++) {\n            const chr = text.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return MathUtil.smi(hash);\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/StringUtil.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 684,
    "kind": "class",
    "name": "StringUtil",
    "memberof": "packages/core/src/StringUtil.js",
    "static": true,
    "longname": "packages/core/src/StringUtil.js~StringUtil",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/StringUtil.js",
    "importStyle": "{StringUtil}",
    "description": "",
    "lineNumber": 11,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "startsWith",
    "memberof": "packages/core/src/StringUtil.js~StringUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/StringUtil.js~StringUtil.startsWith",
    "access": "public",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/StringUtil.js~StringUtil",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/StringUtil.js~StringUtil.hashCode",
    "access": "public",
    "description": "",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 687,
    "kind": "file",
    "name": "packages/core/src/Year.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\nimport { requireNonNull, requireInstance } from './assert';\nimport { MathUtil } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { Clock } from './Clock';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { DateTimeFormatterBuilder } from './format/DateTimeFormatterBuilder';\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { LocalDate } from './LocalDate';\nimport { Month } from './Month';\nimport { MonthDay } from './MonthDay';\nimport { SignStyle } from './format/SignStyle';\nimport { Temporal } from './temporal/Temporal';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalField } from './temporal/TemporalField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { TemporalQuery, createTemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalUnit } from './temporal/TemporalUnit';\nimport { YearConstants } from './YearConstants';\nimport { YearMonth } from './YearMonth';\nimport { ZoneId } from './ZoneId';\n\n\n/**\n * A year in the ISO-8601 calendar system, such as `2007`.\n *\n * {@link Year} is an immutable date-time object that represents a year.\n * Any field that can be derived from a year can be obtained.\n *\n * **Note that years in the ISO chronology only align with years in the\n * Gregorian-Julian system for modern years. Parts of Russia did not switch to the\n * modern Gregorian/ISO rules until 1920.\n * As such, historical years must be treated with caution.**\n *\n * This class does not store or represent a month, day, time or time-zone.\n * For example, the value \"2007\" can be stored in a {@link Year}.\n *\n * Years represented by this class follow the ISO-8601 standard and use\n * the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * Year.MIN_VALUE = -999.999;\n *\n * The minimum supported year. Theoretically the minimum could be -28.542.4812 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MIN_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n * Year.MAX_VALUE = 999.999;\n *\n * The maximum supported year. Theoretically the maximum could be 285.428.751 years in javascript.\n * approx LocalDateTime.ofEpochSecond(Number.MAX_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n *\n */\nexport class Year extends Temporal {\n\n    /**\n     *\n     * @param {number} value\n     * @private\n     */\n    constructor(value) {\n        super();\n        this._year = MathUtil.safeToInt(value);\n    }\n\n    /**\n     *\n     * @return {number} gets the value\n     */\n    value() {\n        return this._year;\n    }\n\n    /**\n     * function overloading for {@link Year.now}\n     *\n     * if called without arguments, then {@link Year.now0} is executed.\n\n     * if called with 1 arguments and first argument is an instance of ZoneId, then {@link Year.nowZoneId} is executed.\n     *\n     * Otherwise {@link Year.nowClock} is executed.\n     *\n     * @param {!(ZoneId|Clock)} zoneIdOrClock\n     * @returns {Year}\n     */\n    static now(zoneIdOrClock = undefined) {\n        if (zoneIdOrClock === undefined) {\n            return Year.now0();\n        } else if (zoneIdOrClock instanceof ZoneId) {\n            return Year.nowZoneId(zoneIdOrClock);\n        } else {\n            return Year.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {Year} the current year using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return Year.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {Year} the current year using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        requireNonNull(zone, 'zone');\n        requireInstance(zone, ZoneId, 'zone');\n        return Year.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {Year} the current year, not null\n     */\n    static nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        requireInstance(clock, Clock, 'clock');\n        const now = LocalDate.now(clock);  // called once\n        return Year.of(now.year());\n    }\n    /**\n     * Obtains an instance of {@link Year}.\n     *\n     * This method accepts a year value from the proleptic ISO calendar system.\n     *\n     * * The year 2AD/CE is represented by 2.\n     * * The year 1AD/CE is represented by 1.\n     * * The year 1BC/BCE is represented by 0.\n     * * The year 2BC/BCE is represented by -1.\n     *\n     * @param {Number} isoYear  the ISO proleptic year to represent, from {@link MIN_VALUE} to {@link MAX_VALUE}\n     * @return {Year} the year, not null\n     * @throws DateTimeException if the field is invalid\n     */\n    static of(isoYear) {\n        requireNonNull(isoYear, 'isoYear');\n        ChronoField.YEAR.checkValidValue(isoYear);\n        return new Year(isoYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link Year} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link Year}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link Year::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {Year} the year, not null\n     * @throws DateTimeException if unable to convert to a {@link Year}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof Year) {\n            return temporal;\n        }\n        try {\n            /* TODO: we support only ISO for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return Year.of(temporal.get(ChronoField.YEAR));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain Year from TemporalAccessor: ${ \n                temporal}, type ${temporal && temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Year.parse}\n     *\n     * if called with 1 argument, then {@link Year.parseText} is executed.\n     *\n     * Otherwise {@link Year.parseTextFormatter} is executed.\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {Year}\n     */\n    static parse(text, formatter) {\n        if (arguments.length <= 1) {\n            return Year.parseText(text);\n        } else {\n            return Year.parseTextFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string such as `2007`.\n     *\n     * The string must represent a valid year.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007\", not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseText(text) {\n        requireNonNull(text, 'text');\n        return Year.parse(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link Year} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {Year} the parsed year, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseTextFormatter(text, formatter = PARSER) {\n        requireNonNull(text, 'text');\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, Year.FROM);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} year  the year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeap(year) {\n        return ((MathUtil.intMod(year, 4) === 0) && ((MathUtil.intMod(year, 100) !== 0) || (MathUtil.intMod(year, 400) === 0)));\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (this.isSupported(field)) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as an `int`.\n     *\n     * This queries this year for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year as a `long`.\n     *\n     * This queries this year for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeap() {\n        return Year.isLeap(this._year);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this year with the specified field set to a new value.\n     *\n     * This returns a new {@link Year}, based on this one, with the value\n     * for the specified field changed.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link Year} with the specified year-of-era\n     *   The era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link Year} with the specified year.\n     *   This completely replaces the date and is equivalent to {@link of}.\n     * * {@link ERA} -\n     *   Returns a {@link Year} with the specified era.\n     *   The year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @returns {Year} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA:\n                    return Year.of((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR:\n                    return Year.of(newValue);\n                case ChronoField.ERA:\n                    return (this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {Year} based on this year with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, 'amountToAdd');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year with the specified number of years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {Year} based on this year with the period added, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this year with the specified number of years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {Year} based on this year with the period subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported year range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYear.adjustInto(temporal);\n     *   temporal = temporal.with(thisYear);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n         if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n         throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n         }*/\n        return temporal.with(ChronoField.YEAR, this._year);\n    }\n\n    /**\n     * Checks if the month-day is valid for this year.\n     *\n     * This method checks whether this year and the input month and day form\n     * a valid date.\n     *\n     * @param {MonthDay} monthDay  the month-day to validate, null returns false\n     * @return {boolean} true if the month and day are valid for this year\n     */\n    isValidMonthDay(monthDay) {\n        return monthDay != null && monthDay.isValidYear(this._year);\n    }\n\n    /**\n     * Gets the length of this year in days.\n     *\n     * @return {number} the length of this year in days, 365 or 366\n     */\n    length() {\n        return this.isLeap() ? 366 : 365;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year with a day-of-year to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified day-of-year.\n     *\n     * The day-of-year value 366 is only valid in a leap year.\n     *\n     * @param {number} dayOfYear  the day-of-year to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified date of year, not null\n     * @throws DateTimeException if the day of year is zero or less, 366 or greater or equal\n     *  to 366 and this is not a leap year\n     */\n    atDay(dayOfYear) {\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    }\n\n    /**\n     * function overloading for {@link Year.atMonth}\n     *\n     * if called with 1 arguments and first argument is instance of Month, then {@link Year.atMonthMonth} is executed.\n     *\n     * Otherwise {@link Year.atMonthNumber} is executed.\n     *\n     * @param {Month|number} monthOrNumber\n     * @returns {YearMonth}\n     */\n    atMonth(monthOrNumber) {\n        if (arguments.length === 1 && monthOrNumber instanceof Month) {\n            return this.atMonthMonth(monthOrNumber);\n        } else {\n            return this.atMonthNumber(monthOrNumber);\n        }\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {Month} month  the month-of-year to use, not null\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     */\n    atMonthMonth(month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month to create a {@link YearMonth}.\n     *\n     * This returns a {@link YearMonth} formed from this year and the specified month.\n     * All possible combinations of year and month are valid.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} month  the month-of-year to use, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month formed from this year and the specified month, not null\n     * @throws DateTimeException if the month is invalid\n     */\n    atMonthNumber(month) {\n        requireNonNull(month, 'month');\n        return YearMonth.of(this._year, month);\n    }\n\n    /**\n     * Combines this year with a month-day to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year and the specified month-day.\n     *\n     * A month-day of February 29th will be adjusted to February 28th in the resulting\n     * date if the year is not a leap year.\n     *\n     * @param {MonthDay} monthDay  the month-day to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified month-day, not null\n     */\n    atMonthDay(monthDay) {\n        requireNonNull(monthDay, 'monthDay');\n        requireInstance(monthDay, MonthDay, 'monthDay');\n        return monthDay.atYear(this._year);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year using the specified query.\n     *\n     * This queries this year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query()');\n        requireInstance(query, TemporalQuery, 'query()');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.YEARS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year to another year.\n     *\n     * The comparison is based on the value of the year.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year - other._year;\n    }\n\n    /**\n     * Is this year after the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this is after the specified year\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year > other._year;\n    }\n\n    /**\n     * Is this year before the specified year.\n     *\n     * @param {Year} other  the other year to compare to, not null\n     * @return {boolean} true if this point is before the specified year\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Year, 'other');\n        return this._year < other._year;\n    }\n    /**\n     * Outputs this year as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Checks if this year is equal to the specified {@link Year}.\n     *\n     * The comparison is based on the value\n     *\n     * @param {*} other - the other year, null returns false\n     * @return {boolean} true if the other duration is equal to this one\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Year) {\n            return this.value() === other.value();\n        }\n        return false;\n    }\n    /**\n     * Outputs this year as a string.\n     *\n     * @return {String} a string representation of this year, not null\n     */\n    toString() {\n        return `${this._year}`;\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Calculates the amount of time until another temporal in terms of the specified unit.\n     * This calculates the amount of time between two temporal objects in terms of a single {@link TemporalUnit}. The start and end points are this and the specified temporal. The end point is converted to be of the same type as the start point if different. The result will be negative if the end is before the start. For example, the amount in hours between two temporal objects can be calculated using `startTime.until(endTime, HOURS)`.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals. For example, the amount in hours between the times 11:30 and 13:29 will only be one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use `TemporalUnit.between(Temporal, Temporal)`:\n     *\n     * <pre>\n     *    // these two lines are equivalent\n     *    temporal = start.until(end, unit);\n     *    temporal = unit.between(start, end);\n     * </pre>\n     *\n     * The choice should be made based on which makes the code more readable.\n     * For example, this method allows the number of days between two dates to be calculated:\n     *\n     * <pre>\n     *   daysBetween = start.until(end, DAYS);\n     *   // or alternatively\n     *   daysBetween = DAYS.between(start, end);\n     * </pre>\n     *\n     * ### Implementation Requirements:\n     * Implementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of {@link ChronoUnit}. An {@link UnsupportedTemporalTypeException} must be thrown for {@link ChronoUnit} instances that are unsupported.\n     * If the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.between(Temporal, Temporal)` passing this as the first argument and the converted input temporal as the second argument.\n     *\n     * In summary, implementations must behave in a manner equivalent to this pseudo-code:\n     *\n     * <pre>\n     *   // convert the end temporal to the same type as this class\n     *   if (unit instanceof ChronoUnit) {\n     *     // if unit is supported, then calculate and return result\n     *     // else throw UnsupportedTemporalTypeException for unsupported units\n     *   }\n     *   return unit.between(this, convertedEndTemporal);\n     * </pre>\n     *\n     * Note that the unit's between method must only be invoked if the two temporal objects have exactly the same type evaluated by `getClass()`.\n     *\n     * Implementations must ensure that no observable state is altered when this read-only method is invoked.\n     *\n     * @param {Temporal} endExclusive - the end temporal, exclusive, converted to be of the same type as this object, not null\n     * @param {TemporalUnit} unit - the unit to measure the amount in, not null\n     * @return {number} the amount of time between this temporal object and the specified one in terms of the unit; positive if the specified object is later than this one, negative if it is earlier than this one\n     * @throws DateTimeException - if the amount cannot be calculated, or the end temporal cannot be converted to the same type as this temporal\n     * @throws UnsupportedTemporalTypeException - if the unit is not supported\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        const end = Year.from(endExclusive);\n\n        if (unit instanceof ChronoUnit) {\n            const yearsUntil = end.value() - this.value();\n            switch (unit) {\n                case ChronoUnit.YEARS:\n                    return yearsUntil;\n                case ChronoUnit.DECADES:\n                    return MathUtil.intDiv(yearsUntil, 10);\n                case ChronoUnit.CENTURIES:\n                    return MathUtil.intDiv(yearsUntil, 100);\n                case ChronoUnit.MILLENNIA:\n                    return MathUtil.intDiv(yearsUntil, 1000);\n                case ChronoUnit.ERAS:\n                    return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    Year.MIN_VALUE = YearConstants.MIN_VALUE;\n    Year.MAX_VALUE = YearConstants.MAX_VALUE;\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .toFormatter();\n\n    Year.FROM = createTemporalQuery('Year.FROM', (temporal) => {\n        return Year.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/Year.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 688,
    "kind": "class",
    "name": "Year",
    "memberof": "packages/core/src/Year.js",
    "static": true,
    "longname": "packages/core/src/Year.js~Year",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Year.js",
    "importStyle": "{Year}",
    "description": "A year in the ISO-8601 calendar system, such as `2007`.\n\n{@link Year} is an immutable date-time object that represents a year.\nAny field that can be derived from a year can be obtained.\n\n**Note that years in the ISO chronology only align with years in the\nGregorian-Julian system for modern years. Parts of Russia did not switch to the\nmodern Gregorian/ISO rules until 1920.\nAs such, historical years must be treated with caution.**\n\nThis class does not store or represent a month, day, time or time-zone.\nFor example, the value \"2007\" can be stored in a {@link Year}.\n\nYears represented by this class follow the ISO-8601 standard and use\nthe proleptic numbering system. Year 1 is preceded by year 0, then by year -1.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\n### Static properties of Class {@link LocalDate}\n\nYear.MIN_VALUE = -999.999;\n\nThe minimum supported year. Theoretically the minimum could be -28.542.4812 years in javascript.\napprox LocalDateTime.ofEpochSecond(Number.MIN_SAFE_INTEGER, 0, ZoneOffset.UTC).year()\n\nYear.MAX_VALUE = 999.999;\n\nThe maximum supported year. Theoretically the maximum could be 285.428.751 years in javascript.\napprox LocalDateTime.ofEpochSecond(Number.MAX_SAFE_INTEGER, 0, ZoneOffset.UTC).year()",
    "lineNumber": 69,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 689,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 690,
    "kind": "member",
    "name": "_year",
    "memberof": "packages/core/src/Year.js~Year",
    "static": false,
    "longname": "packages/core/src/Year.js~Year#_year",
    "access": "private",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "value",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#value",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "gets the value"
    },
    "params": []
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.now",
    "access": "public",
    "description": "function overloading for {@link Year.now}\n\nif called without arguments, then {@link Year.now0} is executed.\n\nif called with 1 arguments and first argument is an instance of ZoneId, then {@link Year.nowZoneId} is executed.\n\nOtherwise {@link Year.nowClock} is executed.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Year}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 693,
    "kind": "method",
    "name": "now0",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.now0",
    "access": "public",
    "description": "Obtains the current year from the system clock in the default time-zone.\n\nThis will query the system clock (see {@link Clock#systemDefaultZone}) in the default\ntime-zone to obtain the current year.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 122,
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the current year using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 694,
    "kind": "method",
    "name": "nowZoneId",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.nowZoneId",
    "access": "public",
    "description": "Obtains the current year from the system clock in the specified time-zone.\n\nThis will query the system clock (see {@link Clock#system}) to obtain the current year.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the current year using the system clock, not null"
    }
  },
  {
    "__docId__": 695,
    "kind": "method",
    "name": "nowClock",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.nowClock",
    "access": "public",
    "description": "Obtains the current year from the specified clock.\n\nThis will query the specified clock to obtain the current year.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection.",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the current year, not null"
    }
  },
  {
    "__docId__": 696,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.of",
    "access": "public",
    "description": "Obtains an instance of {@link Year}.\n\nThis method accepts a year value from the proleptic ISO calendar system.\n\n* The year 2AD/CE is represented by 2.\n* The year 1AD/CE is represented by 1.\n* The year 1BC/BCE is represented by 0.\n* The year 2BC/BCE is represented by -1.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "isoYear",
        "description": "the ISO proleptic year to represent, from {@link MIN_VALUE} to {@link MAX_VALUE}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field is invalid"
      }
    ]
  },
  {
    "__docId__": 697,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.from",
    "access": "public",
    "description": "Obtains an instance of {@link Year} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link Year}.\n\nThe conversion extracts the {@link ChronoField#YEAR} field.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link Year::from}.",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link Year}"
      }
    ]
  },
  {
    "__docId__": 698,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.parse",
    "access": "public",
    "description": "function overloading for {@link Year.parse}\n\nif called with 1 argument, then {@link Year.parseText} is executed.\n\nOtherwise {@link Year.parseTextFormatter} is executed.",
    "lineNumber": 227,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Year}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 699,
    "kind": "method",
    "name": "parseText",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.parseText",
    "access": "public",
    "description": "Obtains an instance of {@link Year} from a text string such as `2007`.\n\nThe string must represent a valid year.\nYears outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.",
    "lineNumber": 245,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse such as \"2007\", not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the parsed year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 700,
    "kind": "method",
    "name": "parseTextFormatter",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.parseTextFormatter",
    "access": "public",
    "description": "Obtains an instance of {@link Year} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a year.",
    "lineNumber": 260,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "the parsed year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 701,
    "kind": "method",
    "name": "isLeap",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~Year.isLeap",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 287,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    }
  },
  {
    "__docId__": 702,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isSupported",
    "access": "public",
    "description": "function overloading for {@link YearMonth.isSupported}\n\nif called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n\notherwise {@link YearMonth.isSupportedUnit} is executed",
    "lineNumber": 301,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField",
          "ChronoUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 703,
    "kind": "method",
    "name": "isSupportedField",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isSupportedField",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this year can be queried for the specified field.\nIf false, then calling {@link range} and {@link get} will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nThe supported fields are:\n\n* {@link YEAR_OF_ERA}\n* {@link YEAR}\n* {@link ERA}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this year, false if not"
    }
  },
  {
    "__docId__": 704,
    "kind": "method",
    "name": "isSupportedUnit",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isSupportedUnit",
    "access": "public",
    "description": null,
    "lineNumber": 341,
    "undocument": true,
    "params": [
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis year is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 370,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 706,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#get",
    "access": "public",
    "description": "Gets the value of the specified field from this year as an `int`.\n\nThis queries this year for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this year.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 402,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this year as a `long`.\n\nThis queries this year for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this year.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 428,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 708,
    "kind": "method",
    "name": "isLeap",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isLeap",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 460,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    },
    "params": []
  },
  {
    "__docId__": 709,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#_withField",
    "access": "private",
    "description": "Returns a copy of this year with the specified field set to a new value.\n\nThis returns a new {@link Year}, based on this one, with the value\nfor the specified field changed.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n\n* {@link YEAR_OF_ERA} -\n  Returns a {@link Year} with the specified year-of-era\n  The era will be unchanged.\n* {@link YEAR} -\n  Returns a {@link Year} with the specified year.\n  This completely replaces the date and is equivalent to {@link of}.\n* {@link ERA} -\n  Returns a {@link Year} with the specified era.\n  The year-of-era will be unchanged.\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a {@link DateTimeException} will be thrown.\n\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Year} based on `this` with the specified field set, not null"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field cannot be set"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 710,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#_plusUnit",
    "access": "private",
    "description": "",
    "lineNumber": 530,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "based on this year with the addition made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the addition cannot be made"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 711,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#plusYears",
    "access": "public",
    "description": "Returns a copy of this year with the specified number of years added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 556,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "based on this year with the period added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported year range"
      }
    ]
  },
  {
    "__docId__": 712,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#minusYears",
    "access": "public",
    "description": "Returns a copy of this year with the specified number of years subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 574,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Year"
      ],
      "spread": false,
      "description": "based on this year with the period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported year range"
      }
    ]
  },
  {
    "__docId__": 713,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this year.\n\nThis returns a temporal object of the same observable type as the input\nwith the year changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField#YEAR} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisYear.adjustInto(temporal);\n  temporal = temporal.with(thisYear);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 604,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 714,
    "kind": "method",
    "name": "isValidMonthDay",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isValidMonthDay",
    "access": "public",
    "description": "Checks if the month-day is valid for this year.\n\nThis method checks whether this year and the input month and day form\na valid date.",
    "lineNumber": 622,
    "params": [
      {
        "nullable": null,
        "types": [
          "MonthDay"
        ],
        "spread": false,
        "optional": false,
        "name": "monthDay",
        "description": "the month-day to validate, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the month and day are valid for this year"
    }
  },
  {
    "__docId__": 715,
    "kind": "method",
    "name": "length",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#length",
    "access": "public",
    "description": "Gets the length of this year in days.",
    "lineNumber": 631,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of this year in days, 365 or 366"
    },
    "params": []
  },
  {
    "__docId__": 716,
    "kind": "method",
    "name": "atDay",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#atDay",
    "access": "public",
    "description": "Combines this year with a day-of-year to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this year and the specified day-of-year.\n\nThe day-of-year value 366 is only valid in a leap year.",
    "lineNumber": 648,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date formed from this year and the specified date of year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day of year is zero or less, 366 or greater or equal\n to 366 and this is not a leap year"
      }
    ]
  },
  {
    "__docId__": 717,
    "kind": "method",
    "name": "atMonth",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#atMonth",
    "access": "public",
    "description": "function overloading for {@link Year.atMonth}\n\nif called with 1 arguments and first argument is instance of Month, then {@link Year.atMonthMonth} is executed.\n\nOtherwise {@link Year.atMonthNumber} is executed.",
    "lineNumber": 662,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{YearMonth}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Month",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthOrNumber",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 718,
    "kind": "method",
    "name": "atMonthMonth",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#atMonthMonth",
    "access": "public",
    "description": "Combines this year with a month to create a {@link YearMonth}.\n\nThis returns a {@link YearMonth} formed from this year and the specified month.\nAll possible combinations of year and month are valid.\n\nThis method can be used as part of a chain to produce a date:\n<pre>\n LocalDate date = year.atMonth(month).atDay(day);\n</pre>",
    "lineNumber": 684,
    "params": [
      {
        "nullable": null,
        "types": [
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the year-month formed from this year and the specified month, not null"
    }
  },
  {
    "__docId__": 719,
    "kind": "method",
    "name": "atMonthNumber",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#atMonthNumber",
    "access": "public",
    "description": "Combines this year with a month to create a {@link YearMonth}.\n\nThis returns a {@link YearMonth} formed from this year and the specified month.\nAll possible combinations of year and month are valid.\n\nThis method can be used as part of a chain to produce a date:\n<pre>\n LocalDate date = year.atMonth(month).atDay(day);\n</pre>",
    "lineNumber": 705,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to use, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the year-month formed from this year and the specified month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the month is invalid"
      }
    ]
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "atMonthDay",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#atMonthDay",
    "access": "public",
    "description": "Combines this year with a month-day to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this year and the specified month-day.\n\nA month-day of February 29th will be adjusted to February 28th in the resulting\ndate if the year is not a leap year.",
    "lineNumber": 721,
    "params": [
      {
        "nullable": null,
        "types": [
          "MonthDay"
        ],
        "spread": false,
        "optional": false,
        "name": "monthDay",
        "description": "the month-day to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date formed from this year and the specified month-day, not null"
    }
  },
  {
    "__docId__": 721,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#query",
    "access": "public",
    "description": "Queries this year using the specified query.\n\nThis queries this year using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 746,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 722,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#compareTo",
    "access": "public",
    "description": "Compares this year to another year.\n\nThe comparison is based on the value of the year.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 769,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 723,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isAfter",
    "access": "public",
    "description": "Is this year after the specified year.",
    "lineNumber": 781,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified year"
    }
  },
  {
    "__docId__": 724,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#isBefore",
    "access": "public",
    "description": "Is this year before the specified year.",
    "lineNumber": 793,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified year"
    }
  },
  {
    "__docId__": 725,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#format",
    "access": "public",
    "description": "Outputs this year as a string using the formatter.",
    "lineNumber": 805,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted year string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 726,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#equals",
    "access": "public",
    "description": "Checks if this year is equal to the specified {@link Year}.\n\nThe comparison is based on the value",
    "lineNumber": 819,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the other duration is equal to this one"
    }
  },
  {
    "__docId__": 727,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#toString",
    "access": "public",
    "description": "Outputs this year as a string.",
    "lineNumber": 833,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "a string representation of this year, not null"
    },
    "params": []
  },
  {
    "__docId__": 728,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 843,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 729,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/Year.js~Year",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/Year.js~Year#until",
    "access": "public",
    "description": "Calculates the amount of time until another temporal in terms of the specified unit.\nThis calculates the amount of time between two temporal objects in terms of a single {@link TemporalUnit}. The start and end points are this and the specified temporal. The end point is converted to be of the same type as the start point if different. The result will be negative if the end is before the start. For example, the amount in hours between two temporal objects can be calculated using `startTime.until(endTime, HOURS)`.\n\nThe calculation returns a whole number, representing the number of complete units between the two temporals. For example, the amount in hours between the times 11:30 and 13:29 will only be one hour as it is one minute short of two hours.\n\nThere are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use `TemporalUnit.between(Temporal, Temporal)`:\n\n<pre>\n   // these two lines are equivalent\n   temporal = start.until(end, unit);\n   temporal = unit.between(start, end);\n</pre>\n\nThe choice should be made based on which makes the code more readable.\nFor example, this method allows the number of days between two dates to be calculated:\n\n<pre>\n  daysBetween = start.until(end, DAYS);\n  // or alternatively\n  daysBetween = DAYS.between(start, end);\n</pre>\n\n### Implementation Requirements:\nImplementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of {@link ChronoUnit}. An {@link UnsupportedTemporalTypeException} must be thrown for {@link ChronoUnit} instances that are unsupported.\nIf the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.between(Temporal, Temporal)` passing this as the first argument and the converted input temporal as the second argument.\n\nIn summary, implementations must behave in a manner equivalent to this pseudo-code:\n\n<pre>\n  // convert the end temporal to the same type as this class\n  if (unit instanceof ChronoUnit) {\n    // if unit is supported, then calculate and return result\n    // else throw UnsupportedTemporalTypeException for unsupported units\n  }\n  return unit.between(this, convertedEndTemporal);\n</pre>\n\nNote that the unit's between method must only be invoked if the two temporal objects have exactly the same type evaluated by `getClass()`.\n\nImplementations must ensure that no observable state is altered when this read-only method is invoked.",
    "lineNumber": 896,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end temporal, exclusive, converted to be of the same type as this object, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the amount in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of time between this temporal object and the specified one in terms of the unit; positive if the specified object is later than this one, negative if it is earlier than this one"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the amount cannot be calculated, or the end temporal cannot be converted to the same type as this temporal"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException - if the unit is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 730,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/Year.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/Year.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/Year.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 921,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 731,
    "kind": "file",
    "name": "packages/core/src/YearConstants.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n/**\n * attempt to avoid dependency cycles... define all constants here and they could be used\n * so instead of using e.g. Year.MAX_VALUE we could use YearConstants.MAX_VALUE to avoid the cycle\n */\nexport class YearConstants {}\n\nexport function _init() {\n    /**\n     * The minimum supported year\n     */\n    YearConstants.MIN_VALUE = -999999;\n    /**\n     * The maximum supported year\n     */\n    YearConstants.MAX_VALUE = 999999;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/YearConstants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 732,
    "kind": "class",
    "name": "YearConstants",
    "memberof": "packages/core/src/YearConstants.js",
    "static": true,
    "longname": "packages/core/src/YearConstants.js~YearConstants",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/YearConstants.js",
    "importStyle": "{YearConstants}",
    "description": "attempt to avoid dependency cycles... define all constants here and they could be used\nso instead of using e.g. Year.MAX_VALUE we could use YearConstants.MAX_VALUE to avoid the cycle",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 733,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/YearConstants.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearConstants.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/YearConstants.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 734,
    "kind": "file",
    "name": "packages/core/src/YearMonth.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { requireNonNull, requireInstance } from './assert';\nimport { DateTimeException, UnsupportedTemporalTypeException } from './errors';\nimport { MathUtil } from './MathUtil';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { Clock } from './Clock';\nimport { DateTimeFormatterBuilder } from './format/DateTimeFormatterBuilder';\nimport { IsoChronology } from './chrono/IsoChronology';\nimport { LocalDate } from './LocalDate';\nimport { Month } from './Month';\nimport { SignStyle } from './format/SignStyle';\nimport { Temporal } from './temporal/Temporal';\nimport { TemporalField } from './temporal/TemporalField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { TemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalUnit } from './temporal/TemporalUnit';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { ValueRange } from './temporal/ValueRange';\nimport { Year } from './Year';\nimport { ZoneId } from './ZoneId';\n\n/**\n * A year-month in the ISO-8601 calendar system, such as `2007-12`.\n *\n * {@link YearMonth} is an immutable date-time object that represents the combination\n * of a year and month. Any field that can be derived from a year and month, such as\n * quarter-of-year, can be obtained.\n *\n * This class does not store or represent a day, time or time-zone.\n * For example, the value \"October 2007\" can be stored in a {@link YearMonth}.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class YearMonth extends Temporal {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.now}\n     *\n     * if called with 0 argument {@link YearMonth.now0} is executed,\n     *\n     * if called with 1 argument and first argument is an instance of ZoneId, then {@link YearMonth.nowZoneId} is executed,\n     *\n     * otherwise {@link YearMonth.nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @returns {YearMonth}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return YearMonth.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return YearMonth.nowZoneId(zoneIdOrClock);\n        } else {\n            return YearMonth.nowClock(zoneIdOrClock);\n        }\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the default time-zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current year-month.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {YearMonth} the current year-month using the system clock and default time-zone, not null\n     */\n    static now0() {\n        return YearMonth.nowClock(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year-month from the system clock in the specified time-zone.\n     *\n     * This will query the system clock (see {@link Clock#system}) to obtain the current year-month.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone  the zone ID to use, not null\n     * @return {YearMonth} the current year-month using the system clock, not null\n     */\n    static nowZoneId(zone) {\n        return YearMonth.nowClock(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year-month from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year-month.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using dependency injection.\n     *\n     * @param {Clock} clock  the clock to use, not null\n     * @return {YearMonth} the current year-month, not null\n     */\n    static nowClock(clock) {\n        const now = LocalDate.now(clock);\n        return YearMonth.of(now.year(), now.month());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.of}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.ofNumberMonth} is executed,\n     *\n     * otherwise {@link YearMonth.ofNumberNumber} is executed\n     *\n     * @param {!number} year\n     * @param {!(Month|number)} monthOrNumber\n     * @returns {YearMonth}\n     */\n    static of(year, monthOrNumber) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return YearMonth.ofNumberMonth(year, monthOrNumber);\n        } else {\n            return YearMonth.ofNumberNumber(year, monthOrNumber);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {Month} month  the month-of-year to represent, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    static ofNumberMonth(year, month) {\n        requireNonNull(month, 'month');\n        requireInstance(month, Month, 'month');\n        return YearMonth.ofNumberNumber(year, month.value());\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a year and month.\n     *\n     * @param {number} year  the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, from 1 (January) to 12 (December)\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if either field value is invalid\n     */\n    static ofNumberNumber(year, month) {\n        requireNonNull(year, 'year');\n        requireNonNull(month, 'month');\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link YearMonth} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link YearMonth}.\n     *\n     * The conversion extracts the {@link ChronoField#YEAR} and\n     * {@link ChronoField#MONTH_OF_YEAR} fields.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link YearMonth::from}.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to convert, not null\n     * @return {YearMonth} the year-month, not null\n     * @throws DateTimeException if unable to convert to a {@link YearMonth}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof YearMonth) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain YearMonth from TemporalAccessor: ${ \n                temporal}, type ${temporal && temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearMonth.parse}\n     *\n     * if called with 2 argument and first argument is an instance of Month, then {@link YearMonth.parseString} is executed,\n     *\n     * otherwise {@link YearMonth.parseStringFormatter} is executed\n     *\n     * @param {!(String)} text\n     * @param {?DateTimeFormatter} formatter\n     * @returns {YearMonth}\n     */\n    static parse(text, formatter) {\n        if (arguments.length === 1) {\n            return YearMonth.parseString(text);\n        } else {\n            return YearMonth.parseStringFormatter(text, formatter);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string such as `2007-12`.\n     *\n     * The string must represent a valid year-month.\n     * The format must be {@link yyyy-MM}.\n     * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.\n     *\n     * @param {String} text  the text to parse such as \"2007-12\", not null\n     * @return {YearMonth} the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseString(text) {\n        return YearMonth.parseStringFormatter(text, PARSER);\n    }\n\n    /**\n     * Obtains an instance of {@link YearMonth} from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year-month.\n     *\n     * @param {String} text  the text to parse, not null\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return the parsed year-month, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parseStringFormatter(text, formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, YearMonth.FROM);\n    }\n\n\n    /**\n     * Constructor.\n     *\n     * @param {number} year  the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} month  the month-of-year to represent, validated from 1 (January) to 12 (December)\n     * @private\n     */\n    constructor(year, month) {\n        super();\n        this._year = MathUtil.safeToInt(year);\n        this._month = MathUtil.safeToInt(month);\n    }\n\n    /**\n     * function overloading for {@link YearMonth.isSupported}\n     *\n     * if called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n     *\n     * otherwise {@link YearMonth.isSupportedUnit} is executed\n     *\n     * @param {!(TemporalField|ChronoUnit)} fieldOrUnit\n     * @returns {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    }\n\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year-month can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * The supported fields are:\n     *\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field  the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year-month, false if not\n     */\n    isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR ||\n                    field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year-month is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field === ChronoField.YEAR_OF_ERA) {\n            return (this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as an `int`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month, except {@link EPOCH_MONTH} which is too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-month as a `long`.\n     *\n     * This queries this year-month for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this year-month.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.MONTH_OF_YEAR: return this._month;\n                case ChronoField.PROLEPTIC_MONTH: return this._getProlepticMonth();\n                case ChronoField.YEAR_OF_ERA: return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR: return this._year;\n                case ChronoField.ERA: return (this._year < 1 ? 0 : 1);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    _getProlepticMonth() {\n        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), (this._month - 1));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #getMonth()\n     */\n    monthValue() {\n        return this._month;\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     */\n    month() {\n        return Month.of(this._month);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Checks if the day-of-month is valid for this year-month.\n     *\n     * This method checks whether this year and month and the input day form\n     * a valid date.\n     *\n     * @param {number} dayOfMonth  the day-of-month to validate, from 1 to 31, invalid value returns false\n     * @return {boolean} true if the day is valid for this year-month\n     */\n    isValidDay(dayOfMonth) {\n        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n    }\n\n    /**\n     * Returns the length of the month, taking account of the year.\n     *\n     * This returns the length of the month in days.\n     * For example, a date in January would return 31.\n     *\n     * @return {number} the length of the month in days, from 28 to 31\n     */\n    lengthOfMonth() {\n        return this.month().length(this.isLeapYear());\n    }\n\n    /**\n     * Returns the length of the year.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    /**\n     * function overloading for {@link YearMonth.with}\n     *\n     * if called with 1 argument, then {@link YearMonth.withAdjuster} is executed,\n     * otherwise {@link YearMonth.withFieldValue} is executed.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {?number} value nullable only of first argument is an instance of TemporalAdjuster\n     * @returns {YearMonth}\n     */\n    with(adjusterOrField, value) {\n        if (arguments.length === 1) {\n            return this._withAdjuster(adjusterOrField);\n        } else {\n            return this._withField(adjusterOrField, value);\n        }\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified field set to a new value.\n     *\n     * This returns a new {@link YearMonth}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year or month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     *\n     * * {@link MONTH_OF_YEAR} -\n     *   Returns a {@link YearMonth} with the specified month-of-year.\n     *   The year will be unchanged.\n     * * {@link PROLEPTIC_MONTH} -\n     *   Returns a {@link YearMonth} with the specified proleptic-month.\n     *   This completely replaces the year and month of this object.\n     * * {@link YEAR_OF_ERA} -\n     *   Returns a {@link YearMonth} with the specified year-of-era\n     *   The month and era will be unchanged.\n     * * {@link YEAR} -\n     *   Returns a {@link YearMonth} with the specified year.\n     *   The month will be unchanged.\n     * * {@link ERA} -\n     *   Returns a {@link YearMonth} with the specified era.\n     *   The month and year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a {@link DateTimeException} will be thrown.\n     *\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field  the field to set in the result, not null\n     * @param {number} newValue  the new value of the field in the result\n     * @return a {@link YearMonth} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            const f = field;\n            f.checkValidValue(newValue);\n            switch (f) {\n                case ChronoField.MONTH_OF_YEAR: return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH: return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA: return this.withYear((this._year < 1 ? 1 - newValue : newValue));\n                case ChronoField.YEAR: return this.withYear(newValue);\n                case ChronoField.ERA: return (this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link YearMonth} with the year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year  the year to set in the returned year-month, from MIN_YEAR to MAX_YEAR\n     * @return {YearMonth} based on this year-month with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        ChronoField.YEAR.checkValidValue(year);\n        return new YearMonth(year, this._month);\n    }\n\n    /**\n     * Returns a copy of this {@link YearMonth} with the month-of-year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month  the month-of-year to set in the returned year-month, from 1 (January) to 12 (December)\n     * @return {YearMonth} based on this year-month with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(this._year, month);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * @param {number} amountToAdd\n     * @param {TemporalUnit} unit\n     * @return {YearMonth} based on this year-month with the addition made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.MONTHS: return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS: return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA: return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS: return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd  the years to add, may be negative\n     * @return {YearMonth} based on this year-month with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return this.withYear(newYear);\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToAdd  the months to add, may be negative\n     * @return {YearMonth} based on this year-month with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        const monthCount = (this._year * 12) + (this._month - 1);\n        const calcMonths = monthCount + monthsToAdd;\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        const newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return new YearMonth(newYear, newMonth);\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this year-month with the specified period in years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract  the years to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this year-month with the specified period in months subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} monthsToSubtract  the months to subtract, may be negative\n     * @return {YearMonth} based on this year-month with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    minusMonths(monthsToSubtract) {\n        return (monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year-month using the specified query.\n     *\n     * This queries this year-month using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year-month.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year and month changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal#with}\n     * passing {@link ChronoField#PROLEPTIC_MONTH} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYearMonth.adjustInto(temporal);\n     *   temporal = temporal.with(thisYearMonth);\n     * </pre>\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal  the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, Temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n    }\n\n    /**\n     * Calculates the period between this year-month and another year-month in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two year-months in terms of a single unit.\n     * The start and end points are `this` and the specified year-month.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method must be a {@link YearMonth}.\n     * For example, the period in years between two year-months can be calculated\n     * using {@link startYearMonth.until}.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two year-months.\n     * For example, the period in decades between 2012-06 and 2032-05\n     * will only be one decade as it is one month short of two decades.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, YEARS);   // this method\n     *   dateTime.plus(YEARS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end year-month, which is converted to a {@link YearMonth}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this year-month and the end year-month\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        requireInstance(endExclusive, Temporal, 'endExclusive');\n        requireInstance(unit, TemporalUnit, 'unit');\n\n        const end = YearMonth.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();  // no overflow\n            switch (unit) {\n                case ChronoUnit.MONTHS: return monthsUntil;\n                case ChronoUnit.YEARS: return MathUtil.intDiv(monthsUntil, 12);\n                case ChronoUnit.DECADES: return MathUtil.intDiv(monthsUntil, 120);\n                case ChronoUnit.CENTURIES: return MathUtil.intDiv(monthsUntil, 1200);\n                case ChronoUnit.MILLENNIA: return MathUtil.intDiv(monthsUntil, 12000);\n                case ChronoUnit.ERAS: return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year-month with a day-of-month to create a {@link LocalDate}.\n     *\n     * This returns a {@link LocalDate} formed from this year-month and the specified day-of-month.\n     *\n     * The day-of-month value must be valid for the year-month.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atDay(day);\n     * </pre>\n     *\n     * @param {number} dayOfMonth  the day-of-month to use, from 1 to 31\n     * @return {LocalDate} the date formed from this year-month and the specified day, not null\n     * @throws DateTimeException if the day is invalid for the year-month\n     * @see #isValidDay(int)\n     */\n    atDay(dayOfMonth) {\n        requireNonNull(dayOfMonth, 'dayOfMonth');\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    }\n\n    /**\n     * Returns a {@link LocalDate} at the end of the month.\n     *\n     * This returns a {@link LocalDate} based on this year-month.\n     * The day-of-month is set to the last valid day of the month, taking\n     * into account leap years.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * <pre>\n     *  LocalDate date = year.atMonth(month).atEndOfMonth();\n     * </pre>\n     *\n     * @return {LocalDate} the last valid date of this year-month, not null\n     */\n    atEndOfMonth() {\n        return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year-month to another year-month.\n     *\n     * The comparison is based first on the value of the year, then on the value of the month.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, YearMonth, 'other');\n        let cmp = (this._year - other.year());\n        if (cmp === 0) {\n            cmp = (this._month - other.monthValue());\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this year-month after the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this is after the specified year-month\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this year-month before the specified year-month.\n     *\n     * @param {YearMonth} other  the other year-month to compare to, not null\n     * @return {boolean} true if this point is before the specified year-month\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this year-month is equal to another year-month.\n     *\n     * The comparison is based on the time-line position of the year-months.\n     *\n     * @param {*} obj  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other year-month\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearMonth) {\n            const other = obj;\n            return this.year() === other.year() && this.monthValue() === other.monthValue();\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this year-month as a string, such as `2007-12`.\n     *\n     * The output will be in the format {@link yyyy-MM}:\n     *\n     * @return {String} a string representation of this year-month, not null\n     */\n    toString() {\n        return PARSER.format(this);\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this year-month as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted year-month string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n}\n\nlet PARSER;\n\nexport function _init() {\n\n    PARSER = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .toFormatter();\n\n    YearMonth.FROM = createTemporalQuery('YearMonth.FROM', (temporal) => {\n        return YearMonth.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/YearMonth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 735,
    "kind": "class",
    "name": "YearMonth",
    "memberof": "packages/core/src/YearMonth.js",
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/YearMonth.js",
    "importStyle": "{YearMonth}",
    "description": "A year-month in the ISO-8601 calendar system, such as `2007-12`.\n\n{@link YearMonth} is an immutable date-time object that represents the combination\nof a year and month. Any field that can be derived from a year and month, such as\nquarter-of-year, can be obtained.\n\nThis class does not store or represent a day, time or time-zone.\nFor example, the value \"October 2007\" can be stored in a {@link YearMonth}.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\n### Specification for implementors\n\nThis class is immutable and thread-safe.",
    "lineNumber": 49,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 736,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.now",
    "access": "public",
    "description": "function overloading for {@link YearMonth.now}\n\nif called with 0 argument {@link YearMonth.now0} is executed,\n\nif called with 1 argument and first argument is an instance of ZoneId, then {@link YearMonth.nowZoneId} is executed,\n\notherwise {@link YearMonth.nowClock} is executed",
    "lineNumber": 63,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{YearMonth}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "now0",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.now0",
    "access": "public",
    "description": "Obtains the current year-month from the system clock in the default time-zone.\n\nThis will query the system clock (see {@link Clock#systemDefaultZone}) in the default\ntime-zone to obtain the current year-month.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 85,
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the current year-month using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 738,
    "kind": "method",
    "name": "nowZoneId",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.nowZoneId",
    "access": "public",
    "description": "Obtains the current year-month from the system clock in the specified time-zone.\n\nThis will query the system clock (see {@link Clock#system}) to obtain the current year-month.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the current year-month using the system clock, not null"
    }
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "nowClock",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.nowClock",
    "access": "public",
    "description": "Obtains the current year-month from the specified clock.\n\nThis will query the specified clock to obtain the current year-month.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using dependency injection.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the current year-month, not null"
    }
  },
  {
    "__docId__": 740,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.of",
    "access": "public",
    "description": "function overloading for {@link YearMonth.of}\n\nif called with 2 argument and first argument is an instance of Month, then {@link YearMonth.ofNumberMonth} is executed,\n\notherwise {@link YearMonth.ofNumberNumber} is executed",
    "lineNumber": 132,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{YearMonth}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "Month",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthOrNumber",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 741,
    "kind": "method",
    "name": "ofNumberMonth",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.ofNumberMonth",
    "access": "public",
    "description": "Obtains an instance of {@link YearMonth} from a year and month.",
    "lineNumber": 148,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "Month"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the year-month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 742,
    "kind": "method",
    "name": "ofNumberNumber",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.ofNumberNumber",
    "access": "public",
    "description": "Obtains an instance of {@link YearMonth} from a year and month.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the year-month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if either field value is invalid"
      }
    ]
  },
  {
    "__docId__": 743,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.from",
    "access": "public",
    "description": "Obtains an instance of {@link YearMonth} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link YearMonth}.\n\nThe conversion extracts the {@link ChronoField#YEAR} and\n{@link ChronoField#MONTH_OF_YEAR} fields.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link YearMonth::from}.",
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the year-month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link YearMonth}"
      }
    ]
  },
  {
    "__docId__": 744,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.parse",
    "access": "public",
    "description": "function overloading for {@link YearMonth.parse}\n\nif called with 2 argument and first argument is an instance of Month, then {@link YearMonth.parseString} is executed,\n\notherwise {@link YearMonth.parseStringFormatter} is executed",
    "lineNumber": 217,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{YearMonth}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 745,
    "kind": "method",
    "name": "parseString",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.parseString",
    "access": "public",
    "description": "Obtains an instance of {@link YearMonth} from a text string such as `2007-12`.\n\nThe string must represent a valid year-month.\nThe format must be {@link yyyy-MM}.\nYears outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse such as \"2007-12\", not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "the parsed year-month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 746,
    "kind": "method",
    "name": "parseStringFormatter",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~YearMonth.parseStringFormatter",
    "access": "public",
    "description": "Obtains an instance of {@link YearMonth} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a year-month.",
    "lineNumber": 250,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the parsed year-month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 747,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 263,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, validated from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, validated from 1 (January) to 12 (December)"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 748,
    "kind": "member",
    "name": "_year",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#_year",
    "access": "private",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 749,
    "kind": "member",
    "name": "_month",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#_month",
    "access": "private",
    "description": null,
    "lineNumber": 266,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 750,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isSupported",
    "access": "public",
    "description": "function overloading for {@link YearMonth.isSupported}\n\nif called with 1 argument and first argument is an instance of TemporalField, then {@link YearMonth.isSupportedField} is executed,\n\notherwise {@link YearMonth.isSupportedUnit} is executed",
    "lineNumber": 279,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField",
          "ChronoUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 751,
    "kind": "method",
    "name": "isSupportedField",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isSupportedField",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this year-month can be queried for the specified field.\nIf false, then calling {@link range} and {@link get} will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nThe supported fields are:\n\n* {@link MONTH_OF_YEAR}\n* {@link EPOCH_MONTH}\n* {@link YEAR_OF_ERA}\n* {@link YEAR}\n* {@link ERA}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 314,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this year-month, false if not"
    }
  },
  {
    "__docId__": 752,
    "kind": "method",
    "name": "isSupportedUnit",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isSupportedUnit",
    "access": "public",
    "description": null,
    "lineNumber": 322,
    "undocument": true,
    "params": [
      {
        "name": "unit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 753,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis year-month is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 351,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 754,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#get",
    "access": "public",
    "description": "Gets the value of the specified field from this year-month as an `int`.\n\nThis queries this year-month for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this year-month, except {@link EPOCH_MONTH} which is too\nlarge to fit in an `int` and throw a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 755,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this year-month as a `long`.\n\nThis queries this year-month for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this year-month.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 756,
    "kind": "method",
    "name": "_getProlepticMonth",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#_getProlepticMonth",
    "access": "private",
    "description": null,
    "lineNumber": 426,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 757,
    "kind": "method",
    "name": "year",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#year",
    "access": "public",
    "description": "Gets the year field.\n\nThis method returns the primitive `int` value for the year.\n\nThe year returned by this method is proleptic as per {@link get}.",
    "lineNumber": 440,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 758,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#monthValue",
    "access": "public",
    "description": "Gets the month-of-year field from 1 to 12.\n\nThis method returns the month as an `int` from 1 to 12.\nApplication code is frequently clearer if the enum {@link Month}\nis used by calling {@link getMonth}.",
    "see": [
      "#getMonth()"
    ],
    "lineNumber": 454,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 759,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#month",
    "access": "public",
    "description": "Gets the month-of-year field using the {@link Month} enum.\n\nThis method returns the enum {@link Month} for the month.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value, use {@link Month#getValue}.",
    "lineNumber": 467,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 760,
    "kind": "method",
    "name": "isLeapYear",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isLeapYear",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 490,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    },
    "params": []
  },
  {
    "__docId__": 761,
    "kind": "method",
    "name": "isValidDay",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isValidDay",
    "access": "public",
    "description": "Checks if the day-of-month is valid for this year-month.\n\nThis method checks whether this year and month and the input day form\na valid date.",
    "lineNumber": 503,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to validate, from 1 to 31, invalid value returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the day is valid for this year-month"
    }
  },
  {
    "__docId__": 762,
    "kind": "method",
    "name": "lengthOfMonth",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#lengthOfMonth",
    "access": "public",
    "description": "Returns the length of the month, taking account of the year.\n\nThis returns the length of the month in days.\nFor example, a date in January would return 31.",
    "lineNumber": 515,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of the month in days, from 28 to 31"
    },
    "params": []
  },
  {
    "__docId__": 763,
    "kind": "method",
    "name": "lengthOfYear",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#lengthOfYear",
    "access": "public",
    "description": "Returns the length of the year.\n\nThis returns the length of the year in days, either 365 or 366.",
    "lineNumber": 526,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "366 if the year is leap, 365 otherwise"
    },
    "params": []
  },
  {
    "__docId__": 764,
    "kind": "method",
    "name": "with",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#with",
    "access": "public",
    "description": "function overloading for {@link YearMonth.with}\n\nif called with 1 argument, then {@link YearMonth.withAdjuster} is executed,\notherwise {@link YearMonth.withFieldValue} is executed.",
    "lineNumber": 540,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{YearMonth}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAdjuster",
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "adjusterOrField",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "nullable only of first argument is an instance of TemporalAdjuster"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 765,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#_withField",
    "access": "private",
    "description": "Returns a copy of this year-month with the specified field set to a new value.\n\nThis returns a new {@link YearMonth}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year or month.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n\n* {@link MONTH_OF_YEAR} -\n  Returns a {@link YearMonth} with the specified month-of-year.\n  The year will be unchanged.\n* {@link PROLEPTIC_MONTH} -\n  Returns a {@link YearMonth} with the specified proleptic-month.\n  This completely replaces the year and month of this object.\n* {@link YEAR_OF_ERA} -\n  Returns a {@link YearMonth} with the specified year-of-era\n  The month and era will be unchanged.\n* {@link YEAR} -\n  Returns a {@link YearMonth} with the specified year.\n  The month will be unchanged.\n* {@link ERA} -\n  Returns a {@link YearMonth} with the specified era.\n  The month and year-of-era will be unchanged.\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a {@link DateTimeException} will be thrown.\n\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 594,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a {@link YearMonth} based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field cannot be set"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 766,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#withYear",
    "access": "public",
    "description": "Returns a copy of this {@link YearMonth} with the year altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 622,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the returned year-month, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 767,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#withMonth",
    "access": "public",
    "description": "Returns a copy of this {@link YearMonth} with the month-of-year altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 636,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the returned year-month, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#_plusUnit",
    "access": "private",
    "description": "",
    "lineNumber": 650,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the addition made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the addition cannot be made"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 769,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#plusYears",
    "access": "public",
    "description": "Returns a copy of this year-month with the specified period in years added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 676,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 770,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#plusMonths",
    "access": "public",
    "description": "Returns a copy of this year-month with the specified period in months added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 693,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToAdd",
        "description": "the months to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the months added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 771,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#minusYears",
    "access": "public",
    "description": "Returns a copy of this year-month with the specified period in years subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 715,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#minusMonths",
    "access": "public",
    "description": "Returns a copy of this year-month with the specified period in months subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 728,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthsToSubtract",
        "description": "the months to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearMonth"
      ],
      "spread": false,
      "description": "based on this year-month with the months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#query",
    "access": "public",
    "description": "Queries this year-month using the specified query.\n\nThis queries this year-month using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 750,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 774,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this year-month.\n\nThis returns a temporal object of the same observable type as the input\nwith the year and month changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField#PROLEPTIC_MONTH} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisYearMonth.adjustInto(temporal);\n  temporal = temporal.with(thisYearMonth);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 790,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 775,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#until",
    "access": "public",
    "description": "Calculates the period between this year-month and another year-month in\nterms of the specified unit.\n\nThis calculates the period between two year-months in terms of a single unit.\nThe start and end points are `this` and the specified year-month.\nThe result will be negative if the end is before the start.\nThe {@link Temporal} passed to this method must be a {@link YearMonth}.\nFor example, the period in years between two year-months can be calculated\nusing {@link startYearMonth.until}.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two year-months.\nFor example, the period in decades between 2012-06 and 2032-05\nwill only be one decade as it is one month short of two decades.\n\nThis method operates in association with {@link TemporalUnit#between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, YEARS);   // this method\n  dateTime.plus(YEARS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link MONTHS}, {@link YEARS}, {@link DECADES},\n{@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\nOther {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing `this` as the first argument and the input temporal as\nthe second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 843,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end year-month, which is converted to a {@link YearMonth}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this year-month and the end year-month"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be calculated"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 776,
    "kind": "method",
    "name": "atDay",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#atDay",
    "access": "public",
    "description": "Combines this year-month with a day-of-month to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this year-month and the specified day-of-month.\n\nThe day-of-month value must be valid for the year-month.\n\nThis method can be used as part of a chain to produce a date:\n<pre>\n LocalDate date = year.atMonth(month).atDay(day);\n</pre>",
    "see": [
      "#isValidDay(int)"
    ],
    "lineNumber": 883,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to use, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date formed from this year-month and the specified day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day is invalid for the year-month"
      }
    ]
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "atEndOfMonth",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#atEndOfMonth",
    "access": "public",
    "description": "Returns a {@link LocalDate} at the end of the month.\n\nThis returns a {@link LocalDate} based on this year-month.\nThe day-of-month is set to the last valid day of the month, taking\ninto account leap years.\n\nThis method can be used as part of a chain to produce a date:\n<pre>\n LocalDate date = year.atMonth(month).atEndOfMonth();\n</pre>",
    "lineNumber": 902,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the last valid date of this year-month, not null"
    },
    "params": []
  },
  {
    "__docId__": 778,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#compareTo",
    "access": "public",
    "description": "Compares this year-month to another year-month.\n\nThe comparison is based first on the value of the year, then on the value of the month.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 916,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-month to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 779,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isAfter",
    "access": "public",
    "description": "Is this year-month after the specified year-month.",
    "lineNumber": 932,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-month to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified year-month"
    }
  },
  {
    "__docId__": 780,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#isBefore",
    "access": "public",
    "description": "Is this year-month before the specified year-month.",
    "lineNumber": 942,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-month to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified year-month"
    }
  },
  {
    "__docId__": 781,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#equals",
    "access": "public",
    "description": "Checks if this year-month is equal to another year-month.\n\nThe comparison is based on the time-line position of the year-months.",
    "lineNumber": 955,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other year-month"
    }
  },
  {
    "__docId__": 782,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#toString",
    "access": "public",
    "description": "Outputs this year-month as a string, such as `2007-12`.\n\nThe output will be in the format {@link yyyy-MM}:",
    "lineNumber": 974,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "a string representation of this year-month, not null"
    },
    "params": []
  },
  {
    "__docId__": 783,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 984,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 784,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/YearMonth.js~YearMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/YearMonth.js~YearMonth#format",
    "access": "public",
    "description": "Outputs this year-month as a string using the formatter.",
    "lineNumber": 995,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted year-month string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 785,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/YearMonth.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/YearMonth.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/YearMonth.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1004,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 786,
    "kind": "file",
    "name": "packages/core/src/ZoneId.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from './assert';\nimport { DateTimeException } from './errors';\n\nimport { StringUtil } from './StringUtil';\n\nimport { Instant } from './Instant';\n\nexport class ZoneId {\n    /**\n     * Gets the system default time-zone.\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation');\n    }\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * This set includes the string form of all available region-based IDs.\n     * Offset-based zone IDs are not included in the returned set.\n     * The ID can be passed to {@link of} to create a {@link ZoneId}.\n     *\n     * The set of zone IDs can increase over time, although in a typical application\n     * the set of IDs is fixed. Each call to this method is thread-safe.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds() {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException('not supported operation');\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     *\n     * This method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\n     * A {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     *\n     * Parsing matches the zone ID step by step as follows.\n     *\n     * * If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n     * * If the zone ID consists of a single letter, the zone ID is invalid\n     *   and {@link DateTimeException} is thrown.\n     * * If the zone ID starts with '+' or '-', the ID is parsed as a\n     *   {@link ZoneOffset} using {@link ZoneOffset#of}.\n     * * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n     *   with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n     * * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *   then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *   a two or three letter prefix and a suffix starting with the sign.\n     *   The suffix is parsed as a {@link ZoneOffset}.\n     *   The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n     *   and the normalized offset ID as per {@link ZoneOffset#getId}.\n     *   The rules of the returned {@link ZoneId} will be equivalent to the\n     *   parsed {@link ZoneOffset}.\n     * * All other IDs are parsed as region-based zone IDs. Region IDs must\n     *   match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n     *   otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n     *   in the configured set of IDs, {@link ZoneRulesException} is thrown.\n     *   The detailed format of the region ID depends on the group supplying the data.\n     *   The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *   This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *   This is compatible with most IDs from {@link java.util.TimeZone}.\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException(`not supported operation${zoneId}`);\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} wrapping an offset.\n     *\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty `''` the {@link ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException(`not supported operation${prefix}${offset}`);\n    }\n\n\n    /**\n     * Obtains an instance of {@link ZoneId} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n     *\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@link ZoneId}\n     */\n    static from(temporal) {\n        // Find implementation at {@link ZoneIdFactory}\n        throw new DateTimeException(`not supported operation${temporal}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the unique time-zone ID.\n     *\n     * This ID uniquely defines this object.\n     * The format of an offset based ID is defined by {@link ZoneOffset#getId}.\n     *\n     * @return {String} the time-zone unique ID, not null\n     */\n    id(){\n        abstractMethodFail('ZoneId.id');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone rules for this ID allowing calculations to be performed.\n     *\n     * The rules provide the functionality associated with a time-zone,\n     * such as finding the offset for a given instant or local date-time.\n     *\n     * A time-zone can be invalid if it is deserialized in a Java Runtime which\n     * does not have the same rules loaded as the Java Runtime that stored it.\n     * In this case, calling this method will throw a {@link ZoneRulesException}.\n     *\n     * The rules are supplied by {@link ZoneRulesProvider}. An advanced provider may\n     * support dynamic updates to the rules without restarting the Java Runtime.\n     * If so, then the result of this method may change over time.\n     * Each individual call will be still remain thread-safe.\n     *\n     * {@link ZoneOffset} will always return a set of rules where the offset never changes.\n     *\n     * @return {!ZoneRules} the rules, not null\n     * @throws ZoneRulesException if no rules are available for this ID\n     */\n    rules(){\n        abstractMethodFail('ZoneId.rules');\n    }\n\n    /**\n      * Normalizes the time-zone ID, returning a {@link ZoneOffset} where possible.\n      *\n      * The returns a normalized {@link ZoneId} that can be used in place of this ID.\n      * The result will have {@link ZoneRules} equivalent to those returned by this object,\n      * however the ID returned by {@link getId} may be different.\n      *\n      * The normalization checks if the rules of this {@link ZoneId} have a fixed offset.\n      * If they do, then the {@link ZoneOffset} equal to that offset is returned.\n      * Otherwise `this` is returned.\n      *\n      * @return {ZoneId} the time-zone unique ID, not null\n      */\n    normalized() {\n        const rules = this.rules();\n        if (rules.isFixedOffset()) {\n            return rules.offset(Instant.EPOCH);\n        }\n        //try {\n        //} catch (ZoneRulesException ex) {\n        //    // ignore invalid objects\n        //}\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Checks if this time-zone ID is equal to another time-zone ID.\n      *\n      * The comparison is based on the ID.\n      *\n      * @param {*} other  the object to check, null returns false\n      * @return {boolean} true if this is equal to the other time-zone ID\n      */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZoneId) {\n            return this.id() === other.id();\n        }\n        return false;\n    }\n\n    /**\n      * A hash code for this time-zone ID.\n      *\n      * @return {number} a suitable hash code\n      */\n    hashCode() {\n        return StringUtil.hashCode(this.id());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Outputs this zone as a string, using the ID.\n      *\n      * @return {string} a string representation of this time-zone ID, not null\n      */\n    toString() {\n        return this.id();\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/ZoneId.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 787,
    "kind": "class",
    "name": "ZoneId",
    "memberof": "packages/core/src/ZoneId.js",
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneId.js",
    "importStyle": "{ZoneId}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 788,
    "kind": "method",
    "name": "systemDefault",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId.systemDefault",
    "access": "public",
    "description": "Gets the system default time-zone.",
    "lineNumber": 20,
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "params": []
  },
  {
    "__docId__": 789,
    "kind": "method",
    "name": "getAvailableZoneIds",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId.getAvailableZoneIds",
    "access": "public",
    "description": "Gets the set of available zone IDs.\n\nThis set includes the string form of all available region-based IDs.\nOffset-based zone IDs are not included in the returned set.\nThe ID can be passed to {@link of} to create a {@link ZoneId}.\n\nThe set of zone IDs can increase over time, although in a typical application\nthe set of IDs is fixed. Each call to this method is thread-safe.",
    "lineNumber": 37,
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "a modifiable copy of the set of zone IDs, not null"
    },
    "params": []
  },
  {
    "__docId__": 790,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId.of",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} from an ID ensuring that the\nID is valid and available for use.\n\nThis method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\nA {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\nThe result will always be a valid ID for which {@link ZoneRules} can be obtained.\n\nParsing matches the zone ID step by step as follows.\n\n* If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n* If the zone ID consists of a single letter, the zone ID is invalid\n  and {@link DateTimeException} is thrown.\n* If the zone ID starts with '+' or '-', the ID is parsed as a\n  {@link ZoneOffset} using {@link ZoneOffset#of}.\n* If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n  with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n* If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n  then the ID is a prefixed offset-based ID. The ID is split in two, with\n  a two or three letter prefix and a suffix starting with the sign.\n  The suffix is parsed as a {@link ZoneOffset}.\n  The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n  and the normalized offset ID as per {@link ZoneOffset#getId}.\n  The rules of the returned {@link ZoneId} will be equivalent to the\n  parsed {@link ZoneOffset}.\n* All other IDs are parsed as region-based zone IDs. Region IDs must\n  match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n  otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n  in the configured set of IDs, {@link ZoneRulesException} is thrown.\n  The detailed format of the region ID depends on the group supplying the data.\n  The default set of data is supplied by the IANA Time Zone Database (TZDB).\n  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n  This is compatible with most IDs from {@link java.util.TimeZone}.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": "the time-zone ID, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the zone ID has an invalid format"
      },
      {
        "types": [
          "*"
        ],
        "description": "ZoneRulesException if the zone ID is a region ID that cannot be found"
      }
    ]
  },
  {
    "__docId__": 791,
    "kind": "method",
    "name": "ofOffset",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId.ofOffset",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} wrapping an offset.\n\nIf the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\nwith the prefix and the non-zero offset is returned.\nIf the prefix is empty `''` the {@link ZoneOffset} is returned.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": "the time-zone ID, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the prefix is not one of\n    'GMT', 'UTC', or 'UT', or ''"
      }
    ]
  },
  {
    "__docId__": 792,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneId.js~ZoneId.from",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n\nThe conversion will try to obtain the zone in a way that favours region-based\nzones over offset-based zones using {@link TemporalQueries#zone}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link ZoneId::from}.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link ZoneId}"
      }
    ]
  },
  {
    "__docId__": 793,
    "kind": "method",
    "name": "id",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#id",
    "access": "public",
    "description": "Gets the unique time-zone ID.\n\nThis ID uniquely defines this object.\nThe format of an offset based ID is defined by {@link ZoneOffset#getId}.",
    "lineNumber": 135,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the time-zone unique ID, not null"
    },
    "params": []
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "rules",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#rules",
    "access": "public",
    "description": "Gets the time-zone rules for this ID allowing calculations to be performed.\n\nThe rules provide the functionality associated with a time-zone,\nsuch as finding the offset for a given instant or local date-time.\n\nA time-zone can be invalid if it is deserialized in a Java Runtime which\ndoes not have the same rules loaded as the Java Runtime that stored it.\nIn this case, calling this method will throw a {@link ZoneRulesException}.\n\nThe rules are supplied by {@link ZoneRulesProvider}. An advanced provider may\nsupport dynamic updates to the rules without restarting the Java Runtime.\nIf so, then the result of this method may change over time.\nEach individual call will be still remain thread-safe.\n\n{@link ZoneOffset} will always return a set of rules where the offset never changes.",
    "lineNumber": 160,
    "return": {
      "nullable": false,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": "the rules, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "ZoneRulesException if no rules are available for this ID"
      }
    ],
    "params": []
  },
  {
    "__docId__": 795,
    "kind": "method",
    "name": "normalized",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#normalized",
    "access": "public",
    "description": "Normalizes the time-zone ID, returning a {@link ZoneOffset} where possible.\n\nThe returns a normalized {@link ZoneId} that can be used in place of this ID.\nThe result will have {@link ZoneRules} equivalent to those returned by this object,\nhowever the ID returned by {@link getId} may be different.\n\nThe normalization checks if the rules of this {@link ZoneId} have a fixed offset.\nIf they do, then the {@link ZoneOffset} equal to that offset is returned.\nOtherwise `this` is returned.",
    "lineNumber": 177,
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the time-zone unique ID, not null"
    },
    "params": []
  },
  {
    "__docId__": 796,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#equals",
    "access": "public",
    "description": "Checks if this time-zone ID is equal to another time-zone ID.\n\nThe comparison is based on the ID.",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other time-zone ID"
    }
  },
  {
    "__docId__": 797,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#hashCode",
    "access": "public",
    "description": "A hash code for this time-zone ID.",
    "lineNumber": 213,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 798,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#toString",
    "access": "public",
    "description": "Outputs this zone as a string, using the ID.",
    "lineNumber": 223,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this time-zone ID, not null"
    },
    "params": []
  },
  {
    "__docId__": 799,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/ZoneId.js~ZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneId.js~ZoneId#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 233,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 800,
    "kind": "file",
    "name": "packages/core/src/ZoneIdFactory.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from './assert';\nimport { DateTimeException, IllegalArgumentException } from './errors';\nimport { StringUtil } from './StringUtil';\n\nimport { ZoneOffset } from './ZoneOffset';\nimport { ZoneRegion } from './ZoneRegion';\nimport { ZoneId } from './ZoneId';\n\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { SystemDefaultZoneId } from './zone/SystemDefaultZoneId';\nimport { ZoneRulesProvider } from './zone/ZoneRulesProvider';\n\n/**\n * @see {@link ZoneId}\n *\n * Helper class to avoid dependency cycles.\n * Static methods of the class ZoneIdFactory are added automatically to class ZoneId.\n * @private\n */\nexport class ZoneIdFactory {\n\n    /**\n     * Gets the system default time-zone.\n     *\n     *\n     * @return {ZoneId} the zone ID, not null\n     */\n    static systemDefault() {\n        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    }\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * This set includes the string form of all available region-based IDs.\n     * Offset-based zone IDs are not included in the returned set.\n     * The ID can be passed to {@link of} to create a {@link ZoneId}.\n     *\n     * The set of zone IDs can increase over time, although in a typical application\n     * the set of IDs is fixed. Each call to this method is thread-safe.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds() {\n        return ZoneRulesProvider.getAvailableZoneIds();\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} from an ID ensuring that the\n     * ID is valid and available for use.\n     *\n     * This method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\n     * A {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\n     * The result will always be a valid ID for which {@link ZoneRules} can be obtained.\n     *\n     * Parsing matches the zone ID step by step as follows.\n     *\n     * * If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n     * * If the zone ID consists of a single letter, the zone ID is invalid\n     *   and {@link DateTimeException} is thrown.\n     * * If the zone ID starts with '+' or '-', the ID is parsed as a\n     *   {@link ZoneOffset} using {@link ZoneOffset#of}.\n     * * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n     *   with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n     * * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n     *   then the ID is a prefixed offset-based ID. The ID is split in two, with\n     *   a two or three letter prefix and a suffix starting with the sign.\n     *   The suffix is parsed as a {@link ZoneOffset}.\n     *   The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n     *   and the normalized offset ID as per {@link ZoneOffset#getId}.\n     *   The rules of the returned {@link ZoneId} will be equivalent to the\n     *   parsed {@link ZoneOffset}.\n     * * All other IDs are parsed as region-based zone IDs. Region IDs must\n     *   match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n     *   otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n     *   in the configured set of IDs, {@link ZoneRulesException} is thrown.\n     *   The detailed format of the region ID depends on the group supplying the data.\n     *   The default set of data is supplied by the IANA Time Zone Database (TZDB).\n     *   This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n     *   This is compatible with most IDs from {@link java.util.TimeZone}.\n     *\n     * @param {string} zoneId  the time-zone ID, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if the zone ID has an invalid format\n     * @throws ZoneRulesException if the zone ID is a region ID that cannot be found\n     */\n    static of(zoneId) {\n        requireNonNull(zoneId, 'zoneId');\n        if (zoneId === 'Z') {\n            return ZoneOffset.UTC;\n        }\n        if (zoneId.length === 1) {\n            throw new DateTimeException(`Invalid zone: ${zoneId}`);\n        }\n        if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n            return ZoneOffset.of(zoneId);\n        }\n        if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') ||\n                StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n            const offset = ZoneOffset.of(zoneId.substring(3));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n            }\n            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n        }\n        if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n            const offset = ZoneOffset.of(zoneId.substring(2));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion('UT', offset.rules());\n            }\n            return new ZoneRegion(`UT${offset.id()}`, offset.rules());\n        }\n        // javascript special case\n        if(zoneId === 'SYSTEM'){\n            return ZoneId.systemDefault();\n        }\n        return ZoneRegion.ofId(zoneId);\n    }\n\n    /**\n     * Obtains an instance of {@link ZoneId} wrapping an offset.\n     *\n     * If the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\n     * with the prefix and the non-zero offset is returned.\n     * If the prefix is empty `''` the {@link ZoneOffset} is returned.\n     *\n     * @param {string} prefix  the time-zone ID, not null\n     * @param {ZoneOffset} offset  the offset, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws IllegalArgumentException if the prefix is not one of\n     *     'GMT', 'UTC', or 'UT', or ''\n     */\n    static ofOffset(prefix, offset) {\n        requireNonNull(prefix, 'prefix');\n        requireNonNull(offset, 'offset');\n        if (prefix.length === 0) {\n            return offset;\n        }\n        if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(prefix, offset.rules());\n            }\n            return new ZoneRegion(prefix + offset.id(), offset.rules());\n        }\n        throw new IllegalArgumentException(`Invalid prefix, must be GMT, UTC or UT: ${prefix}`);\n    }\n\n\n    /**\n     * Obtains an instance of {@link ZoneId} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n     *\n     * The conversion will try to obtain the zone in a way that favours region-based\n     * zones over offset-based zones using {@link TemporalQueries#zone}.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZoneId::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZoneId} the zone ID, not null\n     * @throws DateTimeException if unable to convert to a {@link ZoneId}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        const obj = temporal.query(TemporalQueries.zone());\n        if (obj == null) {\n            throw new DateTimeException(`Unable to obtain ZoneId from TemporalAccessor: ${ \n                temporal}, type ${temporal.constructor != null ? temporal.constructor.name : ''}`);\n        }\n        return obj;\n    }\n}\n\nlet SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\n\nexport function _init(){\n    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n\n    // a bit magic to stay a bit more to the threeten bp impl.\n    ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n    ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n    ZoneId.of = ZoneIdFactory.of;\n    ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n    ZoneId.from = ZoneIdFactory.from;\n    ZoneOffset.from = ZoneIdFactory.from;\n\n    // short cut\n    ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/ZoneIdFactory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 801,
    "kind": "class",
    "name": "ZoneIdFactory",
    "memberof": "packages/core/src/ZoneIdFactory.js",
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneIdFactory.js",
    "importStyle": "{ZoneIdFactory}",
    "description": "",
    "see": [
      "{@link ZoneId}\n\nHelper class to avoid dependency cycles.\nStatic methods of the class ZoneIdFactory are added automatically to class ZoneId."
    ],
    "lineNumber": 26,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 802,
    "kind": "method",
    "name": "systemDefault",
    "memberof": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory.systemDefault",
    "access": "public",
    "description": "Gets the system default time-zone.",
    "lineNumber": 34,
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "params": []
  },
  {
    "__docId__": 803,
    "kind": "method",
    "name": "getAvailableZoneIds",
    "memberof": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory.getAvailableZoneIds",
    "access": "public",
    "description": "Gets the set of available zone IDs.\n\nThis set includes the string form of all available region-based IDs.\nOffset-based zone IDs are not included in the returned set.\nThe ID can be passed to {@link of} to create a {@link ZoneId}.\n\nThe set of zone IDs can increase over time, although in a typical application\nthe set of IDs is fixed. Each call to this method is thread-safe.",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "a modifiable copy of the set of zone IDs, not null"
    },
    "params": []
  },
  {
    "__docId__": 804,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory.of",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} from an ID ensuring that the\nID is valid and available for use.\n\nThis method parses the ID producing a {@link ZoneId} or {@link ZoneOffset}.\nA {@link ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.\nThe result will always be a valid ID for which {@link ZoneRules} can be obtained.\n\nParsing matches the zone ID step by step as follows.\n\n* If the zone ID equals 'Z', the result is {@link ZoneOffset.UTC}.\n* If the zone ID consists of a single letter, the zone ID is invalid\n  and {@link DateTimeException} is thrown.\n* If the zone ID starts with '+' or '-', the ID is parsed as a\n  {@link ZoneOffset} using {@link ZoneOffset#of}.\n* If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@link ZoneId}\n  with the same ID and rules equivalent to {@link ZoneOffset.UTC}.\n* If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'\n  then the ID is a prefixed offset-based ID. The ID is split in two, with\n  a two or three letter prefix and a suffix starting with the sign.\n  The suffix is parsed as a {@link ZoneOffset}.\n  The result will be a {@link ZoneId} with the specified UTC/GMT/UT prefix\n  and the normalized offset ID as per {@link ZoneOffset#getId}.\n  The rules of the returned {@link ZoneId} will be equivalent to the\n  parsed {@link ZoneOffset}.\n* All other IDs are parsed as region-based zone IDs. Region IDs must\n  match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`,\n  otherwise a {@link DateTimeException} is thrown. If the zone ID is not\n  in the configured set of IDs, {@link ZoneRulesException} is thrown.\n  The detailed format of the region ID depends on the group supplying the data.\n  The default set of data is supplied by the IANA Time Zone Database (TZDB).\n  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.\n  This is compatible with most IDs from {@link java.util.TimeZone}.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": "the time-zone ID, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the zone ID has an invalid format"
      },
      {
        "types": [
          "*"
        ],
        "description": "ZoneRulesException if the zone ID is a region ID that cannot be found"
      }
    ]
  },
  {
    "__docId__": 805,
    "kind": "method",
    "name": "ofOffset",
    "memberof": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory.ofOffset",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} wrapping an offset.\n\nIf the prefix is 'GMT', 'UTC', or 'UT' a {@link ZoneId}\nwith the prefix and the non-zero offset is returned.\nIf the prefix is empty `''` the {@link ZoneOffset} is returned.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": "the time-zone ID, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the prefix is not one of\n    'GMT', 'UTC', or 'UT', or ''"
      }
    ]
  },
  {
    "__docId__": 806,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~ZoneIdFactory.from",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneId} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link ZoneId}.\n\nThe conversion will try to obtain the zone in a way that favours region-based\nzones over offset-based zones using {@link TemporalQueries#zone}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link ZoneId::from}.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the zone ID, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to a {@link ZoneId}"
      }
    ]
  },
  {
    "__docId__": 807,
    "kind": "variable",
    "name": "SYSTEM_DEFAULT_ZONE_ID_INSTANCE",
    "memberof": "packages/core/src/ZoneIdFactory.js",
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~SYSTEM_DEFAULT_ZONE_ID_INSTANCE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/ZoneIdFactory.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 808,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/ZoneIdFactory.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneIdFactory.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneIdFactory.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 809,
    "kind": "file",
    "name": "packages/core/src/ZoneOffset.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from './assert';\nimport { DateTimeException } from './errors';\nimport { MathUtil } from './MathUtil';\n\nimport { LocalTime } from './LocalTime';\nimport { ZoneId } from './ZoneId';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\n\nimport { ZoneRules } from './zone/ZoneRules';\n\nconst SECONDS_CACHE = {};\nconst ID_CACHE = {};\n\n/**\n *\n * ### Static properties of Class {@link LocalDate}\n *\n * ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n *\n * ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n *\n * ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n *\n * ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n *\n */\nexport class ZoneOffset extends ZoneId {\n    /**\n     *\n     * @param {number} totalSeconds\n     * @private\n     */\n    constructor(totalSeconds){\n        super();\n        ZoneOffset._validateTotalSeconds(totalSeconds);\n        this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n        this._rules = ZoneRules.of(this);\n        this._id = ZoneOffset._buildId(totalSeconds);\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    totalSeconds() {\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {string}\n     */\n    static _buildId(totalSeconds) {\n        if (totalSeconds === 0) {\n            return 'Z';\n        } else {\n            const absTotalSeconds = Math.abs(totalSeconds);\n            const absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n            const absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n            let buf = `${totalSeconds < 0 ? '-' : '+'\n            }${absHours < 10 ? '0' : ''}${absHours\n            }${absMinutes < 10 ? ':0' : ':'}${absMinutes}`;\n            const absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n            if (absSeconds !== 0) {\n                buf += (absSeconds < 10 ? ':0' : ':') + (absSeconds);\n            }\n            return buf;\n        }\n    }\n\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @private\n     */\n    static _validateTotalSeconds(totalSeconds){\n        if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @private\n     */\n    static _validate(hours, minutes, seconds) {\n        if (hours < -18 || hours > 18) {\n            throw new DateTimeException(`Zone offset hours not in valid range: value ${hours \n            } is not in the range -18 to 18`);\n        }\n        if (hours > 0) {\n            if (minutes < 0 || seconds < 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n            }\n        } else if (hours < 0) {\n            if (minutes > 0 || seconds > 0) {\n                throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n            }\n        } else if ((minutes > 0 && seconds < 0) || (minutes < 0 && seconds > 0)) {\n            throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n        }\n        if (Math.abs(minutes) > 59) {\n            throw new DateTimeException(`Zone offset minutes not in valid range: abs(value) ${ \n                Math.abs(minutes)} is not in the range 0 to 59`);\n        }\n        if (Math.abs(seconds) > 59) {\n            throw new DateTimeException(`Zone offset seconds not in valid range: abs(value) ${ \n                Math.abs(seconds)} is not in the range 0 to 59`);\n        }\n        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n            throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZoneOffset} using the ID.\n     *\n     * This method parses the string ID of a {@link ZoneOffset} to\n     * return an instance. The parsing accepts all the formats generated by\n     * {@link getId}, plus some additional formats:\n     *\n     * * {@link Z} - for UTC\n     * * `+h`\n     * * `+hh`\n     * * `+hh:mm`\n     * * `-hh:mm`\n     * * `+hhmm`\n     * * `-hhmm`\n     * * `+hh:mm:ss`\n     * * `-hh:mm:ss`\n     * * `+hhmmss`\n     * * `-hhmmss`\n     *\n     * Note that &plusmn; means either the plus or minus symbol.\n     *\n     * The ID of the returned offset will be normalized to one of the formats\n     * described by {@link getId}.\n     *\n     * The maximum supported range is from +18:00 to -18:00 inclusive.\n     *\n     * @param {string} offsetId  the offset ID, not null\n     * @return {ZoneOffset} the zone-offset, not null\n     * @throws DateTimeException if the offset ID is invalid\n     */\n    static of(offsetId) {\n        requireNonNull(offsetId, 'offsetId');\n        // \"Z\" is always in the cache\n        const offset = ID_CACHE[offsetId];\n        if (offset != null) {\n            return offset;\n        }\n\n        // parse - +h, +hh, +hhmm, +hh:mm, +hhmmss, +hh:mm:ss\n        let hours, minutes, seconds;\n        switch (offsetId.length) {\n            case 2:\n                offsetId = `${offsetId[0]}0${offsetId[1]}`;  // fallthru\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = 0;\n                seconds = 0;\n                break;\n            case 5:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = 0;\n                break;\n            case 6:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = 0;\n                break;\n            case 7:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n                break;\n            case 9:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n                break;\n            default:\n                throw new DateTimeException(`Invalid ID for ZoneOffset, invalid format: ${offsetId}`);\n        }\n        const first = offsetId[0];\n        if (first !== '+' && first !== '-') {\n            throw new DateTimeException(`Invalid ID for ZoneOffset, plus/minus not found when expected: ${offsetId}`);\n        }\n        if (first === '-') {\n            return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n        } else {\n            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n        }\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {string} offsetId - the offset ID, not null\n     * @param {number} pos - the position to parse, valid\n     * @param {boolean} precededByColon - should this number be prefixed by a precededByColon\n     * @return {number} the parsed number, from 0 to 99\n     */\n    static _parseNumber(offsetId, pos, precededByColon) {\n        if (precededByColon && offsetId[pos - 1] !== ':') {\n            throw new DateTimeException(`Invalid ID for ZoneOffset, colon not found when expected: ${offsetId}`);\n        }\n        const ch1 = offsetId[pos];\n        const ch2 = offsetId[pos + 1];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            throw new DateTimeException(`Invalid ID for ZoneOffset, non numeric characters found: ${offsetId}`);\n        }\n        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @returns {ZoneOffset}\n     */\n    static ofHours(hours) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutes(hours, minutes) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n    }\n\n    /**\n     *\n     * @param {number} hours\n     * @param {number} minutes\n     * @param {number} seconds\n     * @returns {ZoneOffset}\n     */\n    static ofHoursMinutesSeconds(hours, minutes, seconds) {\n        ZoneOffset._validate(hours, minutes, seconds);\n        const totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalMinutes\n     * @returns {ZoneOffset}\n     */\n    static ofTotalMinutes(totalMinutes) {\n        const totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    }\n\n    /**\n     *\n     * @param {number} totalSeconds\n     * @returns {ZoneOffset}\n     */\n    static ofTotalSeconds(totalSeconds) {\n        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n            const totalSecs = totalSeconds;\n            let result = SECONDS_CACHE[totalSecs];\n            if (result == null) {\n                result = new ZoneOffset(totalSeconds);\n                SECONDS_CACHE[totalSecs] = result;\n                ID_CACHE[result.id()] = result;\n            }\n            return result;\n        } else {\n            return new ZoneOffset(totalSeconds);\n        }\n    }\n\n    /**\n     * Gets the associated time-zone rules.\n     *\n     * The rules will always return this offset when queried.\n     * The implementation class is immutable, thread-safe and serializable.\n     *\n     * @return {ZoneRules} the rules, not null\n     */\n    rules() {\n        return this._rules;\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as an `int`.\n      *\n      * This queries this offset for the value for the specified field.\n      * The returned value will always be within the valid range of values for the field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n      * Gets the value of the specified field from this offset as a `long`.\n      *\n      * This queries this offset for the value for the specified field.\n      * If it is not possible to return the value, because the field is not supported\n      * or for some other reason, an exception is thrown.\n      *\n      * If the field is a {@link ChronoField} then the query is implemented here.\n      * The {@link OFFSET_SECONDS} field returns the value of the offset.\n      * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n      *\n      * If the field is not a {@link ChronoField}, then the result of this method\n      * is obtained by invoking {@link TemporalField.getFrom}\n      * passing `this` as the argument. Whether the value can be obtained,\n      * and what the value represents, is determined by the field.\n      *\n      * @param {TemporalField} field - the field to get, not null\n      * @return {number} the value for the field\n      * @throws DateTimeException if a value for the field cannot be obtained\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    getLong(field) {\n        if (field === ChronoField.OFFSET_SECONDS) {\n            return this._totalSeconds;\n        } else if (field instanceof ChronoField) {\n            throw new DateTimeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n      * Queries this offset using the specified query.\n      *\n      * This queries this offset using the specified query strategy object.\n      * The {@link TemporalQuery} object defines the logic to be used to\n      * obtain the result. Read the documentation of the query to understand\n      * what the result of this method will be.\n      *\n      * The result of this method is obtained by invoking the\n      * {@link TemporalQuery#queryFrom} method on the\n      * specified query passing `this` as the argument.\n      *\n      * @param {TemporalQuery} query - the query to invoke, not null\n      * @return {*} the query result, null may be returned (defined by the query)\n      * @throws DateTimeException if unable to query (defined by the query)\n      * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n      */\n    query(query) {\n        requireNonNull(query, 'query');\n        if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this;\n        } else if (query === TemporalQueries.localDate() || query === TemporalQueries.localTime() ||\n                 query === TemporalQueries.precision() || query === TemporalQueries.chronology() || query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n      * Adjusts the specified temporal object to have the same offset as this object.\n      *\n      * This returns a temporal object of the same observable type as the input\n      * with the offset changed to be the same as this.\n      *\n      * The adjustment is equivalent to using {@link Temporal#with}\n      * passing {@link ChronoField#OFFSET_SECONDS} as the field.\n      *\n      * In most cases, it is clearer to reverse the calling pattern by using\n      * {@link Temporal#with}:\n      * <pre>\n      *   // these two lines are equivalent, but the second approach is recommended\n      *   temporal = thisOffset.adjustInto(temporal);\n      *   temporal = temporal.with(thisOffset);\n      * </pre>\n      *\n      * This instance is immutable and unaffected by this method call.\n      *\n      * @param {Temporal} temporal - the target object to be adjusted, not null\n      * @return {Temporal} the adjusted object, not null\n      * @throws DateTimeException if unable to make the adjustment\n      * @throws ArithmeticException if numeric overflow occurs\n      */\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n    }\n\n    /**\n     * Compares this offset to another offset in descending order.\n     *\n     * The offsets are compared in the order that they occur for the same time\n     * of day around the world. Thus, an offset of `+10:00` comes before an\n     * offset of `+09:00` and so on down to `-18:00`.\n     *\n     * The comparison is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {!ZoneOffset} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     * @throws NullPointerException if {@link other} is null\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        return other._totalSeconds - this._totalSeconds;\n    }\n\n\n    /**\n     * Checks if this offset is equal to another offset.\n     *\n     * The comparison is based on the amount of the offset in seconds.\n     * This is equivalent to a comparison by ID.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other offset\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof ZoneOffset) {\n            return this._totalSeconds === obj._totalSeconds;\n        }\n        return false;\n    }\n\n    /**\n     * @return {number}\n     */\n    hashCode(){\n        return this._totalSeconds;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString(){\n        return this._id;\n    }\n}\n\nexport function _init() {\n    ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n    ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n    ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n    ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/ZoneOffset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 810,
    "kind": "variable",
    "name": "SECONDS_CACHE",
    "memberof": "packages/core/src/ZoneOffset.js",
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~SECONDS_CACHE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/ZoneOffset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 811,
    "kind": "variable",
    "name": "ID_CACHE",
    "memberof": "packages/core/src/ZoneOffset.js",
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ID_CACHE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/ZoneOffset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 812,
    "kind": "class",
    "name": "ZoneOffset",
    "memberof": "packages/core/src/ZoneOffset.js",
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneOffset.js",
    "importStyle": "{ZoneOffset}",
    "description": "\n### Static properties of Class {@link LocalDate}\n\nZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n\nZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n\nZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n\nZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);",
    "lineNumber": 35,
    "interface": false,
    "extends": [
      "packages/core/src/ZoneId.js~ZoneId"
    ]
  },
  {
    "__docId__": 813,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalSeconds",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 814,
    "kind": "member",
    "name": "_totalSeconds",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#_totalSeconds",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 815,
    "kind": "member",
    "name": "_rules",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#_rules",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 816,
    "kind": "member",
    "name": "_id",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#_id",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 817,
    "kind": "method",
    "name": "totalSeconds",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#totalSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 818,
    "kind": "method",
    "name": "id",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#id",
    "access": "public",
    "description": "",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 819,
    "kind": "method",
    "name": "_buildId",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset._buildId",
    "access": "private",
    "description": "",
    "lineNumber": 70,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalSeconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 820,
    "kind": "method",
    "name": "_validateTotalSeconds",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset._validateTotalSeconds",
    "access": "private",
    "description": "",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalSeconds",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 821,
    "kind": "method",
    "name": "_validate",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset._validate",
    "access": "private",
    "description": "",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 822,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.of",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneOffset} using the ID.\n\nThis method parses the string ID of a {@link ZoneOffset} to\nreturn an instance. The parsing accepts all the formats generated by\n{@link getId}, plus some additional formats:\n\n* {@link Z} - for UTC\n* `+h`\n* `+hh`\n* `+hh:mm`\n* `-hh:mm`\n* `+hhmm`\n* `-hhmm`\n* `+hh:mm:ss`\n* `-hh:mm:ss`\n* `+hhmmss`\n* `-hhmmss`\n\nNote that &plusmn; means either the plus or minus symbol.\n\nThe ID of the returned offset will be normalized to one of the formats\ndescribed by {@link getId}.\n\nThe maximum supported range is from +18:00 to -18:00 inclusive.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetId",
        "description": "the offset ID, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the zone-offset, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the offset ID is invalid"
      }
    ]
  },
  {
    "__docId__": 823,
    "kind": "method",
    "name": "_parseNumber",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset._parseNumber",
    "access": "private",
    "description": "Parse a two digit zero-prefixed number.",
    "lineNumber": 228,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetId",
        "description": "the offset ID, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "the position to parse, valid"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "precededByColon",
        "description": "should this number be prefixed by a precededByColon"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the parsed number, from 0 to 99"
    },
    "ignore": true
  },
  {
    "__docId__": 824,
    "kind": "method",
    "name": "ofHours",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.ofHours",
    "access": "public",
    "description": "",
    "lineNumber": 245,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 825,
    "kind": "method",
    "name": "ofHoursMinutes",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.ofHoursMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 255,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 826,
    "kind": "method",
    "name": "ofHoursMinutesSeconds",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.ofHoursMinutesSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 266,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 827,
    "kind": "method",
    "name": "ofTotalMinutes",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.ofTotalMinutes",
    "access": "public",
    "description": "",
    "lineNumber": 277,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalMinutes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 828,
    "kind": "method",
    "name": "ofTotalSeconds",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset.ofTotalSeconds",
    "access": "public",
    "description": "",
    "lineNumber": 287,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "totalSeconds",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 829,
    "kind": "method",
    "name": "rules",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#rules",
    "access": "public",
    "description": "Gets the associated time-zone rules.\n\nThe rules will always return this offset when queried.\nThe implementation class is immutable, thread-safe and serializable.",
    "lineNumber": 310,
    "return": {
      "nullable": null,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": "the rules, not null"
    },
    "params": []
  },
  {
    "__docId__": 830,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#get",
    "access": "public",
    "description": "Gets the value of the specified field from this offset as an `int`.\n\nThis queries this offset for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link OFFSET_SECONDS} field returns the value of the offset.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 336,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 831,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this offset as a `long`.\n\nThis queries this offset for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link OFFSET_SECONDS} field returns the value of the offset.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 361,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 832,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#query",
    "access": "public",
    "description": "Queries this offset using the specified query.\n\nThis queries this offset using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 388,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 833,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have the same offset as this object.\n\nThis returns a temporal object of the same observable type as the input\nwith the offset changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal#with}\npassing {@link ChronoField#OFFSET_SECONDS} as the field.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisOffset.adjustInto(temporal);\n  temporal = temporal.with(thisOffset);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 834,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#compareTo",
    "access": "public",
    "description": "Compares this offset to another offset in descending order.\n\nThe offsets are compared in the order that they occur for the same time\nof day around the world. Thus, an offset of `+10:00` comes before an\noffset of `+09:00` and so on down to `-18:00`.\n\nThe comparison is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 440,
    "params": [
      {
        "nullable": false,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NullPointerException if {@link other} is null"
      }
    ]
  },
  {
    "__docId__": 835,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#equals",
    "access": "public",
    "description": "Checks if this offset is equal to another offset.\n\nThe comparison is based on the amount of the offset in seconds.\nThis is equivalent to a comparison by ID.",
    "lineNumber": 455,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other offset"
    }
  },
  {
    "__docId__": 836,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#hashCode",
    "access": "public",
    "description": "",
    "lineNumber": 468,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 837,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/ZoneOffset.js~ZoneOffset",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneOffset.js~ZoneOffset#toString",
    "access": "public",
    "description": "",
    "lineNumber": 476,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 838,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/ZoneOffset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneOffset.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneOffset.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 481,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 839,
    "kind": "file",
    "name": "packages/core/src/ZoneRegion.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n\nimport { ZoneId } from './ZoneId';\nimport { ZoneRulesProvider } from './zone/ZoneRulesProvider';\n\n/**\n * A geographical region where the same time-zone rules apply.\n *\n * Time-zone information is categorized as a set of rules defining when and\n * how the offset from UTC/Greenwich changes. These rules are accessed using\n * identifiers based on geographical regions, such as countries or states.\n * The most common region classification is the Time Zone Database (TZDB),\n * which defines regions such as 'Europe/Paris' and 'Asia/Tokyo'.\n *\n * The region identifier, modeled by this class, is distinct from the\n * underlying rules, modeled by {@link ZoneRules}.\n * The rules are defined by governments and change frequently.\n * By contrast, the region identifier is well-defined and long-lived.\n * This separation also allows rules to be shared between regions if appropriate.\n *\n * ### Specification for implementors\n *\n * This class is immutable and thread-safe.\n */\nexport class ZoneRegion extends ZoneId {\n    /**\n     * @param {string} zoneId\n     * @return {ZoneId}\n     */\n    static ofId(zoneId){\n        const rules = ZoneRulesProvider.getRules(zoneId);\n        return new ZoneRegion(zoneId, rules);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {string} id  the time-zone ID, not null\n     * @param {ZoneRules} rules  the rules, null for lazy lookup\n     * @private\n     */\n    constructor(id, rules) {\n        super();\n        this._id = id;\n        this._rules = rules;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @returns {string}\n     */\n    id() {\n        return this._id;\n    }\n\n    /**\n     *\n     * @returns {ZoneRules}\n     */\n    rules() {\n        return this._rules;\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/ZoneRegion.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 840,
    "kind": "class",
    "name": "ZoneRegion",
    "memberof": "packages/core/src/ZoneRegion.js",
    "static": true,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZoneRegion.js",
    "importStyle": "{ZoneRegion}",
    "description": "A geographical region where the same time-zone rules apply.\n\nTime-zone information is categorized as a set of rules defining when and\nhow the offset from UTC/Greenwich changes. These rules are accessed using\nidentifiers based on geographical regions, such as countries or states.\nThe most common region classification is the Time Zone Database (TZDB),\nwhich defines regions such as 'Europe/Paris' and 'Asia/Tokyo'.\n\nThe region identifier, modeled by this class, is distinct from the\nunderlying rules, modeled by {@link ZoneRules}.\nThe rules are defined by governments and change frequently.\nBy contrast, the region identifier is well-defined and long-lived.\nThis separation also allows rules to be shared between regions if appropriate.\n\n### Specification for implementors\n\nThis class is immutable and thread-safe.",
    "lineNumber": 30,
    "interface": false,
    "extends": [
      "packages/core/src/ZoneId.js~ZoneId"
    ]
  },
  {
    "__docId__": 841,
    "kind": "method",
    "name": "ofId",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion.ofId",
    "access": "public",
    "description": "",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 842,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the time-zone ID, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneRules"
        ],
        "spread": false,
        "optional": false,
        "name": "rules",
        "description": "the rules, null for lazy lookup"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 843,
    "kind": "member",
    "name": "_id",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "static": false,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion#_id",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 844,
    "kind": "member",
    "name": "_rules",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "static": false,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion#_rules",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 845,
    "kind": "method",
    "name": "id",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion#id",
    "access": "public",
    "description": "",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 846,
    "kind": "method",
    "name": "rules",
    "memberof": "packages/core/src/ZoneRegion.js~ZoneRegion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZoneRegion.js~ZoneRegion#rules",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneRules}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 847,
    "kind": "file",
    "name": "packages/core/src/ZonedDateTime.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from './assert';\nimport { DateTimeException, IllegalArgumentException } from './errors';\nimport { MathUtil } from './MathUtil';\n\nimport { Clock } from './Clock';\nimport { Instant } from './Instant';\nimport { LocalDate } from './LocalDate';\nimport { LocalDateTime } from './LocalDateTime';\nimport { LocalTime } from './LocalTime';\nimport { OffsetDateTime } from './OffsetDateTime';\nimport { ZoneId } from './ZoneId';\nimport { ZoneOffset } from './ZoneOffset';\n\nimport { ChronoZonedDateTime } from './chrono/ChronoZonedDateTime';\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { createTemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalQueries } from './temporal/TemporalQueries';\n\n/**\n * A date-time with a time-zone in the ISO-8601 calendar system,\n * such as `2007-12-03T10:15:30+01:00 Europe/Paris`.\n *\n * `ZonedDateTime` is an immutable representation of a date-time with a time-zone.\n * This class stores all date and time fields, to a precision of nanoseconds,\n * and a time-zone, with a zone offset used to handle ambiguous local date-times.\n * For example, the value\n * '2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone'\n * can be stored in a {@link ZonedDateTime}.\n *\n * This class handles conversion from the local time-line of {@link LocalDateTime}\n * to the instant time-line of {@link Instant}.\n * The difference between the two time-lines is the offset from UTC/Greenwich,\n * represented by a {@link ZoneOffset}.\n *\n * Converting between the two time-lines involves calculating the offset using the\n * {@link ZoneRules} rules accessed from the {@link ZoneId}.\n * Obtaining the offset for an instant is simple, as there is exactly one valid\n * offset for each instant. By contrast, obtaining the offset for a local date-time\n * is not straightforward. There are three cases:\n *\n * * Normal, with one valid offset. For the vast majority of the year, the normal\n *   case applies, where there is a single valid offset for the local date-time.\n * * Gap, with zero valid offsets. This is when clocks jump forward typically\n *   due to the spring daylight savings change from 'winter' to 'summer'.\n *   In a gap there are local date-time values with no valid offset.\n * * Overlap, with two valid offsets. This is when clocks are set back typically\n *   due to the autumn daylight savings change from 'summer' to 'winter'.\n *   In an overlap there are local date-time values with two valid offsets.\n *\n * Any method that converts directly or implicitly from a local date-time to an\n * instant by obtaining the offset has the potential to be complicated.\n *\n * For Gaps, the general strategy is that if the local date-time falls in the\n * middle of a Gap, then the resulting zoned date-time will have a local date-time\n * shifted forwards by the length of the Gap, resulting in a date-time in the later\n * offset, typically 'summer' time.\n *\n * For Overlaps, the general strategy is that if the local date-time falls in the\n * middle of an Overlap, then the previous offset will be retained. If there is no\n * previous offset, or the previous offset is invalid, then the earlier offset is\n * used, typically 'summer' time. Two additional methods,\n * {@link withEarlierOffsetAtOverlap} and {@link withLaterOffsetAtOverlap},\n * help manage the case of an overlap.\n *\n * ### Specification for implementors\n *\n * A {@link ZonedDateTime} holds state equivalent to three separate objects,\n * a {@link LocalDateTime}, a {@link ZoneId} and the resolved {@link ZoneOffset}.\n * The offset and local date-time are used to define an instant when necessary.\n * The zone ID is used to obtain the rules for how and when the offset changes.\n * The offset cannot be freely set, as the zone controls which offsets are valid.\n */\nexport class ZonedDateTime extends ChronoZonedDateTime {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date-time from the system clock in the specified time-zone or clock\n     * or default time zone.\n     *\n     * This will query the system clock (see {@link Clock#systemDefaultZone}) in the default\n     * time-zone to obtain the current date-time.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {Clock|ZoneId} [clockOrZone=Clock.systemDefaultZone()]\n     * @return {ZonedDateTime} the current date-time using the system clock, not null\n     */\n    static now(clockOrZone) {\n        let clock;\n        if(clockOrZone instanceof ZoneId){\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n        }\n        return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for static {@link ZonedDateTime.of}\n     *\n     * if called with 2 (or less) args {@link ZonedDateTime.of2} is called,\n     * if called with 3 args and the first arg is an instance of LocalDate {@link ZonedDateTime.of3} is called,\n     * otherwise {@link ZonedDateTime.of8} is called.\n     */\n    static of(){\n        if(arguments.length <= 2){\n            return ZonedDateTime.of2.apply(this, arguments);\n        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate){\n            return ZonedDateTime.of3.apply(this, arguments);\n        } else {\n            return ZonedDateTime.of8.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date and time.\n     *\n     * This creates a zoned date-time matching the input local date and time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date time and first combined to form a local date-time.\n     * The local date-time is then resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {LocalTime} time - the local time, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the offset date-time, not null\n     */\n    static of3(date, time, zone) {\n        return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time.\n     *\n     * This creates a zoned date-time matching the input local date-time as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static of2(localDateTime, zone) {\n        return ZonedDateTime.ofLocal(localDateTime, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a year, month, day,\n     * hour, minute, second, nanosecond and time-zone.\n     *\n     * This creates a zoned date-time matching the local date-time of the seven\n     * specified fields as closely as possible.\n     * Time-zone rules, such as daylight savings, mean that not every local date-time\n     * is valid for the specified zone, thus the local date-time may be adjusted.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, when clocks are set back, there are two valid offsets.\n     * This method uses the earlier offset typically corresponding to 'summer'.\n     *\n     * In the case of a gap, when clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     * {@link LocalDateTime} has five additional convenience variants of the\n     * equivalent factory method taking fewer arguments.\n     * They are not provided here to reduce the footprint of the API.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @param {number} hour - the hour-of-day to represent, from 0 to 23\n     * @param {number} minute - the minute-of-hour to represent, from 0 to 59\n     * @param {number} second - the second-of-minute to represent, from 0 to 59\n     * @param {number} nanoOfSecond - the nano-of-second to represent, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime } the offset date-time, not null\n     * @throws DateTimeException if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     */\n    static of8(\n        year, month, dayOfMonth,\n        hour, minute, second, nanoOfSecond, zone) {\n        const dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return ZonedDateTime.ofLocal(dt, zone, null);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a local date-time\n     * using the preferred offset if possible.\n     *\n     * The local date-time is resolved to a single instant on the time-line.\n     * This is achieved by finding a valid offset from UTC/Greenwich for the local\n     * date-time as defined by the {@link ZoneRules} of the zone ID.\n     *\n     * In most cases, there is only one valid offset for a local date-time.\n     * In the case of an overlap, where clocks are set back, there are two valid offsets.\n     * If the preferred offset is one of the valid offsets then it is used.\n     * Otherwise the earlier valid offset is used, typically corresponding to 'summer'.\n     *\n     * In the case of a gap, where clocks jump forward, there is no valid offset.\n     * Instead, the local date-time is adjusted to be later by the length of the gap.\n     * For a typical one hour daylight savings change, the local date-time will be\n     * moved one hour later into the offset typically corresponding to 'summer'.\n     *\n     * @param {!LocalDateTime} localDateTime - the local date-time, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @param {ZoneOffset} preferredOffset - the zone offset, null if no preference\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLocal(localDateTime, zone, preferredOffset) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset) {\n            return new ZonedDateTime(localDateTime, zone, zone);\n        }\n        let offset = null;\n        const rules = zone.rules();\n        const validOffsets = rules.validOffsets(localDateTime);\n        if (validOffsets.length === 1) {\n            offset = validOffsets[0];\n        } else if (validOffsets.length === 0) {\n            const trans = rules.transition(localDateTime);\n            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n            offset = trans.offsetAfter();\n        } else {\n            if (preferredOffset != null &&\n                    validOffsets.some((validOffset) => {return validOffset.equals(preferredOffset);})) {\n                offset = preferredOffset;\n            } else {\n                offset = requireNonNull(validOffsets[0], 'offset');  // protect against bad ZoneRules\n            }\n        }\n\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link ZonedDateTime.ofInstant}.\n     * if called with 2 args {@link ZonedDateTime.ofInstant2} is called\n     * otherwise {@link ZonedDateTime.ofInstant3}.\n     */\n    static ofInstant(){\n        if (arguments.length === 2){\n            return ZonedDateTime.ofInstant2.apply(this, arguments);\n        } else {\n            return ZonedDateTime.ofInstant3.apply(this, arguments);\n        }\n    }\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from an {@link Instant}.\n     *\n     * This creates a zoned date-time with the same instant as that specified.\n     * Calling {@link toInstant} will return an instant equal to the one used here.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param {!Instant} instant - the instant to create the date-time from, not null\n     * @param {!ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static ofInstant2(instant, zone) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from the instant formed by combining\n     * the local date-time and offset.\n     *\n     * This creates a zoned date-time by combining the {@link LocalDateTime} and {@link ZoneOffset}.\n     * This combination uniquely specifies an instant without ambiguity.\n     *\n     * Converting an instant to a zoned date-time is simple as there is only one valid\n     * offset for each instant. If the valid offset is different to the offset specified,\n     * the the date-time and offset of the zoned date-time will differ from those specified.\n     *\n     * If the {@link ZoneId} to be used is a {@link ZoneOffset}, this method is equivalent\n     * to {@link of}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofInstant3(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} using seconds from the\n     * epoch of 1970-01-01T00:00:00Z.\n     *\n     * @param {number} epochSecond - the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     * @param {number} nanoOfSecond - the nanosecond within the second, from 0 to 999,999,999\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if the result exceeds the supported range\n     */\n    static _create(epochSecond, nanoOfSecond, zone) {\n        const rules = zone.rules();\n        const instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  // TODO: rules should be queryable by epochSeconds\n        const offset = rules.offset(instant);\n        const ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n        return new ZonedDateTime(ldt, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} strictly validating the\n     * combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time ensuring that the offset is valid for the\n     * local date-time according to the rules of the specified zone.\n     * If the offset is invalid, an exception is thrown.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofStrict(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        const rules = zone.rules();\n        if (rules.isValidOffset(localDateTime, offset) === false) {\n            const trans = rules.transition(localDateTime);\n            if (trans != null && trans.isGap()) {\n                // error message says daylight savings for simplicity\n                // even though there are other kinds of gaps\n                throw new DateTimeException(`LocalDateTime ${localDateTime \n                } does not exist in zone ${zone \n                } due to a gap in the local time-line, typically caused by daylight savings`);\n            }\n            throw new DateTimeException(`ZoneOffset \"${offset}\" is not valid for LocalDateTime \"${ \n                localDateTime}\" in zone \"${zone}\"`);\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    /**\n     * Obtains an instance of {@link ZonedDateTime} leniently, for advanced use cases,\n     * allowing any combination of local date-time, offset and zone ID.\n     *\n     * This creates a zoned date-time with no checks other than no nulls.\n     * This means that the resulting zoned date-time may have an offset that is in conflict\n     * with the zone ID.\n     *\n     * This method is intended for advanced use cases.\n     * For example, consider the case where a zoned date-time with valid fields is created\n     * and then stored in a database or serialization-based store. At some later point,\n     * the object is then re-loaded. However, between those points in time, the government\n     * that defined the time-zone has changed the rules, such that the originally stored\n     * local date-time now does not occur. This method can be used to create the object\n     * in an 'invalid' state, despite the change in rules.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @param {ZoneId} zone - the time-zone, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    static ofLenient(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, 'localDateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n            throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a temporal object.\n     *\n     * A {@link TemporalAccessor} represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of {@link ZonedDateTime}.\n     *\n     * The conversion will first obtain a {@link ZoneId}. It will then try to obtain an instant.\n     * If that fails it will try to obtain a local date-time.\n     * The zoned date time will either be a combination of {@link ZoneId} and instant,\n     * or {@link ZoneId} and local date-time.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link ZonedDateTime::from}.\n     *\n     * @param {!TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     * @throws DateTimeException if unable to convert to an {@link ZonedDateTime}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        if (temporal instanceof ZonedDateTime) {\n            return temporal;\n        }\n        const zone = ZoneId.from(temporal);\n        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            const zdt = ZonedDateTime._from(temporal, zone);\n            if(zdt != null) return zdt;\n        }\n        const ldt = LocalDateTime.from(temporal);\n        return ZonedDateTime.of2(ldt, zone);\n    }\n\n    static _from(temporal, zone){\n        try {\n            return ZonedDateTime.__from(temporal, zone);\n        } catch (ex) {\n            if(!(ex instanceof DateTimeException)) throw ex;\n            // ignore\n        }\n    }\n\n    static __from(temporal, zone){\n        const epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n        const nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n        return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link ZonedDateTime} from a text string such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The string must represent a valid date-time and is parsed using\n     * {@link org.threeten.bp.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.\n     *\n     * @param {!string} text - the text to parse such as '2007-12-03T10:15:30+01:00[Europe/Paris]', not null\n     * @param {!DateTimeFormatter} [formatter=DateTimeFormatter.ISO_ZONED_DATE_TIME] - the formatter to use\n     * @return {ZonedDateTime} the parsed zoned date-time, not null\n     * @throws DateTimeParseException if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, ZonedDateTime.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDateTime} dateTime - the date-time, validated as not null\n     * @param {ZoneOffset} offset - the zone offset, validated as not null\n     * @param {ZoneUd} zone - the time-zone, validated as not null\n     * @private\n     */\n    constructor(dateTime, offset, zone) {\n        requireNonNull(dateTime, 'dateTime');\n        requireNonNull(offset, 'offset');\n        requireNonNull(zone, 'zone');\n\n        super();\n\n        /**\n         * The local date-time.\n         */\n        this._dateTime = dateTime;\n        /**\n         * The offset from UTC/Greenwich.\n         */\n        this._offset = offset;\n        /**\n         * The time-zone.\n         */\n        this._zone = zone;\n    }\n\n    /**\n     * Resolves the new local date-time using this zone ID, retaining the offset if possible.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveLocal(newDateTime) {\n        requireNonNull(newDateTime, 'newDateTime');\n        return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n    }\n\n    /**\n     * Resolves the new local date-time using the offset to identify the instant.\n     *\n     * @param {LocalDateTime} newDateTime - the new local date-time, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveInstant(newDateTime) {\n        return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n    }\n\n    /**\n     * Resolves the offset into this zoned date-time.\n     *\n     * This ignores the offset, unless it can be used in an overlap.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZonedDateTime} the zoned date-time, not null\n     */\n    _resolveOffset(offset) {\n        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n            return new ZonedDateTime(this._dateTime, offset, this._zone);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this date-time can be queried for the specified field.\n     * If false, then calling {@link range} and {@link get} will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * * {@link NANO_OF_SECOND}\n     * * {@link NANO_OF_DAY}\n     * * {@link MICRO_OF_SECOND}\n     * * {@link MICRO_OF_DAY}\n     * * {@link MILLI_OF_SECOND}\n     * * {@link MILLI_OF_DAY}\n     * * {@link SECOND_OF_MINUTE}\n     * * {@link SECOND_OF_DAY}\n     * * {@link MINUTE_OF_HOUR}\n     * * {@link MINUTE_OF_DAY}\n     * * {@link HOUR_OF_AMPM}\n     * * {@link CLOCK_HOUR_OF_AMPM}\n     * * {@link HOUR_OF_DAY}\n     * * {@link CLOCK_HOUR_OF_DAY}\n     * * {@link AMPM_OF_DAY}\n     * * {@link DAY_OF_WEEK}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_MONTH}\n     * * {@link ALIGNED_DAY_OF_WEEK_IN_YEAR}\n     * * {@link DAY_OF_MONTH}\n     * * {@link DAY_OF_YEAR}\n     * * {@link EPOCH_DAY}\n     * * {@link ALIGNED_WEEK_OF_MONTH}\n     * * {@link ALIGNED_WEEK_OF_YEAR}\n     * * {@link MONTH_OF_YEAR}\n     * * {@link EPOCH_MONTH}\n     * * {@link YEAR_OF_ERA}\n     * * {@link YEAR}\n     * * {@link ERA}\n     * * {@link INSTANT_SECONDS}\n     * * {@link OFFSET_SECONDS}\n     *\n     * All other {@link ChronoField} instances will return false.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date-time, false if not\n     */\n    isSupported(fieldOrUnit) {\n        if(fieldOrUnit instanceof ChronoField){\n            return true;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return (fieldOrUnit != null && fieldOrUnit.isSupportedBy(this));\n    }\n\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date-time is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as an `int`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n     * {@link EPOCH_DAY}, {@link EPOCH_MONTH} and {@link INSTANT_SECONDS} which are too\n     * large to fit in an `int` and throw a {@link DateTimeException}.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.getLong(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date-time as a `long`.\n     *\n     * This queries this date-time for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields (see {@link isSupported}) will return valid\n     * values based on this date-time.\n     * All other {@link ChronoField} instances will throw a {@link DateTimeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {!TemporalField} field  the field to get, not null\n     * @return {number} the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    getLong(field) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS: return this._offset.totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        requireNonNull(field, 'field');\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as '+01:00'.\n     *\n     * This is the offset of the local date-time from UTC/Greenwich.\n     *\n     * @return {ZoneOffset}the zone offset, not null\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * earlier of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the earlier of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the earlier offset, not null\n     */\n    withEarlierOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this._dateTime);\n        if (trans != null && trans.isOverlap()) {\n            const earlierOffset = trans.offsetBefore();\n            if (earlierOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Returns a copy of this date-time changing the zone offset to the\n     * later of the two valid offsets at a local time-line overlap.\n     *\n     * This method only has any effect when the local time-line overlaps, such as\n     * at an autumn daylight savings cutover. In this scenario, there are two\n     * valid offsets for the local date-time. Calling this method will return\n     * a zoned date-time with the later of the two selected.\n     *\n     * If this method is called when it is not an overlap, `this`\n     * is returned.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the later offset, not null\n     */\n    withLaterOffsetAtOverlap() {\n        const trans = this._zone.rules().transition(this.toLocalDateTime());\n        if (trans != null) {\n            const laterOffset = trans.offsetAfter();\n            if (laterOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the time-zone, such as 'Europe/Paris'.\n     *\n     * This returns the zone ID. This identifies the time-zone {@link ZoneRules}\n     * that determine when and how the offset from UTC/Greenwich changes.\n     *\n     * The zone ID may be same as the offset (see {@link getOffset}).\n     * If this is true, then any future calculations, such as addition or subtraction,\n     * have no complex edge cases due to time-zone rules.\n     * See also {@link withFixedOffsetZone}.\n     *\n     * @return {ZoneId} the time-zone, not null\n     */\n    zone() {\n        return this._zone;\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the local date-time if possible.\n     *\n     * This method changes the time-zone and retains the local date-time.\n     * The local date-time is only changed if it is invalid for the new zone,\n     * determined using the same approach as\n     * {@link ofLocal}.\n     *\n     * To change the zone and adjust the local date-time,\n     * use {@link withZoneSameInstant}.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     */\n    withZoneSameLocal(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    }\n\n    /**\n     * Returns a copy of this date-time with a different time-zone,\n     * retaining the instant.\n     *\n     * This method changes the time-zone and retains the instant.\n     * This normally results in a change to the local date-time.\n     *\n     * This method is based on retaining the same instant, thus gaps and overlaps\n     * in the local time-line have no effect on the result.\n     *\n     * To change the offset while keeping the local time,\n     * use {@link withZoneSameLocal}.\n     *\n     * @param {ZoneId} zone - the time-zone to change to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested zone, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    withZoneSameInstant(zone) {\n        requireNonNull(zone, 'zone');\n        return this._zone.equals(zone) ? this :\n            ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n    }\n\n    /**\n     * Returns a copy of this date-time with the zone ID set to the offset.\n     *\n     * This returns a zoned date-time where the zone ID is the same as {@link getOffset}.\n     * The local date-time, offset and instant of the result will be the same as in this date-time.\n     *\n     * Setting the date-time to a fixed single offset means that any future\n     * calculations, such as addition or subtraction, have no complex edge cases\n     * due to time-zone rules.\n     * This might also be useful when sending a zoned date-time across a network,\n     * as most protocols, such as ISO-8601, only handle offsets,\n     * and not region-based zone IDs.\n     *\n     * This is equivalent to {@link ZonedDateTime.of}.\n     *\n     * @return {ZonedDateTime} a {@link ZonedDateTime} with the zone ID set to the offset, not null\n     */\n    withFixedOffsetZone() {\n        return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per {@link get}.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._dateTime.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     *\n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link getMonth}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see #month()\n     */\n    monthValue() {\n        return this._dateTime.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the {@link Month} enum.\n     *\n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link Month#getValue}.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see #getMonthValue()\n     */\n    month() {\n        return this._dateTime.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     *\n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     *\n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._dateTime.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n     *\n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value, use {@link DayOfWeek#getValue}.\n     *\n     * Additional information can be obtained from the {@link DayOfWeek}.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the hour-of-day field.\n     *\n     * @return {number} the hour-of-day, from 0 to 23\n     */\n    hour() {\n        return this._dateTime.hour();\n    }\n\n    /**\n     * Gets the minute-of-hour field.\n     *\n     * @return {number} the minute-of-hour, from 0 to 59\n     */\n    minute() {\n        return this._dateTime.minute();\n    }\n\n    /**\n     * Gets the second-of-minute field.\n     *\n     * @return {number} the second-of-minute, from 0 to 59\n     */\n    second() {\n        return this._dateTime.second();\n    }\n\n    /**\n     * Gets the nano-of-second field.\n     *\n     * @return {number} the nano-of-second, from 0 to 999,999,999\n     */\n    nano() {\n        return this._dateTime.nano();\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns an adjusted copy of this date-time.\n     *\n     * This returns a new {@link ZonedDateTime}, based on this one, with the date-time adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the {@link TemporalAdjuster} interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     *\n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static org.threeten.bp.Month.*;\n     *  import static org.threeten.bp.temporal.Adjusters.*;\n     *\n     *  result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     *\n     * The classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\n     * thus this method can be used to change the date, time or offset:\n     * <pre>\n     *  result = zonedDateTime.with(date);\n     *  result = zonedDateTime.with(time);\n     * </pre>\n     *\n     * {@link ZoneOffset} also implements {@link TemporalAdjuster} however it is less likely\n     * that setting the offset will have the effect you expect. When an offset is passed in,\n     * the local date-time is combined with the new offset to form an {@link Instant}.\n     * The instant and original zone are then used to create the result.\n     * This algorithm means that it is quite likely that the output has a different offset\n     * to the specified offset. It will however work correctly when passing in the offset\n     * applicable for the instant of the zoned date-time, and will work correctly if passing\n     * one of the two valid offsets during a daylight savings overlap when the same local time\n     * occurs twice.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the adjustment made, not null\n     * @throws DateTimeException if the adjustment cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n        } else if (adjuster instanceof LocalTime) {\n            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n        } else if (adjuster instanceof LocalDateTime) {\n            return this._resolveLocal(adjuster);\n        } else if (adjuster instanceof Instant) {\n            const instant = adjuster;\n            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._resolveOffset(adjuster);\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this date-time with the specified field set to a new value.\n     *\n     * This returns a {@link ZonedDateTime}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * In some cases, changing the specified field can cause the resulting date-time to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     *\n     * The {@link INSTANT_SECONDS} field will return a date-time with the specified instant.\n     * The zone and nano-of-second are unchanged.\n     * The result will have an offset derived from the new instant and original zone.\n     * If the new instant value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The {@link OFFSET_SECONDS} field will typically be ignored.\n     * The offset of a {@link ZonedDateTime} is controlled primarily by the time-zone.\n     * As such, changing the offset does not generally make sense, because there is only\n     * one valid offset for the local date-time and zone.\n     * If the zoned date-time is in a daylight savings overlap, then the offset is used\n     * to switch between the two valid offsets. In all other cases, the offset is ignored.\n     * If the new offset value is outside the valid range then a {@link DateTimeException} will be thrown.\n     *\n     * The other supported fields (see {@link isSupported}) will behave as in {@link LocalDateTime#with}.\n     * The zone is not part of the calculation and will be unchanged.\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on `this` with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.INSTANT_SECONDS: return ZonedDateTime._create(newValue, this.nano(), this._zone);\n                case ChronoField.OFFSET_SECONDS: {\n                    const offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n                    return this._resolveOffset(offset);\n                }\n            }\n            return this._resolveLocal(this._dateTime.with(field, newValue));\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the year (see {@link LocalDateTime#withYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested year, not null\n     * @throws DateTimeException if the year value is invalid\n     */\n    withYear(year) {\n        return this._resolveLocal(this._dateTime.withYear(year));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the month-of-year value altered.\n     *\n     * This operates on the local time-line,\n     * changing the month (see {@link LocalDateTime#withMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested month, not null\n     * @throws DateTimeException if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._resolveLocal(this._dateTime.withMonth(month));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-month value altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-month (see {@link LocalDateTime#withDayOfMonth}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested day, not null\n     * @throws DateTimeException if the day-of-month value is invalid\n     * @throws DateTimeException if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the day-of-year altered.\n     *\n     * This operates on the local time-line,\n     * changing the day-of-year (see {@link LocalDateTime#withDayOfYear}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date with the requested day, not null\n     * @throws DateTimeException if the day-of-year value is invalid\n     * @throws DateTimeException if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the hour-of-day value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withHour}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hour - the hour-of-day to set in the result, from 0 to 23\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested hour, not null\n     * @throws DateTimeException if the hour value is invalid\n     */\n    withHour(hour) {\n        return this._resolveLocal(this._dateTime.withHour(hour));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the minute-of-hour value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withMinute}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minute - the minute-of-hour to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested minute, not null\n     * @throws DateTimeException if the minute value is invalid\n     */\n    withMinute(minute) {\n        return this._resolveLocal(this._dateTime.withMinute(minute));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the second-of-minute value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withSecond}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} second - the second-of-minute to set in the result, from 0 to 59\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested second, not null\n     * @throws DateTimeException if the second value is invalid\n     */\n    withSecond(second) {\n        return this._resolveLocal(this._dateTime.withSecond(second));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the nano-of-second value altered.\n     *\n     * This operates on the local time-line,\n     * changing the time (see {@link LocalDateTime#withNano}) of the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanoOfSecond - the nano-of-second to set in the result, from 0 to 999,999,999\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the requested nanosecond, not null\n     * @throws DateTimeException if the nano value is invalid\n     */\n    withNano(nanoOfSecond) {\n        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the time truncated.\n     *\n     * Truncation returns a copy of the original date-time with fields\n     * smaller than the specified unit set to zero.\n     * For example, truncating with {@link ChronoUnit#MINUTES}\n     * will set the second-of-minute and nano-of-second field to zero.\n     *\n     * The unit must have a duration (see {@link TemporalUnit#getDuration})\n     * that divides into the length of a standard day without remainder.\n     * This includes all supplied time units on {@link ChronoUnit} and\n     * {@link ChronoUnit#DAYS}. Other units throw an exception.\n     *\n     * This operates on the local time-line, truncating the underlying local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalUnit} unit - the unit to truncate to, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the time truncated, not null\n     * @throws DateTimeException if unable to truncate\n     */\n    truncatedTo(unit) {\n        return this._resolveLocal(this._dateTime.truncatedTo(unit));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this date-time with the specified period added.\n     *\n     * This method returns a new date-time based on this date-time with the specified period added.\n     * This can be used to add any period that is defined by a unit, for example to add years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first added to the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the addition.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first added to the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the addition.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period added, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit.isDateBased()) {\n                return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n            } else {\n                return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n            }\n        }\n        requireNonNull(unit, 'unit');\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years added.\n     *\n     * This operates on the local time-line, adding years to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        return this._resolveLocal(this._dateTime.plusYears(years));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months added.\n     *\n     * This operates on the local time-line, adding months to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        return this._resolveLocal(this._dateTime.plusMonths(months));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks added.\n     *\n     * This operates on the local time-line, adding weeks to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the weeks added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days added.\n     *\n     * This operates on the local time-line, adding days to the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the days added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        return this._resolveLocal(this._dateTime.plusDays(days));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours added.\n     *\n     * This operates on the instant time-line, such that adding one hour will\n     * always be a duration of one hour later.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus adding one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Adding one hour to 00:30+02:00 will result in 01:30+02:00\n     * * Adding one hour to 01:30+02:00 will result in 01:30+01:00\n     * * Adding one hour to 01:30+01:00 will result in 02:30+01:00\n     * * Adding three hours to 00:30+02:00 will result in 02:30+01:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusHours(hours) {\n        return this._resolveInstant(this._dateTime.plusHours(hours));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes added.\n     *\n     * This operates on the instant time-line, such that adding one minute will\n     * always be a duration of one minute later.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusMinutes(minutes) {\n        return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds added.\n     *\n     * This operates on the instant time-line, such that adding one second will\n     * always be a duration of one second later.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusSeconds(seconds) {\n        return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds added.\n     *\n     * This operates on the instant time-line, such that adding one nano will\n     * always be a duration of one nano later.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to add, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds added, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    plusNanos(nanos) {\n        return this._resolveInstant(this._dateTime.plusNanos(nanos));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Returns a copy of this date-time with the specified period subtracted.\n     *\n     * This method returns a new date-time based on this date-time with the specified period subtracted.\n     * This can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\n     * The unit is responsible for the details of the calculation, including the resolution\n     * of any edge cases in the calculation.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line.\n     * The period is first subtracted from the local date-time, then converted back\n     * to a zoned date-time using the zone ID.\n     * The conversion uses {@link ofLocal}\n     * with the offset before the subtraction.\n     *\n     * Time units operate on the instant time-line.\n     * The period is first subtracted from the local date-time, then converted back to\n     * a zoned date-time using the zone ID.\n     * The conversion uses {@link ofInstant}\n     * with the offset before the subtraction.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the specified period subtracted, not null\n     * @throws DateTimeException if the unit cannot be added to this type\n     */\n    _minusUnit(amountToSubtract, unit) {\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in years subtracted.\n     *\n     * This operates on the local time-line, subtracting years from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the years subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this.plusYears(-1 * years);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in months subtracted.\n     *\n     * This operates on the local time-line, subtracting months from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the months subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in weeks subtracted.\n     *\n     * This operates on the local time-line, subtracting weeks from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the weeks subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in days subtracted.\n     *\n     * This operates on the local time-line, subtracting days from the local date-time.\n     * This is then converted back to a {@link ZonedDateTime}, using the zone ID\n     * to obtain the offset.\n     *\n     * When converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\n     * then the offset will be retained if possible, otherwise the earlier offset will be used.\n     * If in a gap, the local date-time will be adjusted forward by the length of the gap.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the days subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this.plusDays(-1 * days);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in hours subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one hour will\n     * always be a duration of one hour earlier.\n     * This may cause the local date-time to change by an amount other than one hour.\n     * Note that this is a different approach to that used by days, months and years,\n     * thus subtracting one day is not the same as adding 24 hours.\n     *\n     * For example, consider a time-zone where the spring DST cutover means that the\n     * local times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n     *\n     * * Subtracting one hour from 02:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+01:00 will result in 01:30+02:00\n     * * Subtracting one hour from 01:30+02:00 will result in 00:30+01:00\n     * * Subtracting three hours from 02:30+01:00 will result in 00:30+02:00\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} hours - the hours to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the hours subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusHours(hours) {\n        return this.plusHours(-1 * hours);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in minutes subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one minute will\n     * always be a duration of one minute earlier.\n     * This may cause the local date-time to change by an amount other than one minute.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} minutes - the minutes to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the minutes subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusMinutes(minutes) {\n        return this.plusMinutes(-1 * minutes);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in seconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one second will\n     * always be a duration of one second earlier.\n     * This may cause the local date-time to change by an amount other than one second.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} seconds - the seconds to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the seconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusSeconds(seconds) {\n        return this.plusSeconds(-1 * seconds);\n    }\n\n    /**\n     * Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds subtracted.\n     *\n     * This operates on the instant time-line, such that subtracting one nano will\n     * always be a duration of one nano earlier.\n     * This may cause the local date-time to change by an amount other than one nano.\n     * Note that this is a different approach to that used by days, months and years.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} nanos - the nanos to subtract, may be negative\n     * @return {ZonedDateTime} a {@link ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null\n     * @throws DateTimeException if the result exceeds the supported date range\n     */\n    minusNanos(nanos) {\n        return this.plusNanos(-1 * nanos);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date-time using the specified query.\n     *\n     * This queries this date-time using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        requireNonNull(query, 'query');\n        return super.query(query);\n    }\n\n    /**\n     * Calculates the period between this date-time and another date-time in\n     * terms of the specified unit.\n     *\n     * This calculates the period between two date-times in terms of a single unit.\n     * The start and end points are `this` and the specified date-time.\n     * The result will be negative if the end is before the start.\n     * For example, the period in days between two date-times can be calculated\n     * using {@link startDateTime.until}.\n     *\n     * The {@link Temporal} passed to this method must be a {@link ZonedDateTime}.\n     * If the time-zone differs between the two zoned date-times, the specified\n     * end date-time is normalized to have the same zone as this date-time.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two date-times.\n     * For example, the period in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\n     * will only be one month as it is one minute short of two months.\n     *\n     * This method operates in association with {@link TemporalUnit#between}.\n     * The result of this method is a `long` representing the amount of\n     * the specified unit. By contrast, the result of {@link between} is an\n     * object that can be used directly in addition/subtraction:\n     * <pre>\n     *   long period = start.until(end, MONTHS);   // this method\n     *   dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n     * </pre>\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n     * {@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n     * {@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n     * {@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\n     * Other {@link ChronoUnit} values will throw an exception.\n     *\n     * The calculation for date and time units differ.\n     *\n     * Date units operate on the local time-line, using the local date-time.\n     * For example, the period from noon on day 1 to noon the following day\n     * in days will always be counted as exactly one day, irrespective of whether\n     * there was a daylight savings change or not.\n     *\n     * Time units operate on the instant time-line.\n     * The calculation effectively converts both zoned date-times to instants\n     * and then calculates the period between the instants.\n     * For example, the period from noon on day 1 to noon the following day\n     * in hours may be 23, 24 or 25 hours (or some other amount) depending on\n     * whether there was a daylight savings change or not.\n     *\n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing `this` as the first argument and the input temporal as\n     * the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive  the end date-time, which is converted to a {@link ZonedDateTime}, not null\n     * @param {TemporalUnit} unit  the unit to measure the period in, not null\n     * @return {number} the amount of the period between this date-time and the end date-time\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        let end = ZonedDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withZoneSameInstant(this._zone);\n            if (unit.isDateBased()) {\n                return this._dateTime.until(end._dateTime, unit);\n            } else {\n                const difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n                const adjustedEnd = end._dateTime.plusSeconds(difference);\n                return this._dateTime.until(adjustedEnd, unit);\n            }\n        }\n        return unit.between(this, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the {@link LocalDateTime} part of this date-time.\n     *\n     * This returns a {@link LocalDateTime} with the same year, month, day and time\n     * as this date-time.\n     *\n     * @return {LocalDateTime} the local date-time part of this date-time, not null\n     */\n    toLocalDateTime() {\n        return this._dateTime;\n    }\n\n    /**\n     * Gets the {@link LocalDate} part of this date-time.\n     *\n     * This returns a {@link LocalDate} with the same year, month and day\n     * as this date-time.\n     *\n     * @return {LocalDate} the date part of this date-time, not null\n     */\n    toLocalDate() {\n        return this._dateTime.toLocalDate();\n    }\n\n    /**\n     * Gets the {@link LocalTime} part of this date-time.\n     *\n     * This returns a {@link LocalTime} with the same hour, minute, second and\n     * nanosecond as this date-time.\n     *\n     * @return {LocalTime} the time part of this date-time, not null\n     */\n    toLocalTime() {\n        return this._dateTime.toLocalTime();\n    }\n\n    /**\n     * Converts this date-time to an {@link OffsetDateTime}.\n     *\n     * This creates an offset date-time using the local date-time and offset.\n     * The zone ID is ignored.\n     *\n     * @return {OffsetDateTime} an offset date-time representing the same local date-time and offset, not null\n     */\n    toOffsetDateTime() {\n        return OffsetDateTime.of(this._dateTime, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * Only objects of type {@link ZonedDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZonedDateTime) {\n            return this._dateTime.equals(other._dateTime) &&\n                this._offset.equals(other._offset) &&\n                this._zone.equals(other._zone);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date-time.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date-time as a string, such as\n     * `2007-12-03T10:15:30+01:00[Europe/Paris]`.\n     *\n     * The format consists of the {@link LocalDateTime} followed by the {@link ZoneOffset}.\n     * If the {@link ZoneId} is not the same as the offset, then the ID is output.\n     * The output is compatible with ISO-8601 if the offset and ID are the same.\n     *\n     * @return {string} a string representation of this date-time, not null\n     */\n    toString() {\n        let str = this._dateTime.toString() + this._offset.toString();\n        if (this._offset !== this._zone) {\n            str += `[${this._zone.toString()}]`;\n        }\n        return str;\n    }\n\n    /**\n     *\n     * @return {string} same as {@link ZonedDateTime.toString}\n     */\n    toJSON() {\n        return this.toString();\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        return super.format(formatter);\n    }\n\n}\n\nexport function _init(){\n    ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', (temporal) => {\n        return ZonedDateTime.from(temporal);\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/ZonedDateTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 848,
    "kind": "class",
    "name": "ZonedDateTime",
    "memberof": "packages/core/src/ZonedDateTime.js",
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZonedDateTime.js",
    "importStyle": "{ZonedDateTime}",
    "description": "A date-time with a time-zone in the ISO-8601 calendar system,\nsuch as `2007-12-03T10:15:30+01:00 Europe/Paris`.\n\n`ZonedDateTime` is an immutable representation of a date-time with a time-zone.\nThis class stores all date and time fields, to a precision of nanoseconds,\nand a time-zone, with a zone offset used to handle ambiguous local date-times.\nFor example, the value\n'2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone'\ncan be stored in a {@link ZonedDateTime}.\n\nThis class handles conversion from the local time-line of {@link LocalDateTime}\nto the instant time-line of {@link Instant}.\nThe difference between the two time-lines is the offset from UTC/Greenwich,\nrepresented by a {@link ZoneOffset}.\n\nConverting between the two time-lines involves calculating the offset using the\n{@link ZoneRules} rules accessed from the {@link ZoneId}.\nObtaining the offset for an instant is simple, as there is exactly one valid\noffset for each instant. By contrast, obtaining the offset for a local date-time\nis not straightforward. There are three cases:\n\n* Normal, with one valid offset. For the vast majority of the year, the normal\n  case applies, where there is a single valid offset for the local date-time.\n* Gap, with zero valid offsets. This is when clocks jump forward typically\n  due to the spring daylight savings change from 'winter' to 'summer'.\n  In a gap there are local date-time values with no valid offset.\n* Overlap, with two valid offsets. This is when clocks are set back typically\n  due to the autumn daylight savings change from 'summer' to 'winter'.\n  In an overlap there are local date-time values with two valid offsets.\n\nAny method that converts directly or implicitly from a local date-time to an\ninstant by obtaining the offset has the potential to be complicated.\n\nFor Gaps, the general strategy is that if the local date-time falls in the\nmiddle of a Gap, then the resulting zoned date-time will have a local date-time\nshifted forwards by the length of the Gap, resulting in a date-time in the later\noffset, typically 'summer' time.\n\nFor Overlaps, the general strategy is that if the local date-time falls in the\nmiddle of an Overlap, then the previous offset will be retained. If there is no\nprevious offset, or the previous offset is invalid, then the earlier offset is\nused, typically 'summer' time. Two additional methods,\n{@link withEarlierOffsetAtOverlap} and {@link withLaterOffsetAtOverlap},\nhelp manage the case of an overlap.\n\n### Specification for implementors\n\nA {@link ZonedDateTime} holds state equivalent to three separate objects,\na {@link LocalDateTime}, a {@link ZoneId} and the resolved {@link ZoneOffset}.\nThe offset and local date-time are used to define an instant when necessary.\nThe zone ID is used to obtain the rules for how and when the offset changes.\nThe offset cannot be freely set, as the zone controls which offsets are valid.",
    "lineNumber": 81,
    "interface": false,
    "extends": [
      "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime"
    ]
  },
  {
    "__docId__": 849,
    "kind": "method",
    "name": "now",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.now",
    "access": "public",
    "description": "Obtains the current date-time from the system clock in the specified time-zone or clock\nor default time zone.\n\nThis will query the system clock (see {@link Clock#systemDefaultZone}) in the default\ntime-zone to obtain the current date-time.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock",
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Clock.systemDefaultZone()",
        "defaultRaw": "Clock.systemDefaultZone()",
        "name": "clockOrZone",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the current date-time using the system clock, not null"
    }
  },
  {
    "__docId__": 850,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.of",
    "access": "public",
    "description": "function overloading for static {@link ZonedDateTime.of}\n\nif called with 2 (or less) args {@link ZonedDateTime.of2} is called,\nif called with 3 args and the first arg is an instance of LocalDate {@link ZonedDateTime.of3} is called,\notherwise {@link ZonedDateTime.of8} is called.",
    "lineNumber": 116,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 851,
    "kind": "method",
    "name": "of3",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.of3",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a local date and time.\n\nThis creates a zoned date-time matching the input local date and time as closely as possible.\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may be adjusted.\n\nThe local date time and first combined to form a local date-time.\nThe local date-time is then resolved to a single instant on the time-line.\nThis is achieved by finding a valid offset from UTC/Greenwich for the local\ndate-time as defined by the {@link ZoneRules} of the zone ID.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, when clocks are set back, there are two valid offsets.\nThis method uses the earlier offset typically corresponding to 'summer'.\n\nIn the case of a gap, when clocks jump forward, there is no valid offset.\nInstead, the local date-time is adjusted to be later by the length of the gap.\nFor a typical one hour daylight savings change, the local date-time will be\nmoved one hour later into the offset typically corresponding to 'summer'.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the local date, not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the local time, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the offset date-time, not null"
    }
  },
  {
    "__docId__": 852,
    "kind": "method",
    "name": "of2",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.of2",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a local date-time.\n\nThis creates a zoned date-time matching the input local date-time as closely as possible.\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may be adjusted.\n\nThe local date-time is resolved to a single instant on the time-line.\nThis is achieved by finding a valid offset from UTC/Greenwich for the local\ndate-time as defined by the {@link ZoneRules} of the zone ID.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, when clocks are set back, there are two valid offsets.\nThis method uses the earlier offset typically corresponding to 'summer'.\n\nIn the case of a gap, when clocks jump forward, there is no valid offset.\nInstead, the local date-time is adjusted to be later by the length of the gap.\nFor a typical one hour daylight savings change, the local date-time will be\nmoved one hour later into the offset typically corresponding to 'summer'.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time, not null"
      },
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    }
  },
  {
    "__docId__": 853,
    "kind": "method",
    "name": "of8",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.of8",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a year, month, day,\nhour, minute, second, nanosecond and time-zone.\n\nThis creates a zoned date-time matching the local date-time of the seven\nspecified fields as closely as possible.\nTime-zone rules, such as daylight savings, mean that not every local date-time\nis valid for the specified zone, thus the local date-time may be adjusted.\n\nThe local date-time is resolved to a single instant on the time-line.\nThis is achieved by finding a valid offset from UTC/Greenwich for the local\ndate-time as defined by the {@link ZoneRules} of the zone ID.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, when clocks are set back, there are two valid offsets.\nThis method uses the earlier offset typically corresponding to 'summer'.\n\nIn the case of a gap, when clocks jump forward, there is no valid offset.\nInstead, the local date-time is adjusted to be later by the length of the gap.\nFor a typical one hour daylight savings change, the local date-time will be\nmoved one hour later into the offset typically corresponding to 'summer'.\n\nThis method exists primarily for writing test cases.\nNon test-code will typically use other methods to create an offset time.\n{@link LocalDateTime} has five additional convenience variants of the\nequivalent factory method taking fewer arguments.\nThey are not provided here to reduce the footprint of the API.",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, from 1 (January) to 12 (December)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": "the hour-of-day to represent, from 0 to 23"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": "the minute-of-hour to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": "the second-of-minute to represent, from 0 to 59"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to represent, from 0 to 999,999,999"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime "
      ],
      "spread": false,
      "description": "the offset date-time, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value of any field is out of range, or\n if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 854,
    "kind": "method",
    "name": "ofLocal",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofLocal",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a local date-time\nusing the preferred offset if possible.\n\nThe local date-time is resolved to a single instant on the time-line.\nThis is achieved by finding a valid offset from UTC/Greenwich for the local\ndate-time as defined by the {@link ZoneRules} of the zone ID.\n\nIn most cases, there is only one valid offset for a local date-time.\nIn the case of an overlap, where clocks are set back, there are two valid offsets.\nIf the preferred offset is one of the valid offsets then it is used.\nOtherwise the earlier valid offset is used, typically corresponding to 'summer'.\n\nIn the case of a gap, where clocks jump forward, there is no valid offset.\nInstead, the local date-time is adjusted to be later by the length of the gap.\nFor a typical one hour daylight savings change, the local date-time will be\nmoved one hour later into the offset typically corresponding to 'summer'.",
    "lineNumber": 253,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time, not null"
      },
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "preferredOffset",
        "description": "the zone offset, null if no preference"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    }
  },
  {
    "__docId__": 855,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofInstant",
    "access": "public",
    "description": "function overloading for {@link ZonedDateTime.ofInstant}.\nif called with 2 args {@link ZonedDateTime.ofInstant2} is called\notherwise {@link ZonedDateTime.ofInstant3}.",
    "lineNumber": 286,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 856,
    "kind": "method",
    "name": "ofInstant2",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofInstant2",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from an {@link Instant}.\n\nThis creates a zoned date-time with the same instant as that specified.\nCalling {@link toInstant} will return an instant equal to the one used here.\n\nConverting an instant to a zoned date-time is simple as there is only one valid\noffset for each instant.",
    "lineNumber": 307,
    "params": [
      {
        "nullable": false,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to create the date-time from, not null"
      },
      {
        "nullable": false,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 857,
    "kind": "method",
    "name": "ofInstant3",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofInstant3",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from the instant formed by combining\nthe local date-time and offset.\n\nThis creates a zoned date-time by combining the {@link LocalDateTime} and {@link ZoneOffset}.\nThis combination uniquely specifies an instant without ambiguity.\n\nConverting an instant to a zoned date-time is simple as there is only one valid\noffset for each instant. If the valid offset is different to the offset specified,\nthe the date-time and offset of the zoned date-time will differ from those specified.\n\nIf the {@link ZoneId} to be used is a {@link ZoneOffset}, this method is equivalent\nto {@link of}.",
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    }
  },
  {
    "__docId__": 858,
    "kind": "method",
    "name": "_create",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime._create",
    "access": "private",
    "description": "Obtains an instance of {@link ZonedDateTime} using seconds from the\nepoch of 1970-01-01T00:00:00Z.",
    "lineNumber": 349,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochSecond",
        "description": "the number of seconds from the epoch of 1970-01-01T00:00:00Z"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nanosecond within the second, from 0 to 999,999,999"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported range"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 859,
    "kind": "method",
    "name": "ofStrict",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofStrict",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} strictly validating the\ncombination of local date-time, offset and zone ID.\n\nThis creates a zoned date-time ensuring that the offset is valid for the\nlocal date-time according to the rules of the specified zone.\nIf the offset is invalid, an exception is thrown.",
    "lineNumber": 371,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    }
  },
  {
    "__docId__": 860,
    "kind": "method",
    "name": "ofLenient",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.ofLenient",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} leniently, for advanced use cases,\nallowing any combination of local date-time, offset and zone ID.\n\nThis creates a zoned date-time with no checks other than no nulls.\nThis means that the resulting zoned date-time may have an offset that is in conflict\nwith the zone ID.\n\nThis method is intended for advanced use cases.\nFor example, consider the case where a zoned date-time with valid fields is created\nand then stored in a database or serialization-based store. At some later point,\nthe object is then re-loaded. However, between those points in time, the government\nthat defined the time-zone has changed the rules, such that the originally stored\nlocal date-time now does not occur. This method can be used to create the object\nin an 'invalid' state, despite the change in rules.",
    "lineNumber": 412,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    }
  },
  {
    "__docId__": 861,
    "kind": "method",
    "name": "from",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.from",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a temporal object.\n\nA {@link TemporalAccessor} represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of {@link ZonedDateTime}.\n\nThe conversion will first obtain a {@link ZoneId}. It will then try to obtain an instant.\nIf that fails it will try to obtain a local date-time.\nThe zoned date time will either be a combination of {@link ZoneId} and instant,\nor {@link ZoneId} and local date-time.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link ZonedDateTime::from}.",
    "lineNumber": 441,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to convert to an {@link ZonedDateTime}"
      }
    ]
  },
  {
    "__docId__": 862,
    "kind": "method",
    "name": "_from",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime._from",
    "access": "private",
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 863,
    "kind": "method",
    "name": "__from",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.__from",
    "access": "private",
    "description": null,
    "lineNumber": 464,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "zone",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 864,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime.parse",
    "access": "public",
    "description": "Obtains an instance of {@link ZonedDateTime} from a text string such as\n`2007-12-03T10:15:30+01:00[Europe/Paris]`.\n\nThe string must represent a valid date-time and is parsed using\n{@link org.threeten.bp.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.",
    "lineNumber": 483,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse such as '2007-12-03T10:15:30+01:00[Europe/Paris]', not null"
      },
      {
        "nullable": false,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DateTimeFormatter.ISO_ZONED_DATE_TIME",
        "defaultRaw": "DateTimeFormatter.ISO_ZONED_DATE_TIME",
        "name": "formatter",
        "description": "the formatter to use"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the parsed zoned date-time, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 865,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 497,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": "the date-time, validated as not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, validated as not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneUd"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, validated as not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 866,
    "kind": "member",
    "name": "_dateTime",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_dateTime",
    "access": "private",
    "description": "The local date-time.",
    "lineNumber": 507,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 867,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_offset",
    "access": "private",
    "description": "The offset from UTC/Greenwich.",
    "lineNumber": 511,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 868,
    "kind": "member",
    "name": "_zone",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_zone",
    "access": "private",
    "description": "The time-zone.",
    "lineNumber": 515,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 869,
    "kind": "method",
    "name": "_resolveLocal",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_resolveLocal",
    "access": "private",
    "description": "Resolves the new local date-time using this zone ID, retaining the offset if possible.",
    "lineNumber": 524,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateTime",
        "description": "the new local date-time, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 870,
    "kind": "method",
    "name": "_resolveInstant",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_resolveInstant",
    "access": "private",
    "description": "Resolves the new local date-time using the offset to identify the instant.",
    "lineNumber": 535,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "newDateTime",
        "description": "the new local date-time, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 871,
    "kind": "method",
    "name": "_resolveOffset",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_resolveOffset",
    "access": "private",
    "description": "Resolves the offset into this zoned date-time.\n\nThis ignores the offset, unless it can be used in an overlap.",
    "lineNumber": 547,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "the zoned date-time, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 872,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this date-time can be queried for the specified field.\nIf false, then calling {@link range} and {@link get} will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n* {@link NANO_OF_SECOND}\n* {@link NANO_OF_DAY}\n* {@link MICRO_OF_SECOND}\n* {@link MICRO_OF_DAY}\n* {@link MILLI_OF_SECOND}\n* {@link MILLI_OF_DAY}\n* {@link SECOND_OF_MINUTE}\n* {@link SECOND_OF_DAY}\n* {@link MINUTE_OF_HOUR}\n* {@link MINUTE_OF_DAY}\n* {@link HOUR_OF_AMPM}\n* {@link CLOCK_HOUR_OF_AMPM}\n* {@link HOUR_OF_DAY}\n* {@link CLOCK_HOUR_OF_DAY}\n* {@link AMPM_OF_DAY}\n* {@link DAY_OF_WEEK}\n* {@link ALIGNED_DAY_OF_WEEK_IN_MONTH}\n* {@link ALIGNED_DAY_OF_WEEK_IN_YEAR}\n* {@link DAY_OF_MONTH}\n* {@link DAY_OF_YEAR}\n* {@link EPOCH_DAY}\n* {@link ALIGNED_WEEK_OF_MONTH}\n* {@link ALIGNED_WEEK_OF_YEAR}\n* {@link MONTH_OF_YEAR}\n* {@link EPOCH_MONTH}\n* {@link YEAR_OF_ERA}\n* {@link YEAR}\n* {@link ERA}\n* {@link INSTANT_SECONDS}\n* {@link OFFSET_SECONDS}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 605,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this date-time, false if not"
    }
  },
  {
    "__docId__": 873,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis date-time is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 637,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 874,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#get",
    "access": "public",
    "description": "Gets the value of the specified field from this date-time as an `int`.\n\nThis queries this date-time for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time, except {@link NANO_OF_DAY}, {@link MICRO_OF_DAY},\n{@link EPOCH_DAY}, {@link EPOCH_MONTH} and {@link INSTANT_SECONDS} which are too\nlarge to fit in an `int` and throw a {@link DateTimeException}.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 672,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 875,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this date-time as a `long`.\n\nThis queries this date-time for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields (see {@link isSupported}) will return valid\nvalues based on this date-time.\nAll other {@link ChronoField} instances will throw a {@link DateTimeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 698,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 876,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#offset",
    "access": "public",
    "description": "Gets the zone offset, such as '+01:00'.\n\nThis is the offset of the local date-time from UTC/Greenwich.",
    "lineNumber": 718,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{ZoneOffset}the zone offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 877,
    "kind": "method",
    "name": "withEarlierOffsetAtOverlap",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withEarlierOffsetAtOverlap",
    "access": "public",
    "description": "Returns a copy of this date-time changing the zone offset to the\nearlier of the two valid offsets at a local time-line overlap.\n\nThis method only has any effect when the local time-line overlaps, such as\nat an autumn daylight savings cutover. In this scenario, there are two\nvalid offsets for the local date-time. Calling this method will return\na zoned date-time with the earlier of the two selected.\n\nIf this method is called when it is not an overlap, `this`\nis returned.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 738,
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the earlier offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 878,
    "kind": "method",
    "name": "withLaterOffsetAtOverlap",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withLaterOffsetAtOverlap",
    "access": "public",
    "description": "Returns a copy of this date-time changing the zone offset to the\nlater of the two valid offsets at a local time-line overlap.\n\nThis method only has any effect when the local time-line overlaps, such as\nat an autumn daylight savings cutover. In this scenario, there are two\nvalid offsets for the local date-time. Calling this method will return\na zoned date-time with the later of the two selected.\n\nIf this method is called when it is not an overlap, `this`\nis returned.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 765,
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the later offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 879,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#zone",
    "access": "public",
    "description": "Gets the time-zone, such as 'Europe/Paris'.\n\nThis returns the zone ID. This identifies the time-zone {@link ZoneRules}\nthat determine when and how the offset from UTC/Greenwich changes.\n\nThe zone ID may be same as the offset (see {@link getOffset}).\nIf this is true, then any future calculations, such as addition or subtraction,\nhave no complex edge cases due to time-zone rules.\nSee also {@link withFixedOffsetZone}.",
    "lineNumber": 790,
    "return": {
      "nullable": null,
      "types": [
        "ZoneId"
      ],
      "spread": false,
      "description": "the time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 880,
    "kind": "method",
    "name": "withZoneSameLocal",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withZoneSameLocal",
    "access": "public",
    "description": "Returns a copy of this date-time with a different time-zone,\nretaining the local date-time if possible.\n\nThis method changes the time-zone and retains the local date-time.\nThe local date-time is only changed if it is invalid for the new zone,\ndetermined using the same approach as\n{@link ofLocal}.\n\nTo change the zone and adjust the local date-time,\nuse {@link withZoneSameInstant}.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 811,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone to change to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested zone, not null"
    }
  },
  {
    "__docId__": 881,
    "kind": "method",
    "name": "withZoneSameInstant",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withZoneSameInstant",
    "access": "public",
    "description": "Returns a copy of this date-time with a different time-zone,\nretaining the instant.\n\nThis method changes the time-zone and retains the instant.\nThis normally results in a change to the local date-time.\n\nThis method is based on retaining the same instant, thus gaps and overlaps\nin the local time-line have no effect on the result.\n\nTo change the offset while keeping the local time,\nuse {@link withZoneSameLocal}.",
    "lineNumber": 833,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone to change to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested zone, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 882,
    "kind": "method",
    "name": "withFixedOffsetZone",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withFixedOffsetZone",
    "access": "public",
    "description": "Returns a copy of this date-time with the zone ID set to the offset.\n\nThis returns a zoned date-time where the zone ID is the same as {@link getOffset}.\nThe local date-time, offset and instant of the result will be the same as in this date-time.\n\nSetting the date-time to a fixed single offset means that any future\ncalculations, such as addition or subtraction, have no complex edge cases\ndue to time-zone rules.\nThis might also be useful when sending a zoned date-time across a network,\nas most protocols, such as ISO-8601, only handle offsets,\nand not region-based zone IDs.\n\nThis is equivalent to {@link ZonedDateTime.of}.",
    "lineNumber": 856,
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} with the zone ID set to the offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 883,
    "kind": "method",
    "name": "year",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#year",
    "access": "public",
    "description": "Gets the year field.\n\nThis method returns the primitive `int` value for the year.\n\nThe year returned by this method is proleptic as per {@link get}.\nTo obtain the year-of-era, use `get(YEAR_OF_ERA)`.",
    "lineNumber": 871,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 884,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#monthValue",
    "access": "public",
    "description": "Gets the month-of-year field from 1 to 12.\n\nThis method returns the month as an `int` from 1 to 12.\nApplication code is frequently clearer if the enum {@link Month}\nis used by calling {@link getMonth}.",
    "see": [
      "#month()"
    ],
    "lineNumber": 885,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 885,
    "kind": "method",
    "name": "month",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#month",
    "access": "public",
    "description": "Gets the month-of-year field using the {@link Month} enum.\n\nThis method returns the enum {@link Month} for the month.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value, use {@link Month#getValue}.",
    "see": [
      "#getMonthValue()"
    ],
    "lineNumber": 899,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 886,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#dayOfMonth",
    "access": "public",
    "description": "Gets the day-of-month field.\n\nThis method returns the primitive `int` value for the day-of-month.",
    "lineNumber": 910,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 887,
    "kind": "method",
    "name": "dayOfYear",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#dayOfYear",
    "access": "public",
    "description": "Gets the day-of-year field.\n\nThis method returns the primitive `int` value for the day-of-year.",
    "lineNumber": 921,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 365, or 366 in a leap year"
    },
    "params": []
  },
  {
    "__docId__": 888,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#dayOfWeek",
    "access": "public",
    "description": "Gets the day-of-week field, which is an enum {@link DayOfWeek}.\n\nThis method returns the enum {@link DayOfWeek} for the day-of-week.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value, use {@link DayOfWeek#getValue}.\n\nAdditional information can be obtained from the {@link DayOfWeek}.\nThis includes textual names of the values.",
    "lineNumber": 937,
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 889,
    "kind": "method",
    "name": "hour",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#hour",
    "access": "public",
    "description": "Gets the hour-of-day field.",
    "lineNumber": 947,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the hour-of-day, from 0 to 23"
    },
    "params": []
  },
  {
    "__docId__": 890,
    "kind": "method",
    "name": "minute",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minute",
    "access": "public",
    "description": "Gets the minute-of-hour field.",
    "lineNumber": 956,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the minute-of-hour, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 891,
    "kind": "method",
    "name": "second",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#second",
    "access": "public",
    "description": "Gets the second-of-minute field.",
    "lineNumber": 965,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the second-of-minute, from 0 to 59"
    },
    "params": []
  },
  {
    "__docId__": 892,
    "kind": "method",
    "name": "nano",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#nano",
    "access": "public",
    "description": "Gets the nano-of-second field.",
    "lineNumber": 974,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the nano-of-second, from 0 to 999,999,999"
    },
    "params": []
  },
  {
    "__docId__": 893,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this date-time.\n\nThis returns a new {@link ZonedDateTime}, based on this one, with the date-time adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the year field.\nA more complex adjuster might set the date to the last day of the month.\nA selection of common adjustments is provided in {@link TemporalAdjusters}.\nThese include finding the 'last day of the month' and 'next Wednesday'.\nKey date-time classes also implement the {@link TemporalAdjuster} interface,\nsuch as {@link Month} and {@link MonthDay}.\nThe adjuster is responsible for handling special cases, such as the varying\nlengths of month and leap years.\n\nFor example this code returns a date on the last day of July:\n<pre>\n import static org.threeten.bp.Month.*;\n import static org.threeten.bp.temporal.Adjusters.*;\n\n result = zonedDateTime.with(JULY).with(lastDayOfMonth());\n</pre>\n\nThe classes {@link LocalDate} and {@link LocalTime} implement {@link TemporalAdjuster},\nthus this method can be used to change the date, time or offset:\n<pre>\n result = zonedDateTime.with(date);\n result = zonedDateTime.with(time);\n</pre>\n\n{@link ZoneOffset} also implements {@link TemporalAdjuster} however it is less likely\nthat setting the offset will have the effect you expect. When an offset is passed in,\nthe local date-time is combined with the new offset to form an {@link Instant}.\nThe instant and original zone are then used to create the result.\nThis algorithm means that it is quite likely that the output has a different offset\nto the specified offset. It will however work correctly when passing in the offset\napplicable for the instant of the zoned date-time, and will work correctly if passing\none of the two valid offsets during a daylight savings overlap when the same local time\noccurs twice.\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster#adjustInto} method on the\nspecified adjuster passing `this` as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1032,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on `this` with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the adjustment cannot be made"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 894,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_withField",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified field set to a new value.\n\nThis returns a {@link ZonedDateTime}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year, month or day-of-month.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIn some cases, changing the specified field can cause the resulting date-time to become invalid,\nsuch as changing the month from 31st January to February would make the day-of-month invalid.\nIn cases like this, the field is responsible for resolving the date. Typically it will choose\nthe previous valid date, which would be the last valid day of February in this example.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\n\nThe {@link INSTANT_SECONDS} field will return a date-time with the specified instant.\nThe zone and nano-of-second are unchanged.\nThe result will have an offset derived from the new instant and original zone.\nIf the new instant value is outside the valid range then a {@link DateTimeException} will be thrown.\n\nThe {@link OFFSET_SECONDS} field will typically be ignored.\nThe offset of a {@link ZonedDateTime} is controlled primarily by the time-zone.\nAs such, changing the offset does not generally make sense, because there is only\none valid offset for the local date-time and zone.\nIf the zoned date-time is in a daylight savings overlap, then the offset is used\nto switch between the two valid offsets. In all other cases, the offset is ignored.\nIf the new offset value is outside the valid range then a {@link DateTimeException} will be thrown.\n\nThe other supported fields (see {@link isSupported}) will behave as in {@link LocalDateTime#with}.\nThe zone is not part of the calculation and will be unchanged.\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1100,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field cannot be set"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the field is not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 895,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withYear",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the year value altered.\n\nThis operates on the local time-line,\nchanging the year (see {@link LocalDateTime#withYear}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the result, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 896,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withMonth",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the month-of-year value altered.\n\nThis operates on the local time-line,\nchanging the month (see {@link LocalDateTime#withMonth}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1155,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the result, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 897,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withDayOfMonth",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the day-of-month value altered.\n\nThis operates on the local time-line,\nchanging the day-of-month (see {@link LocalDateTime#withDayOfMonth}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1178,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to set in the result, from 1 to 28-31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month value is invalid"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 898,
    "kind": "method",
    "name": "withDayOfYear",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withDayOfYear",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the day-of-year altered.\n\nThis operates on the local time-line,\nchanging the day-of-year (see {@link LocalDateTime#withDayOfYear}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1201,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to set in the result, from 1 to 365-366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-year value is invalid"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the day-of-year is invalid for the year"
      }
    ]
  },
  {
    "__docId__": 899,
    "kind": "method",
    "name": "withHour",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withHour",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the hour-of-day value altered.\n\nThis operates on the local time-line,\nchanging the time (see {@link LocalDateTime#withHour}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1224,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hour",
        "description": "the hour-of-day to set in the result, from 0 to 23"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested hour, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the hour value is invalid"
      }
    ]
  },
  {
    "__docId__": 900,
    "kind": "method",
    "name": "withMinute",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withMinute",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the minute-of-hour value altered.\n\nThis operates on the local time-line,\nchanging the time (see {@link LocalDateTime#withMinute}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1246,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minute",
        "description": "the minute-of-hour to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested minute, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the minute value is invalid"
      }
    ]
  },
  {
    "__docId__": 901,
    "kind": "method",
    "name": "withSecond",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withSecond",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the second-of-minute value altered.\n\nThis operates on the local time-line,\nchanging the time (see {@link LocalDateTime#withSecond}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1268,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "second",
        "description": "the second-of-minute to set in the result, from 0 to 59"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested second, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the second value is invalid"
      }
    ]
  },
  {
    "__docId__": 902,
    "kind": "method",
    "name": "withNano",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#withNano",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the nano-of-second value altered.\n\nThis operates on the local time-line,\nchanging the time (see {@link LocalDateTime#withNano}) of the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1290,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanoOfSecond",
        "description": "the nano-of-second to set in the result, from 0 to 999,999,999"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the requested nanosecond, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the nano value is invalid"
      }
    ]
  },
  {
    "__docId__": 903,
    "kind": "method",
    "name": "truncatedTo",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#truncatedTo",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the time truncated.\n\nTruncation returns a copy of the original date-time with fields\nsmaller than the specified unit set to zero.\nFor example, truncating with {@link ChronoUnit#MINUTES}\nwill set the second-of-minute and nano-of-second field to zero.\n\nThe unit must have a duration (see {@link TemporalUnit#getDuration})\nthat divides into the length of a standard day without remainder.\nThis includes all supplied time units on {@link ChronoUnit} and\n{@link ChronoUnit#DAYS}. Other units throw an exception.\n\nThis operates on the local time-line, truncating the underlying local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID to obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1321,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to truncate to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the time truncated, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to truncate"
      }
    ]
  },
  {
    "__docId__": 904,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified period added.\n\nThis method returns a new date-time based on this date-time with the specified period added.\nThis can be used to add any period that is defined by a unit, for example to add years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThe calculation for date and time units differ.\n\nDate units operate on the local time-line.\nThe period is first added to the local date-time, then converted back\nto a zoned date-time using the zone ID.\nThe conversion uses {@link ofLocal}\nwith the offset before the addition.\n\nTime units operate on the instant time-line.\nThe period is first added to the local date-time, then converted back to\na zoned date-time using the zone ID.\nThe conversion uses {@link ofInstant}\nwith the offset before the addition.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1356,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the specified period added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 905,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusYears",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in years added.\n\nThis operates on the local time-line, adding years to the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1386,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 906,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in months added.\n\nThis operates on the local time-line, adding months to the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1407,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the months added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 907,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in weeks added.\n\nThis operates on the local time-line, adding weeks to the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1428,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the weeks added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 908,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusDays",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in days added.\n\nThis operates on the local time-line, adding days to the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1449,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{ZonedDateTime}a {@link ZonedDateTime} based on this date-time with the days added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 909,
    "kind": "method",
    "name": "plusHours",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusHours",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in hours added.\n\nThis operates on the instant time-line, such that adding one hour will\nalways be a duration of one hour later.\nThis may cause the local date-time to change by an amount other than one hour.\nNote that this is a different approach to that used by days, months and years,\nthus adding one day is not the same as adding 24 hours.\n\nFor example, consider a time-zone where the spring DST cutover means that the\nlocal times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n\n* Adding one hour to 00:30+02:00 will result in 01:30+02:00\n* Adding one hour to 01:30+02:00 will result in 01:30+01:00\n* Adding one hour to 01:30+01:00 will result in 02:30+01:00\n* Adding three hours to 00:30+02:00 will result in 02:30+01:00\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1477,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the hours to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the hours added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 910,
    "kind": "method",
    "name": "plusMinutes",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in minutes added.\n\nThis operates on the instant time-line, such that adding one minute will\nalways be a duration of one minute later.\nThis may cause the local date-time to change by an amount other than one minute.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1495,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the minutes to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the minutes added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 911,
    "kind": "method",
    "name": "plusSeconds",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in seconds added.\n\nThis operates on the instant time-line, such that adding one second will\nalways be a duration of one second later.\nThis may cause the local date-time to change by an amount other than one second.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1513,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the seconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 912,
    "kind": "method",
    "name": "plusNanos",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#plusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds added.\n\nThis operates on the instant time-line, such that adding one nano will\nalways be a duration of one nano later.\nThis may cause the local date-time to change by an amount other than one nano.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1531,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanos to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the nanoseconds added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 913,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#_minusUnit",
    "access": "private",
    "description": "Returns a copy of this date-time with the specified period subtracted.\n\nThis method returns a new date-time based on this date-time with the specified period subtracted.\nThis can be used to subtract any period that is defined by a unit, for example to subtract years, months or days.\nThe unit is responsible for the details of the calculation, including the resolution\nof any edge cases in the calculation.\n\nThe calculation for date and time units differ.\n\nDate units operate on the local time-line.\nThe period is first subtracted from the local date-time, then converted back\nto a zoned date-time using the zone ID.\nThe conversion uses {@link ofLocal}\nwith the offset before the subtraction.\n\nTime units operate on the instant time-line.\nThe period is first subtracted from the local date-time, then converted back to\na zoned date-time using the zone ID.\nThe conversion uses {@link ofInstant}\nwith the offset before the subtraction.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1566,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the unit to subtract from the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the specified period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the unit cannot be added to this type"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 914,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusYears",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in years subtracted.\n\nThis operates on the local time-line, subtracting years from the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1588,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 915,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusMonths",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in months subtracted.\n\nThis operates on the local time-line, subtracting months from the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1609,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 916,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusWeeks",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in weeks subtracted.\n\nThis operates on the local time-line, subtracting weeks from the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1630,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the weeks subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 917,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusDays",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in days subtracted.\n\nThis operates on the local time-line, subtracting days from the local date-time.\nThis is then converted back to a {@link ZonedDateTime}, using the zone ID\nto obtain the offset.\n\nWhen converting back to {@link ZonedDateTime}, if the local date-time is in an overlap,\nthen the offset will be retained if possible, otherwise the earlier offset will be used.\nIf in a gap, the local date-time will be adjusted forward by the length of the gap.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1651,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the days subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 918,
    "kind": "method",
    "name": "minusHours",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusHours",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in hours subtracted.\n\nThis operates on the instant time-line, such that subtracting one hour will\nalways be a duration of one hour earlier.\nThis may cause the local date-time to change by an amount other than one hour.\nNote that this is a different approach to that used by days, months and years,\nthus subtracting one day is not the same as adding 24 hours.\n\nFor example, consider a time-zone where the spring DST cutover means that the\nlocal times 01:00 to 01:59 occur twice changing from offset +02:00 to +01:00.\n\n* Subtracting one hour from 02:30+01:00 will result in 01:30+02:00\n* Subtracting one hour from 01:30+01:00 will result in 01:30+02:00\n* Subtracting one hour from 01:30+02:00 will result in 00:30+01:00\n* Subtracting three hours from 02:30+01:00 will result in 00:30+02:00\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1679,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "hours",
        "description": "the hours to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the hours subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 919,
    "kind": "method",
    "name": "minusMinutes",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusMinutes",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in minutes subtracted.\n\nThis operates on the instant time-line, such that subtracting one minute will\nalways be a duration of one minute earlier.\nThis may cause the local date-time to change by an amount other than one minute.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1697,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minutes",
        "description": "the minutes to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the minutes subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 920,
    "kind": "method",
    "name": "minusSeconds",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusSeconds",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in seconds subtracted.\n\nThis operates on the instant time-line, such that subtracting one second will\nalways be a duration of one second earlier.\nThis may cause the local date-time to change by an amount other than one second.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1715,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "seconds",
        "description": "the seconds to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the seconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 921,
    "kind": "method",
    "name": "minusNanos",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#minusNanos",
    "access": "public",
    "description": "Returns a copy of this {@link ZonedDateTime} with the specified period in nanoseconds subtracted.\n\nThis operates on the instant time-line, such that subtracting one nano will\nalways be a duration of one nano earlier.\nThis may cause the local date-time to change by an amount other than one nano.\nNote that this is a different approach to that used by days, months and years.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1733,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "nanos",
        "description": "the nanos to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": "a {@link ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 922,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#query",
    "access": "public",
    "description": "Queries this date-time using the specified query.\n\nThis queries this date-time using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery#queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 1755,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query (defined by the query)"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 923,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#until",
    "access": "public",
    "description": "Calculates the period between this date-time and another date-time in\nterms of the specified unit.\n\nThis calculates the period between two date-times in terms of a single unit.\nThe start and end points are `this` and the specified date-time.\nThe result will be negative if the end is before the start.\nFor example, the period in days between two date-times can be calculated\nusing {@link startDateTime.until}.\n\nThe {@link Temporal} passed to this method must be a {@link ZonedDateTime}.\nIf the time-zone differs between the two zoned date-times, the specified\nend date-time is normalized to have the same zone as this date-time.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two date-times.\nFor example, the period in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z\nwill only be one month as it is one minute short of two months.\n\nThis method operates in association with {@link TemporalUnit#between}.\nThe result of this method is a `long` representing the amount of\nthe specified unit. By contrast, the result of {@link between} is an\nobject that can be used directly in addition/subtraction:\n<pre>\n  long period = start.until(end, MONTHS);   // this method\n  dateTime.plus(MONTHS.between(start, end));      // use in plus/minus\n</pre>\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units {@link NANOS}, {@link MICROS}, {@link MILLIS}, {@link SECONDS},\n{@link MINUTES}, {@link HOURS} and {@link HALF_DAYS}, {@link DAYS},\n{@link WEEKS}, {@link MONTHS}, {@link YEARS}, {@link DECADES},\n{@link CENTURIES}, {@link MILLENNIA} and {@link ERAS} are supported.\nOther {@link ChronoUnit} values will throw an exception.\n\nThe calculation for date and time units differ.\n\nDate units operate on the local time-line, using the local date-time.\nFor example, the period from noon on day 1 to noon the following day\nin days will always be counted as exactly one day, irrespective of whether\nthere was a daylight savings change or not.\n\nTime units operate on the instant time-line.\nThe calculation effectively converts both zoned date-times to instants\nand then calculates the period between the instants.\nFor example, the period from noon on day 1 to noon the following day\nin hours may be 23, 24 or 25 hours (or some other amount) depending on\nwhether there was a daylight savings change or not.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing `this` as the first argument and the input temporal as\nthe second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1825,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date-time, which is converted to a {@link ZonedDateTime}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this date-time and the end date-time"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be calculated"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 924,
    "kind": "method",
    "name": "toLocalDateTime",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toLocalDateTime",
    "access": "public",
    "description": "Gets the {@link LocalDateTime} part of this date-time.\n\nThis returns a {@link LocalDateTime} with the same year, month, day and time\nas this date-time.",
    "lineNumber": 1849,
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the local date-time part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 925,
    "kind": "method",
    "name": "toLocalDate",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toLocalDate",
    "access": "public",
    "description": "Gets the {@link LocalDate} part of this date-time.\n\nThis returns a {@link LocalDate} with the same year, month and day\nas this date-time.",
    "lineNumber": 1861,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 926,
    "kind": "method",
    "name": "toLocalTime",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toLocalTime",
    "access": "public",
    "description": "Gets the {@link LocalTime} part of this date-time.\n\nThis returns a {@link LocalTime} with the same hour, minute, second and\nnanosecond as this date-time.",
    "lineNumber": 1873,
    "return": {
      "nullable": null,
      "types": [
        "LocalTime"
      ],
      "spread": false,
      "description": "the time part of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 927,
    "kind": "method",
    "name": "toOffsetDateTime",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toOffsetDateTime",
    "access": "public",
    "description": "Converts this date-time to an {@link OffsetDateTime}.\n\nThis creates an offset date-time using the local date-time and offset.\nThe zone ID is ignored.",
    "lineNumber": 1885,
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "an offset date-time representing the same local date-time and offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 928,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#equals",
    "access": "public",
    "description": "Checks if this date-time is equal to another date-time.\n\nThe comparison is based on the offset date-time and the zone.\nOnly objects of type {@link ZonedDateTime} are compared, other types return false.",
    "lineNumber": 1899,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other date-time"
    }
  },
  {
    "__docId__": 929,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#hashCode",
    "access": "public",
    "description": "A hash code for this date-time.",
    "lineNumber": 1916,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 930,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toString",
    "access": "public",
    "description": "Outputs this date-time as a string, such as\n`2007-12-03T10:15:30+01:00[Europe/Paris]`.\n\nThe format consists of the {@link LocalDateTime} followed by the {@link ZoneOffset}.\nIf the {@link ZoneId} is not the same as the offset, then the ID is output.\nThe output is compatible with ISO-8601 if the offset and ID are the same.",
    "lineNumber": 1931,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this date-time, not null"
    },
    "params": []
  },
  {
    "__docId__": 931,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#toJSON",
    "access": "public",
    "description": "",
    "lineNumber": 1943,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "same as {@link ZonedDateTime.toString}"
    },
    "params": []
  },
  {
    "__docId__": 932,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/ZonedDateTime.js~ZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/ZonedDateTime.js~ZonedDateTime#format",
    "access": "public",
    "description": "Outputs this date-time as a string using the formatter.",
    "lineNumber": 1954,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted date-time string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 933,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/ZonedDateTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/ZonedDateTime.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/ZonedDateTime.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1960,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 934,
    "kind": "file",
    "name": "packages/core/src/_init.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { _init as ZoneOffsetInit } from './ZoneOffset';\nimport { _init as DayOfWeekInit } from './DayOfWeek';\nimport { _init as DurationInit } from './Duration';\nimport { _init as InstantInit } from './Instant';\nimport { _init as LocalDateInit } from './LocalDate';\nimport { _init as LocalTimeInit } from './LocalTime';\nimport { _init as LocalDateTimeInit } from './LocalDateTime';\nimport { _init as MonthInit } from './Month';\nimport { _init as MonthDayInit } from './MonthDay';\nimport { _init as OffsetDateTimeInit } from './OffsetDateTime';\nimport { _init as OffsetTimeInit } from './OffsetTime';\nimport { _init as PeriodInit } from './Period';\nimport { _init as YearInit } from './Year';\nimport { _init as YearConstantsInit } from './YearConstants';\nimport { _init as YearMonthInit } from './YearMonth';\nimport { _init as ZonedDateTimeInit } from './ZonedDateTime';\nimport { _init as IsoChronologyInit } from './chrono/IsoChronology';\nimport { _init as DateTimeFormatterInit } from './format/DateTimeFormatter';\nimport { _init as ChronoFieldInit } from './temporal/ChronoField';\nimport { _init as ChronoUnitInit } from './temporal/ChronoUnit';\nimport { _init as IsoFieldsInit } from './temporal/IsoFields';\nimport { _init as DateTimeFormatterBuilderInit } from './format/DateTimeFormatterBuilder';\n\nimport { _init as TemporalQueriesInit } from './temporal/TemporalQueriesFactory';\nimport { _init as ZoneIdInit } from './ZoneIdFactory';\n\nlet isInit = false;\n\nfunction init() {\n\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    YearConstantsInit();\n    DurationInit();\n    ChronoUnitInit();\n    ChronoFieldInit();\n    LocalTimeInit();\n    IsoFieldsInit();\n    TemporalQueriesInit();\n    DayOfWeekInit();\n    InstantInit();\n    LocalDateInit();\n    LocalDateTimeInit();\n    YearInit();\n    MonthInit();\n    YearMonthInit();\n    MonthDayInit();\n    PeriodInit();\n    ZoneOffsetInit();\n    ZonedDateTimeInit();\n    ZoneIdInit();\n    IsoChronologyInit();\n    DateTimeFormatterInit();\n    DateTimeFormatterBuilderInit();\n    OffsetDateTimeInit();\n    OffsetTimeInit();\n}\n\ninit();\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/_init.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 935,
    "kind": "variable",
    "name": "isInit",
    "memberof": "packages/core/src/_init.js",
    "static": true,
    "longname": "packages/core/src/_init.js~isInit",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 936,
    "kind": "function",
    "name": "init",
    "memberof": "packages/core/src/_init.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/_init.js~init",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 937,
    "kind": "file",
    "name": "packages/core/src/assert.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { NullPointerException, IllegalArgumentException } from './errors';\n\n/**\n * @private\n *\n * @param assertion\n * @param msg\n * @param error\n */\nexport function assert(assertion, msg, error) {\n    if(!assertion){\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\n/**\n * @private\n *\n * @param value\n * @param parameterName\n * @returns {*}\n */\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(`${parameterName} must not be null`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param value\n * @param _class\n * @param parameterName\n * @returns {_class}\n */\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(`${parameterName} must be an instance of ${_class.name ? _class.name : _class}${value && value.constructor && value.constructor.name ? `, but is ${value.constructor.name}` : ''}`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param methodName\n */\nexport function abstractMethodFail(methodName){\n    throw new TypeError(`abstract method \"${methodName}\" is not implemented`);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/assert.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 938,
    "kind": "function",
    "name": "assert",
    "memberof": "packages/core/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/assert.js~assert",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/assert.js",
    "importStyle": "{assert}",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "assertion",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 939,
    "kind": "function",
    "name": "requireNonNull",
    "memberof": "packages/core/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/assert.js~requireNonNull",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/assert.js",
    "importStyle": "{requireNonNull}",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parameterName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 940,
    "kind": "function",
    "name": "requireInstance",
    "memberof": "packages/core/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/assert.js~requireInstance",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/assert.js",
    "importStyle": "{requireInstance}",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{_class}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "_class",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parameterName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "_class"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 941,
    "kind": "function",
    "name": "abstractMethodFail",
    "memberof": "packages/core/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/assert.js~abstractMethodFail",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/assert.js",
    "importStyle": "{abstractMethodFail}",
    "description": "",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "methodName",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 942,
    "kind": "file",
    "name": "packages/core/src/chrono/ChronoLocalDate.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull, requireInstance } from '../assert';\n\nimport { ChronoField } from '../temporal/ChronoField';\nimport { ChronoUnit } from '../temporal/ChronoUnit';\nimport { DateTimeFormatter } from '../format/DateTimeFormatter';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\nimport { Temporal } from '../temporal/Temporal';\n\nimport { LocalDate } from '../LocalDate';\n\n/**\n * A date without time-of-day or time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDate}, not this interface.**\n *\n * A {@link ChronoLocalDate} is the abstract representation of a date where the\n * {@link Chronology}, or calendar system, is pluggable.\n * The date is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDate} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in the following documentation.\n *\n * The primary use case where this interface should be used is where the generic\n * type parameter `C` is fully defined as a specific chronology.\n * In that case, the assumptions of that chronology are known at development\n * time and specified in the code.\n *\n * When the chronology is defined in the generic type parameter as ? or otherwise\n * unknown at development time, the rest of the discussion below applies.\n *\n * To emphasize the point, declaring a method signature, field or variable as this\n * interface type can initially seem like the sensible way to globalize an application,\n * however it is usually the wrong approach.\n * As such, it should be considered an application-wide architectural decision to choose\n * to use this interface as opposed to {@link LocalDate}.\n *\n * #### Architectural issues to consider\n *\n * These are some of the points that must be considered before using this interface\n * throughout an application.\n *\n * 1) Applications using this interface, as opposed to using just {@link LocalDate},\n * face a significantly higher probability of bugs. This is because the calendar system\n * in use is not known at development time. A key cause of bugs is where the developer\n * applies assumptions from their day-to-day knowledge of the ISO calendar system\n * to code that is intended to deal with any arbitrary calendar system.\n * The section below outlines how those assumptions can cause problems\n * The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n * This should also be considered a extra cost in maintenance for the lifetime of the code.\n *\n * 2) This interface does not enforce immutability of implementations.\n * While the implementation notes indicate that all implementations must be immutable\n * there is nothing in the code or type system to enforce this. Any method declared\n * to accept a {@link ChronoLocalDate} could therefore be passed a poorly or\n * maliciously written mutable implementation.\n *\n * 3) Applications using this interface  must consider the impact of eras.\n * {@link LocalDate} shields users from the concept of eras, by ensuring that `getYear()`\n * returns the proleptic year. That decision ensures that developers can think of\n * {@link LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\n * By contrast, users of this interface must think of dates as consisting of four fields -\n * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n * For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n * Whenever one reign ends and another starts, the year-of-era is reset to one.\n *\n * 4) The only agreed international standard for passing a date between two systems\n * is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n * throughout the application will inevitably lead to the requirement to pass the date\n * across a network or component boundary, requiring an application specific protocol or format.\n *\n * 5) Long term persistence, such as a database, will almost always only accept dates in the\n * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n * calendar systems increases the complications of interacting with persistence.\n *\n * 6) Most of the time, passing a {@link ChronoLocalDate} throughout an application\n * is unnecessary, as discussed in the last section below.\n *\n * #### False assumptions causing bugs in multi-calendar system code\n *\n * As indicated above, there are many issues to consider when try to use and manipulate a\n * date in an arbitrary calendar system. These are some of the key issues.\n *\n * Code that queries the day-of-month and assumes that the value will never be more than\n * 31 is invalid. Some calendar systems have more than 31 days in some months.\n *\n * Code that adds 12 months to a date and assumes that a year has been added is invalid.\n * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n *\n * Code that adds one month to a date and assumes that the month-of-year value will increase\n * by one or wrap to the next year is invalid. Some calendar systems have a variable number\n * of months in a year, such as the Hebrew.\n *\n * Code that adds one month, then adds a second one month and assumes that the day-of-month\n * will remain close to its original value is invalid. Some calendar systems have a large difference\n * between the length of the longest month and the length of the shortest month.\n * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n *\n * Code that adds seven days and assumes that a week has been added is invalid.\n * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.\n *\n * Code that assumes that because the year of `date1` is greater than the year of `date2`\n * then `date1` is after `date2` is invalid. This is invalid for all calendar systems\n * when referring to the year-of-era, and especially untrue of the Japanese calendar system\n * where the year-of-era restarts with the reign of every new Emperor.\n *\n * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n * Not all calendar systems start the year when the month value is one.\n *\n * In general, manipulating a date, and even querying a date, is wide open to bugs when the\n * calendar system is unknown at development time. This is why it is essential that code using\n * this interface is subjected to additional code reviews. It is also why an architectural\n * decision to avoid this interface type is usually the correct one.\n *\n * #### Using LocalDate instead\n *\n * The primary alternative to using this interface throughout your application is as follows.\n *\n * * Declare all method signatures referring to dates in terms of {@link LocalDate}.\n * * Either store the chronology (calendar system) in the user profile or lookup the chronology\n *   from the user locale.\n * * Convert the ISO {@link LocalDate} to and from the user's preferred calendar system during\n *   printing and parsing.\n *\n * This approach treats the problem of globalized calendar systems as a localization issue\n * and confines it to the UI layer. This approach is in keeping with other localization\n * issues in the java platform.\n *\n * As discussed above, performing calculations on a date where the rules of the calendar system\n * are pluggable requires skill and is not recommended.\n * Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n * is extremely rare. For example, it is highly unlikely that the business rules of a library\n * book rental scheme will allow rentals to be for one month, where meaning of the month\n * is dependent on the user's preferred calendar system.\n *\n * A key use case for calculations on a date in an arbitrary calendar system is producing\n * a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n * and use of this interface solely within a few methods of the UI layer may be justified.\n *\n * In any other part of the system, where a date must be manipulated in a calendar system\n * other than ISO, the use case will generally specify the calendar system to use.\n * For example, an application may need to calculate the next Islamic or Hebrew holiday\n * which may require manipulating the date.\n * This kind of use case can be handled as follows:\n *\n * * start from the ISO {@link LocalDate} being passed to the method\n * * convert the date to the alternate calendar system, which for this use case is known\n *   rather than arbitrary\n * * perform the calculation\n * * convert back to {@link LocalDate}\n *\n * Developers writing low-level frameworks or libraries should also avoid this interface.\n * Instead, one of the two general purpose access interfaces should be used.\n * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\n * if read-write access is required.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * Additional calendar systems may be added to the system.\n * See {@link Chronology} for more details.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n */\nexport class ChronoLocalDate extends Temporal {\n\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toEpochDay());\n        } else if (query === TemporalQueries.localTime() || query === TemporalQueries.zone() ||\n                query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n    }\n    /**\n     * Formats this date using the specified formatter.\n     *\n     * This date will be passed to the formatter to produce a string.\n     *\n     * The default implementation must behave as follows:\n     * <pre>\n     *  return formatter.format(this);\n     * </pre>\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to use, not null\n     * @return {String} the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.format(this);\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/chrono/ChronoLocalDate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 943,
    "kind": "class",
    "name": "ChronoLocalDate",
    "memberof": "packages/core/src/chrono/ChronoLocalDate.js",
    "static": true,
    "longname": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/chrono/ChronoLocalDate.js",
    "importStyle": "{ChronoLocalDate}",
    "description": "A date without time-of-day or time-zone in an arbitrary chronology, intended\nfor advanced globalization use cases.\n\n**Most applications should declare method signatures, fields and variables\nas {@link LocalDate}, not this interface.**\n\nA {@link ChronoLocalDate} is the abstract representation of a date where the\n{@link Chronology}, or calendar system, is pluggable.\nThe date is defined in terms of fields expressed by {@link TemporalField},\nwhere most common implementations are defined in {@link ChronoField}.\nThe chronology defines how the calendar system operates and the meaning of\nthe standard fields.\n\n#### When to use this interface\n\nThe design of the API encourages the use of {@link LocalDate} rather than this\ninterface, even in the case where the application needs to deal with multiple\ncalendar systems. The rationale for this is explored in the following documentation.\n\nThe primary use case where this interface should be used is where the generic\ntype parameter `C` is fully defined as a specific chronology.\nIn that case, the assumptions of that chronology are known at development\ntime and specified in the code.\n\nWhen the chronology is defined in the generic type parameter as ? or otherwise\nunknown at development time, the rest of the discussion below applies.\n\nTo emphasize the point, declaring a method signature, field or variable as this\ninterface type can initially seem like the sensible way to globalize an application,\nhowever it is usually the wrong approach.\nAs such, it should be considered an application-wide architectural decision to choose\nto use this interface as opposed to {@link LocalDate}.\n\n#### Architectural issues to consider\n\nThese are some of the points that must be considered before using this interface\nthroughout an application.\n\n1) Applications using this interface, as opposed to using just {@link LocalDate},\nface a significantly higher probability of bugs. This is because the calendar system\nin use is not known at development time. A key cause of bugs is where the developer\napplies assumptions from their day-to-day knowledge of the ISO calendar system\nto code that is intended to deal with any arbitrary calendar system.\nThe section below outlines how those assumptions can cause problems\nThe primary mechanism for reducing this increased risk of bugs is a strong code review process.\nThis should also be considered a extra cost in maintenance for the lifetime of the code.\n\n2) This interface does not enforce immutability of implementations.\nWhile the implementation notes indicate that all implementations must be immutable\nthere is nothing in the code or type system to enforce this. Any method declared\nto accept a {@link ChronoLocalDate} could therefore be passed a poorly or\nmaliciously written mutable implementation.\n\n3) Applications using this interface  must consider the impact of eras.\n{@link LocalDate} shields users from the concept of eras, by ensuring that `getYear()`\nreturns the proleptic year. That decision ensures that developers can think of\n{@link LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\nBy contrast, users of this interface must think of dates as consisting of four fields -\nera, year-of-era, month-of-year and day-of-month. The extra era field is frequently\nforgotten, yet it is of vital importance to dates in an arbitrary calendar system.\nFor example, in the Japanese calendar system, the era represents the reign of an Emperor.\nWhenever one reign ends and another starts, the year-of-era is reset to one.\n\n4) The only agreed international standard for passing a date between two systems\nis the ISO-8601 standard which requires the ISO calendar system. Using this interface\nthroughout the application will inevitably lead to the requirement to pass the date\nacross a network or component boundary, requiring an application specific protocol or format.\n\n5) Long term persistence, such as a database, will almost always only accept dates in the\nISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\ncalendar systems increases the complications of interacting with persistence.\n\n6) Most of the time, passing a {@link ChronoLocalDate} throughout an application\nis unnecessary, as discussed in the last section below.\n\n#### False assumptions causing bugs in multi-calendar system code\n\nAs indicated above, there are many issues to consider when try to use and manipulate a\ndate in an arbitrary calendar system. These are some of the key issues.\n\nCode that queries the day-of-month and assumes that the value will never be more than\n31 is invalid. Some calendar systems have more than 31 days in some months.\n\nCode that adds 12 months to a date and assumes that a year has been added is invalid.\nSome calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n\nCode that adds one month to a date and assumes that the month-of-year value will increase\nby one or wrap to the next year is invalid. Some calendar systems have a variable number\nof months in a year, such as the Hebrew.\n\nCode that adds one month, then adds a second one month and assumes that the day-of-month\nwill remain close to its original value is invalid. Some calendar systems have a large difference\nbetween the length of the longest month and the length of the shortest month.\nFor example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n\nCode that adds seven days and assumes that a week has been added is invalid.\nSome calendar systems have weeks of other than seven days, such as the French Revolutionary.\n\nCode that assumes that because the year of `date1` is greater than the year of `date2`\nthen `date1` is after `date2` is invalid. This is invalid for all calendar systems\nwhen referring to the year-of-era, and especially untrue of the Japanese calendar system\nwhere the year-of-era restarts with the reign of every new Emperor.\n\nCode that treats month-of-year one and day-of-month one as the start of the year is invalid.\nNot all calendar systems start the year when the month value is one.\n\nIn general, manipulating a date, and even querying a date, is wide open to bugs when the\ncalendar system is unknown at development time. This is why it is essential that code using\nthis interface is subjected to additional code reviews. It is also why an architectural\ndecision to avoid this interface type is usually the correct one.\n\n#### Using LocalDate instead\n\nThe primary alternative to using this interface throughout your application is as follows.\n\n* Declare all method signatures referring to dates in terms of {@link LocalDate}.\n* Either store the chronology (calendar system) in the user profile or lookup the chronology\n  from the user locale.\n* Convert the ISO {@link LocalDate} to and from the user's preferred calendar system during\n  printing and parsing.\n\nThis approach treats the problem of globalized calendar systems as a localization issue\nand confines it to the UI layer. This approach is in keeping with other localization\nissues in the java platform.\n\nAs discussed above, performing calculations on a date where the rules of the calendar system\nare pluggable requires skill and is not recommended.\nFortunately, the need to perform calculations on a date in an arbitrary calendar system\nis extremely rare. For example, it is highly unlikely that the business rules of a library\nbook rental scheme will allow rentals to be for one month, where meaning of the month\nis dependent on the user's preferred calendar system.\n\nA key use case for calculations on a date in an arbitrary calendar system is producing\na month-by-month calendar for display and user interaction. Again, this is a UI issue,\nand use of this interface solely within a few methods of the UI layer may be justified.\n\nIn any other part of the system, where a date must be manipulated in a calendar system\nother than ISO, the use case will generally specify the calendar system to use.\nFor example, an application may need to calculate the next Islamic or Hebrew holiday\nwhich may require manipulating the date.\nThis kind of use case can be handled as follows:\n\n* start from the ISO {@link LocalDate} being passed to the method\n* convert the date to the alternate calendar system, which for this use case is known\n  rather than arbitrary\n* perform the calculation\n* convert back to {@link LocalDate}\n\nDevelopers writing low-level frameworks or libraries should also avoid this interface.\nInstead, one of the two general purpose access interfaces should be used.\nUse {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\nif read-write access is required.\n\n### Specification for implementors\n\nThis interface must be implemented with care to ensure other classes operate correctly.\nAll implementations that can be instantiated must be final, immutable and thread-safe.\nSubclasses should be Serializable wherever possible.\n\nAdditional calendar systems may be added to the system.\nSee {@link Chronology} for more details.\n\nIn JDK 8, this is an interface with default methods.\nSince there are no default methods in JDK 7, an abstract class is used.",
    "lineNumber": 183,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 944,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate#isSupported",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "fieldOrUnit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 945,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate#query",
    "access": "public",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 946,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 947,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDate.js~ChronoLocalDate#format",
    "access": "public",
    "description": "Formats this date using the specified formatter.\n\nThis date will be passed to the formatter to produce a string.\n\nThe default implementation must behave as follows:\n<pre>\n return formatter.format(this);\n</pre>",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the formatted date string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 948,
    "kind": "file",
    "name": "packages/core/src/chrono/ChronoLocalDateTime.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull, requireInstance } from '../assert';\nimport { MathUtil } from '../MathUtil';\n\nimport { LocalDate } from '../LocalDate';\nimport { Instant } from '../Instant';\nimport { ZoneOffset } from '../ZoneOffset';\nimport { ChronoUnit } from '../temporal/ChronoUnit';\nimport { ChronoField } from '../temporal/ChronoField';\nimport { Temporal } from '../temporal/Temporal';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\n\n/**\n * A date-time without a time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n *\n * **Most applications should declare method signatures, fields and variables\n * as {@link LocalDateTime}, not this interface.**\n *\n * A {@link ChronoLocalDateTime} is the abstract representation of a local date-time\n * where the {@link Chronology}, or calendar system, is pluggable.\n * The date-time is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * #### When to use this interface\n *\n * The design of the API encourages the use of {@link LocalDateTime} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.\n *\n * Ensure that the discussion in {@link ChronoLocalDate} has been read and understood\n * before using this interface.\n *\n * ### Specification for implementors\n *\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n *\n * In JDK 8, this is an interface with default methods.\n * Since there are no default methods in JDK 7, an abstract class is used.\n *\n * @param D the date type\n */\nexport class ChronoLocalDateTime extends Temporal {\n    /* <D extends ChronoLocalDate>\n        extends DefaultInterfaceTemporal\n        implements Temporal, TemporalAdjuster, Comparable<ChronoLocalDateTime<?>> */\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of this date-time.\n     *\n     * The {@link Chronology} represents the calendar system in use.\n     * The era and other fields in {@link ChronoField} are defined by the chronology.\n     *\n     * @return the chronology, not null\n     */\n    chronology() {\n        return this.toLocalDate().chronology();\n    }\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.zoneId() || query === TemporalQueries.offset()) {\n            return null;\n        }\n        return super.query(query);\n    }\n\n    adjustInto(temporal) {\n        return temporal\n            .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay())\n            .with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This combines this local date-time and the specified offset to form\n     * an {@link Instant}.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant(offset) {\n        requireInstance(offset, ZoneOffset, 'zoneId');\n        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This combines this local date-time and the specified offset to calculate the\n     * epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @param {ZoneOffset} offset  the offset to use for the conversion, not null\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond(offset) {\n        requireNonNull(offset, 'offset');\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= offset.totalSeconds();\n        return MathUtil.safeToInt(secs);\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/chrono/ChronoLocalDateTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 949,
    "kind": "class",
    "name": "ChronoLocalDateTime",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js",
    "static": true,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/chrono/ChronoLocalDateTime.js",
    "importStyle": "{ChronoLocalDateTime}",
    "description": "A date-time without a time-zone in an arbitrary chronology, intended\nfor advanced globalization use cases.\n\n**Most applications should declare method signatures, fields and variables\nas {@link LocalDateTime}, not this interface.**\n\nA {@link ChronoLocalDateTime} is the abstract representation of a local date-time\nwhere the {@link Chronology}, or calendar system, is pluggable.\nThe date-time is defined in terms of fields expressed by {@link TemporalField},\nwhere most common implementations are defined in {@link ChronoField}.\nThe chronology defines how the calendar system operates and the meaning of\nthe standard fields.\n\n#### When to use this interface\n\nThe design of the API encourages the use of {@link LocalDateTime} rather than this\ninterface, even in the case where the application needs to deal with multiple\ncalendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.\n\nEnsure that the discussion in {@link ChronoLocalDate} has been read and understood\nbefore using this interface.\n\n### Specification for implementors\n\nThis interface must be implemented with care to ensure other classes operate correctly.\nAll implementations that can be instantiated must be final, immutable and thread-safe.\nSubclasses should be Serializable wherever possible.\n\nIn JDK 8, this is an interface with default methods.\nSince there are no default methods in JDK 7, an abstract class is used.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "D",
        "description": "the date type"
      }
    ],
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 950,
    "kind": "method",
    "name": "chronology",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime#chronology",
    "access": "public",
    "description": "Gets the chronology of this date-time.\n\nThe {@link Chronology} represents the calendar system in use.\nThe era and other fields in {@link ChronoField} are defined by the chronology.",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the chronology, not null"
    },
    "params": []
  },
  {
    "__docId__": 951,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime#query",
    "access": "public",
    "description": "",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 952,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 953,
    "kind": "method",
    "name": "toInstant",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime#toInstant",
    "access": "public",
    "description": "Converts this date-time to an {@link Instant}.\n\nThis combines this local date-time and the specified offset to form\nan {@link Instant}.",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to use for the conversion, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} representing the same instant, not null"
    }
  },
  {
    "__docId__": 954,
    "kind": "method",
    "name": "toEpochSecond",
    "memberof": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoLocalDateTime.js~ChronoLocalDateTime#toEpochSecond",
    "access": "public",
    "description": "Converts this date-time to the number of seconds from the epoch\nof 1970-01-01T00:00:00Z.\n\nThis combines this local date-time and the specified offset to calculate the\nepoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\nInstants on the time-line after the epoch are positive, earlier are negative.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to use for the conversion, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of seconds from the epoch of 1970-01-01T00:00:00Z"
    }
  },
  {
    "__docId__": 955,
    "kind": "file",
    "name": "packages/core/src/chrono/ChronoZonedDateTime.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../assert';\nimport { Instant } from '../Instant';\nimport { LocalDate } from '../LocalDate';\nimport { MathUtil } from '../MathUtil';\n\nimport { ChronoUnit } from '../temporal/ChronoUnit';\nimport { Temporal } from '../temporal/Temporal';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\n\nexport class ChronoZonedDateTime extends Temporal {\n    query(query) {\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone();\n        } else if (query === TemporalQueries.chronology()) {\n            return this.toLocalDate().chronology();\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (query === TemporalQueries.offset()) {\n            return this.offset();\n        } else if (query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Outputs this date-time as a string using the formatter.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    /**\n     * Converts this date-time to an {@link Instant}.\n     *\n     * This returns an {@link Instant} representing the same point on the\n     * time-line as this date-time. The calculation combines the\n     * local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}).\n     *\n     * @return {Instant} an {@link Instant} representing the same instant, not null\n     */\n    toInstant() {\n        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n    }\n\n    /**\n     * Converts this date-time to the number of seconds from the epoch\n     * of 1970-01-01T00:00:00Z.\n     *\n     * This uses the local date-time (see {@link toLocalDateTime}) and\n     * offset (see {@link getOffset}) to calculate the epoch-second value,\n     * which is the number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier are negative.\n     *\n     * @return {number} the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    toEpochSecond() {\n        const epochDay = this.toLocalDate().toEpochDay();\n        let secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= this.offset().totalSeconds();\n        return secs;\n    }\n\n    /**\n      * Compares this date-time to another date-time, including the chronology.\n      *\n      * The comparison is based first on the instant, then on the local date-time,\n      * then on the zone ID, then on the chronology.\n      * It is \"consistent with equals\", as defined by {@link Comparable}.\n      *\n      * If all the date-time objects being compared are in the same chronology, then the\n      * additional chronology stage is not required.\n      *\n      * @param {ChronoZonedDateTime} other - the other date-time to compare to, not null\n      * @return {number} the comparator value, negative if less, positive if greater\n      */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        let cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n                if (cmp === 0) {\n                    cmp = strcmp(this.zone().id(), other.zone().id());\n                    // we only support iso for now\n                    //if (cmp === 0) {\n                    //    cmp = toLocalDate().getChronology().compareTo(other.toLocalDate().getChronology());\n                    //}\n                }\n            }\n        }\n        return cmp;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of this date-time is after that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isAfter(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this is after the specified date-time\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is before that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} in that it\n     * only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().isBefore(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if this point is before the specified date-time\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        const thisEpochSec = this.toEpochSecond();\n        const otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec ||\n            (thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano());\n    }\n\n    /**\n     * Checks if the instant of this date-time is equal to that of the specified date-time.\n     *\n     * This method differs from the comparison in {@link compareTo} and {@link equals}\n     * in that it only compares the instant of the date-time. This is equivalent to using\n     * `dateTime1.toInstant().equals(dateTime2.toInstant())`.\n     *\n     * @param {!ChronoZonedDateTime} other - the other date-time to compare to, not null\n     * @return {boolean} true if the instant equals the instant of the specified date-time\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        return this.toEpochSecond() === other.toEpochSecond() &&\n                this.toLocalTime().nano() === other.toLocalTime().nano();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date-time is equal to another date-time.\n     *\n     * The comparison is based on the offset date-time and the zone.\n     * To compare for the same instant on the time-line, use {@link compareTo}.\n     * Only objects of type {@link ChronoZoneDateTime} are compared, other types return false.\n     *\n     * @param {*} other  the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date-time\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ChronoZonedDateTime) {\n            return this.compareTo(other) === 0;\n        }\n        return false;\n    }\n\n}\n\nfunction strcmp(a, b){\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/chrono/ChronoZonedDateTime.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 956,
    "kind": "class",
    "name": "ChronoZonedDateTime",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js",
    "static": true,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/chrono/ChronoZonedDateTime.js",
    "importStyle": "{ChronoZonedDateTime}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ]
  },
  {
    "__docId__": 957,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#query",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 958,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#format",
    "access": "public",
    "description": "Outputs this date-time as a string using the formatter.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted date-time string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 959,
    "kind": "method",
    "name": "toInstant",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#toInstant",
    "access": "public",
    "description": "Converts this date-time to an {@link Instant}.\n\nThis returns an {@link Instant} representing the same point on the\ntime-line as this date-time. The calculation combines the\nlocal date-time (see {@link toLocalDateTime}) and\noffset (see {@link getOffset}).",
    "lineNumber": 56,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "an {@link Instant} representing the same instant, not null"
    },
    "params": []
  },
  {
    "__docId__": 960,
    "kind": "method",
    "name": "toEpochSecond",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#toEpochSecond",
    "access": "public",
    "description": "Converts this date-time to the number of seconds from the epoch\nof 1970-01-01T00:00:00Z.\n\nThis uses the local date-time (see {@link toLocalDateTime}) and\noffset (see {@link getOffset}) to calculate the epoch-second value,\nwhich is the number of elapsed seconds from 1970-01-01T00:00:00Z.\nInstants on the time-line after the epoch are positive, earlier are negative.",
    "lineNumber": 71,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of seconds from the epoch of 1970-01-01T00:00:00Z"
    },
    "params": []
  },
  {
    "__docId__": 961,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#compareTo",
    "access": "public",
    "description": "Compares this date-time to another date-time, including the chronology.\n\nThe comparison is based first on the instant, then on the local date-time,\nthen on the zone ID, then on the chronology.\nIt is \"consistent with equals\", as defined by {@link Comparable}.\n\nIf all the date-time objects being compared are in the same chronology, then the\nadditional chronology stage is not required.",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoZonedDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 962,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#isAfter",
    "access": "public",
    "description": "Checks if the instant of this date-time is after that of the specified date-time.\n\nThis method differs from the comparison in {@link compareTo} in that it\nonly compares the instant of the date-time. This is equivalent to using\n`dateTime1.toInstant().isAfter(dateTime2.toInstant())`.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": false,
        "types": [
          "ChronoZonedDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified date-time"
    }
  },
  {
    "__docId__": 963,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#isBefore",
    "access": "public",
    "description": "Checks if the instant of this date-time is before that of the specified date-time.\n\nThis method differs from the comparison in {@link compareTo} in that it\nonly compares the instant of the date-time. This is equivalent to using\n`dateTime1.toInstant().isBefore(dateTime2.toInstant())`.",
    "lineNumber": 139,
    "params": [
      {
        "nullable": false,
        "types": [
          "ChronoZonedDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified date-time"
    }
  },
  {
    "__docId__": 964,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#isEqual",
    "access": "public",
    "description": "Checks if the instant of this date-time is equal to that of the specified date-time.\n\nThis method differs from the comparison in {@link compareTo} and {@link equals}\nin that it only compares the instant of the date-time. This is equivalent to using\n`dateTime1.toInstant().equals(dateTime2.toInstant())`.",
    "lineNumber": 157,
    "params": [
      {
        "nullable": false,
        "types": [
          "ChronoZonedDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date-time to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the instant equals the instant of the specified date-time"
    }
  },
  {
    "__docId__": 965,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~ChronoZonedDateTime#equals",
    "access": "public",
    "description": "Checks if this date-time is equal to another date-time.\n\nThe comparison is based on the offset date-time and the zone.\nTo compare for the same instant on the time-line, use {@link compareTo}.\nOnly objects of type {@link ChronoZoneDateTime} are compared, other types return false.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other date-time"
    }
  },
  {
    "__docId__": 966,
    "kind": "function",
    "name": "strcmp",
    "memberof": "packages/core/src/chrono/ChronoZonedDateTime.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/chrono/ChronoZonedDateTime.js~strcmp",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/chrono/ChronoZonedDateTime.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 967,
    "kind": "file",
    "name": "packages/core/src/chrono/IsoChronology.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { Enum } from '../Enum';\nimport { requireNonNull } from '../assert';\nimport { DateTimeException } from '../errors';\nimport { MathUtil } from '../MathUtil';\n\nimport { DayOfWeek } from '../DayOfWeek';\nimport { LocalDate } from '../LocalDate';\nimport { Month } from '../Month';\nimport { Year } from '../Year';\n\nimport { ChronoField } from '../temporal/ChronoField';\nimport { ResolverStyle } from '../format/ResolverStyle';\nimport { TemporalAdjusters } from '../temporal/TemporalAdjusters';\n\nexport class IsoChronology extends Enum{\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @param {number} prolepticYear - the ISO proleptic year to check\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    static isLeapYear(prolepticYear) {\n        return ((prolepticYear & 3) === 0) && ((prolepticYear % 100) !== 0 || (prolepticYear % 400) === 0);\n    }\n\n    /**\n     * Updates the map of field-values during resolution.\n     *\n     * @param {EnumMap} fieldValues  the fieldValues map to update, not null\n     * @param {ChronoField} field  the field to update, not null\n     * @param {number} value  the value to update, not null\n     * @throws DateTimeException if a conflict occurs\n     */\n    _updateResolveMap(fieldValues, field, value) {\n        // TODO: this function is in Chronology in threetenbp, maybe needs to be moved?\n        requireNonNull(fieldValues, 'fieldValues');\n        requireNonNull(field, 'field');\n        const current = fieldValues.get(field);\n        if (current != null && current !== value) {\n            throw new DateTimeException(`Invalid state, field: ${field} ${current} conflicts with ${field} ${value}`);\n        }\n        fieldValues.put(field, value);\n    }\n\n    resolveDate(fieldValues, resolverStyle) {\n        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n        }\n\n        // normalize fields\n        const prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n        if (prolepticMonth != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n            }\n            this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n        }\n\n        // eras\n        const yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n        if (yoeLong != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n            }\n            const era = fieldValues.remove(ChronoField.ERA);\n            if (era == null) {\n                const year = fieldValues.get(ChronoField.YEAR);\n                if (resolverStyle === ResolverStyle.STRICT) {\n                    // do not invent era if strict, but do cross-check with year\n                    if (year != null) {\n                        this._updateResolveMap(fieldValues, ChronoField.YEAR, (year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                    } else {\n                        // reinstate the field removed earlier, no cross-check issues\n                        fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n                    }\n                } else {\n                    // invent era\n                    this._updateResolveMap(fieldValues, ChronoField.YEAR, (year == null || year > 0 ? yoeLong: MathUtil.safeSubtract(1, yoeLong)));\n                }\n            } else if (era === 1) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n            } else if (era === 0) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n            } else {\n                throw new DateTimeException(`Invalid value for era: ${era}`);\n            }\n        } else if (fieldValues.containsKey(ChronoField.ERA)) {\n            ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));  // always validated\n        }\n\n        // build date\n        if (fieldValues.containsKey(ChronoField.YEAR)) {\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    const moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n                    let dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const months = moy - 1;\n                        const days = dom - 1;\n                        return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n                    } else if (resolverStyle === ResolverStyle.SMART){\n                        ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n                        if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n                            dom = Math.min(dom, 30);\n                        } else if (moy === 2) {\n                            dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n                        }\n                        return LocalDate.of(y, moy, dom);\n                    } else {\n                        return LocalDate.of(y, moy, dom);\n                    }\n                }\n                /*\n                if (fieldValues.containsKey(ALIGNED_WEEK_OF_MONTH)) {\n                    if (fieldValues.containsKey(ALIGNED_DAY_OF_WEEK_IN_MONTH)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int ad = ALIGNED_DAY_OF_WEEK_IN_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                    if (fieldValues.containsKey(DAY_OF_WEEK)) {\n                        int y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                        if (resolverStyle == ResolverStyle.LENIENT) {\n                            long months = Jdk8Methods.safeSubtract(fieldValues.remove(ChronoField.MONTH_OF_YEAR), 1);\n                            long weeks = Jdk8Methods.safeSubtract(fieldValues.remove(ALIGNED_WEEK_OF_MONTH), 1);\n                            long days = Jdk8Methods.safeSubtract(fieldValues.remove(DAY_OF_WEEK), 1);\n                            return LocalDate.of(y, 1, 1).plusMonths(months).plusWeeks(weeks).plusDays(days);\n                        }\n                        int moy = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.MONTH_OF_YEAR));\n                        int aw = ALIGNED_WEEK_OF_MONTH.checkValidIntValue(fieldValues.remove(ALIGNED_WEEK_OF_MONTH));\n                        int dow = DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(DAY_OF_WEEK));\n                        LocalDate date = LocalDate.of(y, moy, 1).plusWeeks(aw - 1).with(nextOrSame(DayOfWeek.of(dow)));\n                        if (resolverStyle == ResolverStyle.STRICT && date.get(ChronoField.MONTH_OF_YEAR) != moy) {\n                            throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                        }\n                        return date;\n                    }\n                }\n*/\n            }\n            if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n                const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                if (resolverStyle === ResolverStyle.LENIENT) {\n                    const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n                    return LocalDate.ofYearDay(y, 1).plusDays(days);\n                }\n                const doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n                return LocalDate.ofYearDay(y, doy);\n            }\n            if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                    const date = LocalDate.of(y, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different year');\n                    }\n                    return date;\n                }\n                if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n                    const y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        const weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        const days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n                        return LocalDate.of(y, 1, 1).plusWeeks(weeks).plusDays(days);\n                    }\n                    const aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    const dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n                    const date = LocalDate.of(y, 1, 1).plusWeeks(aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== y) {\n                        throw new DateTimeException('Strict mode rejected date parsed to a different month');\n                    }\n                    return date;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Obtains an ISO local date from another date-time object.\n     * <p>\n     * This is equivalent to {@link LocalDate#from(TemporalAccessor)}.\n     *\n     * @param temporal  the date-time object to convert, not null\n     * @return the ISO local date, not null\n     * @throws DateTimeException if unable to create the date\n     */\n    date(temporal) {\n        return LocalDate.from(temporal);\n    }\n\n}\n\nexport function _init() {\n    IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/chrono/IsoChronology.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 968,
    "kind": "class",
    "name": "IsoChronology",
    "memberof": "packages/core/src/chrono/IsoChronology.js",
    "static": true,
    "longname": "packages/core/src/chrono/IsoChronology.js~IsoChronology",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/chrono/IsoChronology.js",
    "importStyle": "{IsoChronology}",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ]
  },
  {
    "__docId__": 969,
    "kind": "method",
    "name": "isLeapYear",
    "memberof": "packages/core/src/chrono/IsoChronology.js~IsoChronology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/chrono/IsoChronology.js~IsoChronology.isLeapYear",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "prolepticYear",
        "description": "the ISO proleptic year to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    }
  },
  {
    "__docId__": 970,
    "kind": "method",
    "name": "_updateResolveMap",
    "memberof": "packages/core/src/chrono/IsoChronology.js~IsoChronology",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/IsoChronology.js~IsoChronology#_updateResolveMap",
    "access": "private",
    "description": "Updates the map of field-values during resolution.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "EnumMap"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldValues",
        "description": "the fieldValues map to update, not null"
      },
      {
        "nullable": null,
        "types": [
          "ChronoField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to update, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to update, not null"
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a conflict occurs"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 971,
    "kind": "method",
    "name": "resolveDate",
    "memberof": "packages/core/src/chrono/IsoChronology.js~IsoChronology",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/IsoChronology.js~IsoChronology#resolveDate",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "fieldValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolverStyle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 972,
    "kind": "method",
    "name": "date",
    "memberof": "packages/core/src/chrono/IsoChronology.js~IsoChronology",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/chrono/IsoChronology.js~IsoChronology#date",
    "access": "public",
    "description": "Obtains an ISO local date from another date-time object.\n<p>\nThis is equivalent to {@link LocalDate#from(TemporalAccessor)}.",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the date-time object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the ISO local date, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to create the date"
      }
    ]
  },
  {
    "__docId__": 973,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/chrono/IsoChronology.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/chrono/IsoChronology.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/chrono/IsoChronology.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 974,
    "kind": "file",
    "name": "packages/core/src/convert.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { IllegalArgumentException } from './errors';\n\nimport { LocalDate } from './LocalDate';\nimport { LocalDateTime } from './LocalDateTime';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { ZoneId } from './ZoneId';\nimport { Instant } from './Instant';\n\nclass ToNativeJsConverter {\n    /**\n     * @param {!(LocalDate|LocalDateTime|ZonedDateTime|Instant)} temporal - a joda temporal instance\n     * @param {ZoneId} [zone] - the zone of the temporal,\n     *  the default value for LocalDate and LocalDateTime is ZoneId.systemDefault().\n     */\n    constructor(temporal, zone){\n        let zonedDateTime;\n\n        if(temporal instanceof Instant) {\n            this.instant = temporal;\n            return;\n        } else if(temporal instanceof LocalDate) {\n            zone = zone == null ?  ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atStartOfDay(zone);\n        } else if (temporal instanceof LocalDateTime) {\n            zone = zone == null ? ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atZone(zone);\n        } else if (temporal instanceof ZonedDateTime) {\n            if (zone == null) {\n                zonedDateTime = temporal;\n            } else {\n                zonedDateTime = temporal.withZoneSameInstant(zone);\n            }\n        } else {\n            throw new IllegalArgumentException(`unsupported instance for convert operation:${temporal}`);\n        }\n\n        this.instant = zonedDateTime.toInstant();\n    }\n\n    /**\n     *\n     * @returns {Date}\n     */\n    toDate() {\n        return new Date(this.instant.toEpochMilli());\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    toEpochMilli() {\n        return this.instant.toEpochMilli();\n    }\n}\n\n/**\n * converts a LocalDate, LocalDateTime or ZonedDateTime to a native Javascript Date.\n *\n * In a first step the temporal is converted to an Instant by adding implicit values.\n * \n * A LocalDate is implicit set to a LocalDateTime at start of day. \n * A LocalDateTime is implicit set to a ZonedDateTime with \n * the passed zone or if null, with the system default time zone. \n * A ZonedDateTime is converted to an Instant, if a zone is specified the zonedDateTime is adjusted to this \n * zone, keeping the same Instant.\n *\n * In a second step the instant is converted to a native Javascript Date\n *\n * default zone for LocalDate and LocalDateTime is ZoneId.systemDefault().\n *\n * @example\n * convert(localDate).toDate() // returns a javascript Date\n * convert(localDate).toEpochMilli()   // returns the epochMillis\n *\n * @param {!(LocalDate|LocalDateTime|ZonedDateTime)} temporal - a joda temporal instance\n * @param {ZoneId} [zone] - the zone of the temporal\n * @returns {ToNativeJsConverter}\n */\nexport function convert(temporal, zone){\n    return new ToNativeJsConverter(temporal, zone);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/convert.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 975,
    "kind": "class",
    "name": "ToNativeJsConverter",
    "memberof": "packages/core/src/convert.js",
    "static": true,
    "longname": "packages/core/src/convert.js~ToNativeJsConverter",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/convert.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 976,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/convert.js~ToNativeJsConverter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/convert.js~ToNativeJsConverter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 20,
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate",
          "LocalDateTime",
          "ZonedDateTime",
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "a joda temporal instance"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "name": "zone",
        "description": "the zone of the temporal,\n the default value for LocalDate and LocalDateTime is ZoneId.systemDefault()."
      }
    ]
  },
  {
    "__docId__": 977,
    "kind": "member",
    "name": "instant",
    "memberof": "packages/core/src/convert.js~ToNativeJsConverter",
    "static": false,
    "longname": "packages/core/src/convert.js~ToNativeJsConverter#instant",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 979,
    "kind": "method",
    "name": "toDate",
    "memberof": "packages/core/src/convert.js~ToNativeJsConverter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/convert.js~ToNativeJsConverter#toDate",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Date}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 980,
    "kind": "method",
    "name": "toEpochMilli",
    "memberof": "packages/core/src/convert.js~ToNativeJsConverter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/convert.js~ToNativeJsConverter#toEpochMilli",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 981,
    "kind": "function",
    "name": "convert",
    "memberof": "packages/core/src/convert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/convert.js~convert",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/convert.js",
    "importStyle": "{convert}",
    "description": "converts a LocalDate, LocalDateTime or ZonedDateTime to a native Javascript Date.\n\nIn a first step the temporal is converted to an Instant by adding implicit values.\n\nA LocalDate is implicit set to a LocalDateTime at start of day. \nA LocalDateTime is implicit set to a ZonedDateTime with \nthe passed zone or if null, with the system default time zone. \nA ZonedDateTime is converted to an Instant, if a zone is specified the zonedDateTime is adjusted to this \nzone, keeping the same Instant.\n\nIn a second step the instant is converted to a native Javascript Date\n\ndefault zone for LocalDate and LocalDateTime is ZoneId.systemDefault().",
    "examples": [
      "convert(localDate).toDate() // returns a javascript Date\nconvert(localDate).toEpochMilli()   // returns the epochMillis"
    ],
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ToNativeJsConverter}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "LocalDate",
          "LocalDateTime",
          "ZonedDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "a joda temporal instance"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "name": "zone",
        "description": "the zone of the temporal"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ToNativeJsConverter"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 982,
    "kind": "file",
    "name": "packages/core/src/errors.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init, superErrorClass = Error) {\n    function JsJodaException(message) {\n        if (!Error.captureStackTrace) {\n            this.stack = (new Error()).stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n        this.toString = function () {\n            return `${this.name}: ${this.message}`;\n        };\n    }\n    JsJodaException.prototype = Object.create(superErrorClass.prototype);\n    JsJodaException.prototype.name = name;\n    JsJodaException.prototype.constructor = JsJodaException;\n    return JsJodaException;\n}\n\nexport const DateTimeException = createErrorType('DateTimeException', messageWithCause);\nexport const DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nexport const UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nexport const ArithmeticException = createErrorType('ArithmeticException');\nexport const IllegalArgumentException = createErrorType('IllegalArgumentException');\nexport const IllegalStateException = createErrorType('IllegalStateException');\nexport const NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause = null) {\n    let msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += `\\n-------\\nCaused by: ${cause.stack}\\n-------\\n`;\n    }\n    this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text = '', index = 0, cause = null) {\n    let msg = message || this.name;\n    msg += `: ${text}, at index: ${index}`;\n    if (cause !== null && cause instanceof Error) {\n        msg += `\\n-------\\nCaused by: ${cause.stack}\\n-------\\n`;\n    }\n    this.message = msg;\n    this.parsedString = () => {\n        return text;\n    };\n    this.errorIndex = () => {\n        return index;\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/errors.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 983,
    "kind": "function",
    "name": "createErrorType",
    "memberof": "packages/core/src/errors.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/errors.js~createErrorType",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2016, Philipp Thürwächter & Pattrick Hüper"
      },
      {
        "tagName": "@license",
        "tagValue": "BSD-3-Clause (see LICENSE in the root directory of this source tree)"
      }
    ],
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "init",
        "types": [
          "*"
        ]
      },
      {
        "name": "superErrorClass",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "Error",
        "defaultValue": "Error"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 984,
    "kind": "variable",
    "name": "DateTimeException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~DateTimeException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{DateTimeException}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 985,
    "kind": "variable",
    "name": "DateTimeParseException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~DateTimeParseException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{DateTimeParseException}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 986,
    "kind": "variable",
    "name": "UnsupportedTemporalTypeException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~UnsupportedTemporalTypeException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{UnsupportedTemporalTypeException}",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 987,
    "kind": "variable",
    "name": "ArithmeticException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~ArithmeticException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{ArithmeticException}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 988,
    "kind": "variable",
    "name": "IllegalArgumentException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~IllegalArgumentException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{IllegalArgumentException}",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 989,
    "kind": "variable",
    "name": "IllegalStateException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~IllegalStateException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{IllegalStateException}",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 990,
    "kind": "variable",
    "name": "NullPointerException",
    "memberof": "packages/core/src/errors.js",
    "static": true,
    "longname": "packages/core/src/errors.js~NullPointerException",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": "{NullPointerException}",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 991,
    "kind": "function",
    "name": "messageWithCause",
    "memberof": "packages/core/src/errors.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/errors.js~messageWithCause",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "cause",
        "optional": true,
        "types": [
          "undefined"
        ],
        "defaultValue": "undefined"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 992,
    "kind": "function",
    "name": "messageForDateTimeParseException",
    "memberof": "packages/core/src/errors.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/errors.js~messageForDateTimeParseException",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/errors.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "index",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "cause",
        "optional": true,
        "types": [
          "undefined"
        ],
        "defaultValue": "undefined"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 993,
    "kind": "file",
    "name": "packages/core/src/format/DateTimeBuilder.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../assert';\nimport { DateTimeException } from '../errors';\nimport { MathUtil } from '../MathUtil';\n\nimport { EnumMap } from './EnumMap';\nimport { ResolverStyle } from './ResolverStyle';\n\nimport { IsoChronology } from '../chrono/IsoChronology';\nimport { ChronoLocalDate } from '../chrono/ChronoLocalDate';\nimport { ChronoField } from '../temporal/ChronoField';\nimport { TemporalAccessor } from '../temporal/TemporalAccessor';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\n\nimport { LocalTime } from '../LocalTime';\nimport { LocalDate } from '../LocalDate';\nimport { Period } from '../Period';\n\nimport { ZoneOffset } from '../ZoneOffset';\n\n/**\n * Builder that can holds date and time fields and related date and time objects.\n *\n * The builder is used to hold onto different elements of date and time.\n * It is designed as two separate maps:\n *\n * * from {@link TemporalField} to `long` value, where the value may be\n *   outside the valid range for the field\n * * from {@link Class} to {@link TemporalAccessor}, holding larger scale objects\n *   like {@link LocalDateTime}.\n *\n *   @private\n */\nexport class DateTimeBuilder extends TemporalAccessor {\n\n    /**\n     * Creates a new instance of the builder with a single field-value.\n     *\n     * This is equivalent to using {@link addFieldValue} on an empty builder.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {number} value - the value to add, not null\n     * @return {DateTimeBuilder}\n     */\n    static create(field, value) {\n        const dtb = new DateTimeBuilder();\n        dtb._addFieldValue(field, value);\n        return dtb;\n    }\n\n\n    constructor(){\n        super();\n\n        /**\n         * The map of other fields.\n         */\n        this.fieldValues = new EnumMap();\n        /**\n         * The chronology.\n         */\n        this.chrono = null;\n        /**\n         * The zone.\n         */\n        this.zone = null;\n        /**\n         * The date.\n         */\n        this.date = null;\n        /**\n         * The time.\n         */\n        this.time = null;\n        /**\n         * The leap second flag.\n         */\n        this.leapSecond = false;\n        /**\n         * The excess days.\n         */\n        this.excessDays = null;\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @return {Number} field value\n     */\n    getFieldValue0(field) {\n        return this.fieldValues.get(field);\n    }\n\n    /**\n     * Adds a field-value pair to the builder.\n     *\n     * This adds a field to the builder.\n     * If the field is not already present, then the field-value pair is added to the map.\n     * If the field is already present and it has the same value as that specified, no action occurs.\n     * If the field is already present and it has a different value to that specified, then\n     * an exception is thrown.\n     *\n     * @param {TemporalField} field - the field to add, not null\n     * @param {Number} value - the value to add, not null\n     * @return {DateTimeBuilder}, this for method chaining\n     * @throws DateTimeException if the field is already present with a different value\n     */\n    _addFieldValue(field, value) {\n        requireNonNull(field, 'field');\n        const old = this.getFieldValue0(field);  // check first for better error message\n        if (old != null && old !== value) {\n            throw new DateTimeException(`Conflict found: ${field} ${old} differs from ${field} ${value}: ${this}`);\n        }\n        return this._putFieldValue0(field, value);\n    }\n\n    /**\n     * @param {TemporalField} field\n     * @param {Number} value\n     * @return {DateTimeBuilder}, this for method chaining\n     */\n    _putFieldValue0(field, value) {\n        this.fieldValues.put(field, value);\n        return this;\n    }\n\n    /**\n     * Resolves the builder, evaluating the date and time.\n     *\n     * This examines the contents of the build.er and resolves it to produce the best\n     * available date and time, throwing an exception if a problem occurs.\n     * Calling this method changes the state of the builder.\n     *\n     * @param {ResolverStyle} resolverStyle - how to resolve\n     * @param {TemporalField[]} resolverFields\n     * @return {DateTimeBuilder} this, for method chaining\n     */\n    resolve(resolverStyle, resolverFields) {\n        if (resolverFields != null) {\n            this.fieldValues.retainAll(resolverFields);\n        }\n        // handle standard fields\n        // this._mergeInstantFields();\n        this._mergeDate(resolverStyle);\n        this._mergeTime(resolverStyle);\n        //if (resolveFields(resolverStyle)) {\n        //    mergeInstantFields();\n        //    mergeDate(resolverStyle);\n        //    mergeTime(resolverStyle);\n        //}\n        this._resolveTimeInferZeroes(resolverStyle);\n        //this._crossCheck();\n        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n            this.date = this.date.plus(this.excessDays);\n            this.excessDays = Period.ZERO;\n        }\n        //resolveFractional();\n        this._resolveInstant();\n        return this;\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeDate(resolverStyle) {\n        //if (this.chrono instanceof IsoChronology) {\n        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n        //} else {\n        //    if (this.fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n        //        this._checkDate(LocalDate.ofEpochDay(this.fieldValues.remove(ChronoField.EPOCH_DAY)));\n        //        return;\n        //    }\n        //}\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @private\n     */\n    _checkDate(date) {\n        if (date != null) {\n            this._addObject(date);\n            for (const fieldName in this.fieldValues.keySet()) {\n                const field = ChronoField.byName(fieldName);\n                if (field) {\n                    if (this.fieldValues.get(field) !== undefined) { // undefined if \"removed\" in EnumMap\n                        if (field.isDateBased()) {\n                            let val1;\n                            try {\n                                val1 = date.getLong(field);\n                            } catch (ex) {\n                                if (ex instanceof DateTimeException) {\n                                    continue;\n                                } else {\n                                    throw ex;\n                                }\n                            }\n                            const val2 = this.fieldValues.get(field);\n                            if (val1 !== val2) {\n                                throw new DateTimeException(`Conflict found: Field ${field} ${val1} differs from ${field} ${val2} derived from ${date}`);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _mergeTime(resolverStyle) {\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n        }\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n            const ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) {\n                    // ok\n                } else {\n                    ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_AMPM, ch === 12 ? 0 : ch);\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n                ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n            }\n            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n                ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n            const ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n            const hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n        }\n        //        if (timeFields.containsKey(HOUR_OF_DAY) && timeFields.containsKey(MINUTE_OF_HOUR)) {\n        //            const hod = timeFields.remove(HOUR_OF_DAY);\n        //            const moh = timeFields.remove(MINUTE_OF_HOUR);\n        //            this._addFieldValue(MINUTE_OF_DAY, hod * 60 + moh);\n        //        }\n        //        if (timeFields.containsKey(MINUTE_OF_DAY) && timeFields.containsKey(SECOND_OF_MINUTE)) {\n        //            const mod = timeFields.remove(MINUTE_OF_DAY);\n        //            const som = timeFields.remove(SECOND_OF_MINUTE);\n        //            this._addFieldValue(SECOND_OF_DAY, mod * 60 + som);\n        //        }\n        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n            const nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.NANO_OF_DAY.checkValidValue(nod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n            const cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n            const lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n            const sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n            const mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n        }\n\n        //            const sod = MathUtil.intDiv(nod, 1000000000L);\n        //            this._addFieldValue(HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n        //            this._addFieldValue(MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n        //            this._addFieldValue(SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        //            this._addFieldValue(NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000L));\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n                ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n            }\n            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n                ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            const cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + (MathUtil.intMod(cos, 1000)));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            const nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(nos, 1000000));\n            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            const cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, cos * 1000);\n        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n            const los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, los * 1000000);\n        }\n    }\n\n    /**\n     *\n     * @param {ResolverStyle} resolverStyle\n     * @private\n     */\n    _resolveTimeInferZeroes(resolverStyle) {\n        let hod =  this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n        const moh =  this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n        const som =  this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n        let nos =  this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n        if (hod == null) {\n            return;\n        }\n        if (moh == null && (som != null || nos != null)) {\n            return;\n        }\n        if (moh != null && som == null && nos != null) {\n            return;\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (hod != null) {\n                if (resolverStyle === ResolverStyle.SMART &&\n                                hod === 24 &&\n                                (moh == null || moh === 0) &&\n                                (som == null || som === 0) &&\n                                (nos == null || nos === 0)) {\n                    hod = 0;\n                    this.excessDays = Period.ofDays(1);\n                }\n                const hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n                if (moh != null) {\n                    const mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n                    if (som != null) {\n                        const somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n                        if (nos != null) {\n                            const nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n                        } else {\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n                        }\n                    } else {\n                        if (nos == null) {\n                            this._addObject(LocalTime.of(hodVal, mohVal));\n                        }\n                    }\n                } else {\n                    if (som == null && nos == null) {\n                        this._addObject(LocalTime.of(hodVal, 0));\n                    }\n                }\n            }\n        } else {\n            if (hod != null) {\n                let hodVal = hod;\n                if (moh != null) {\n                    if (som != null) {\n                        if (nos == null) {\n                            nos = 0;\n                        }\n                        let totalNanos = MathUtil.safeMultiply(hodVal, 3600000000000);\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, nos);\n                        const excessDays =  MathUtil.floorDiv(totalNanos, 86400000000000);  // safe int cast\n                        const nod = MathUtil.floorMod(totalNanos, 86400000000000);\n                        this._addObject(LocalTime.ofNanoOfDay(nod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    } else {\n                        let totalSecs = MathUtil.safeMultiply(hodVal, 3600);\n                        totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n                        const excessDays =  MathUtil.floorDiv(totalSecs, 86400);  // safe int cast\n                        const sod = MathUtil.floorMod(totalSecs, 86400);\n                        this._addObject(LocalTime.ofSecondOfDay(sod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    }\n                } else {\n                    const excessDays = MathUtil.safeToInt(MathUtil.floorDiv(hodVal, 24));\n                    hodVal = MathUtil.floorMod(hodVal, 24);\n                    this._addObject(LocalTime.of(hodVal, 0));\n                    this.excessDays = Period.ofDays(excessDays);\n                }\n            }\n        }\n        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n    }\n\n    /**\n     *\n     * @param {ChronoLocalDate|LocalTime} dateOrTime\n     * @private\n     */\n    _addObject(dateOrTime) {\n        if (dateOrTime instanceof ChronoLocalDate){\n            this.date = dateOrTime;\n        } else if (dateOrTime instanceof LocalTime){\n            this.time = dateOrTime;\n        }\n    }\n\n    _resolveInstant() {\n        if (this.date != null && this.time != null) {\n            const offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n            if (offsetSecs != null) {\n                const offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n                const instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n            } else if (this.zone != null) {\n                const instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n            }\n        }\n    }\n\n    /**\n     * Builds the specified type from the values in this builder.\n     *\n     * This attempts to build the specified type from this builder.\n     * If the builder cannot return the type, an exception is thrown.\n     *\n     * @param {!TemporalQuery} type - the type to invoke `from` on, not null\n     * @return {*} the extracted value, not null\n     * @throws DateTimeException if an error occurs\n     */\n    build(type) {\n        return type.queryFrom(this);\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    isSupported(field) {\n        if (field == null) {\n            return false;\n        }\n        return (this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined) ||\n                (this.date != null && this.date.isSupported(field)) ||\n                (this.time != null && this.time.isSupported(field));\n    }\n\n    /**\n     *\n     * @param {TemporalField} field\n     * @returns {number}\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        const value = this.getFieldValue0(field);\n        if (value == null) {\n            if (this.date != null && this.date.isSupported(field)) {\n                return this.date.getLong(field);\n            }\n            if (this.time != null && this.time.isSupported(field)) {\n                return this.time.getLong(field);\n            }\n            throw new DateTimeException(`Field not found: ${field}`);\n        }\n        return value;\n    }\n\n    /**\n     *\n     * @param {!TemporalQuery} query\n     * @returns {*}\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()) {\n            return this.zone;\n        } else if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        } else if (query === TemporalQueries.localDate()) {\n            return this.date != null ? LocalDate.from(this.date) : null;\n        } else if (query === TemporalQueries.localTime()) {\n            return this.time;\n        } else if (query === TemporalQueries.zone() || query === TemporalQueries.offset()) {\n            return query.queryFrom(this);\n        } else if (query === TemporalQueries.precision()) {\n            return null;  // not a complete date/time\n        }\n        // inline TemporalAccessor.super.query(query) as an optimization\n        // non-JDK classes are not permitted to make this optimization\n        return query.queryFrom(this);\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DateTimeBuilder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 994,
    "kind": "class",
    "name": "DateTimeBuilder",
    "memberof": "packages/core/src/format/DateTimeBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeBuilder.js",
    "importStyle": "{DateTimeBuilder}",
    "description": "Builder that can holds date and time fields and related date and time objects.\n\nThe builder is used to hold onto different elements of date and time.\nIt is designed as two separate maps:\n\n* from {@link TemporalField} to `long` value, where the value may be\n  outside the valid range for the field\n* from {@link Class} to {@link TemporalAccessor}, holding larger scale objects\n  like {@link LocalDateTime}.",
    "lineNumber": 39,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor"
    ],
    "ignore": true
  },
  {
    "__docId__": 995,
    "kind": "method",
    "name": "create",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder.create",
    "access": "public",
    "description": "Creates a new instance of the builder with a single field-value.\n\nThis is equivalent to using {@link addFieldValue} on an empty builder.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to add, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeBuilder"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 996,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true
  },
  {
    "__docId__": 997,
    "kind": "member",
    "name": "fieldValues",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#fieldValues",
    "access": "public",
    "description": "The map of other fields.",
    "lineNumber": 63,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 998,
    "kind": "member",
    "name": "chrono",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#chrono",
    "access": "public",
    "description": "The chronology.",
    "lineNumber": 67,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 999,
    "kind": "member",
    "name": "zone",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#zone",
    "access": "public",
    "description": "The zone.",
    "lineNumber": 71,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1000,
    "kind": "member",
    "name": "date",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#date",
    "access": "public",
    "description": "The date.",
    "lineNumber": 75,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1001,
    "kind": "member",
    "name": "time",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#time",
    "access": "public",
    "description": "The time.",
    "lineNumber": 79,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1002,
    "kind": "member",
    "name": "leapSecond",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#leapSecond",
    "access": "public",
    "description": "The leap second flag.",
    "lineNumber": 83,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1003,
    "kind": "member",
    "name": "excessDays",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#excessDays",
    "access": "public",
    "description": "The excess days.",
    "lineNumber": 87,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1004,
    "kind": "method",
    "name": "getFieldValue0",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#getFieldValue0",
    "access": "public",
    "description": "",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "field value"
    }
  },
  {
    "__docId__": 1005,
    "kind": "method",
    "name": "_addFieldValue",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_addFieldValue",
    "access": "private",
    "description": "Adds a field-value pair to the builder.\n\nThis adds a field to the builder.\nIf the field is not already present, then the field-value pair is added to the map.\nIf the field is already present and it has the same value as that specified, no action occurs.\nIf the field is already present and it has a different value to that specified, then\nan exception is thrown.",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to add, not null"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{DateTimeBuilder}, this for method chaining"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field is already present with a different value"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1006,
    "kind": "method",
    "name": "_putFieldValue0",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_putFieldValue0",
    "access": "private",
    "description": "",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "{DateTimeBuilder}, this for method chaining"
    },
    "ignore": true
  },
  {
    "__docId__": 1007,
    "kind": "method",
    "name": "resolve",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#resolve",
    "access": "public",
    "description": "Resolves the builder, evaluating the date and time.\n\nThis examines the contents of the build.er and resolves it to produce the best\navailable date and time, throwing an exception if a problem occurs.\nCalling this method changes the state of the builder.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": "how to resolve"
      },
      {
        "nullable": null,
        "types": [
          "TemporalField[]"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverFields",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeBuilder"
      ],
      "spread": false,
      "description": "this, for method chaining"
    }
  },
  {
    "__docId__": 1010,
    "kind": "method",
    "name": "_mergeDate",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_mergeDate",
    "access": "private",
    "description": "",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1011,
    "kind": "method",
    "name": "_checkDate",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_checkDate",
    "access": "private",
    "description": "",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1012,
    "kind": "method",
    "name": "_mergeTime",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_mergeTime",
    "access": "private",
    "description": "",
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1013,
    "kind": "method",
    "name": "_resolveTimeInferZeroes",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_resolveTimeInferZeroes",
    "access": "private",
    "description": "",
    "lineNumber": 352,
    "params": [
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1018,
    "kind": "method",
    "name": "_addObject",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_addObject",
    "access": "private",
    "description": "",
    "lineNumber": 441,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChronoLocalDate",
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateOrTime",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1021,
    "kind": "method",
    "name": "_resolveInstant",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#_resolveInstant",
    "access": "private",
    "description": null,
    "lineNumber": 449,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1022,
    "kind": "method",
    "name": "build",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#build",
    "access": "public",
    "description": "Builds the specified type from the values in this builder.\n\nThis attempts to build the specified type from this builder.\nIf the builder cannot return the type, an exception is thrown.",
    "lineNumber": 473,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "the type to invoke `from` on, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the extracted value, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs"
      }
    ]
  },
  {
    "__docId__": 1023,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#isSupported",
    "access": "public",
    "description": "",
    "lineNumber": 482,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1024,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#getLong",
    "access": "public",
    "description": "",
    "lineNumber": 496,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1025,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeBuilder.js~DateTimeBuilder#query",
    "access": "public",
    "description": "",
    "lineNumber": 516,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1026,
    "kind": "file",
    "name": "packages/core/src/format/DateTimeFormatter.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, requireNonNull } from '../assert';\n\nimport { DateTimeParseException, NullPointerException } from '../errors';\n\nimport { Period } from '../Period';\n\nimport { ParsePosition } from './ParsePosition';\nimport { DateTimeBuilder } from './DateTimeBuilder';\nimport { DateTimeParseContext } from './DateTimeParseContext';\nimport { DateTimePrintContext } from './DateTimePrintContext';\nimport { DateTimeFormatterBuilder } from './DateTimeFormatterBuilder';\nimport { SignStyle } from './SignStyle';\nimport { StringBuilder } from './StringBuilder';\nimport { ResolverStyle } from './ResolverStyle';\n\nimport { IsoChronology } from '../chrono/IsoChronology';\nimport { ChronoField } from '../temporal/ChronoField';\nimport { createTemporalQuery } from '../temporal/TemporalQuery';\n\n/**\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * DateTimeFormatter.ISO_LOCAL_DATE\n *\n * DateTimeFormatter.ISO_LOCAL_TIME\n *\n * DateTimeFormatter.ISO_LOCAL_DATE_TIME\n *\n */\nexport class DateTimeFormatter {\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query that provides access to the excess days that were parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null period, with a zero period returned instead of null.\n     *\n     * There are two situations where this query may return a non-zero period.\n     *\n     * * If the {@link ResolverStyle} is {@link LENIENT} and a time is parsed\n     *   without a date, then the complete result of the parse consists of a\n     *   {@link LocalTime} and an excess {@link Period} in days.\n     * * If the {@link ResolverStyle} is {@link SMART} and a time is parsed\n     *   without a date where the time is 24:00:00, then the complete result of\n     *   the parse consists of a {@link LocalTime} of 00:00:00 and an excess\n     *   {@link Period} of one day.\n     *\n     * In both cases, if a complete {@link ChronoLocalDateTime} or {@link Instant}\n     * is parsed, then the excess days are added to the date part.\n     * As a result, this query will return a zero period.\n     *\n     * The {@link SMART} behaviour handles the common \"end of day\" 24:00 value.\n     * Processing in {@link LENIENT} mode also produces the same result:\n     * <pre>\n     *  Text to parse        Parsed object                         Excess days\n     *  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n     *  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n     *  \"00:00\"              LocalTime.of(0, 0)                    ZERO\n     *  \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n     * </pre>\n     * The query can be used as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  LocalTime time = parsed.query(LocalTime.FROM);\n     *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());\n     * </pre>\n     * @return {TemporalQuery} a query that provides access to the excess days that were parsed\n     */\n    static parsedExcessDays() {\n        return DateTimeFormatter.PARSED_EXCESS_DAYS;\n    }\n\n    /**\n     * A query that provides access to whether a leap-second was parsed.\n     *\n     * This returns a singleton {@link TemporalQuery} that provides\n     * access to additional information from the parse. The query always returns\n     * a non-null boolean, true if parsing saw a leap-second, false if not.\n     *\n     * Instant parsing handles the special \"leap second\" time of '23:59:60'.\n     * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other\n     * local times in different time-zones. To avoid this potential ambiguity,\n     * the handling of leap-seconds is limited to\n     * {@link DateTimeFormatterBuilder#appendInstant}, as that method\n     * always parses the instant with the UTC zone offset.\n     *\n     * If the time '23:59:60' is received, then a simple conversion is applied,\n     * replacing the second-of-minute of 60 with 59. This query can be used\n     * on the parse result to determine if the leap-second adjustment was made.\n     * The query will return one second of excess if it did adjust to remove\n     * the leap-second, and zero if not. Note that applying a leap-second\n     * smoothing mechanism, such as UTC-SLS, is the responsibility of the\n     * application, as follows:\n     * <pre>\n     *  TemporalAccessor parsed = formatter.parse(str);\n     *  Instant instant = parsed.query(Instant::from);\n     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n     *    // validate leap-second is correct and apply correct smoothing\n     *  }\n     * </pre>\n     * @return a query that provides access to whether a leap-second was parsed\n     */\n    static parsedLeapSecond() {\n        return DateTimeFormatter.PARSED_LEAP_SECOND;\n    }\n\n    /**\n     * Creates a formatter using the specified pattern.\n     *\n     * This method will create a formatter based on a simple pattern of letters and symbols.\n     *\n     * The returned formatter will use the default locale, but this can be changed\n     * using {@link DateTimeFormatter.withLocale}.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The following pattern letters are defined:\n     * <pre>\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | u      | year                       | year             | 2004; 04\n     *  | y      | year-of-era                | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form `TextStyle.SHORT`.\n     * Exactly 4 pattern letters will use the full form `TextStyle.FULL`.\n     * Exactly 5 pattern letters will use the narrow form `TextStyle.NARROW`.\n     *\n     * **NOTE**: since text styles require locale support, they are currently not supported in js-joda!\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link DateTimeFormatterBuilder.appendValue}.\n     * Otherwise, the count of digits is used as the width of the output field as per\n     * {@link DateTimeFormatterBuilder.appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a {@link DateTimeFormatterBuilder.appendValueReduced}\n     * two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per `SignStyle.NORMAL`.\n     * Otherwise, the sign is output if the pad width is exceeded, as per `SignStyle.EXCEEDS_PAD`\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws `IllegalArgumentException`.\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws `IllegalArgumentException`.\n     *\n     * **NOTE**: since zone ids and name require the iana tzdb, they are currently not supported in js-joda!\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws `IllegalArgumentException`.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws `IllegalArgumentException`.\n     * The output will be '+0000' when the offset is zero.\n     *\n     * **Optional section**: The optional section markers work exactly like calling\n     * {@link DateTimeFormatterBuilder.optionalStart} and {@link DateTimeFormatterBuilder.optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link DateTimeFormatterBuilder.padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @return {DateTimeFormatter} the formatter based on the pattern, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormatterBuilder#appendPattern(String)\n     * @example\n     * var s = LocalDate.parse('2016-04-01').format(DateTimeFormatter.ofPattern('d MM yyyy'));\n     * console.log(s); // '1 04 2016'\n     *\n     */\n    static ofPattern(pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer/parser to use, not null\n     * @param locale  the locale to use, not null\n     * @param decimalStyle  the decimal style to use, not null\n     * @param resolverStyle  the resolver style to use, not null\n     * @param resolverFields  the fields to use during resolving, null for all fields\n     * @param chrono  the chronology to use, null for no override\n     * @param zone  the zone to use, null for no override\n     * @private\n     */\n    constructor(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono=IsoChronology.INSTANCE, zone) {\n        assert(printerParser != null);\n        assert(decimalStyle != null);\n        assert(resolverStyle != null);\n        /**\n         * The printer and/or parser to use, not null.\n         */\n        this._printerParser = printerParser;\n        /**\n         * The locale to use for formatting. // nyi\n         */\n        this._locale = locale;\n        /**\n         * The symbols to use for formatting, not null.\n         */\n        this._decimalStyle = decimalStyle;\n        /**\n         * The resolver style to use, not null.\n         */\n        this._resolverStyle = resolverStyle;\n        /**\n         * The fields to use in resolving, null for all fields.\n         */\n        this._resolverFields = resolverFields;\n        /**\n         * The chronology to use for formatting, null for no override.\n         */\n        this._chrono = chrono;\n        /**\n         * The zone to use for formatting, null for no override. // nyi\n         */\n        this._zone = zone;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    decimalStyle() {\n        return this._decimalStyle;\n    }\n\n    chronology() {\n        return this._chrono;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new override chronology.\n     *\n     * This returns a formatter with similar state to this formatter but\n     * with the override chronology set.\n     * By default, a formatter has no override chronology, returning null.\n     *\n     * If an override is added, then any date that is printed or parsed will be affected.\n     *\n     * When printing, if the {@link Temporal} object contains a date then it will\n     * be converted to a date in the override chronology.\n     * Any time or zone will be retained unless overridden.\n     * The converted result will behave in a manner equivalent to an implementation\n     * of {@link ChronoLocalDate},{@link ChronoLocalDateTime} or {@link ChronoZonedDateTime}.\n     *\n     * When parsing, the override chronology will be used to interpret the\n     * {@link ChronoField} into a date unless the\n     * formatter directly parses a valid chronology.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param chrono  the new chronology, not null\n     * @return a formatter based on this formatter with the requested override chronology, not null\n     */\n    withChronology(chrono) {\n        if (this._chrono != null && this._chrono.equals(chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle,\n            this._resolverStyle, this._resolverFields, chrono, this._zone);\n    }\n\n    /**\n     * not yet supported\n     * @returns {DateTimeFormatter}\n     */\n    withLocale(){\n        return this;\n    }\n\n    /**\n     * Returns a copy of this formatter with a new resolver style.\n     * <p>\n     * This returns a formatter with similar state to this formatter but\n     * with the resolver style set. By default, a formatter has the\n     * {@link ResolverStyle#SMART SMART} resolver style.\n     * <p>\n     * Changing the resolver style only has an effect during parsing.\n     * Parsing a text string occurs in two phases.\n     * Phase 1 is a basic text parse according to the fields added to the builder.\n     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n     * The resolver style is used to control how phase 2, resolving, happens.\n     * See {@link ResolverStyle} for more information on the options available.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ResolverStyle} resolverStyle  the new resolver style, not null\n     * @return {DateTimeFormatter} a formatter based on this formatter with the requested resolver style, not null\n     */\n    withResolverStyle(resolverStyle) {\n        requireNonNull(resolverStyle, 'resolverStyle');\n        if (resolverStyle.equals(this._resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object using this formatter.\n     *\n     * This formats the date-time to a String using the rules of the formatter.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to print, not null\n     * @return {String} the printed string, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    format(temporal) {\n        const buf = new StringBuilder(32);\n        this._formatTo(temporal, buf);\n        return buf.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats a date-time object to an {@link Appendable} using this formatter.\n     *\n     * This formats the date-time to the specified destination.\n     * {@link Appendable} is a general purpose interface that is implemented by all\n     * key character output classes including {@link StringBuffer}, {@link StringBuilder},\n     * {@link PrintStream} and {@link Writer}.\n     *\n     * Although {@link Appendable} methods throw an {@link IOException}, this method does not.\n     * Instead, any {@link IOException} is wrapped in a runtime exception.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to print, not null\n     * @param {StringBuilder} appendable - the appendable to print to, not null\n     * @throws DateTimeException if an error occurs during formatting\n     */\n    _formatTo(temporal, appendable) {\n        requireNonNull(temporal, 'temporal');\n        requireNonNull(appendable, 'appendable');\n        const context = new DateTimePrintContext(temporal, this);\n        this._printerParser.print(context, appendable);\n    }\n\n    /**\n     * function overloading for {@link DateTimeFormatter.parse}\n     *\n     * if called with one arg {@link DateTimeFormatter.parse1} is called\n     * otherwise {@link DateTimeFormatter.parse2}\n     *\n     * @param {string} text\n     * @param {TemporalQuery} type\n     * @return {TemporalAccessor}\n     */\n    parse(text, type){\n        if(arguments.length === 1){\n            return this.parse1(text);\n        } else {\n            return this.parse2(text, type);\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param {String} text  the text to parse, not null\n     * @return {TemporalAccessor} the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse1(text) {\n        requireNonNull(text, 'text');\n        try {\n            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    /**\n     * Fully parses the text producing a temporal object.\n     *\n     * This parses the entire text producing a temporal object.\n     * It is typically more useful to use {@link parse}.\n     * The result of this method is {@link TemporalAccessor} which has been resolved,\n     * applying basic validation checks to help ensure a valid date-time.\n     *\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param text  the text to parse, not null\n     * @param type the type to extract, not null\n * @return the parsed temporal object, not null\n     * @throws DateTimeParseException if unable to parse the requested result\n     */\n    parse2(text, type) {\n        requireNonNull(text, 'text');\n        requireNonNull(type, 'type');\n        try {\n            const builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n            return builder.build(type);\n        } catch (ex) {\n            if(ex instanceof DateTimeParseException){\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    }\n\n    _createError(text, ex) {\n        let abbr = '';\n        if (text.length > 64) {\n            abbr = `${text.substring(0, 64)}...`;\n        } else {\n            abbr = text;\n        }\n        return new DateTimeParseException(`Text '${abbr}' could not be parsed: ${ex.message}`, text, 0, ex);\n    }\n\n\n    /**\n     * Parses the text to a builder.\n     *\n     * This parses to a {@link DateTimeBuilder} ensuring that the text is fully parsed.\n     * This method throws {@link DateTimeParseException} if unable to parse, or\n     * some other {@link DateTimeException} if another date/time problem occurs.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, null if parsing whole string\n     * @return the engine representing the result of the parse, not null\n     * @throws DateTimeParseException if the parse fails\n     */\n    _parseToBuilder(text, position) {\n        const pos = (position != null ? position : new ParsePosition(0));\n        const result = this._parseUnresolved0(text, pos);\n        if (result == null || pos.getErrorIndex() >= 0 || (position == null && pos.getIndex() < text.length)) {\n            let abbr = '';\n            if (text.length > 64) {\n                abbr = `${text.substr(0, 64).toString()}...`;\n            } else {\n                abbr = text;\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new DateTimeParseException(`Text '${abbr}' could not be parsed at index ${ \n                    pos.getErrorIndex()}`, text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(`Text '${abbr}' could not be parsed, unparsed text found at index ${ \n                    pos.getIndex()}`, text, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    }\n\n    /**\n     * Parses the text using this formatter, without resolving the result, intended\n     * for advanced use cases.\n     *\n     * Parsing is implemented as a two-phase operation.\n     * First, the text is parsed using the layout defined by the formatter, producing\n     * a {@link Map} of field to value, a {@link ZoneId} and a {@link Chronology}.\n     * Second, the parsed data is *resolved*, by validating, combining and\n     * simplifying the various fields into more useful ones.\n     * This method performs the parsing stage but not the resolving stage.\n     *\n     * The result of this method is {@link TemporalAccessor} which represents the\n     * data as seen in the input. Values are not validated, thus parsing a date string\n     * of '2012-00-65' would result in a temporal with three fields - year of '2012',\n     * month of '0' and day-of-month of '65'.\n     *\n     * The text will be parsed from the specified start {@link ParsePosition}.\n     * The entire length of the text does not have to be parsed, the {@link ParsePosition}\n     * will be updated with the index at the end of parsing.\n     *\n     * Errors are returned using the error index field of the {@link ParsePosition}\n     * instead of {@link DateTimeParseException}.\n     * The returned error index will be set to an index indicative of the error.\n     * Callers must check for errors before using the context.\n     *\n     * If the formatter parses the same field more than once with different values,\n     * the result will be an error.\n     *\n     * This method is intended for advanced use cases that need access to the\n     * internal state during parsing. Typical application code should use\n     * {@link parse} or the parse method on the target type.\n     *\n     * @param text  the text to parse, not null\n     * @param position  the position to parse from, updated with length parsed\n     *  and the index of any error, not null\n     * @return the parsed text, null if the parse results in an error\n     * @throws DateTimeException if some problem occurs during parsing\n     * @throws IndexOutOfBoundsException if the position is invalid\n     */\n    parseUnresolved(text, position) {\n        return this._parseUnresolved0(text, position);\n    }\n\n    _parseUnresolved0(text, position) {\n        assert(text != null, 'text', NullPointerException);\n        assert(position != null, 'position', NullPointerException);\n        const context = new DateTimeParseContext(this);\n        let pos = position.getIndex();\n        pos = this._printerParser.parse(context, text, pos);\n        if (pos < 0) {\n            position.setErrorIndex(~pos);  // index not updated from input\n            return null;\n        }\n        position.setIndex(pos);  // errorIndex not updated from input\n        return context.toParsed();\n    }\n\n    /**\n     * Returns the formatter as a composite printer parser.\n     *\n     * @param {boolean} optional  whether the printer/parser should be optional\n     * @return {CompositePrinterParser} the printer/parser, not null\n     */\n    _toPrinterParser(optional) {\n        return this._printerParser.withOptional(optional);\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        const pattern = this._printerParser.toString();\n        return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n    }\n\n}\n\nexport function _init() {\n\n    DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n        .optionalStart()\n        .appendLiteral(':')\n        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n        .optionalStart()\n        .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .appendLiteral('T')\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendInstant()\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()\n        .append(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n        .optionalStart()\n        .appendLiteral('[')\n        .parseCaseSensitive()\n        .appendZoneId()\n        // .appendZoneRegionId()\n        .appendLiteral(']')\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendValue(ChronoField.MONTH_OF_YEAR, 2)\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .appendOffsetId()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_YEAR)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-W')\n        .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR)\n        .appendLiteral('-')\n        .appendValue(ChronoField.DAY_OF_WEEK)\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE)\n        .optionalStart()\n        .appendOffsetId()\n        .optionalEnd()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .append(DateTimeFormatter.ISO_LOCAL_TIME)\n        .optionalStart()\n        .appendOffsetId()\n        .optionalEnd()\n        .toFormatter(ResolverStyle.STRICT);\n\n    DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder()\n        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        .optionalStart()\n        .appendOffsetId()\n        .optionalEnd()\n        .toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n\n    // TODO:\n    //  RFC_1123_DATE_TIME - https://www.threeten.org/threetenbp/apidocs/org/threeten/bp/format/DateTimeFormatter.html#RFC_1123_DATE_TIME\n\n    DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    });\n\n    DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', (temporal) => {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.leapSecond;\n        } else {\n            return false;\n        }\n    });\n\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DateTimeFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1027,
    "kind": "class",
    "name": "DateTimeFormatter",
    "memberof": "packages/core/src/format/DateTimeFormatter.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatter.js",
    "importStyle": "{DateTimeFormatter}",
    "description": "\n### Static properties of Class {@link DateTimeFormatter}\n\nDateTimeFormatter.ISO_LOCAL_DATE\n\nDateTimeFormatter.ISO_LOCAL_TIME\n\nDateTimeFormatter.ISO_LOCAL_DATE_TIME",
    "lineNumber": 37,
    "interface": false
  },
  {
    "__docId__": 1028,
    "kind": "method",
    "name": "parsedExcessDays",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter.parsedExcessDays",
    "access": "public",
    "description": "A query that provides access to the excess days that were parsed.\n\nThis returns a singleton {@link TemporalQuery} that provides\naccess to additional information from the parse. The query always returns\na non-null period, with a zero period returned instead of null.\n\nThere are two situations where this query may return a non-zero period.\n\n* If the {@link ResolverStyle} is {@link LENIENT} and a time is parsed\n  without a date, then the complete result of the parse consists of a\n  {@link LocalTime} and an excess {@link Period} in days.\n* If the {@link ResolverStyle} is {@link SMART} and a time is parsed\n  without a date where the time is 24:00:00, then the complete result of\n  the parse consists of a {@link LocalTime} of 00:00:00 and an excess\n  {@link Period} of one day.\n\nIn both cases, if a complete {@link ChronoLocalDateTime} or {@link Instant}\nis parsed, then the excess days are added to the date part.\nAs a result, this query will return a zero period.\n\nThe {@link SMART} behaviour handles the common \"end of day\" 24:00 value.\nProcessing in {@link LENIENT} mode also produces the same result:\n<pre>\n Text to parse        Parsed object                         Excess days\n \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO\n \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO\n \"00:00\"              LocalTime.of(0, 0)                    ZERO\n \"24:00\"              LocalTime.of(0, 0)                    Period.ofDays(1)\n</pre>\nThe query can be used as follows:\n<pre>\n TemporalAccessor parsed = formatter.parse(str);\n LocalTime time = parsed.query(LocalTime.FROM);\n Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());\n</pre>",
    "lineNumber": 78,
    "return": {
      "nullable": null,
      "types": [
        "TemporalQuery"
      ],
      "spread": false,
      "description": "a query that provides access to the excess days that were parsed"
    },
    "params": []
  },
  {
    "__docId__": 1029,
    "kind": "method",
    "name": "parsedLeapSecond",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter.parsedLeapSecond",
    "access": "public",
    "description": "A query that provides access to whether a leap-second was parsed.\n\nThis returns a singleton {@link TemporalQuery} that provides\naccess to additional information from the parse. The query always returns\na non-null boolean, true if parsing saw a leap-second, false if not.\n\nInstant parsing handles the special \"leap second\" time of '23:59:60'.\nLeap seconds occur at '23:59:60' in the UTC time-zone, but at other\nlocal times in different time-zones. To avoid this potential ambiguity,\nthe handling of leap-seconds is limited to\n{@link DateTimeFormatterBuilder#appendInstant}, as that method\nalways parses the instant with the UTC zone offset.\n\nIf the time '23:59:60' is received, then a simple conversion is applied,\nreplacing the second-of-minute of 60 with 59. This query can be used\non the parse result to determine if the leap-second adjustment was made.\nThe query will return one second of excess if it did adjust to remove\nthe leap-second, and zero if not. Note that applying a leap-second\nsmoothing mechanism, such as UTC-SLS, is the responsibility of the\napplication, as follows:\n<pre>\n TemporalAccessor parsed = formatter.parse(str);\n Instant instant = parsed.query(Instant::from);\n if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n   // validate leap-second is correct and apply correct smoothing\n }\n</pre>",
    "lineNumber": 112,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that provides access to whether a leap-second was parsed"
    },
    "params": []
  },
  {
    "__docId__": 1030,
    "kind": "method",
    "name": "ofPattern",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter.ofPattern",
    "access": "public",
    "description": "Creates a formatter using the specified pattern.\n\nThis method will create a formatter based on a simple pattern of letters and symbols.\n\nThe returned formatter will use the default locale, but this can be changed\nusing {@link DateTimeFormatter.withLocale}.\n\nAll letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\nThe following pattern letters are defined:\n<pre>\n |Symbol  |Meaning                     |Presentation      |Examples\n |--------|----------------------------|------------------|----------------------------------------------------\n | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n | u      | year                       | year             | 2004; 04\n | y      | year-of-era                | year             | 2004; 04\n | D      | day-of-year                | number           | 189\n | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n | d      | day-of-month               | number           | 10\n |        |                            |                  |\n | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n | Y      | week-based-year            | year             | 1996; 96\n | w      | week-of-year               | number           | 27\n | W      | week-of-month              | number           | 27\n | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n | F      | week-of-month              | number           | 3\n |        |                            |                  |\n | a      | am-pm-of-day               | text             | PM\n | h      | clock-hour-of-am-pm (1-12) | number           | 12\n | K      | hour-of-am-pm (0-11)       | number           | 0\n | k      | clock-hour-of-am-pm (1-24) | number           | 0\n |        |                            |                  |\n | H      | hour-of-day (0-23)         | number           | 0\n | m      | minute-of-hour             | number           | 30\n | s      | second-of-minute           | number           | 55\n | S      | fraction-of-second         | fraction         | 978\n | A      | milli-of-day               | number           | 1234\n | n      | nano-of-second             | number           | 987654321\n | N      | nano-of-day                | number           | 1234000000\n |        |                            |                  |\n | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n |        |                            |                  |\n | p      | pad next                   | pad modifier     | 1\n |        |                            |                  |\n | '      | escape for text            | delimiter        |\n | ''     | single quote               | literal          | '\n | [      | optional section start     |                  |\n | ]      | optional section end       |                  |\n | {}     | reserved for future use    |                  |\n</pre>\n\nThe count of pattern letters determine the format.\n\n**Text**: The text style is determined based on the number of pattern letters used.\nLess than 4 pattern letters will use the short form `TextStyle.SHORT`.\nExactly 4 pattern letters will use the full form `TextStyle.FULL`.\nExactly 5 pattern letters will use the narrow form `TextStyle.NARROW`.\n\n**NOTE**: since text styles require locale support, they are currently not supported in js-joda!\n\n**Number**: If the count of letters is one, then the value is printed using the minimum number\nof digits and without padding as per {@link DateTimeFormatterBuilder.appendValue}.\nOtherwise, the count of digits is used as the width of the output field as per\n{@link DateTimeFormatterBuilder.appendValue}.\n\n**Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\nOtherwise use the Number rules above.\n\n**Fraction**: Outputs the nano-of-second field as a fraction-of-second.\nThe nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\nIf it is less than 9, then the nano-of-second value is truncated, with only the most\nsignificant digits being output.\nWhen parsing in strict mode, the number of parsed digits must match the count of pattern letters.\nWhen parsing in lenient mode, the number of parsed digits must be at least the count of pattern\nletters, up to 9 digits.\n\n**Year**: The count of letters determines the minimum field width below which padding is used.\nIf the count of letters is two, then a {@link DateTimeFormatterBuilder.appendValueReduced}\ntwo digit form is used.\nFor printing, this outputs the rightmost two digits. For parsing, this will parse using the\nbase value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\nIf the count of letters is less than four (but not two), then the sign is only output for negative\nyears as per `SignStyle.NORMAL`.\nOtherwise, the sign is output if the pad width is exceeded, as per `SignStyle.EXCEEDS_PAD`\n\n**ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\nIf the count of letters is two, then the time-zone ID is output.\nAny other count of letters throws `IllegalArgumentException`.\n\n**Zone names**: This outputs the display name of the time-zone ID.\nIf the count of letters is one, two or three, then the short name is output.\nIf the count of letters is four, then the full name is output.\nFive or more letters throws `IllegalArgumentException`.\n\n**NOTE**: since zone ids and name require the iana tzdb, they are currently not supported in js-joda!\n\n**Offset X and x**: This formats the offset based on the number of pattern letters.\nOne letter outputs just the hour', such as '+01', unless the minute is non-zero\nin which case the minute is also output, such as '+0130'.\nTwo letters outputs the hour and minute, without a colon, such as '+0130'.\nThree letters outputs the hour and minute, with a colon, such as '+01:30'.\nFour letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\nFive letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\nSix or more letters throws `IllegalArgumentException`.\nPattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\nwhereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n\n**Offset Z**: This formats the offset based on the number of pattern letters.\nOne, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\nFour or more letters throws `IllegalArgumentException`.\nThe output will be '+0000' when the offset is zero.\n\n**Optional section**: The optional section markers work exactly like calling\n{@link DateTimeFormatterBuilder.optionalStart} and {@link DateTimeFormatterBuilder.optionalEnd}.\n\n**Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\nThe pad width is determined by the number of pattern letters.\nThis is the same as calling {@link DateTimeFormatterBuilder.padNext}.\n\nFor example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n\nAny unrecognized letter is an error.\nAny non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\nDespite this, it is recommended to use single quotes around all characters that you want to\noutput directly to ensure that future changes do not break your application.",
    "examples": [
      "var s = LocalDate.parse('2016-04-01').format(DateTimeFormatter.ofPattern('d MM yyyy'));\nconsole.log(s); // '1 04 2016'"
    ],
    "see": [
      "DateTimeFormatterBuilder#appendPattern(String)"
    ],
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatter"
      ],
      "spread": false,
      "description": "the formatter based on the pattern, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the pattern is invalid"
      }
    ]
  },
  {
    "__docId__": 1031,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 274,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "printerParser",
        "description": "the printer/parser to use, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the locale to use, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "decimalStyle",
        "description": "the decimal style to use, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": "the resolver style to use, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverFields",
        "description": "the fields to use during resolving, null for all fields"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "chrono",
        "description": "the chronology to use, null for no override"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone to use, null for no override"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1032,
    "kind": "member",
    "name": "_printerParser",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_printerParser",
    "access": "private",
    "description": "The printer and/or parser to use, not null.",
    "lineNumber": 281,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1033,
    "kind": "member",
    "name": "_locale",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_locale",
    "access": "private",
    "description": "The locale to use for formatting. // nyi",
    "lineNumber": 285,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1034,
    "kind": "member",
    "name": "_decimalStyle",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_decimalStyle",
    "access": "private",
    "description": "The symbols to use for formatting, not null.",
    "lineNumber": 289,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1035,
    "kind": "member",
    "name": "_resolverStyle",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_resolverStyle",
    "access": "private",
    "description": "The resolver style to use, not null.",
    "lineNumber": 293,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1036,
    "kind": "member",
    "name": "_resolverFields",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_resolverFields",
    "access": "private",
    "description": "The fields to use in resolving, null for all fields.",
    "lineNumber": 297,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1037,
    "kind": "member",
    "name": "_chrono",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_chrono",
    "access": "private",
    "description": "The chronology to use for formatting, null for no override.",
    "lineNumber": 301,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1038,
    "kind": "member",
    "name": "_zone",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_zone",
    "access": "private",
    "description": "The zone to use for formatting, null for no override. // nyi",
    "lineNumber": 305,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1039,
    "kind": "method",
    "name": "locale",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#locale",
    "access": "public",
    "description": null,
    "lineNumber": 308,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1040,
    "kind": "method",
    "name": "decimalStyle",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#decimalStyle",
    "access": "public",
    "description": null,
    "lineNumber": 312,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1041,
    "kind": "method",
    "name": "chronology",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#chronology",
    "access": "public",
    "description": null,
    "lineNumber": 316,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1042,
    "kind": "method",
    "name": "withChronology",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#withChronology",
    "access": "public",
    "description": "Returns a copy of this formatter with a new override chronology.\n\nThis returns a formatter with similar state to this formatter but\nwith the override chronology set.\nBy default, a formatter has no override chronology, returning null.\n\nIf an override is added, then any date that is printed or parsed will be affected.\n\nWhen printing, if the {@link Temporal} object contains a date then it will\nbe converted to a date in the override chronology.\nAny time or zone will be retained unless overridden.\nThe converted result will behave in a manner equivalent to an implementation\nof {@link ChronoLocalDate},{@link ChronoLocalDateTime} or {@link ChronoZonedDateTime}.\n\nWhen parsing, the override chronology will be used to interpret the\n{@link ChronoField} into a date unless the\nformatter directly parses a valid chronology.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 344,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "chrono",
        "description": "the new chronology, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a formatter based on this formatter with the requested override chronology, not null"
    }
  },
  {
    "__docId__": 1043,
    "kind": "method",
    "name": "withLocale",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#withLocale",
    "access": "public",
    "description": "not yet supported",
    "lineNumber": 356,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{DateTimeFormatter}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatter"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1044,
    "kind": "method",
    "name": "withResolverStyle",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#withResolverStyle",
    "access": "public",
    "description": "Returns a copy of this formatter with a new resolver style.\n<p>\nThis returns a formatter with similar state to this formatter but\nwith the resolver style set. By default, a formatter has the\n{@link ResolverStyle#SMART SMART} resolver style.\n<p>\nChanging the resolver style only has an effect during parsing.\nParsing a text string occurs in two phases.\nPhase 1 is a basic text parse according to the fields added to the builder.\nPhase 2 resolves the parsed field-value pairs into date and/or time objects.\nThe resolver style is used to control how phase 2, resolving, happens.\nSee {@link ResolverStyle} for more information on the options available.\n<p>\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 379,
    "params": [
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": "the new resolver style, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatter"
      ],
      "spread": false,
      "description": "a formatter based on this formatter with the requested resolver style, not null"
    }
  },
  {
    "__docId__": 1045,
    "kind": "method",
    "name": "format",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#format",
    "access": "public",
    "description": "Formats a date-time object using this formatter.\n\nThis formats the date-time to a String using the rules of the formatter.",
    "lineNumber": 396,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to print, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the printed string, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during formatting"
      }
    ]
  },
  {
    "__docId__": 1046,
    "kind": "method",
    "name": "_formatTo",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_formatTo",
    "access": "private",
    "description": "Formats a date-time object to an {@link Appendable} using this formatter.\n\nThis formats the date-time to the specified destination.\n{@link Appendable} is a general purpose interface that is implemented by all\nkey character output classes including {@link StringBuffer}, {@link StringBuilder},\n{@link PrintStream} and {@link Writer}.\n\nAlthough {@link Appendable} methods throw an {@link IOException}, this method does not.\nInstead, any {@link IOException} is wrapped in a runtime exception.",
    "lineNumber": 418,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to print, not null"
      },
      {
        "nullable": null,
        "types": [
          "StringBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "appendable",
        "description": "the appendable to print to, not null"
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if an error occurs during formatting"
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1047,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#parse",
    "access": "public",
    "description": "function overloading for {@link DateTimeFormatter.parse}\n\nif called with one arg {@link DateTimeFormatter.parse1} is called\notherwise {@link DateTimeFormatter.parse2}",
    "lineNumber": 435,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAccessor"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1048,
    "kind": "method",
    "name": "parse1",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#parse1",
    "access": "public",
    "description": "Fully parses the text producing a temporal object.\n\nThis parses the entire text producing a temporal object.\nIt is typically more useful to use {@link parse}.\nThe result of this method is {@link TemporalAccessor} which has been resolved,\napplying basic validation checks to help ensure a valid date-time.\n\nIf the parse completes without reading the entire length of the text,\nor a problem occurs during parsing or merging, then an exception is thrown.",
    "lineNumber": 458,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAccessor"
      ],
      "spread": false,
      "description": "the parsed temporal object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if unable to parse the requested result"
      }
    ]
  },
  {
    "__docId__": 1049,
    "kind": "method",
    "name": "parse2",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#parse2",
    "access": "public",
    "description": "Fully parses the text producing a temporal object.\n\nThis parses the entire text producing a temporal object.\nIt is typically more useful to use {@link parse}.\nThe result of this method is {@link TemporalAccessor} which has been resolved,\napplying basic validation checks to help ensure a valid date-time.\n\nIf the parse completes without reading the entire length of the text,\nor a problem occurs during parsing or merging, then an exception is thrown.",
    "lineNumber": 487,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "the type to extract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the parsed temporal object, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if unable to parse the requested result"
      }
    ]
  },
  {
    "__docId__": 1050,
    "kind": "method",
    "name": "_createError",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_createError",
    "access": "private",
    "description": null,
    "lineNumber": 502,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "ex",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1051,
    "kind": "method",
    "name": "_parseToBuilder",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_parseToBuilder",
    "access": "private",
    "description": "Parses the text to a builder.\n\nThis parses to a {@link DateTimeBuilder} ensuring that the text is fully parsed.\nThis method throws {@link DateTimeParseException} if unable to parse, or\nsome other {@link DateTimeException} if another date/time problem occurs.",
    "lineNumber": 526,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "the position to parse from, updated with length parsed\n and the index of any error, null if parsing whole string"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the engine representing the result of the parse, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeParseException if the parse fails"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1052,
    "kind": "method",
    "name": "parseUnresolved",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#parseUnresolved",
    "access": "public",
    "description": "Parses the text using this formatter, without resolving the result, intended\nfor advanced use cases.\n\nParsing is implemented as a two-phase operation.\nFirst, the text is parsed using the layout defined by the formatter, producing\na {@link Map} of field to value, a {@link ZoneId} and a {@link Chronology}.\nSecond, the parsed data is *resolved*, by validating, combining and\nsimplifying the various fields into more useful ones.\nThis method performs the parsing stage but not the resolving stage.\n\nThe result of this method is {@link TemporalAccessor} which represents the\ndata as seen in the input. Values are not validated, thus parsing a date string\nof '2012-00-65' would result in a temporal with three fields - year of '2012',\nmonth of '0' and day-of-month of '65'.\n\nThe text will be parsed from the specified start {@link ParsePosition}.\nThe entire length of the text does not have to be parsed, the {@link ParsePosition}\nwill be updated with the index at the end of parsing.\n\nErrors are returned using the error index field of the {@link ParsePosition}\ninstead of {@link DateTimeParseException}.\nThe returned error index will be set to an index indicative of the error.\nCallers must check for errors before using the context.\n\nIf the formatter parses the same field more than once with different values,\nthe result will be an error.\n\nThis method is intended for advanced use cases that need access to the\ninternal state during parsing. Typical application code should use\n{@link parse} or the parse method on the target type.",
    "lineNumber": 586,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "the position to parse from, updated with length parsed\n and the index of any error, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the parsed text, null if the parse results in an error"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if some problem occurs during parsing"
      },
      {
        "types": [
          "*"
        ],
        "description": "IndexOutOfBoundsException if the position is invalid"
      }
    ]
  },
  {
    "__docId__": 1053,
    "kind": "method",
    "name": "_parseUnresolved0",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_parseUnresolved0",
    "access": "private",
    "description": null,
    "lineNumber": 590,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1054,
    "kind": "method",
    "name": "_toPrinterParser",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#_toPrinterParser",
    "access": "private",
    "description": "Returns the formatter as a composite printer parser.",
    "lineNumber": 610,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "optional",
        "description": "whether the printer/parser should be optional"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompositePrinterParser"
      ],
      "spread": false,
      "description": "the printer/parser, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 1055,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter#toString",
    "access": "public",
    "description": "",
    "lineNumber": 618,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1056,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/format/DateTimeFormatter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatter.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatter.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 625,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1057,
    "kind": "file",
    "name": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, requireNonNull, requireInstance } from '../assert';\nimport { IllegalArgumentException, IllegalStateException } from '../errors';\nimport { MathUtil } from '../MathUtil';\n\nimport { LocalDate } from '../LocalDate';\nimport { LocalDateTime } from '../LocalDateTime';\nimport { ZoneOffset } from '../ZoneOffset';\nimport { ChronoLocalDate } from '../chrono/ChronoLocalDate';\nimport { ChronoField } from '../temporal/ChronoField';\nimport { IsoFields } from '../temporal/IsoFields';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\n\nimport { DateTimeFormatter } from './DateTimeFormatter';\nimport { DecimalStyle } from './DecimalStyle';\nimport { SignStyle } from './SignStyle';\nimport { TextStyle } from './TextStyle';\nimport { ResolverStyle } from './ResolverStyle';\n\nimport { CharLiteralPrinterParser } from './parser/CharLiteralPrinterParser';\nimport { CompositePrinterParser } from './parser/CompositePrinterParser';\nimport { FractionPrinterParser } from './parser/FractionPrinterParser';\nimport { NumberPrinterParser, ReducedPrinterParser } from './parser/NumberPrinterParser';\nimport { OffsetIdPrinterParser } from './parser/OffsetIdPrinterParser';\nimport { PadPrinterParserDecorator } from './parser/PadPrinterParserDecorator';\nimport { SettingsParser } from './parser/SettingsParser';\nimport { StringLiteralPrinterParser } from './parser/StringLiteralPrinterParser';\nimport { ZoneIdPrinterParser } from './parser/ZoneIdPrinterParser';\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nexport class DateTimeFormatterBuilder {\n\n    /**\n     * Constructs a new instance of the builder.\n     */\n    constructor() {\n        /**\n         * The currently active builder, used by the outermost builder.\n         */\n        this._active = this;\n        /**\n         * The parent builder, null for the outermost builder.\n         */\n        this._parent = null;\n\n        /**\n         * The list of printers that will be used.\n         */\n        this._printerParsers = [];\n\n        /**\n         * Whether this builder produces an optional formatter.\n         */\n        this._optional = false;\n        /**\n         * The width to pad the next field to.\n         */\n        this._padNextWidth = 0;\n\n        /**\n         * The character to pad the next field with.\n         */\n        this._padNextChar = null;\n\n        /**\n         * The index of the last variable width value parser.\n         */\n        this._valueParserIndex = -1;\n    }\n\n    /**\n     * Private static factory, replaces private threeten constructor\n     * Returns a new instance of the builder.\n     *\n     * @param {DateTimeFormatterBuilder} parent  the parent builder, not null\n     * @param {boolean} optional  whether the formatter is optional, not null\n     * @return {DateTimeFormatterBuilder} new instance\n     */\n    static _of(parent, optional){\n        requireNonNull(parent, 'parent');\n        requireNonNull(optional, 'optional');\n\n        const dtFormatterBuilder = new DateTimeFormatterBuilder();\n        dtFormatterBuilder._parent = parent;\n        dtFormatterBuilder._optional = optional;\n\n        return dtFormatterBuilder;\n    }\n\n    /**\n     * Changes the parse style to be case sensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseInsensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * Since the default is case sensitive, this method should only be used after\n     * a previous call to {@link parseCaseInsensitive}.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseSensitive() {\n        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be case insensitive for the remainder of the formatter.\n     *\n     * Parsing can be case sensitive or insensitive - by default it is case sensitive.\n     * This method allows the case sensitivity setting of parsing to be changed.\n     *\n     * Calling this method changes the state of the builder such that all\n     * subsequent builder method calls will parse text in case sensitive mode.\n     * See {@link parseCaseSensitive} for the opposite setting.\n     * The parse case sensitive/insensitive methods may be called at any point\n     * in the builder, thus the parser can swap between case parsing modes\n     * multiple times during the parse.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseCaseInsensitive() {\n        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Changes the parse style to be strict for the remainder of the formatter.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * As strict is the default, this is normally only needed after calling {@link parseLenient}.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseLenient} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseStrict() {\n        this._appendInternalPrinterParser(SettingsParser.STRICT);\n        return this;\n    }\n\n    /**\n     * Changes the parse style to be lenient for the remainder of the formatter.\n     * Note that case sensitivity is set separately to this method.\n     *\n     * Parsing can be strict or lenient - by default its strict.\n     * This controls the degree of flexibility in matching the text and sign styles.\n     * Applications calling this method should typically also call {@link parseCaseInsensitive}.\n     *\n     * When used, this method changes the parsing to be strict from this point onwards.\n     * The change will remain in force until the end of the formatter that is eventually\n     * constructed or until {@link parseStrict} is called.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseLenient() {\n        this._appendInternalPrinterParser(SettingsParser.LENIENT);\n        return this;\n    }\n\n    /**\n     * Appends a default value for a field to the formatter for use in parsing.\n     * <p>\n     * This appends an instruction to the builder to inject a default value\n     * into the parsed result. This is especially useful in conjunction with\n     * optional parts of the formatter.\n     * <p>\n     * For example, consider a formatter that parses the year, followed by\n     * an optional month, with a further optional day-of-month. Using such a\n     * formatter would require the calling code to check whether a full date,\n     * year-month or just a year had been parsed. This method can be used to\n     * default the month and day-of-month to a sensible value, such as the\n     * first of the month, allowing the calling code to always get a date.\n     * <p>\n     * During formatting, this method has no effect.\n     * <p>\n     * During parsing, the current state of the parse is inspected.\n     * If the specified field has no associated value, because it has not been\n     * parsed successfully at that point, then the specified value is injected\n     * into the parse result. Injection is immediate, thus the field-value pair\n     * will be visible to any subsequent elements in the formatter.\n     * As such, this method is normally called at the end of the builder.\n     *\n     * @param {TemporalField} field  the field to default the value of, not null\n     * @param {number} value  the value to default the field to\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    parseDefaulting(field, value) {\n        requireNonNull(field);\n        this._appendInternal(new DefaultingParser(field, value));\n        return this;\n    }\n\n    /**\n     * appendValue function overloading\n     */\n    appendValue(){\n        if(arguments.length === 1){\n            return this._appendValue1.apply(this, arguments);\n        } else if(arguments.length === 2){\n            return this._appendValue2.apply(this, arguments);\n        } else {\n            return this._appendValue4.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a normal\n     * output style.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be printed as per the normal print of an integer value.\n     * Only negative numbers will be signed. No padding will be added.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * requiring one digit, but accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * @param field  the field to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValue1(field) {\n        requireNonNull(field);\n        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter using a fixed\n     * width, zero-padded approach.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * The value will be zero-padded on the left. If the size of the value\n     * means that it cannot be printed within the width then an exception is thrown.\n     * If the value of the field is negative then an exception is thrown during printing.\n     *\n     * This method supports a special technique of parsing known as 'adjacent value parsing'.\n     * This technique solves the problem where a variable length value is followed by one or more\n     * fixed length values. The standard parser is greedy, and thus it would normally\n     * steal the digits that are needed by the fixed width value parsers that follow the\n     * variable width one.\n     *\n     * No action is required to initiate 'adjacent value parsing'.\n     * When a call to {@link appendValue} with a variable width is made, the builder\n     * enters adjacent value parsing setup mode. If the immediately subsequent method\n     * call or calls on the same builder are to this method, then the parser will reserve\n     * space so that the fixed width values can be parsed.\n     *\n     * For example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2)`.\n     * The year is a variable width parse of between 1 and 19 digits.\n     * The month is a fixed width parse of 2 digits.\n     * Because these were appended to the same builder immediately after one another,\n     * the year parser will reserve two digits for the month to parse.\n     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.\n     * Without adjacent value parsing, the year would greedily parse all six digits and leave\n     * nothing for the month.\n     *\n     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser\n     * that immediately follow any kind of variable width value.\n     * Calling any other append method will end the setup of adjacent value parsing.\n     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,\n     * simply add the `appendValue` to another {@link DateTimeFormatterBuilder}\n     * and add that to this builder.\n     *\n     * If adjacent parsing is active, then parsing must match exactly the specified\n     * number of digits in both strict and lenient modes.\n     * In addition, no positive or negative sign is permitted.\n     *\n     * @param field  the field to append, not null\n     * @param width  the width of the printed field, from 1 to 19\n     * @return this, for chaining, not null\n     * @throws IllegalArgumentException if the width is invalid\n     */\n    _appendValue2(field, width) {\n        requireNonNull(field);\n        if (width < 1 || width > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The width must be from 1 to ${MAX_WIDTH} inclusive but was ${width}`);\n        }\n        const pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the value of a date-time field to the formatter providing full\n     * control over printing.\n     *\n     * The value of the field will be output during a print.\n     * If the value cannot be obtained then an exception will be thrown.\n     *\n     * This method provides full control of the numeric formatting, including\n     * zero-padding and the positive/negative sign.\n     *\n     * The parser for a variable width value such as this normally behaves greedily,\n     * accepting as many digits as possible.\n     * This behavior can be affected by 'adjacent value parsing'.\n     * See {@link appendValue} for full details.\n     *\n     * In strict parsing mode, the minimum number of parsed digits is `minWidth`.\n     * In lenient parsing mode, the minimum number of parsed digits is one.\n     *\n     * If this method is invoked with equal minimum and maximum widths and a sign style of\n     * `NOT_NEGATIVE` then it delegates to `appendValue(TemporalField, int)`.\n     * In this scenario, the printing and parsing behavior described there occur.\n     *\n     * @param field  the field to append, not null\n     * @param minWidth  the minimum field width of the printed field, from 1 to 19\n     * @param maxWidth  the maximum field width of the printed field, from 1 to 19\n     * @param signStyle  the positive/negative output style, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the widths are invalid\n     */\n    _appendValue4(field, minWidth, maxWidth, signStyle) {\n        requireNonNull(field);\n        requireNonNull(signStyle);\n        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n            return this._appendValue2(field, maxWidth);\n        }\n        if (minWidth < 1 || minWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${minWidth}`);\n        }\n        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(`The minimum width must be from 1 to ${MAX_WIDTH} inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(`The maximum width must exceed or equal the minimum width but ${maxWidth} < ${minWidth}`);\n        }\n        const pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * appendValueReduced function overloading\n     */\n    appendValueReduced() {\n        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n        } else {\n            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * Since fields such as year vary by chronology, it is recommended to use the\n     * {@link appendValueReduced} date}\n     * variant of this method in most cases. This variant is suitable for\n     * simple fields or working with only the ISO chronology.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {number} baseValue  the base value of the range of valid values\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n        requireNonNull(field, 'field');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends the reduced value of a date-time field to the formatter.\n     *\n     * This is typically used for formatting and parsing a two digit year.\n     *\n     * The base date is used to calculate the full value during parsing.\n     * For example, if the base date is 1950-01-01 then parsed values for\n     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.\n     * Only the year would be extracted from the date, thus a base date of\n     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.\n     * This behavior is necessary to support fields such as week-based-year\n     * or other calendar systems where the parsed value does not align with\n     * standard ISO years.\n     *\n     * The exact behavior is as follows. Parse the full set of fields and\n     * determine the effective chronology using the last chronology if\n     * it appears more than once. Then convert the base date to the\n     * effective chronology. Then extract the specified field from the\n     * chronology-specific base date and use it to determine the\n     * `baseValue` used below.\n     *\n     * For formatting, the `width` and `maxWidth` are used to\n     * determine the number of characters to format.\n     * If they are equal then the format is fixed width.\n     * If the value of the field is within the range of the `baseValue` using\n     * `width` characters then the reduced value is formatted otherwise the value is\n     * truncated to fit `maxWidth`.\n     * The rightmost characters are output to match the width, left padding with zero.\n     *\n     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\n     * For lenient parsing, the number of characters must be at least 1 and less than 10.\n     * If the number of digits parsed is equal to `width` and the value is positive,\n     * the value of the field is computed to be the first number greater than\n     * or equal to the `baseValue` with the same least significant characters,\n     * otherwise the value parsed is the field value.\n     * This allows a reduced value to be entered for values in range of the baseValue\n     * and width and absolute values can be entered for values outside the range.\n     *\n     * For example, a base value of `1980` and a width of `2` will have\n     * valid values from `1980` to `2079`.\n     * During parsing, the text `\"12\"` will result in the value `2012` as that\n     * is the value within the range where the last two characters are \"12\".\n     * By contrast, parsing the text `\"1915\"` will result in the value `1915`.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {number} width  the field width of the printed and parsed field, from 1 to 10\n     * @param {number} maxWidth  the maximum field width of the printed field, from 1 to 10\n     * @param {ChronoLocalDate} baseDate  the base date used to calculate the base value for the range\n     *  of valid values in the parsed chronology, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the width or base value is invalid\n     */\n    _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n        requireNonNull(field, 'field');\n        requireNonNull(baseDate, 'baseDate');\n        requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n        const pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n        this._appendValuePrinterParser(pp);\n        return this;\n    }\n\n    /**\n     * Appends a fixed width printer-parser.\n     *\n     * @param pp  the printer-parser, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    _appendValuePrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._valueParserIndex >= 0 &&\n                this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n            const activeValueParser = this._active._valueParserIndex;\n\n            // adjacent parsing mode, update setting in previous parsers\n            let basePP = this._active._printerParsers[activeValueParser];\n            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n                // Append the width to the subsequentWidth of the active parser\n                basePP = basePP.withSubsequentWidth(pp.maxWidth());\n                // Append the new parser as a fixed width\n                this._appendInternal(pp.withFixedWidth());\n                // Retain the previous active parser\n                this._active._valueParserIndex = activeValueParser;\n            } else {\n                // Modify the active parser to be fixed width\n                basePP = basePP.withFixedWidth();\n                // The new parser becomes the mew active parser\n                this._active._valueParserIndex = this._appendInternal(pp);\n            }\n            // Replace the modified parser with the updated one\n            this._active._printerParsers[activeValueParser] = basePP;\n        } else {\n            // The new Parser becomes the active parser\n            this._active._valueParserIndex = this._appendInternal(pp);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the fractional value of a date-time field to the formatter.\n     *\n     * The fractional value of the field will be output including the\n     * preceding decimal point. The preceding value is not output.\n     * For example, the second-of-minute value of 15 would be output as `.25`.\n     *\n     * The width of the printed fraction can be controlled. Setting the\n     * minimum width to zero will cause no output to be generated.\n     * The printed fraction will have the minimum width necessary between\n     * the minimum and maximum widths - trailing zeroes are omitted.\n     * No rounding occurs due to the maximum width - digits are simply dropped.\n     *\n     * When parsing in strict mode, the number of parsed digits must be between\n     * the minimum and maximum width. When parsing in lenient mode, the minimum\n     * width is considered to be zero and the maximum is nine.\n     *\n     * If the value cannot be obtained then an exception will be thrown.\n     * If the value is negative an exception will be thrown.\n     * If the field does not have a fixed set of valid values then an\n     * exception will be thrown.\n     * If the field value in the date-time to be printed is invalid it\n     * cannot be printed and an exception will be thrown.\n     *\n     * @param {TemporalField} field  the field to append, not null\n     * @param {Number} minWidth  the minimum width of the field excluding the decimal point, from 0 to 9\n     * @param {Number} maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the field has a variable set of valid values or\n     *  either width is invalid\n     */\n    appendFraction(field, minWidth, maxWidth, decimalPoint) {\n        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n        return this;\n    }\n\n    /**\n     * Appends an instant using ISO-8601 to the formatter with control over\n     * the number of fractional digits.\n     *\n     * Instants have a fixed output format, although this method provides some\n     * control over the fractional digits. They are converted to a date-time\n     * with a zone-offset of UTC and printed using the standard ISO-8601 format.\n     * The localized decimal style is not used.\n     *\n     * The {@link this.fractionalDigits} parameter allows the output of the fractional\n     * second to be controlled. Specifying zero will cause no fractional digits\n     * to be output. From 1 to 9 will output an increasing number of digits, using\n     * zero right-padding if necessary. The special value -1 is used to output as\n     * many digits as necessary to avoid any trailing zeroes.\n     *\n     * When parsing in strict mode, the number of parsed digits must match the\n     * fractional digits. When parsing in lenient mode, any number of fractional\n     * digits from zero to nine are accepted.\n     *\n     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS}\n     * and optionally (@code NANO_OF_SECOND). The value of {@link INSTANT_SECONDS}\n     * may be outside the maximum range of {@link LocalDateTime}.\n     *\n     * The {@link ResolverStyle} has no effect on instant parsing.\n     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.\n     * The leap-second time of '23:59:59' is handled to some degree, see\n     * {@link DateTimeFormatter#parsedLeapSecond} for full details.\n     *\n     * An alternative to this method is to format/parse the instant as a single\n     * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.\n     *\n     * @param {number} [fractionalDigits=-2] - the number of fractional second digits to format with,\n     *  from 0 to 9, or -1 to use as many digits as necessary\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendInstant(fractionalDigits=-2) {\n        if (fractionalDigits < -2 || fractionalDigits > 9) {\n            throw new IllegalArgumentException(`Invalid fractional digits: ${fractionalDigits}`);\n        }\n        this._appendInternal(new InstantPrinterParser(fractionalDigits));\n        return this;\n    }\n\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     * This is equivalent to calling `appendOffset(\"HH:MM:ss\", \"Z\")`.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffsetId() {\n        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n        return this;\n    }\n\n    /**\n     * Appends the zone offset, such as '+01:00', to the formatter.\n     *\n     * This appends an instruction to print/parse the offset ID to the builder.\n     *\n     * During printing, the offset is obtained using a mechanism equivalent\n     * to querying the temporal with {@link TemporalQueries#offset}.\n     * It will be printed using the format defined below.\n     * If the offset cannot be obtained then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * During parsing, the offset is parsed using the format defined below.\n     * If the offset cannot be parsed then an exception is thrown unless the\n     * section of the formatter is optional.\n     *\n     * The format of the offset is controlled by a pattern which must be one\n     * of the following:\n     *\n     * * `+HH` - hour only, ignoring minute and second\n     * * `+HHmm` - hour, with minute if non-zero, ignoring second, no colon\n     * * `+HH:mm` - hour, with minute if non-zero, ignoring second, with colon\n     * * `+HHMM` - hour and minute, ignoring second, no colon\n     * * `+HH:MM` - hour and minute, ignoring second, with colon\n     * * `+HHMMss` - hour and minute, with second if non-zero, no colon\n     * * `+HH:MM:ss` - hour and minute, with second if non-zero, with colon\n     * * `+HHMMSS` - hour, minute and second, no colon\n     * * `+HH:MM:SS` - hour, minute and second, with colon\n     *\n     * The \"no offset\" text controls what text is printed when the total amount of\n     * the offset fields to be output is zero.\n     * Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.\n     * Three formats are accepted for parsing UTC - the \"no offset\" text, and the\n     * plus and minus versions of zero defined by the pattern.\n     *\n     * @param {String} pattern  the pattern to use, not null\n     * @param {String} noOffsetText  the text to use when the offset is zero, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendOffset(pattern, noOffsetText) {\n        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n        return this;\n    }\n\n    /**\n      * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n      *\n      * This appends an instruction to print/parse the zone ID to the builder.\n      * The zone ID is obtained in a strict manner suitable for {@link ZonedDateTime}.\n      * By contrast, {@link OffsetDateTime} does not have a zone ID suitable\n      * for use with this method, see {@link appendZoneOrOffsetId}.\n      *\n      * During printing, the zone is obtained using a mechanism equivalent\n      * to querying the temporal with {@link TemporalQueries#zoneId}.\n      * It will be printed using the result of {@link ZoneId#getId}.\n      * If the zone cannot be obtained then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * During parsing, the zone is parsed and must match a known zone or offset.\n      * If the zone cannot be parsed then an exception is thrown unless the\n      * section of the formatter is optional.\n      *\n      * @return {DateTimeFormatterBuilder} this, for chaining, not null\n      * @see #appendZoneRegionId()\n      */\n    appendZoneId() {\n        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the elements defined by the specified pattern to the builder.\n     *\n     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\n     * The characters '{' and '}' are reserved for future use.\n     * The characters '[' and ']' indicate optional patterns.\n     * The following pattern letters are defined:\n     * <pre>\n     *  |Symbol  |Meaning                     |Presentation      |Examples\n     *  |--------|----------------------------|------------------|----------------------------------------------------\n     *  | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n     *  | u      | year                       | year             | 2004; 04\n     *  | y      | year-of-era                | year             | 2004; 04\n     *  | D      | day-of-year                | number           | 189\n     *  | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n     *  | d      | day-of-month               | number           | 10\n     *  |        |                            |                  |\n     *  | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n     *  | Y      | week-based-year            | year             | 1996; 96\n     *  | w      | week-of-year               | number           | 27\n     *  | W      | week-of-month              | number           | 27\n     *  | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n     *  | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n     *  | F      | week-of-month              | number           | 3\n     *  |        |                            |                  |\n     *  | a      | am-pm-of-day               | text             | PM\n     *  | h      | clock-hour-of-am-pm (1-12) | number           | 12\n     *  | K      | hour-of-am-pm (0-11)       | number           | 0\n     *  | k      | clock-hour-of-am-pm (1-24) | number           | 0\n     *  |        |                            |                  |\n     *  | H      | hour-of-day (0-23)         | number           | 0\n     *  | m      | minute-of-hour             | number           | 30\n     *  | s      | second-of-minute           | number           | 55\n     *  | S      | fraction-of-second         | fraction         | 978\n     *  | A      | milli-of-day               | number           | 1234\n     *  | n      | nano-of-second             | number           | 987654321\n     *  | N      | nano-of-day                | number           | 1234000000\n     *  |        |                            |                  |\n     *  | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n     *  | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n     *  | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n     *  | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n     *  |        |                            |                  |\n     *  | p      | pad next                   | pad modifier     | 1\n     *  |        |                            |                  |\n     *  | '      | escape for text            | delimiter        |\n     *  | ''     | single quote               | literal          | '\n     *  | [      | optional section start     |                  |\n     *  | ]      | optional section end       |                  |\n     *  | {}     | reserved for future use    |                  |\n     * </pre>\n     *\n     * The count of pattern letters determine the format.\n     *\n     * **Text**: The text style is determined based on the number of pattern letters used.\n     * Less than 4 pattern letters will use the short form (see {@link TextStyle#SHORT}).\n     * Exactly 4 pattern letters will use the full form (see {@link TextStyle#FULL}).\n     * Exactly 5 pattern letters will use the narrow form (see {@link TextStyle#NARROW}).\n     *\n     * **Number**: If the count of letters is one, then the value is printed using the minimum number\n     * of digits and without padding as per {@link appendValue}. Otherwise, the\n     * count of digits is used as the width of the output field as per {@link appendValue}.\n     *\n     * **Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\n     * Otherwise use the Number rules above.\n     *\n     * **Fraction**: Outputs the nano-of-second field as a fraction-of-second.\n     * The nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\n     * If it is less than 9, then the nano-of-second value is truncated, with only the most\n     * significant digits being output.\n     * When parsing in strict mode, the number of parsed digits must match the count of pattern letters.\n     * When parsing in lenient mode, the number of parsed digits must be at least the count of pattern\n     * letters, up to 9 digits.\n     *\n     * **Year**: The count of letters determines the minimum field width below which padding is used.\n     * If the count of letters is two, then a reduced (see {@link appendValueReduced}) two digit form is used.\n     * For printing, this outputs the rightmost two digits. For parsing, this will parse using the\n     * base value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\n     * If the count of letters is less than four (but not two), then the sign is only output for negative\n     * years as per {@link SignStyle#NORMAL}.\n     * Otherwise, the sign is output if the pad width is exceeded, as per {@link SignStyle#EXCEEDS_PAD}\n     *\n     * **ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\n     * If the count of letters is two, then the time-zone ID is output.\n     * Any other count of letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   VV          appendZoneId()\n     * </pre>\n     *\n     * **Zone names**: This outputs the display name of the time-zone ID.\n     * If the count of letters is one, two or three, then the short name is output.\n     * If the count of letters is four, then the full name is output.\n     * Five or more letters throws {@link IllegalArgumentException}.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   z           appendZoneText(TextStyle.SHORT)\n     *   zz          appendZoneText(TextStyle.SHORT)\n     *   zzz         appendZoneText(TextStyle.SHORT)\n     *   zzzz        appendZoneText(TextStyle.FULL)\n     * </pre>\n     *\n     * **Offset X and x**: This formats the offset based on the number of pattern letters.\n     * One letter outputs just the hour', such as '+01', unless the minute is non-zero\n     * in which case the minute is also output, such as '+0130'.\n     * Two letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Three letters outputs the hour and minute, with a colon, such as '+01:30'.\n     * Four letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\n     * Five letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\n     * Six or more letters throws {@link IllegalArgumentException}.\n     * Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\n     * whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   X           appendOffset(\"+HHmm\",\"Z\")\n     *   XX          appendOffset(\"+HHMM\",\"Z\")\n     *   XXX         appendOffset(\"+HH:MM\",\"Z\")\n     *   XXXX        appendOffset(\"+HHMMss\",\"Z\")\n     *   XXXXX       appendOffset(\"+HH:MM:ss\",\"Z\")\n     *   x           appendOffset(\"+HHmm\",\"+00\")\n     *   xx          appendOffset(\"+HHMM\",\"+0000\")\n     *   xxx         appendOffset(\"+HH:MM\",\"+00:00\")\n     *   xxxx        appendOffset(\"+HHMMss\",\"+0000\")\n     *   xxxxx       appendOffset(\"+HH:MM:ss\",\"+00:00\")\n     * </pre>\n     *\n     * **Offset Z**: This formats the offset based on the number of pattern letters.\n     * One, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\n     * Four or more letters throws {@link IllegalArgumentException}.\n     * The output will be '+0000' when the offset is zero.\n     * <pre>\n     *  Pattern     Equivalent builder methods\n     *   Z           appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZ          appendOffset(\"+HHMM\",\"+0000\")\n     *   ZZZ         appendOffset(\"+HHMM\",\"+0000\")\n     * </pre>\n     *\n     * **Optional section**: The optional section markers work exactly like calling {@link optionalStart}\n     * and {@link optionalEnd}.\n     *\n     * **Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\n     * The pad width is determined by the number of pattern letters.\n     * This is the same as calling {@link padNext}.\n     *\n     * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n     *\n     * Any unrecognized letter is an error.\n     * Any non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\n     * Despite this, it is recommended to use single quotes around all characters that you want to\n     * output directly to ensure that future changes do not break your application.\n     *\n     * Note that the pattern string is similar, but not identical, to\n     * {@link java.text.SimpleDateFormat}.\n     * The pattern string is also similar, but not identical, to that defined by the\n     * Unicode Common Locale Data Repository (CLDR/LDML).\n     * Pattern letters 'E' and 'u' are merged, which changes the meaning of \"E\" and \"EE\" to be numeric.\n     * Pattern letters 'X' is aligned with Unicode CLDR/LDML, which affects pattern 'X'.\n     * Pattern letter 'y' and 'Y' parse years of two digits and more than 4 digits differently.\n     * Pattern letters 'n', 'A', 'N', 'I' and 'p' are added.\n     * Number types will reject large numbers.\n     *\n     * @param {String} pattern  the pattern to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    appendPattern(pattern) {\n        requireNonNull(pattern, 'pattern');\n        this._parsePattern(pattern);\n        return this;\n    }\n\n\n    //-----------------------------------------------------------------------\n    // empty implementations of locale functionality, be implemented/overridden by js-joda-locale\n\n    appendZoneText() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');\n    }\n\n    appendText() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');\n    }\n\n    appendLocalizedOffset() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');\n    }\n\n    appendWeekField() {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');\n    }\n\n    //-----------------------------------------------------------------------\n\n    _parsePattern(pattern) {\n        /** Map of letters to fields. */\n        const FIELD_MAP = {\n            'G': ChronoField.ERA,\n            'y': ChronoField.YEAR_OF_ERA,\n            'u': ChronoField.YEAR,\n            'Q': IsoFields.QUARTER_OF_YEAR,\n            'q': IsoFields.QUARTER_OF_YEAR,\n            'M': ChronoField.MONTH_OF_YEAR,\n            'L': ChronoField.MONTH_OF_YEAR,\n            'D': ChronoField.DAY_OF_YEAR,\n            'd': ChronoField.DAY_OF_MONTH,\n            'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n            'E': ChronoField.DAY_OF_WEEK,\n            'c': ChronoField.DAY_OF_WEEK,\n            'e': ChronoField.DAY_OF_WEEK,\n            'a': ChronoField.AMPM_OF_DAY,\n            'H': ChronoField.HOUR_OF_DAY,\n            'k': ChronoField.CLOCK_HOUR_OF_DAY,\n            'K': ChronoField.HOUR_OF_AMPM,\n            'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n            'm': ChronoField.MINUTE_OF_HOUR,\n            's': ChronoField.SECOND_OF_MINUTE,\n            'S': ChronoField.NANO_OF_SECOND,\n            'A': ChronoField.MILLI_OF_DAY,\n            'n': ChronoField.NANO_OF_SECOND,\n            'N': ChronoField.NANO_OF_DAY\n        };\n\n        for (let pos = 0; pos < pattern.length; pos++) {\n            let cur = pattern.charAt(pos);\n            if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                let start = pos++;\n                for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                let count = pos - start;\n                // padding\n                if (cur === 'p') {\n                    let pad = 0;\n                    if (pos < pattern.length) {\n                        cur = pattern.charAt(pos);\n                        if ((cur >= 'A' && cur <= 'Z') || (cur >= 'a' && cur <= 'z')) {\n                            pad = count;\n                            start = pos++;\n                            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);  // short loop\n                            count = pos - start;\n                        }\n                    }\n                    if (pad === 0) {\n                        throw new IllegalArgumentException(\n                            `Pad letter 'p' must be followed by valid pad pattern: ${pattern}`);\n                    }\n                    this.padNext(pad); // pad and continue parsing\n                }\n                // main rules\n                const field = FIELD_MAP[cur];\n                if (field != null) {\n                    this._parseField(cur, count, field);\n                } else if (cur === 'z') {\n                    if (count > 4) {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    } else if (count === 4) {\n                        this.appendZoneText(TextStyle.FULL);\n                    } else {\n                        this.appendZoneText(TextStyle.SHORT);\n                    }\n                } else if (cur === 'V') {\n                    if (count !== 2) {\n                        throw new IllegalArgumentException(`Pattern letter count must be 2: ${cur}`);\n                    }\n                    this.appendZoneId();\n                } else if (cur === 'Z') {\n                    if (count < 4) {\n                        this.appendOffset('+HHMM', '+0000');\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else if (count === 5) {\n                        this.appendOffset('+HH:MM:ss', 'Z');\n                    } else {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    }\n                } else if (cur === 'O') {\n                    if (count === 1) {\n                        this.appendLocalizedOffset(TextStyle.SHORT);\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else {\n                        throw new IllegalArgumentException(`Pattern letter count must be 1 or 4: ${cur}`);\n                    }\n                } else if (cur === 'X') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    }\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n                } else if (cur === 'x') {\n                    if (count > 5) {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    }\n                    const zero = (count === 1 ? '+00' : (count % 2 === 0 ? '+0000' : '+00:00'));\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n                } else if (cur === 'W') {\n                    if (count > 1) {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    }\n                    this.appendWeekField('W', count);\n                } else if (cur === 'w') {\n                    if (count > 2) {\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                    }\n                    this.appendWeekField('w', count);\n                } else if (cur === 'Y') {\n                    this.appendWeekField('Y', count);\n                } else {\n                    throw new IllegalArgumentException(`Unknown pattern letter: ${cur}`);\n                }\n                pos--;\n\n            } else if (cur === '\\'') {\n                // parse literals\n                const start = pos++;\n                for (; pos < pattern.length; pos++) {\n                    if (pattern.charAt(pos) === '\\'') {\n                        if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n                            pos++;\n                        } else {\n                            break;  // end of literal\n                        }\n                    }\n                }\n                if (pos >= pattern.length) {\n                    throw new IllegalArgumentException(`Pattern ends with an incomplete string literal: ${pattern}`);\n                }\n                const str = pattern.substring(start + 1, pos);\n                if (str.length === 0) {\n                    this.appendLiteral('\\'');\n                } else {\n                    this.appendLiteral(str.replace('\\'\\'', '\\''));\n                }\n\n            } else if (cur === '[') {\n                this.optionalStart();\n\n            } else if (cur === ']') {\n                if (this._active._parent === null) {\n                    throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n                }\n                this.optionalEnd();\n\n            } else if (cur === '{' || cur === '}' || cur === '#') {\n                throw new IllegalArgumentException(`Pattern includes reserved character: '${cur}'`);\n            } else {\n                this.appendLiteral(cur);\n            }\n        }\n    }\n\n    _parseField(cur, count, field) {\n        switch (cur) {\n            case 'u':\n            case 'y':\n                if (count === 2) {\n                    this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n                } else if (count < 4) {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);\n                } else {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);\n                }\n                break;\n            case 'M':\n            case 'Q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                break;\n            case 'L':\n            case 'q':\n                switch (count) {\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                break;\n            case 'e':\n                switch (count) {\n                    case 1:\n                    case 2:\n                        this.appendWeekField('e', count);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'c':\n                switch (count) {\n                    case 1:\n                        this.appendWeekField('c', count);\n                        break;\n                    case 2:\n                        throw new IllegalArgumentException(`Invalid number of pattern letters: ${cur}`);\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'a':\n                if (count === 1) {\n                    this.appendText(field, TextStyle.SHORT);\n                } else {\n                    throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'E':\n            case 'G':\n                switch (count) {\n                    case 1:\n                    case 2:\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                // eslint-disable-next-line no-unreachable\n                break;\n            case 'S':\n                this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n                break;\n            case 'F':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                break;\n            case 'd':\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n            case 'm':\n            case 's':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count === 2) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                break;\n            case 'D':\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count <= 3) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException(`Too many pattern letters: ${cur}`);\n                }\n                break;\n            default:\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    this.appendValue(field, count);\n                }\n                break;\n        }\n    }\n\n    /**\n     * padNext function overloading\n     */\n    padNext() {\n        if (arguments.length === 1) {\n            return this._padNext1.apply(this, arguments);\n        } else {\n            return this._padNext2.apply(this, arguments);\n        }\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width using a space.\n     *\n     * This padding will pad to a fixed width using spaces.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext1(padWidth) {\n        return this._padNext2(padWidth, ' ');\n    }\n\n    /**\n     * Causes the next added printer/parser to pad to a fixed width.\n     *\n     * This padding is intended for padding other than zero-padding.\n     * Zero-padding should be achieved using the appendValue methods.\n     *\n     * During formatting, the decorated element will be output and then padded\n     * to the specified width. An exception will be thrown during printing if\n     * the pad width is exceeded.\n     *\n     * During parsing, the padding and decorated element are parsed.\n     * If parsing is lenient, then the pad width is treated as a maximum.\n     * If parsing is case insensitive, then the pad character is matched ignoring case.\n     * The padding is parsed greedily. Thus, if the decorated element starts with\n     * the pad character, it will not be parsed.\n     *\n     * @param {number} padWidth  the pad width, 1 or greater\n     * @param {String} padChar  the pad character\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalArgumentException if pad width is too small\n     */\n    _padNext2(padWidth, padChar) {\n        if (padWidth < 1) {\n            throw new IllegalArgumentException(`The pad width must be at least one but was ${padWidth}`);\n        }\n        this._active._padNextWidth = padWidth;\n        this._active._padNextChar = padChar;\n        this._active._valueParserIndex = -1;\n        return this;\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Mark the start of an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling this method and ended by calling\n     * {@link optionalEnd} or by ending the build process.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.\n     * The optional section ends automatically at the end of the builder.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    optionalStart() {\n        this._active._valueParserIndex = -1;\n        this._active = DateTimeFormatterBuilder._of(this._active, true);\n        return this;\n    }\n\n    /**\n     * Ends an optional section.\n     *\n     * The output of printing can include optional sections, which may be nested.\n     * An optional section is started by calling {@link optionalStart} and ended\n     * using this method (or at the end of the builder).\n     *\n     * Calling this method without having previously called `optionalStart`\n     * will throw an exception.\n     * Calling this method immediately after calling `optionalStart` has no effect\n     * on the formatter other than ending the (empty) optional section.\n     *\n     * All elements in the optional section are treated as optional.\n     * During printing, the section is only output if data is available in the\n     * {@link TemporalAccessor} for all the elements in the section.\n     * During parsing, the whole section may be missing from the parsed string.\n     *\n     * For example, consider a builder setup as\n     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.\n     * During printing, the minute will only be output if its value can be obtained from the date-time.\n     * During parsing, the input will be successfully parsed whether the minute is present or not.\n     *\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     * @throws IllegalStateException if there was no previous call to `optionalStart`\n     */\n    optionalEnd() {\n        if (this._active._parent == null) {\n            throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n        }\n        if (this._active._printerParsers.length > 0) {\n            const cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n            this._active = this._active._parent;\n            this._appendInternal(cpp);\n        } else {\n            this._active = this._active._parent;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternal(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    /**\n     * Appends a string literal to the formatter.\n     *\n     * This string will be output during a print.\n     *\n     * If the literal is empty, nothing is added to the formatter.\n     *\n     * @param literal  the literal to append, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    appendLiteral(literal) {\n        assert(literal != null);\n        if (literal.length > 0) {\n            if (literal.length === 1) {\n                this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n            } else {\n                this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a printer and/or parser to the internal list handling padding.\n     *\n     * @param pp  the printer-parser to add, not null\n     * @return the index into the active parsers list\n     */\n    _appendInternalPrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends all the elements of a formatter to the builder.\n     *\n     * This method has the same effect as appending each of the constituent\n     * parts of the formatter directly to this builder.\n     *\n     * @param {DateTimeFormatter} formatter  the formatter to add, not null\n     * @return {DateTimeFormatterBuilder} this, for chaining, not null\n     */\n    append(formatter) {\n        requireNonNull(formatter, 'formatter');\n        this._appendInternal(formatter._toPrinterParser(false));\n        return this;\n    }\n\n    /**\n     * Completes this builder by creating the DateTimeFormatter.\n     *\n     * This will create a formatter with the specified locale.\n     * Numbers will be printed and parsed using the standard non-localized set of symbols.\n     *\n     * Calling this method will end any open optional sections by repeatedly\n     * calling {@link optionalEnd} before creating the formatter.\n     *\n     * This builder can still be used after creating the formatter if desired,\n     * although the state may have been changed by calls to `optionalEnd`.\n     *\n     * @param resolverStyle  the new resolver style\n     * @return the created formatter, not null\n     */\n    toFormatter(resolverStyle=ResolverStyle.SMART) {\n        while (this._active._parent != null) {\n            this.optionalEnd();\n        }\n        const pp = new CompositePrinterParser(this._printerParsers, false);\n        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n    }\n\n}\n\n// days in a 400 year cycle = 146097\n// days in a 10,000 year cycle = 146097 * 25\n// seconds per day = 86400\nconst SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nconst SECONDS_0000_TO_1970 = ((146097 * 5) - (30 * 365 + 7)) * 86400;\n\n/**\n * Prints or parses an ISO-8601 instant.\n */\nclass InstantPrinterParser  {\n\n    constructor(fractionalDigits) {\n        this.fractionalDigits = fractionalDigits;\n    }\n\n    print(context, buf) {\n        // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX\n        const inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n        let inNanos = 0;\n        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n        }\n        if (inSecs == null) {\n            return false;\n        }\n        const inSec = inSecs;\n        let inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n        if (inSec >= -SECONDS_0000_TO_1970) {\n            // current era\n            const zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n            const hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n            const lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            const ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            if (hi > 0) {\n                buf.append('+').append(hi);\n            }\n            buf.append(ldt.toString());\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n        } else {\n            // before current era\n            const zeroSecs = inSec + SECONDS_0000_TO_1970;\n            const hi = MathUtil.intDiv(zeroSecs, SECONDS_PER_10000_YEARS);\n            const lo = MathUtil.intMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            const ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            const pos = buf.length();\n            buf.append(ldt.toString());\n            if (ldt.second() === 0) {\n                buf.append(':00');\n            }\n            if (hi < 0) {\n                if (ldt.year() === -10000) {\n                    buf.replace(pos, pos + 2, `${hi - 1}`);\n                } else if (lo === 0) {\n                    buf.insert(pos, hi);\n                } else {\n                    buf.insert(pos + 1, Math.abs(hi));\n                }\n            }\n        }\n        //fraction\n        if (this.fractionalDigits === -2) {\n            if (inNano !== 0) {\n                buf.append('.');\n                if (MathUtil.intMod(inNano, 1000000) === 0) {\n                    buf.append((`${MathUtil.intDiv(inNano, 1000000) + 1000}`).substring(1));\n                } else if (MathUtil.intMod(inNano, 1000) === 0) {\n                    buf.append((`${MathUtil.intDiv(inNano, 1000) + 1000000}`).substring(1));\n                } else {\n                    buf.append((`${(inNano) + 1000000000}`).substring(1));\n                }\n            }\n        } else if (this.fractionalDigits > 0 || (this.fractionalDigits === -1 && inNano > 0)) {\n            buf.append('.');\n            let div = 100000000;\n            for (let i = 0; ((this.fractionalDigits === -1 && inNano > 0) || i < this.fractionalDigits); i++) {\n                const digit = MathUtil.intDiv(inNano, div);\n                buf.append(digit);\n                inNano = inNano - (digit * div);\n                div = MathUtil.intDiv(div, 10);\n            }\n        }\n        buf.append('Z');\n        return true;\n    }\n\n    parse(context, text, position) {\n        // new context to avoid overwriting fields like year/month/day\n        const newContext = context.copy();\n        const minDigits = (this.fractionalDigits < 0 ? 0 : this.fractionalDigits);\n        const maxDigits = (this.fractionalDigits < 0 ? 9 : this.fractionalDigits);\n        const parser = new DateTimeFormatterBuilder()\n            .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n            .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':')\n            .appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z')\n            .toFormatter()._toPrinterParser(false);\n        const pos = parser.parse(newContext, text, position);\n        if (pos < 0) {\n            return pos;\n        }\n        // parser restricts most fields to 2 digits, so definitely int\n        // correctly parsed nano is also guaranteed to be valid\n        const yearParsed = newContext.getParsed(ChronoField.YEAR);\n        const month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n        const day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n        let hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n        const min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n        const secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n        const nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n        let sec = (secVal != null ? secVal : 0);\n        const nano = (nanoVal != null ? nanoVal : 0);\n        const year = MathUtil.intMod(yearParsed, 10000);\n        let days = 0;\n        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n            hour = 0;\n            days = 1;\n        } else if (hour === 23 && min === 59 && sec === 60) {\n            context.setParsedLeapSecond();\n            sec = 59;\n        }\n        let instantSecs;\n        try {\n            const ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n        } catch (ex) {\n            return ~position;\n        }\n        let successPos = pos;\n        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n    }\n\n    toString() {\n        return 'Instant()';\n    }\n}\n\n/**\n * Used by parseDefaulting().\n * @implements {DateTimePrinterParser}\n * @private\n */\nclass DefaultingParser {\n    /**\n     * @param {TemporalField} field \n     * @param {number} value \n     */\n    constructor(field, value) {\n        this._field = field;\n        this._value = value;\n    }\n\n    /**\n     * @param {DateTimePrintContext} context\n     * @param {StringBuilder} buf\n     * @return {boolean}\n     */\n    print() {\n        return true;\n    }\n\n\n    /** \n     * @param {DateTimeParseContext} context \n     * @param {string} text\n     * @param {number} position \n     * @returns {number}\n     */\n    parse(context, text, position) {\n        if (context.getParsed(this._field) == null) {\n            context.setParsedField(this._field, this._value, position, position);\n        }\n        return position;\n    }\n}\n\nexport function _init() {\n    ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n\n    DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n    DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n    DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n    DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n    DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n    DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n    DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n    DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DateTimeFormatterBuilder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1058,
    "kind": "variable",
    "name": "MAX_WIDTH",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~MAX_WIDTH",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1059,
    "kind": "class",
    "name": "DateTimeFormatterBuilder",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": "{DateTimeFormatterBuilder}",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 1060,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#constructor",
    "access": "public",
    "description": "Constructs a new instance of the builder.",
    "lineNumber": 42
  },
  {
    "__docId__": 1061,
    "kind": "member",
    "name": "_active",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_active",
    "access": "private",
    "description": "The currently active builder, used by the outermost builder.",
    "lineNumber": 46,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1062,
    "kind": "member",
    "name": "_parent",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_parent",
    "access": "private",
    "description": "The parent builder, null for the outermost builder.",
    "lineNumber": 50,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1063,
    "kind": "member",
    "name": "_printerParsers",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_printerParsers",
    "access": "private",
    "description": "The list of printers that will be used.",
    "lineNumber": 55,
    "ignore": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 1064,
    "kind": "member",
    "name": "_optional",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_optional",
    "access": "private",
    "description": "Whether this builder produces an optional formatter.",
    "lineNumber": 60,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1065,
    "kind": "member",
    "name": "_padNextWidth",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_padNextWidth",
    "access": "private",
    "description": "The width to pad the next field to.",
    "lineNumber": 64,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 1066,
    "kind": "member",
    "name": "_padNextChar",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_padNextChar",
    "access": "private",
    "description": "The character to pad the next field with.",
    "lineNumber": 69,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1067,
    "kind": "member",
    "name": "_valueParserIndex",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_valueParserIndex",
    "access": "private",
    "description": "The index of the last variable width value parser.",
    "lineNumber": 74,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1068,
    "kind": "method",
    "name": "_of",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder._of",
    "access": "private",
    "description": "Private static factory, replaces private threeten constructor\nReturns a new instance of the builder.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatterBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "parent",
        "description": "the parent builder, not null"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "optional",
        "description": "whether the formatter is optional, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "new instance"
    },
    "ignore": true
  },
  {
    "__docId__": 1069,
    "kind": "method",
    "name": "parseCaseSensitive",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#parseCaseSensitive",
    "access": "public",
    "description": "Changes the parse style to be case sensitive for the remainder of the formatter.\n\nParsing can be case sensitive or insensitive - by default it is case sensitive.\nThis method allows the case sensitivity setting of parsing to be changed.\n\nCalling this method changes the state of the builder such that all\nsubsequent builder method calls will parse text in case sensitive mode.\nSee {@link parseCaseInsensitive} for the opposite setting.\nThe parse case sensitive/insensitive methods may be called at any point\nin the builder, thus the parser can swap between case parsing modes\nmultiple times during the parse.\n\nSince the default is case sensitive, this method should only be used after\na previous call to {@link parseCaseInsensitive}.",
    "lineNumber": 114,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1070,
    "kind": "method",
    "name": "parseCaseInsensitive",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#parseCaseInsensitive",
    "access": "public",
    "description": "Changes the parse style to be case insensitive for the remainder of the formatter.\n\nParsing can be case sensitive or insensitive - by default it is case sensitive.\nThis method allows the case sensitivity setting of parsing to be changed.\n\nCalling this method changes the state of the builder such that all\nsubsequent builder method calls will parse text in case sensitive mode.\nSee {@link parseCaseSensitive} for the opposite setting.\nThe parse case sensitive/insensitive methods may be called at any point\nin the builder, thus the parser can swap between case parsing modes\nmultiple times during the parse.",
    "lineNumber": 134,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1071,
    "kind": "method",
    "name": "parseStrict",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#parseStrict",
    "access": "public",
    "description": "Changes the parse style to be strict for the remainder of the formatter.\n\nParsing can be strict or lenient - by default its strict.\nThis controls the degree of flexibility in matching the text and sign styles.\n\nWhen used, this method changes the parsing to be strict from this point onwards.\nAs strict is the default, this is normally only needed after calling {@link parseLenient}.\nThe change will remain in force until the end of the formatter that is eventually\nconstructed or until {@link parseLenient} is called.",
    "lineNumber": 153,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1072,
    "kind": "method",
    "name": "parseLenient",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#parseLenient",
    "access": "public",
    "description": "Changes the parse style to be lenient for the remainder of the formatter.\nNote that case sensitivity is set separately to this method.\n\nParsing can be strict or lenient - by default its strict.\nThis controls the degree of flexibility in matching the text and sign styles.\nApplications calling this method should typically also call {@link parseCaseInsensitive}.\n\nWhen used, this method changes the parsing to be strict from this point onwards.\nThe change will remain in force until the end of the formatter that is eventually\nconstructed or until {@link parseStrict} is called.",
    "lineNumber": 172,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1073,
    "kind": "method",
    "name": "parseDefaulting",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#parseDefaulting",
    "access": "public",
    "description": "Appends a default value for a field to the formatter for use in parsing.\n<p>\nThis appends an instruction to the builder to inject a default value\ninto the parsed result. This is especially useful in conjunction with\noptional parts of the formatter.\n<p>\nFor example, consider a formatter that parses the year, followed by\nan optional month, with a further optional day-of-month. Using such a\nformatter would require the calling code to check whether a full date,\nyear-month or just a year had been parsed. This method can be used to\ndefault the month and day-of-month to a sensible value, such as the\nfirst of the month, allowing the calling code to always get a date.\n<p>\nDuring formatting, this method has no effect.\n<p>\nDuring parsing, the current state of the parse is inspected.\nIf the specified field has no associated value, because it has not been\nparsed successfully at that point, then the specified value is injected\ninto the parse result. Injection is immediate, thus the field-value pair\nwill be visible to any subsequent elements in the formatter.\nAs such, this method is normally called at the end of the builder.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to default the value of, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to default the field to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    }
  },
  {
    "__docId__": 1074,
    "kind": "method",
    "name": "appendValue",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendValue",
    "access": "public",
    "description": "appendValue function overloading",
    "lineNumber": 213,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1075,
    "kind": "method",
    "name": "_appendValue1",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValue1",
    "access": "private",
    "description": "Appends the value of a date-time field to the formatter using a normal\noutput style.\n\nThe value of the field will be output during a print.\nIf the value cannot be obtained then an exception will be thrown.\n\nThe value will be printed as per the normal print of an integer value.\nOnly negative numbers will be signed. No padding will be added.\n\nThe parser for a variable width value such as this normally behaves greedily,\nrequiring one digit, but accepting as many digits as possible.\nThis behavior can be affected by 'adjacent value parsing'.\nSee {@link appendValue} for full details.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 1076,
    "kind": "method",
    "name": "_appendValue2",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValue2",
    "access": "private",
    "description": "Appends the value of a date-time field to the formatter using a fixed\nwidth, zero-padded approach.\n\nThe value of the field will be output during a print.\nIf the value cannot be obtained then an exception will be thrown.\n\nThe value will be zero-padded on the left. If the size of the value\nmeans that it cannot be printed within the width then an exception is thrown.\nIf the value of the field is negative then an exception is thrown during printing.\n\nThis method supports a special technique of parsing known as 'adjacent value parsing'.\nThis technique solves the problem where a variable length value is followed by one or more\nfixed length values. The standard parser is greedy, and thus it would normally\nsteal the digits that are needed by the fixed width value parsers that follow the\nvariable width one.\n\nNo action is required to initiate 'adjacent value parsing'.\nWhen a call to {@link appendValue} with a variable width is made, the builder\nenters adjacent value parsing setup mode. If the immediately subsequent method\ncall or calls on the same builder are to this method, then the parser will reserve\nspace so that the fixed width values can be parsed.\n\nFor example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2)`.\nThe year is a variable width parse of between 1 and 19 digits.\nThe month is a fixed width parse of 2 digits.\nBecause these were appended to the same builder immediately after one another,\nthe year parser will reserve two digits for the month to parse.\nThus, the text '201106' will correctly parse to a year of 2011 and a month of 6.\nWithout adjacent value parsing, the year would greedily parse all six digits and leave\nnothing for the month.\n\nAdjacent value parsing applies to each set of fixed width not-negative values in the parser\nthat immediately follow any kind of variable width value.\nCalling any other append method will end the setup of adjacent value parsing.\nThus, in the unlikely event that you need to avoid adjacent value parsing behavior,\nsimply add the `appendValue` to another {@link DateTimeFormatterBuilder}\nand add that to this builder.\n\nIf adjacent parsing is active, then parsing must match exactly the specified\nnumber of digits in both strict and lenient modes.\nIn addition, no positive or negative sign is permitted.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "the width of the printed field, from 1 to 19"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the width is invalid"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1077,
    "kind": "method",
    "name": "_appendValue4",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValue4",
    "access": "private",
    "description": "Appends the value of a date-time field to the formatter providing full\ncontrol over printing.\n\nThe value of the field will be output during a print.\nIf the value cannot be obtained then an exception will be thrown.\n\nThis method provides full control of the numeric formatting, including\nzero-padding and the positive/negative sign.\n\nThe parser for a variable width value such as this normally behaves greedily,\naccepting as many digits as possible.\nThis behavior can be affected by 'adjacent value parsing'.\nSee {@link appendValue} for full details.\n\nIn strict parsing mode, the minimum number of parsed digits is `minWidth`.\nIn lenient parsing mode, the minimum number of parsed digits is one.\n\nIf this method is invoked with equal minimum and maximum widths and a sign style of\n`NOT_NEGATIVE` then it delegates to `appendValue(TemporalField, int)`.\nIn this scenario, the printing and parsing behavior described there occur.",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "minWidth",
        "description": "the minimum field width of the printed field, from 1 to 19"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum field width of the printed field, from 1 to 19"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signStyle",
        "description": "the positive/negative output style, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the widths are invalid"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1078,
    "kind": "method",
    "name": "appendValueReduced",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendValueReduced",
    "access": "public",
    "description": "appendValueReduced function overloading",
    "lineNumber": 357,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1079,
    "kind": "method",
    "name": "_appendValueReducedFieldWidthMaxWidthBaseValue",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValueReducedFieldWidthMaxWidthBaseValue",
    "access": "private",
    "description": "Appends the reduced value of a date-time field to the formatter.\n\nSince fields such as year vary by chronology, it is recommended to use the\n{@link appendValueReduced} date}\nvariant of this method in most cases. This variant is suitable for\nsimple fields or working with only the ISO chronology.\n\nFor formatting, the `width` and `maxWidth` are used to\ndetermine the number of characters to format.\nIf they are equal then the format is fixed width.\nIf the value of the field is within the range of the `baseValue` using\n`width` characters then the reduced value is formatted otherwise the value is\ntruncated to fit `maxWidth`.\nThe rightmost characters are output to match the width, left padding with zero.\n\nFor strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\nFor lenient parsing, the number of characters must be at least 1 and less than 10.\nIf the number of digits parsed is equal to `width` and the value is positive,\nthe value of the field is computed to be the first number greater than\nor equal to the `baseValue` with the same least significant characters,\notherwise the value parsed is the field value.\nThis allows a reduced value to be entered for values in range of the baseValue\nand width and absolute values can be entered for values outside the range.\n\nFor example, a base value of `1980` and a width of `2` will have\nvalid values from `1980` to `2079`.\nDuring parsing, the text `\"12\"` will result in the value `2012` as that\nis the value within the range where the last two characters are \"12\".\nBy contrast, parsing the text `\"1915\"` will result in the value `1915`.",
    "lineNumber": 403,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "the field width of the printed and parsed field, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum field width of the printed field, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "baseValue",
        "description": "the base value of the range of valid values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the width or base value is invalid"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1080,
    "kind": "method",
    "name": "_appendValueReducedFieldWidthMaxWidthBaseDate",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValueReducedFieldWidthMaxWidthBaseDate",
    "access": "private",
    "description": "Appends the reduced value of a date-time field to the formatter.\n\nThis is typically used for formatting and parsing a two digit year.\n\nThe base date is used to calculate the full value during parsing.\nFor example, if the base date is 1950-01-01 then parsed values for\na two digit year parse will be in the range 1950-01-01 to 2049-12-31.\nOnly the year would be extracted from the date, thus a base date of\n1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.\nThis behavior is necessary to support fields such as week-based-year\nor other calendar systems where the parsed value does not align with\nstandard ISO years.\n\nThe exact behavior is as follows. Parse the full set of fields and\ndetermine the effective chronology using the last chronology if\nit appears more than once. Then convert the base date to the\neffective chronology. Then extract the specified field from the\nchronology-specific base date and use it to determine the\n`baseValue` used below.\n\nFor formatting, the `width` and `maxWidth` are used to\ndetermine the number of characters to format.\nIf they are equal then the format is fixed width.\nIf the value of the field is within the range of the `baseValue` using\n`width` characters then the reduced value is formatted otherwise the value is\ntruncated to fit `maxWidth`.\nThe rightmost characters are output to match the width, left padding with zero.\n\nFor strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.\nFor lenient parsing, the number of characters must be at least 1 and less than 10.\nIf the number of digits parsed is equal to `width` and the value is positive,\nthe value of the field is computed to be the first number greater than\nor equal to the `baseValue` with the same least significant characters,\notherwise the value parsed is the field value.\nThis allows a reduced value to be entered for values in range of the baseValue\nand width and absolute values can be entered for values outside the range.\n\nFor example, a base value of `1980` and a width of `2` will have\nvalid values from `1980` to `2079`.\nDuring parsing, the text `\"12\"` will result in the value `2012` as that\nis the value within the range where the last two characters are \"12\".\nBy contrast, parsing the text `\"1915\"` will result in the value `1915`.",
    "lineNumber": 462,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "the field width of the printed and parsed field, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum field width of the printed field, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "ChronoLocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "baseDate",
        "description": "the base date used to calculate the base value for the range\n of valid values in the parsed chronology, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the width or base value is invalid"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1081,
    "kind": "method",
    "name": "_appendValuePrinterParser",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendValuePrinterParser",
    "access": "private",
    "description": "Appends a fixed width printer-parser.",
    "lineNumber": 477,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "pp",
        "description": "the printer-parser, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 1082,
    "kind": "method",
    "name": "appendFraction",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendFraction",
    "access": "public",
    "description": "Appends the fractional value of a date-time field to the formatter.\n\nThe fractional value of the field will be output including the\npreceding decimal point. The preceding value is not output.\nFor example, the second-of-minute value of 15 would be output as `.25`.\n\nThe width of the printed fraction can be controlled. Setting the\nminimum width to zero will cause no output to be generated.\nThe printed fraction will have the minimum width necessary between\nthe minimum and maximum widths - trailing zeroes are omitted.\nNo rounding occurs due to the maximum width - digits are simply dropped.\n\nWhen parsing in strict mode, the number of parsed digits must be between\nthe minimum and maximum width. When parsing in lenient mode, the minimum\nwidth is considered to be zero and the maximum is nine.\n\nIf the value cannot be obtained then an exception will be thrown.\nIf the value is negative an exception will be thrown.\nIf the field does not have a fixed set of valid values then an\nexception will be thrown.\nIf the field value in the date-time to be printed is invalid it\ncannot be printed and an exception will be thrown.",
    "lineNumber": 540,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to append, not null"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minWidth",
        "description": "the minimum width of the field excluding the decimal point, from 0 to 9"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum width of the field excluding the decimal point, from 1 to 9"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "decimalPoint",
        "description": "whether to output the localized decimal point symbol"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the field has a variable set of valid values or\n either width is invalid"
      }
    ]
  },
  {
    "__docId__": 1083,
    "kind": "method",
    "name": "appendInstant",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendInstant",
    "access": "public",
    "description": "Appends an instant using ISO-8601 to the formatter with control over\nthe number of fractional digits.\n\nInstants have a fixed output format, although this method provides some\ncontrol over the fractional digits. They are converted to a date-time\nwith a zone-offset of UTC and printed using the standard ISO-8601 format.\nThe localized decimal style is not used.\n\nThe {@link this.fractionalDigits} parameter allows the output of the fractional\nsecond to be controlled. Specifying zero will cause no fractional digits\nto be output. From 1 to 9 will output an increasing number of digits, using\nzero right-padding if necessary. The special value -1 is used to output as\nmany digits as necessary to avoid any trailing zeroes.\n\nWhen parsing in strict mode, the number of parsed digits must match the\nfractional digits. When parsing in lenient mode, any number of fractional\ndigits from zero to nine are accepted.\n\nThe instant is obtained using {@link ChronoField#INSTANT_SECONDS}\nand optionally (@code NANO_OF_SECOND). The value of {@link INSTANT_SECONDS}\nmay be outside the maximum range of {@link LocalDateTime}.\n\nThe {@link ResolverStyle} has no effect on instant parsing.\nThe end-of-day time of '24:00' is handled as midnight at the start of the following day.\nThe leap-second time of '23:59:59' is handled to some degree, see\n{@link DateTimeFormatter#parsedLeapSecond} for full details.\n\nAn alternative to this method is to format/parse the instant as a single\nepoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.",
    "lineNumber": 580,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "-2",
        "defaultRaw": -2,
        "name": "fractionalDigits",
        "description": "the number of fractional second digits to format with,\n from 0 to 9, or -1 to use as many digits as necessary"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    }
  },
  {
    "__docId__": 1084,
    "kind": "method",
    "name": "appendOffsetId",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendOffsetId",
    "access": "public",
    "description": "Appends the zone offset, such as '+01:00', to the formatter.\n\nThis appends an instruction to print/parse the offset ID to the builder.\nThis is equivalent to calling `appendOffset(\"HH:MM:ss\", \"Z\")`.",
    "lineNumber": 597,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1085,
    "kind": "method",
    "name": "appendOffset",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendOffset",
    "access": "public",
    "description": "Appends the zone offset, such as '+01:00', to the formatter.\n\nThis appends an instruction to print/parse the offset ID to the builder.\n\nDuring printing, the offset is obtained using a mechanism equivalent\nto querying the temporal with {@link TemporalQueries#offset}.\nIt will be printed using the format defined below.\nIf the offset cannot be obtained then an exception is thrown unless the\nsection of the formatter is optional.\n\nDuring parsing, the offset is parsed using the format defined below.\nIf the offset cannot be parsed then an exception is thrown unless the\nsection of the formatter is optional.\n\nThe format of the offset is controlled by a pattern which must be one\nof the following:\n\n* `+HH` - hour only, ignoring minute and second\n* `+HHmm` - hour, with minute if non-zero, ignoring second, no colon\n* `+HH:mm` - hour, with minute if non-zero, ignoring second, with colon\n* `+HHMM` - hour and minute, ignoring second, no colon\n* `+HH:MM` - hour and minute, ignoring second, with colon\n* `+HHMMss` - hour and minute, with second if non-zero, no colon\n* `+HH:MM:ss` - hour and minute, with second if non-zero, with colon\n* `+HHMMSS` - hour, minute and second, no colon\n* `+HH:MM:SS` - hour, minute and second, with colon\n\nThe \"no offset\" text controls what text is printed when the total amount of\nthe offset fields to be output is zero.\nExample values would be 'Z', '+00:00', 'UTC' or 'GMT'.\nThree formats are accepted for parsing UTC - the \"no offset\" text, and the\nplus and minus versions of zero defined by the pattern.",
    "lineNumber": 640,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to use, not null"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "noOffsetText",
        "description": "the text to use when the offset is zero, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    }
  },
  {
    "__docId__": 1086,
    "kind": "method",
    "name": "appendZoneId",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendZoneId",
    "access": "public",
    "description": "Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.\n\nThis appends an instruction to print/parse the zone ID to the builder.\nThe zone ID is obtained in a strict manner suitable for {@link ZonedDateTime}.\nBy contrast, {@link OffsetDateTime} does not have a zone ID suitable\nfor use with this method, see {@link appendZoneOrOffsetId}.\n\nDuring printing, the zone is obtained using a mechanism equivalent\nto querying the temporal with {@link TemporalQueries#zoneId}.\nIt will be printed using the result of {@link ZoneId#getId}.\nIf the zone cannot be obtained then an exception is thrown unless the\nsection of the formatter is optional.\n\nDuring parsing, the zone is parsed and must match a known zone or offset.\nIf the zone cannot be parsed then an exception is thrown unless the\nsection of the formatter is optional.",
    "see": [
      "#appendZoneRegionId()"
    ],
    "lineNumber": 666,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1087,
    "kind": "method",
    "name": "appendPattern",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendPattern",
    "access": "public",
    "description": "Appends the elements defined by the specified pattern to the builder.\n\nAll letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.\nThe characters '{' and '}' are reserved for future use.\nThe characters '[' and ']' indicate optional patterns.\nThe following pattern letters are defined:\n<pre>\n |Symbol  |Meaning                     |Presentation      |Examples\n |--------|----------------------------|------------------|----------------------------------------------------\n | G      | era                        | number/text      | 1; 01; AD; Anno Domini\n | u      | year                       | year             | 2004; 04\n | y      | year-of-era                | year             | 2004; 04\n | D      | day-of-year                | number           | 189\n | M      | month-of-year              | number/text      | 7; 07; Jul; July; J\n | d      | day-of-month               | number           | 10\n |        |                            |                  |\n | Q      | quarter-of-year            | number/text      | 3; 03; Q3\n | Y      | week-based-year            | year             | 1996; 96\n | w      | week-of-year               | number           | 27\n | W      | week-of-month              | number           | 27\n | e      | localized day-of-week      | number           | 2; Tue; Tuesday; T\n | E      | day-of-week                | number/text      | 2; Tue; Tuesday; T\n | F      | week-of-month              | number           | 3\n |        |                            |                  |\n | a      | am-pm-of-day               | text             | PM\n | h      | clock-hour-of-am-pm (1-12) | number           | 12\n | K      | hour-of-am-pm (0-11)       | number           | 0\n | k      | clock-hour-of-am-pm (1-24) | number           | 0\n |        |                            |                  |\n | H      | hour-of-day (0-23)         | number           | 0\n | m      | minute-of-hour             | number           | 30\n | s      | second-of-minute           | number           | 55\n | S      | fraction-of-second         | fraction         | 978\n | A      | milli-of-day               | number           | 1234\n | n      | nano-of-second             | number           | 987654321\n | N      | nano-of-day                | number           | 1234000000\n |        |                            |                  |\n | V      | time-zone ID               | zone-id          | America/Los_Angeles; Z; -08:30\n | z      | time-zone name             | zone-name        | Pacific Standard Time; PST\n | X      | zone-offset 'Z' for zero   | offset-X         | Z; -08; -0830; -08:30; -083015; -08:30:15;\n | x      | zone-offset                | offset-x         | +0000; -08; -0830; -08:30; -083015; -08:30:15;\n | Z      | zone-offset                | offset-Z         | +0000; -0800; -08:00;\n |        |                            |                  |\n | p      | pad next                   | pad modifier     | 1\n |        |                            |                  |\n | '      | escape for text            | delimiter        |\n | ''     | single quote               | literal          | '\n | [      | optional section start     |                  |\n | ]      | optional section end       |                  |\n | {}     | reserved for future use    |                  |\n</pre>\n\nThe count of pattern letters determine the format.\n\n**Text**: The text style is determined based on the number of pattern letters used.\nLess than 4 pattern letters will use the short form (see {@link TextStyle#SHORT}).\nExactly 4 pattern letters will use the full form (see {@link TextStyle#FULL}).\nExactly 5 pattern letters will use the narrow form (see {@link TextStyle#NARROW}).\n\n**Number**: If the count of letters is one, then the value is printed using the minimum number\nof digits and without padding as per {@link appendValue}. Otherwise, the\ncount of digits is used as the width of the output field as per {@link appendValue}.\n\n**Number/Text**: If the count of pattern letters is 3 or greater, use the Text rules above.\nOtherwise use the Number rules above.\n\n**Fraction**: Outputs the nano-of-second field as a fraction-of-second.\nThe nano-of-second value has nine digits, thus the count of pattern letters is from 1 to 9.\nIf it is less than 9, then the nano-of-second value is truncated, with only the most\nsignificant digits being output.\nWhen parsing in strict mode, the number of parsed digits must match the count of pattern letters.\nWhen parsing in lenient mode, the number of parsed digits must be at least the count of pattern\nletters, up to 9 digits.\n\n**Year**: The count of letters determines the minimum field width below which padding is used.\nIf the count of letters is two, then a reduced (see {@link appendValueReduced}) two digit form is used.\nFor printing, this outputs the rightmost two digits. For parsing, this will parse using the\nbase value of 2000, resulting in a year within the range 2000 to 2099 inclusive.\nIf the count of letters is less than four (but not two), then the sign is only output for negative\nyears as per {@link SignStyle#NORMAL}.\nOtherwise, the sign is output if the pad width is exceeded, as per {@link SignStyle#EXCEEDS_PAD}\n\n**ZoneId**: This outputs the time-zone ID, such as 'Europe/Paris'.\nIf the count of letters is two, then the time-zone ID is output.\nAny other count of letters throws {@link IllegalArgumentException}.\n<pre>\n Pattern     Equivalent builder methods\n  VV          appendZoneId()\n</pre>\n\n**Zone names**: This outputs the display name of the time-zone ID.\nIf the count of letters is one, two or three, then the short name is output.\nIf the count of letters is four, then the full name is output.\nFive or more letters throws {@link IllegalArgumentException}.\n<pre>\n Pattern     Equivalent builder methods\n  z           appendZoneText(TextStyle.SHORT)\n  zz          appendZoneText(TextStyle.SHORT)\n  zzz         appendZoneText(TextStyle.SHORT)\n  zzzz        appendZoneText(TextStyle.FULL)\n</pre>\n\n**Offset X and x**: This formats the offset based on the number of pattern letters.\nOne letter outputs just the hour', such as '+01', unless the minute is non-zero\nin which case the minute is also output, such as '+0130'.\nTwo letters outputs the hour and minute, without a colon, such as '+0130'.\nThree letters outputs the hour and minute, with a colon, such as '+01:30'.\nFour letters outputs the hour and minute and optional second, without a colon, such as '+013015'.\nFive letters outputs the hour and minute and optional second, with a colon, such as '+01:30:15'.\nSix or more letters throws {@link IllegalArgumentException}.\nPattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero,\nwhereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'.\n<pre>\n Pattern     Equivalent builder methods\n  X           appendOffset(\"+HHmm\",\"Z\")\n  XX          appendOffset(\"+HHMM\",\"Z\")\n  XXX         appendOffset(\"+HH:MM\",\"Z\")\n  XXXX        appendOffset(\"+HHMMss\",\"Z\")\n  XXXXX       appendOffset(\"+HH:MM:ss\",\"Z\")\n  x           appendOffset(\"+HHmm\",\"+00\")\n  xx          appendOffset(\"+HHMM\",\"+0000\")\n  xxx         appendOffset(\"+HH:MM\",\"+00:00\")\n  xxxx        appendOffset(\"+HHMMss\",\"+0000\")\n  xxxxx       appendOffset(\"+HH:MM:ss\",\"+00:00\")\n</pre>\n\n**Offset Z**: This formats the offset based on the number of pattern letters.\nOne, two or three letters outputs the hour and minute, without a colon, such as '+0130'.\nFour or more letters throws {@link IllegalArgumentException}.\nThe output will be '+0000' when the offset is zero.\n<pre>\n Pattern     Equivalent builder methods\n  Z           appendOffset(\"+HHMM\",\"+0000\")\n  ZZ          appendOffset(\"+HHMM\",\"+0000\")\n  ZZZ         appendOffset(\"+HHMM\",\"+0000\")\n</pre>\n\n**Optional section**: The optional section markers work exactly like calling {@link optionalStart}\nand {@link optionalEnd}.\n\n**Pad modifier**: Modifies the pattern that immediately follows to be padded with spaces.\nThe pad width is determined by the number of pattern letters.\nThis is the same as calling {@link padNext}.\n\nFor example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2.\n\nAny unrecognized letter is an error.\nAny non-letter character, other than '[', ']', '{', '}' and the single quote will be output directly.\nDespite this, it is recommended to use single quotes around all characters that you want to\noutput directly to ensure that future changes do not break your application.\n\nNote that the pattern string is similar, but not identical, to\n{@link java.text.SimpleDateFormat}.\nThe pattern string is also similar, but not identical, to that defined by the\nUnicode Common Locale Data Repository (CLDR/LDML).\nPattern letters 'E' and 'u' are merged, which changes the meaning of \"E\" and \"EE\" to be numeric.\nPattern letters 'X' is aligned with Unicode CLDR/LDML, which affects pattern 'X'.\nPattern letter 'y' and 'Y' parse years of two digits and more than 4 digits differently.\nPattern letters 'n', 'A', 'N', 'I' and 'p' are added.\nNumber types will reject large numbers.",
    "lineNumber": 838,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the pattern is invalid"
      }
    ]
  },
  {
    "__docId__": 1088,
    "kind": "method",
    "name": "appendZoneText",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendZoneText",
    "access": "public",
    "description": null,
    "lineNumber": 848,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1089,
    "kind": "method",
    "name": "appendText",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendText",
    "access": "public",
    "description": null,
    "lineNumber": 852,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1090,
    "kind": "method",
    "name": "appendLocalizedOffset",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendLocalizedOffset",
    "access": "public",
    "description": null,
    "lineNumber": 856,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1091,
    "kind": "method",
    "name": "appendWeekField",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendWeekField",
    "access": "public",
    "description": null,
    "lineNumber": 860,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1092,
    "kind": "method",
    "name": "_parsePattern",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_parsePattern",
    "access": "private",
    "description": null,
    "lineNumber": 866,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "pattern",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1093,
    "kind": "method",
    "name": "_parseField",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_parseField",
    "access": "private",
    "description": null,
    "lineNumber": 1021,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "cur",
        "types": [
          "*"
        ]
      },
      {
        "name": "count",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1094,
    "kind": "method",
    "name": "padNext",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#padNext",
    "access": "public",
    "description": "padNext function overloading",
    "lineNumber": 1192,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1095,
    "kind": "method",
    "name": "_padNext1",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_padNext1",
    "access": "private",
    "description": "Causes the next added printer/parser to pad to a fixed width using a space.\n\nThis padding will pad to a fixed width using spaces.\n\nDuring formatting, the decorated element will be output and then padded\nto the specified width. An exception will be thrown during printing if\nthe pad width is exceeded.\n\nDuring parsing, the padding and decorated element are parsed.\nIf parsing is lenient, then the pad width is treated as a maximum.\nIf parsing is case insensitive, then the pad character is matched ignoring case.\nThe padding is parsed greedily. Thus, if the decorated element starts with\nthe pad character, it will not be parsed.",
    "lineNumber": 1219,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "padWidth",
        "description": "the pad width, 1 or greater"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if pad width is too small"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1096,
    "kind": "method",
    "name": "_padNext2",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_padNext2",
    "access": "private",
    "description": "Causes the next added printer/parser to pad to a fixed width.\n\nThis padding is intended for padding other than zero-padding.\nZero-padding should be achieved using the appendValue methods.\n\nDuring formatting, the decorated element will be output and then padded\nto the specified width. An exception will be thrown during printing if\nthe pad width is exceeded.\n\nDuring parsing, the padding and decorated element are parsed.\nIf parsing is lenient, then the pad width is treated as a maximum.\nIf parsing is case insensitive, then the pad character is matched ignoring case.\nThe padding is parsed greedily. Thus, if the decorated element starts with\nthe pad character, it will not be parsed.",
    "lineNumber": 1244,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "padWidth",
        "description": "the pad width, 1 or greater"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "padChar",
        "description": "the pad character"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if pad width is too small"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1097,
    "kind": "method",
    "name": "optionalStart",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#optionalStart",
    "access": "public",
    "description": "Mark the start of an optional section.\n\nThe output of printing can include optional sections, which may be nested.\nAn optional section is started by calling this method and ended by calling\n{@link optionalEnd} or by ending the build process.\n\nAll elements in the optional section are treated as optional.\nDuring printing, the section is only output if data is available in the\n{@link TemporalAccessor} for all the elements in the section.\nDuring parsing, the whole section may be missing from the parsed string.\n\nFor example, consider a builder setup as\n`builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.\nThe optional section ends automatically at the end of the builder.\nDuring printing, the minute will only be output if its value can be obtained from the date-time.\nDuring parsing, the input will be successfully parsed whether the minute is present or not.",
    "lineNumber": 1276,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "params": []
  },
  {
    "__docId__": 1099,
    "kind": "method",
    "name": "optionalEnd",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#optionalEnd",
    "access": "public",
    "description": "Ends an optional section.\n\nThe output of printing can include optional sections, which may be nested.\nAn optional section is started by calling {@link optionalStart} and ended\nusing this method (or at the end of the builder).\n\nCalling this method without having previously called `optionalStart`\nwill throw an exception.\nCalling this method immediately after calling `optionalStart` has no effect\non the formatter other than ending the (empty) optional section.\n\nAll elements in the optional section are treated as optional.\nDuring printing, the section is only output if data is available in the\n{@link TemporalAccessor} for all the elements in the section.\nDuring parsing, the whole section may be missing from the parsed string.\n\nFor example, consider a builder setup as\n`builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.\nDuring printing, the minute will only be output if its value can be obtained from the date-time.\nDuring parsing, the input will be successfully parsed whether the minute is present or not.",
    "lineNumber": 1307,
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalStateException if there was no previous call to `optionalStart`"
      }
    ],
    "params": []
  },
  {
    "__docId__": 1102,
    "kind": "method",
    "name": "_appendInternal",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendInternal",
    "access": "private",
    "description": "Appends a printer and/or parser to the internal list handling padding.",
    "lineNumber": 1327,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "pp",
        "description": "the printer-parser to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the index into the active parsers list"
    },
    "ignore": true
  },
  {
    "__docId__": 1103,
    "kind": "method",
    "name": "appendLiteral",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#appendLiteral",
    "access": "public",
    "description": "Appends a string literal to the formatter.\n\nThis string will be output during a print.\n\nIf the literal is empty, nothing is added to the formatter.",
    "lineNumber": 1351,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "literal",
        "description": "the literal to append, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    }
  },
  {
    "__docId__": 1104,
    "kind": "method",
    "name": "_appendInternalPrinterParser",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#_appendInternalPrinterParser",
    "access": "private",
    "description": "Appends a printer and/or parser to the internal list handling padding.",
    "lineNumber": 1369,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "pp",
        "description": "the printer-parser to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the index into the active parsers list"
    },
    "ignore": true
  },
  {
    "__docId__": 1105,
    "kind": "method",
    "name": "append",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#append",
    "access": "public",
    "description": "Appends all the elements of a formatter to the builder.\n\nThis method has the same effect as appending each of the constituent\nparts of the formatter directly to this builder.",
    "lineNumber": 1393,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DateTimeFormatterBuilder"
      ],
      "spread": false,
      "description": "this, for chaining, not null"
    }
  },
  {
    "__docId__": 1106,
    "kind": "method",
    "name": "toFormatter",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DateTimeFormatterBuilder#toFormatter",
    "access": "public",
    "description": "Completes this builder by creating the DateTimeFormatter.\n\nThis will create a formatter with the specified locale.\nNumbers will be printed and parsed using the standard non-localized set of symbols.\n\nCalling this method will end any open optional sections by repeatedly\ncalling {@link optionalEnd} before creating the formatter.\n\nThis builder can still be used after creating the formatter if desired,\nalthough the state may have been changed by calls to `optionalEnd`.",
    "lineNumber": 1414,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": "the new resolver style"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the created formatter, not null"
    }
  },
  {
    "__docId__": 1107,
    "kind": "variable",
    "name": "SECONDS_PER_10000_YEARS",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~SECONDS_PER_10000_YEARS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1427,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1108,
    "kind": "variable",
    "name": "SECONDS_0000_TO_1970",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~SECONDS_0000_TO_1970",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1428,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1109,
    "kind": "class",
    "name": "InstantPrinterParser",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": null,
    "description": "Prints or parses an ISO-8601 instant.",
    "lineNumber": 1433,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1110,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 1435,
    "undocument": true
  },
  {
    "__docId__": 1111,
    "kind": "member",
    "name": "fractionalDigits",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser#fractionalDigits",
    "access": "public",
    "description": null,
    "lineNumber": 1436,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1112,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 1439,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1113,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 1511,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1114,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~InstantPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 1558,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1115,
    "kind": "class",
    "name": "DefaultingParser",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": null,
    "description": "Used by parseDefaulting().",
    "lineNumber": 1568,
    "interface": false,
    "implements": [
      "DateTimePrinterParser"
    ],
    "ignore": true
  },
  {
    "__docId__": 1116,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 1573,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 1117,
    "kind": "member",
    "name": "_field",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser#_field",
    "access": "private",
    "description": null,
    "lineNumber": 1574,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1118,
    "kind": "member",
    "name": "_value",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser#_value",
    "access": "private",
    "description": null,
    "lineNumber": 1575,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1119,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser#print",
    "access": "public",
    "description": "",
    "lineNumber": 1583,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimePrintContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "StringBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1120,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~DefaultingParser#parse",
    "access": "public",
    "description": "",
    "lineNumber": 1594,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1121,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/format/DateTimeFormatterBuilder.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimeFormatterBuilder.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeFormatterBuilder.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1602,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1122,
    "kind": "file",
    "name": "packages/core/src/format/DateTimeParseContext.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, requireNonNull } from '../assert';\n\nimport { DateTimeBuilder } from './DateTimeBuilder';\nimport { EnumMap } from './EnumMap';\n\nimport { IsoChronology } from '../chrono/IsoChronology';\nimport { Temporal } from '../temporal/Temporal';\nimport { TemporalQueries } from '../temporal/TemporalQueries';\n\n/**\n * @private\n */\nexport class DateTimeParseContext{\n\n    constructor(){\n        if(arguments.length === 1){\n            if(arguments[0] instanceof DateTimeParseContext){\n                this._constructorSelf.apply(this, arguments);\n                return;\n            } else {\n                this._constructorFormatter.apply(this, arguments);\n            }\n        } else {\n            this._constructorParam.apply(this, arguments);\n        }\n\n        this._caseSensitive = true;\n        this._strict = true;\n        this._parsed = [new Parsed(this)];\n    }\n\n    _constructorParam(locale, symbols, chronology){\n        this._locale = locale;\n        this._symbols = symbols;\n        this._overrideChronology = chronology;\n    }\n\n    _constructorFormatter(formatter){\n        this._locale = formatter.locale();\n        this._symbols = formatter.decimalStyle();\n        this._overrideChronology = formatter.chronology();\n    }\n\n\n    _constructorSelf(other) {\n        this._locale = other._locale;\n        this._symbols = other._symbols;\n        this._overrideChronology = other._overrideChronology;\n        this._overrideZone = other._overrideZone;\n        this._caseSensitive = other._caseSensitive;\n        this._strict = other._strict;\n        this._parsed = [new Parsed(this)];\n    }\n\n    /**\n     * Creates a copy of this context.\n     */\n    copy() {\n        return new DateTimeParseContext(this);\n    }\n\n    symbols(){\n        return this._symbols;\n    }\n\n    isStrict(){\n        return this._strict;\n    }\n\n    setStrict(strict){\n        this._strict = strict;\n    }\n\n    locale() {\n        return this._locale;\n    }\n\n    setLocale(locale) {\n        this._locale = locale;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Starts the parsing of an optional segment of the input.\n     */\n    startOptional() {\n        this._parsed.push(this.currentParsed().copy());\n    }\n\n    /**\n     * Ends the parsing of an optional segment of the input.\n     *\n     * @param {boolean} successful  whether the optional segment was successfully parsed\n     */\n    endOptional(successful) {\n        if (successful) {\n            this._parsed.splice(this._parsed.length - 2, 1);\n        } else {\n            this._parsed.splice(this._parsed.length - 1, 1);\n        }\n    }\n\n    /**\n     * Checks if parsing is case sensitive.\n     *\n     * @return true if parsing is case sensitive, false if case insensitive\n     */\n    isCaseSensitive() {\n        return this._caseSensitive;\n    }\n\n    /**\n     * Sets whether the parsing is case sensitive or not.\n     *\n     * @param caseSensitive  changes the parsing to be case sensitive or not from now on\n     */\n    setCaseSensitive(caseSensitive) {\n        this._caseSensitive = caseSensitive;\n    }\n\n    /**\n     * Helper to compare two {@link CharSequence} instances.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param cs1  the first character sequence, not null\n     * @param offset1  the offset into the first sequence, valid\n     * @param cs2  the second character sequence, not null\n     * @param offset2  the offset into the second sequence, valid\n     * @param length  the length to check, valid\n     * @return true if equal\n     */\n    subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n            return false;\n        }\n        if (! this.isCaseSensitive()) {\n            cs1 = cs1.toLowerCase();\n            cs2 = cs2.toLowerCase();\n        }\n        for (let i = 0; i < length; i++) {\n            const ch1 = cs1[offset1 + i];\n            const ch2 = cs2[offset2 + i];\n            if (ch1 !== ch2) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Helper to compare two `char`.\n     * This uses {@link isCaseSensitive}.\n     *\n     * @param ch1  the first character\n     * @param ch2  the second character\n     * @return true if equal\n     */\n    charEquals(ch1, ch2) {\n        if (this.isCaseSensitive()) {\n            return ch1 === ch2;\n        }\n        return this.charEqualsIgnoreCase(ch1, ch2);\n    }\n\n    /**\n     * Compares two characters ignoring case.\n     *\n     * @param c1  the first\n     * @param c2  the second\n     * @return true if equal\n     */\n    charEqualsIgnoreCase(c1, c2) {\n        return c1 === c2 ||\n                c1.toLowerCase() === c2.toLowerCase();\n    }\n\n    setParsedField(field, value, errorPos, successPos){\n        const currentParsedFieldValues = this.currentParsed().fieldValues;\n        const old = currentParsedFieldValues.get(field);\n        currentParsedFieldValues.set(field, value);\n        return (old != null && old !== value) ? ~errorPos : successPos;\n    }\n\n    /**\n     * Stores the parsed zone.\n     *\n     * This stores the zone that has been parsed.\n     * No validation is performed other than ensuring it is not null.\n     *\n     * @param {ZoneId} zone  the parsed zone, not null\n     */\n    setParsedZone(zone) {\n        requireNonNull(zone, 'zone');\n        this.currentParsed().zone = zone;\n    }\n\n    getParsed(field) {\n        return this.currentParsed().fieldValues.get(field);\n    }\n\n    toParsed() {\n        return this.currentParsed();\n    }\n\n    currentParsed() {\n        return this._parsed[this._parsed.length - 1];\n    }\n\n    /**\n     * Stores the leap second.\n     */\n    setParsedLeapSecond() {\n        this.currentParsed().leapSecond = true;\n    }\n\n    /**\n     * Gets the effective chronology during parsing.\n     *\n     * @return the effective parsing chronology, not null\n     */\n    getEffectiveChronology() {\n        let chrono = this.currentParsed().chrono;\n        if (chrono == null) {\n            chrono = this._overrideChronology;\n            if (chrono == null) {\n                chrono = IsoChronology.INSTANCE;\n            }\n        }\n        return chrono;\n    }\n\n\n}\n\nclass Parsed extends Temporal {\n    constructor(dateTimeParseContext){\n        super();\n        this.chrono = null;\n        this.zone = null;\n        this.fieldValues = new EnumMap();\n        this.leapSecond = false;\n        this.dateTimeParseContext = dateTimeParseContext;\n    }\n\n    copy() {\n        const cloned = new Parsed();\n        cloned.chrono = this.chrono;\n        cloned.zone = this.zone;\n        cloned.fieldValues.putAll(this.fieldValues);\n        cloned.leapSecond = this.leapSecond;\n        cloned.dateTimeParseContext = this.dateTimeParseContext;\n        return cloned;\n    }\n\n    toString() {\n        return `${this.fieldValues}, ${this.chrono}, ${this.zone}`;\n    }\n\n    isSupported(field) {\n        return this.fieldValues.containsKey(field);\n    }\n\n    get(field) {\n        const val = this.fieldValues.get(field);\n        assert(val != null);\n        return val;\n    }\n\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return this.chrono;\n        }\n        if (query === TemporalQueries.zoneId() || query === TemporalQueries.zone()) {\n            return this.zone;\n        }\n        return super.query(query);\n    }\n\n    toBuilder() {\n        const builder = new DateTimeBuilder();\n        builder.fieldValues.putAll(this.fieldValues);\n        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n        if (this.zone != null) {\n            builder.zone = this.zone;\n        } else {\n            builder.zone = this.overrideZone;\n        }\n        builder.leapSecond = this.leapSecond;\n        builder.excessDays = this.excessDays;\n        return builder;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DateTimeParseContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1123,
    "kind": "class",
    "name": "DateTimeParseContext",
    "memberof": "packages/core/src/format/DateTimeParseContext.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeParseContext.js",
    "importStyle": "{DateTimeParseContext}",
    "description": "",
    "lineNumber": 19,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1124,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true
  },
  {
    "__docId__": 1125,
    "kind": "member",
    "name": "_caseSensitive",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_caseSensitive",
    "access": "private",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1126,
    "kind": "member",
    "name": "_strict",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_strict",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1127,
    "kind": "member",
    "name": "_parsed",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_parsed",
    "access": "private",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1128,
    "kind": "method",
    "name": "_constructorParam",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_constructorParam",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      },
      {
        "name": "symbols",
        "types": [
          "*"
        ]
      },
      {
        "name": "chronology",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1129,
    "kind": "member",
    "name": "_locale",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_locale",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1130,
    "kind": "member",
    "name": "_symbols",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_symbols",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1131,
    "kind": "member",
    "name": "_overrideChronology",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_overrideChronology",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1132,
    "kind": "method",
    "name": "_constructorFormatter",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_constructorFormatter",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "formatter",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1136,
    "kind": "method",
    "name": "_constructorSelf",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_constructorSelf",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1140,
    "kind": "member",
    "name": "_overrideZone",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#_overrideZone",
    "access": "private",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1144,
    "kind": "method",
    "name": "copy",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#copy",
    "access": "public",
    "description": "Creates a copy of this context.",
    "lineNumber": 64,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1145,
    "kind": "method",
    "name": "symbols",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#symbols",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1146,
    "kind": "method",
    "name": "isStrict",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#isStrict",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1147,
    "kind": "method",
    "name": "setStrict",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setStrict",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "strict",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1149,
    "kind": "method",
    "name": "locale",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#locale",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1150,
    "kind": "method",
    "name": "setLocale",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setLocale",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1152,
    "kind": "method",
    "name": "startOptional",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#startOptional",
    "access": "public",
    "description": "Starts the parsing of an optional segment of the input.",
    "lineNumber": 91,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1153,
    "kind": "method",
    "name": "endOptional",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#endOptional",
    "access": "public",
    "description": "Ends the parsing of an optional segment of the input.",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "successful",
        "description": "whether the optional segment was successfully parsed"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1154,
    "kind": "method",
    "name": "isCaseSensitive",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#isCaseSensitive",
    "access": "public",
    "description": "Checks if parsing is case sensitive.",
    "lineNumber": 113,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if parsing is case sensitive, false if case insensitive"
    },
    "params": []
  },
  {
    "__docId__": 1155,
    "kind": "method",
    "name": "setCaseSensitive",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setCaseSensitive",
    "access": "public",
    "description": "Sets whether the parsing is case sensitive or not.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "caseSensitive",
        "description": "changes the parsing to be case sensitive or not from now on"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1157,
    "kind": "method",
    "name": "subSequenceEquals",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#subSequenceEquals",
    "access": "public",
    "description": "Helper to compare two {@link CharSequence} instances.\nThis uses {@link isCaseSensitive}.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cs1",
        "description": "the first character sequence, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "offset1",
        "description": "the offset into the first sequence, valid"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cs2",
        "description": "the second character sequence, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "offset2",
        "description": "the offset into the second sequence, valid"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "the length to check, valid"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if equal"
    }
  },
  {
    "__docId__": 1158,
    "kind": "method",
    "name": "charEquals",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#charEquals",
    "access": "public",
    "description": "Helper to compare two `char`.\nThis uses {@link isCaseSensitive}.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ch1",
        "description": "the first character"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ch2",
        "description": "the second character"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if equal"
    }
  },
  {
    "__docId__": 1159,
    "kind": "method",
    "name": "charEqualsIgnoreCase",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#charEqualsIgnoreCase",
    "access": "public",
    "description": "Compares two characters ignoring case.",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c1",
        "description": "the first"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c2",
        "description": "the second"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if equal"
    }
  },
  {
    "__docId__": 1160,
    "kind": "method",
    "name": "setParsedField",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setParsedField",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "errorPos",
        "types": [
          "*"
        ]
      },
      {
        "name": "successPos",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1161,
    "kind": "method",
    "name": "setParsedZone",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setParsedZone",
    "access": "public",
    "description": "Stores the parsed zone.\n\nThis stores the zone that has been parsed.\nNo validation is performed other than ensuring it is not null.",
    "lineNumber": 197,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the parsed zone, not null"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1162,
    "kind": "method",
    "name": "getParsed",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#getParsed",
    "access": "public",
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1163,
    "kind": "method",
    "name": "toParsed",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#toParsed",
    "access": "public",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1164,
    "kind": "method",
    "name": "currentParsed",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#currentParsed",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1165,
    "kind": "method",
    "name": "setParsedLeapSecond",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#setParsedLeapSecond",
    "access": "public",
    "description": "Stores the leap second.",
    "lineNumber": 217,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1166,
    "kind": "method",
    "name": "getEffectiveChronology",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~DateTimeParseContext#getEffectiveChronology",
    "access": "public",
    "description": "Gets the effective chronology during parsing.",
    "lineNumber": 226,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the effective parsing chronology, not null"
    },
    "params": []
  },
  {
    "__docId__": 1167,
    "kind": "class",
    "name": "Parsed",
    "memberof": "packages/core/src/format/DateTimeParseContext.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimeParseContext.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/Temporal.js~Temporal"
    ],
    "ignore": true
  },
  {
    "__docId__": 1168,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 241,
    "undocument": true
  },
  {
    "__docId__": 1169,
    "kind": "member",
    "name": "chrono",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#chrono",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1170,
    "kind": "member",
    "name": "zone",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#zone",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1171,
    "kind": "member",
    "name": "fieldValues",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#fieldValues",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1172,
    "kind": "member",
    "name": "leapSecond",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#leapSecond",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1173,
    "kind": "member",
    "name": "dateTimeParseContext",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#dateTimeParseContext",
    "access": "public",
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1174,
    "kind": "method",
    "name": "copy",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#copy",
    "access": "public",
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1175,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#toString",
    "access": "public",
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1176,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#isSupported",
    "access": "public",
    "description": null,
    "lineNumber": 264,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1177,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#get",
    "access": "public",
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1178,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#query",
    "access": "public",
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1179,
    "kind": "method",
    "name": "toBuilder",
    "memberof": "packages/core/src/format/DateTimeParseContext.js~Parsed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimeParseContext.js~Parsed#toBuilder",
    "access": "public",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1180,
    "kind": "file",
    "name": "packages/core/src/format/DateTimePrintContext.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeException } from '../errors';\n\nimport { DateTimeFormatter } from './DateTimeFormatter';\n\n/**\n * @private\n */\nexport class DateTimePrintContext{\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter|Locale} localeOrFormatter\n     * @param {DecimalStyle} symbols\n     */\n    constructor(temporal, localeOrFormatter, symbols) {\n        if(arguments.length === 2 && arguments[1] instanceof DateTimeFormatter){\n            this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n            this._locale = localeOrFormatter.locale();\n            this._symbols = localeOrFormatter.decimalStyle();\n        } else {\n            this._temporal = temporal;\n            this._locale = localeOrFormatter;\n            this._symbols = symbols;\n        }\n        this._optional = 0;\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @param {DateTimeFormatter} formatter\n     * @returns {TemporalAccessor}\n     */\n    // eslint-disable-next-line no-unused-vars\n    static adjust(temporal, formatter) {\n        // TODO implement\n        return temporal;\n    }\n\n\n    symbols(){\n        return this._symbols;\n    }\n\n    /**\n     * Starts the printing of an optional segment of the input.\n     */\n    startOptional() {\n        this._optional++;\n    }\n\n    /**\n     * Ends the printing of an optional segment of the input.\n     */\n    endOptional() {\n        this._optional--;\n    }\n\n    /**\n     * Gets a value using a query.\n     *\n     * @param {TemporalQuery} query  the query to use, not null\n     * @return {*} the result, null if not found and optional is true\n     * @throws DateTimeException if the type is not available and the section is not optional\n     */\n    getValueQuery(query) {\n        const result = this._temporal.query(query);\n        if (result == null && this._optional === 0) {\n            throw new DateTimeException(`Unable to extract value: ${this._temporal}`);\n        }\n        return result;\n    }\n\n    /**\n     * Gets the value of the specified field.\n     *\n     * This will return the value for the specified field.\n     *\n     * @param field  the field to find, not null\n     * @return the value, null if not found and optional is true\n     * @throws DateTimeException if the field is not available and the section is not optional\n     */\n    getValue(field) {\n        try {\n            return this._temporal.getLong(field);\n        } catch (ex) {\n            if ((ex instanceof DateTimeException) && this._optional > 0) {\n                return null;\n            }\n            throw ex;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the temporal object being output.\n     *\n     * @return {TemporalAccessor} the temporal object, not null\n     */\n    temporal() {\n        return this._temporal;\n    }\n\n    /**\n     * Gets the locale.\n     * <p>\n     * This locale is used to control localization in the print output except\n     * where localization is controlled by the symbols.\n     *\n     * @return the locale, not null\n     */\n    locale() {\n        return this._locale;\n    }\n\n    //-------------------------------------------------------------------------\n    // for testing\n    /**\n     * Sets the date-time being output.\n     *\n     * @param temporal  the date-time object, not null\n     */\n    setDateTime(temporal) {\n        this._temporal = temporal;\n    }\n\n    setLocale(locale) {\n        this._locale = locale;\n    }\n\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DateTimePrintContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1181,
    "kind": "class",
    "name": "DateTimePrintContext",
    "memberof": "packages/core/src/format/DateTimePrintContext.js",
    "static": true,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DateTimePrintContext.js",
    "importStyle": "{DateTimePrintContext}",
    "description": "",
    "lineNumber": 14,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1182,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter",
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "localeOrFormatter",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DecimalStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "symbols",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 1183,
    "kind": "member",
    "name": "_temporal",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#_temporal",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1184,
    "kind": "member",
    "name": "_locale",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#_locale",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1185,
    "kind": "member",
    "name": "_symbols",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#_symbols",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1189,
    "kind": "member",
    "name": "_optional",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#_optional",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 1190,
    "kind": "method",
    "name": "adjust",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext.adjust",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalAccessor}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAccessor"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1191,
    "kind": "method",
    "name": "symbols",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#symbols",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1192,
    "kind": "method",
    "name": "startOptional",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#startOptional",
    "access": "public",
    "description": "Starts the printing of an optional segment of the input.",
    "lineNumber": 54,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1193,
    "kind": "method",
    "name": "endOptional",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#endOptional",
    "access": "public",
    "description": "Ends the printing of an optional segment of the input.",
    "lineNumber": 61,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1194,
    "kind": "method",
    "name": "getValueQuery",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#getValueQuery",
    "access": "public",
    "description": "Gets a value using a query.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the result, null if not found and optional is true"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the type is not available and the section is not optional"
      }
    ]
  },
  {
    "__docId__": 1195,
    "kind": "method",
    "name": "getValue",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#getValue",
    "access": "public",
    "description": "Gets the value of the specified field.\n\nThis will return the value for the specified field.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to find, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the value, null if not found and optional is true"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the field is not available and the section is not optional"
      }
    ]
  },
  {
    "__docId__": 1196,
    "kind": "method",
    "name": "temporal",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#temporal",
    "access": "public",
    "description": "Gets the temporal object being output.",
    "lineNumber": 106,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAccessor"
      ],
      "spread": false,
      "description": "the temporal object, not null"
    },
    "params": []
  },
  {
    "__docId__": 1197,
    "kind": "method",
    "name": "locale",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#locale",
    "access": "public",
    "description": "Gets the locale.\n<p>\nThis locale is used to control localization in the print output except\nwhere localization is controlled by the symbols.",
    "lineNumber": 118,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the locale, not null"
    },
    "params": []
  },
  {
    "__docId__": 1198,
    "kind": "method",
    "name": "setDateTime",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#setDateTime",
    "access": "public",
    "description": "Sets the date-time being output.",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the date-time object, not null"
      }
    ],
    "return": null
  },
  {
    "__docId__": 1200,
    "kind": "method",
    "name": "setLocale",
    "memberof": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DateTimePrintContext.js~DateTimePrintContext#setLocale",
    "access": "public",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1202,
    "kind": "file",
    "name": "packages/core/src/format/DecimalStyle.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nexport class DecimalStyle {\n    /**\n     *\n     * @param zeroChar\n     * @param positiveSignChar\n     * @param negativeSignChar\n     * @param decimalPointChar\n     * @private\n     */\n    constructor(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n        this._zeroDigit = zeroChar;\n        this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n        this._positiveSign = positiveSignChar;\n        this._negativeSign = negativeSignChar;\n        this._decimalSeparator = decimalPointChar;\n    }\n\n    positiveSign(){\n        return this._positiveSign;\n    }\n\n    withPositiveSign(positiveSign) {\n        if (positiveSign === this._positiveSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    negativeSign(){\n        return this._negativeSign;\n    }\n\n    withNegativeSign(negativeSign) {\n        if (negativeSign === this._negativeSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n    }\n\n    zeroDigit(){\n        return this._zeroDigit;\n    }\n\n    withZeroDigit(zeroDigit) {\n        if (zeroDigit === this._zeroDigit) {\n            return this;\n        }\n        return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n    }\n\n    decimalSeparator(){\n        return this._decimalSeparator;\n    }\n\n    withDecimalSeparator(decimalSeparator) {\n        if (decimalSeparator === this._decimalSeparator) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n    }\n\n    convertToDigit(char){\n        const val = char.charCodeAt(0) - this._zeroDigitCharCode;\n        return (val >= 0 && val <= 9) ? val : -1;\n    }\n\n    convertNumberToI18N(numericText) {\n        if (this._zeroDigit === '0') {\n            return numericText;\n        }\n        const diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n        let convertedText = '';\n        for (let i = 0; i < numericText.length; i++) {\n            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n        }\n        return convertedText;\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof DecimalStyle) {\n            return (this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign &&\n                this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator);\n        }\n        return false;\n    }\n\n    hashCode() {\n        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n    }\n\n    toString() {\n        return `DecimalStyle[${this._zeroDigit}${this._positiveSign}${this._negativeSign}${this._decimalSeparator}]`;\n    }\n\n    static of(){\n        throw new Error('not yet supported');\n    }\n    static availableLocales(){\n        throw new Error('not yet supported');\n    }\n\n}\n\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/DecimalStyle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1203,
    "kind": "class",
    "name": "DecimalStyle",
    "memberof": "packages/core/src/format/DecimalStyle.js",
    "static": true,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/DecimalStyle.js",
    "importStyle": "{DecimalStyle}",
    "description": "",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2016, Philipp Thürwächter & Pattrick Hüper"
      },
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2007-present, Stephen Colebourne & Michael Nascimento Santos"
      },
      {
        "tagName": "@license",
        "tagValue": "BSD-3-Clause (see LICENSE in the root directory of this source tree)"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 1204,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "zeroChar",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "positiveSignChar",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "negativeSignChar",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "decimalPointChar",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1205,
    "kind": "member",
    "name": "_zeroDigit",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#_zeroDigit",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1206,
    "kind": "member",
    "name": "_zeroDigitCharCode",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#_zeroDigitCharCode",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1207,
    "kind": "member",
    "name": "_positiveSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#_positiveSign",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1208,
    "kind": "member",
    "name": "_negativeSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#_negativeSign",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1209,
    "kind": "member",
    "name": "_decimalSeparator",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#_decimalSeparator",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1210,
    "kind": "method",
    "name": "positiveSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#positiveSign",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1211,
    "kind": "method",
    "name": "withPositiveSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#withPositiveSign",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "positiveSign",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1212,
    "kind": "method",
    "name": "negativeSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#negativeSign",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1213,
    "kind": "method",
    "name": "withNegativeSign",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#withNegativeSign",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "negativeSign",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1214,
    "kind": "method",
    "name": "zeroDigit",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#zeroDigit",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1215,
    "kind": "method",
    "name": "withZeroDigit",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#withZeroDigit",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "zeroDigit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1216,
    "kind": "method",
    "name": "decimalSeparator",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#decimalSeparator",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1217,
    "kind": "method",
    "name": "withDecimalSeparator",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#withDecimalSeparator",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "decimalSeparator",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1218,
    "kind": "method",
    "name": "convertToDigit",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#convertToDigit",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "char",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1219,
    "kind": "method",
    "name": "convertNumberToI18N",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#convertNumberToI18N",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "numericText",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1220,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#equals",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1221,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#hashCode",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1222,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle#toString",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1223,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle.of",
    "access": "public",
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1224,
    "kind": "method",
    "name": "availableLocales",
    "memberof": "packages/core/src/format/DecimalStyle.js~DecimalStyle",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/DecimalStyle.js~DecimalStyle.availableLocales",
    "access": "public",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1225,
    "kind": "file",
    "name": "packages/core/src/format/EnumMap.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class EnumMap {\n    constructor(){\n        this._map = {};\n    }\n\n    putAll(otherMap){\n        for(const key in otherMap._map){\n            this._map[key] = otherMap._map[key];\n        }\n        return this;\n    }\n\n    containsKey(key){\n        // eslint-disable-next-line no-prototype-builtins\n        return (this._map.hasOwnProperty(key.name())) && (this.get(key) !== undefined);\n    }\n\n    get(key) {\n        return this._map[key.name()];\n    }\n\n    put(key, val) {\n        return this.set(key, val);\n    }\n\n    set(key, val) {\n        this._map[key.name()] = val;\n        return this;\n    }\n\n    retainAll(keyList){\n        const map = {};\n        for(let i=0; i<keyList.length; i++){\n            const key = keyList[i].name();\n            map[key] = this._map[key];\n        }\n        this._map = map;\n        return this;\n    }\n\n    /**\n     * due to the bad performance of delete we just set the key entry to undefined.\n     *\n     * this might lead to issues with \"null\" entries. Calling clear in the end might solve the issue\n     * @param key\n     * @returns {*}\n     */\n    remove(key){\n        const keyName = key.name();\n        const val = this._map[keyName];\n        this._map[keyName] = undefined;\n        return val;\n    }\n\n    keySet(){\n        return this._map;\n    }\n\n    clear(){\n        this._map = {};\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/EnumMap.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1226,
    "kind": "class",
    "name": "EnumMap",
    "memberof": "packages/core/src/format/EnumMap.js",
    "static": true,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/EnumMap.js",
    "importStyle": "{EnumMap}",
    "description": "",
    "lineNumber": 9,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1227,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 1228,
    "kind": "member",
    "name": "_map",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#_map",
    "access": "private",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1229,
    "kind": "method",
    "name": "putAll",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#putAll",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "otherMap",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1230,
    "kind": "method",
    "name": "containsKey",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#containsKey",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1231,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#get",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1232,
    "kind": "method",
    "name": "put",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#put",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1233,
    "kind": "method",
    "name": "set",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#set",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "val",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1234,
    "kind": "method",
    "name": "retainAll",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#retainAll",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "keyList",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1236,
    "kind": "method",
    "name": "remove",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#remove",
    "access": "public",
    "description": "due to the bad performance of delete we just set the key entry to undefined.\n\nthis might lead to issues with \"null\" entries. Calling clear in the end might solve the issue",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1237,
    "kind": "method",
    "name": "keySet",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#keySet",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1238,
    "kind": "method",
    "name": "clear",
    "memberof": "packages/core/src/format/EnumMap.js~EnumMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/EnumMap.js~EnumMap#clear",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1240,
    "kind": "file",
    "name": "packages/core/src/format/ParsePosition.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class ParsePosition {\n    constructor(index) {\n        this._index = index;\n        this._errorIndex = -1;\n    }\n\n    getIndex(){\n        return this._index;\n    }\n\n    setIndex(index){\n        this._index = index;\n    }\n\n    getErrorIndex(){\n        return this._errorIndex;\n    }\n\n    setErrorIndex(errorIndex){\n        this._errorIndex = errorIndex;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/ParsePosition.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1241,
    "kind": "class",
    "name": "ParsePosition",
    "memberof": "packages/core/src/format/ParsePosition.js",
    "static": true,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/ParsePosition.js",
    "importStyle": "{ParsePosition}",
    "description": "",
    "lineNumber": 10,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1242,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 1243,
    "kind": "member",
    "name": "_index",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#_index",
    "access": "private",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1244,
    "kind": "member",
    "name": "_errorIndex",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#_errorIndex",
    "access": "private",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1245,
    "kind": "method",
    "name": "getIndex",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#getIndex",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1246,
    "kind": "method",
    "name": "setIndex",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#setIndex",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1248,
    "kind": "method",
    "name": "getErrorIndex",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#getErrorIndex",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1249,
    "kind": "method",
    "name": "setErrorIndex",
    "memberof": "packages/core/src/format/ParsePosition.js~ParsePosition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/ParsePosition.js~ParsePosition#setErrorIndex",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "errorIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1251,
    "kind": "file",
    "name": "packages/core/src/format/ResolverStyle.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { Enum } from '../Enum';\n\n/**\n * Enumeration of different ways to resolve dates and times.\n * \n * Parsing a text string occurs in two phases.\n * Phase 1 is a basic text parse according to the fields added to the builder.\n * Phase 2 resolves the parsed field-value pairs into date and/or time objects.\n * This style is used to control how phase 2, resolving, happens.\n *\n * ### Static properties of Class {@link DateTimeFormatter}\n *\n * ResolverStyle.STRICT = new ResolverStyle('STRICT');\n *\n * Style to resolve dates and times strictly.\n *\n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n *\n * ResolverStyle.SMART = new ResolverStyle('SMART');\n *\n * Style to resolve dates and times in a smart, or intelligent, manner.\n *\n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n *\n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n *\n * ResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n *\n * Style to resolve dates and times leniently.\n *\n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n *\n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n *\n */\nexport class ResolverStyle extends Enum {}\n\n/**\n * Style to resolve dates and times strictly.\n * \n * Using strict resolution will ensure that all parsed values are within\n * the outer range of valid values for the field. Individual fields may\n * be further processed for strictness.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using strict mode will ensure that the day-of-month is valid\n * for the year-month, rejecting invalid values.\n */\nResolverStyle.STRICT = new ResolverStyle('STRICT');\n/**\n * Style to resolve dates and times in a smart, or intelligent, manner.\n * \n * Using smart resolution will perform the sensible default for each\n * field, which may be the same as strict, the same as lenient, or a third\n * behavior. Individual fields will interpret this differently.\n * \n * For example, resolving year-month and day-of-month in the ISO calendar\n * system using smart mode will ensure that the day-of-month is from\n * 1 to 31, converting any value beyond the last valid day-of-month to be\n * the last valid day-of-month.\n */\nResolverStyle.SMART = new ResolverStyle('SMART');\n/**\n * Style to resolve dates and times leniently.\n * \n * Using lenient resolution will resolve the values in an appropriate\n * lenient manner. Individual fields will interpret this differently.\n * \n * For example, lenient mode allows the month in the ISO calendar system\n * to be outside the range 1 to 12.\n * For example, month 15 is treated as being 3 months after month 12.\n */\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/ResolverStyle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1252,
    "kind": "class",
    "name": "ResolverStyle",
    "memberof": "packages/core/src/format/ResolverStyle.js",
    "static": true,
    "longname": "packages/core/src/format/ResolverStyle.js~ResolverStyle",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/ResolverStyle.js",
    "importStyle": "{ResolverStyle}",
    "description": "Enumeration of different ways to resolve dates and times.\n\nParsing a text string occurs in two phases.\nPhase 1 is a basic text parse according to the fields added to the builder.\nPhase 2 resolves the parsed field-value pairs into date and/or time objects.\nThis style is used to control how phase 2, resolving, happens.\n\n### Static properties of Class {@link DateTimeFormatter}\n\nResolverStyle.STRICT = new ResolverStyle('STRICT');\n\nStyle to resolve dates and times strictly.\n\nUsing strict resolution will ensure that all parsed values are within\nthe outer range of valid values for the field. Individual fields may\nbe further processed for strictness.\n\nFor example, resolving year-month and day-of-month in the ISO calendar\nsystem using strict mode will ensure that the day-of-month is valid\nfor the year-month, rejecting invalid values.\n\nResolverStyle.SMART = new ResolverStyle('SMART');\n\nStyle to resolve dates and times in a smart, or intelligent, manner.\n\nUsing smart resolution will perform the sensible default for each\nfield, which may be the same as strict, the same as lenient, or a third\nbehavior. Individual fields will interpret this differently.\n\nFor example, resolving year-month and day-of-month in the ISO calendar\nsystem using smart mode will ensure that the day-of-month is from\n1 to 31, converting any value beyond the last valid day-of-month to be\nthe last valid day-of-month.\n\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n\nStyle to resolve dates and times leniently.\n\nUsing lenient resolution will resolve the values in an appropriate\nlenient manner. Individual fields will interpret this differently.\n\nFor example, lenient mode allows the month in the ISO calendar system\nto be outside the range 1 to 12.\nFor example, month 15 is treated as being 3 months after month 12.",
    "lineNumber": 56,
    "interface": false,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ]
  },
  {
    "__docId__": 1253,
    "kind": "file",
    "name": "packages/core/src/format/SignStyle.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { Enum } from '../Enum';\n\nexport class SignStyle extends Enum{\n    /**\n     * Parse helper.\n     *\n     * @param positive  true if positive sign parsed, false for negative sign\n     * @param strict  true if strict, false if lenient\n     * @param fixedWidth  true if fixed width, false if not\n     * @return true if valid\n     */\n    parse(positive, strict, fixedWidth){\n        switch (this) {\n            case SignStyle.NORMAL: // NORMAL\n                // valid if negative or (positive and lenient)\n                return !positive || !strict;\n            case SignStyle.ALWAYS: // ALWAYS\n            case SignStyle.EXCEEDS_PAD: // EXCEEDS_PAD\n                return true;\n            default:\n                // valid if lenient and not fixed width\n                return !strict && !fixedWidth;\n        }\n\n    }\n}\n\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/SignStyle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1254,
    "kind": "class",
    "name": "SignStyle",
    "memberof": "packages/core/src/format/SignStyle.js",
    "static": true,
    "longname": "packages/core/src/format/SignStyle.js~SignStyle",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/SignStyle.js",
    "importStyle": "{SignStyle}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ]
  },
  {
    "__docId__": 1255,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/SignStyle.js~SignStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/SignStyle.js~SignStyle#parse",
    "access": "public",
    "description": "Parse helper.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "positive",
        "description": "true if positive sign parsed, false for negative sign"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "strict",
        "description": "true if strict, false if lenient"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "fixedWidth",
        "description": "true if fixed width, false if not"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if valid"
    }
  },
  {
    "__docId__": 1256,
    "kind": "file",
    "name": "packages/core/src/format/StringBuilder.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class StringBuilder {\n    constructor(){\n        this._str = '';\n    }\n\n    append(str){\n        this._str += str;\n        return this;\n    }\n\n    appendChar(str){\n        this._str += str[0];\n        return this;\n    }\n\n    insert(offset, str){\n        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n        return this;\n    }\n\n    replace(start, end, str){\n        this._str = this._str.slice(0, start) + str + this._str.slice(end);\n        return this;\n    }\n\n    length(){\n        return this._str.length;\n    }\n\n    setLength(length){\n        this._str = this._str.slice(0, length);\n        return this;\n    }\n\n\n    toString() {\n        return this._str;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/StringBuilder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1257,
    "kind": "class",
    "name": "StringBuilder",
    "memberof": "packages/core/src/format/StringBuilder.js",
    "static": true,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/StringBuilder.js",
    "importStyle": "{StringBuilder}",
    "description": "",
    "lineNumber": 9,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1258,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 1259,
    "kind": "member",
    "name": "_str",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#_str",
    "access": "private",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1260,
    "kind": "method",
    "name": "append",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#append",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1262,
    "kind": "method",
    "name": "appendChar",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#appendChar",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1264,
    "kind": "method",
    "name": "insert",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#insert",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "offset",
        "types": [
          "*"
        ]
      },
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1266,
    "kind": "method",
    "name": "replace",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#replace",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1268,
    "kind": "method",
    "name": "length",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#length",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1269,
    "kind": "method",
    "name": "setLength",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#setLength",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1271,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/StringBuilder.js~StringBuilder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/StringBuilder.js~StringBuilder#toString",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1272,
    "kind": "file",
    "name": "packages/core/src/format/TextStyle.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { Enum } from '../Enum';\n\n/**\n * Enumeration of the style of text formatting and parsing.\n *\n * Text styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.\n * Each of these three sizes is available in both 'standard' and 'stand-alone' variations.\n *\n * The difference between the three sizes is obvious in most languages.\n * For example, in English the 'full' month is 'January', the 'short' month is 'Jan'\n * and the 'narrow' month is 'J'. Note that the narrow size is often not unique.\n * For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.\n *\n * The difference between the 'standard' and 'stand-alone' forms is trickier to describe\n * as there is no difference in English. However, in other languages there is a difference\n * in the word used when the text is used alone, as opposed to in a complete date.\n * For example, the word used for a month when used alone in a date picker is different\n * to the word used for month in association with a day and year in a date.\n *\n * ### Specification for implementors\n *\n * This is immutable and thread-safe enum.\n */\nexport class TextStyle extends Enum {\n    /**\n     * Checks if the style is stand-alone.\n     *\n     * @return {boolean} true if the style is stand-alone\n     */\n    isStandalone() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n            case TextStyle.SHORT_STANDALONE:\n            case TextStyle.NARROW_STANDALONE:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent stand-alone style.\n     *\n     * @return {TextStyle} the matching stand-alone style\n     */\n    asStandalone() {\n        switch (this) {\n            case TextStyle.FULL:\n                return TextStyle.FULL_STANDALONE;\n            case TextStyle.SHORT:\n                return TextStyle.SHORT_STANDALONE;\n            case TextStyle.NARROW:\n                return TextStyle.NARROW_STANDALONE;\n            default:\n                // all others are already standalone\n                return this;\n        }\n    }\n\n    /**\n     * Converts the style to the equivalent normal style.\n     *\n     * @return {TextStyle} the matching normal style\n     */\n    asNormal() {\n        switch (this) {\n            case TextStyle.FULL_STANDALONE:\n                return TextStyle.FULL;\n            case TextStyle.SHORT_STANDALONE:\n                return TextStyle.SHORT;\n            case TextStyle.NARROW_STANDALONE:\n                return TextStyle.NARROW;\n            default:\n                // all others are already normal\n                return this;\n        }\n    }\n}\n\n/**\n * Full text, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL = new TextStyle('FULL');\n/**\n * Full text for stand-alone use, typically the full description.\n * For example, day-of-week Monday might output \"Monday\".\n */\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\n/**\n * Short text, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT = new TextStyle('SHORT');\n/**\n * Short text for stand-alone use, typically an abbreviation.\n * For example, day-of-week Monday might output \"Mon\".\n */\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\n/**\n * Narrow text, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW = new TextStyle('NARROW');\n/**\n * Narrow text for stand-alone use, typically a single letter.\n * For example, day-of-week Monday might output \"M\".\n */\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/TextStyle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1273,
    "kind": "class",
    "name": "TextStyle",
    "memberof": "packages/core/src/format/TextStyle.js",
    "static": true,
    "longname": "packages/core/src/format/TextStyle.js~TextStyle",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/TextStyle.js",
    "importStyle": "{TextStyle}",
    "description": "Enumeration of the style of text formatting and parsing.\n\nText styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.\nEach of these three sizes is available in both 'standard' and 'stand-alone' variations.\n\nThe difference between the three sizes is obvious in most languages.\nFor example, in English the 'full' month is 'January', the 'short' month is 'Jan'\nand the 'narrow' month is 'J'. Note that the narrow size is often not unique.\nFor example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.\n\nThe difference between the 'standard' and 'stand-alone' forms is trickier to describe\nas there is no difference in English. However, in other languages there is a difference\nin the word used when the text is used alone, as opposed to in a complete date.\nFor example, the word used for a month when used alone in a date picker is different\nto the word used for month in association with a day and year in a date.\n\n### Specification for implementors\n\nThis is immutable and thread-safe enum.",
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ]
  },
  {
    "__docId__": 1274,
    "kind": "method",
    "name": "isStandalone",
    "memberof": "packages/core/src/format/TextStyle.js~TextStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/TextStyle.js~TextStyle#isStandalone",
    "access": "public",
    "description": "Checks if the style is stand-alone.",
    "lineNumber": 35,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the style is stand-alone"
    },
    "params": []
  },
  {
    "__docId__": 1275,
    "kind": "method",
    "name": "asStandalone",
    "memberof": "packages/core/src/format/TextStyle.js~TextStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/TextStyle.js~TextStyle#asStandalone",
    "access": "public",
    "description": "Converts the style to the equivalent stand-alone style.",
    "lineNumber": 51,
    "return": {
      "nullable": null,
      "types": [
        "TextStyle"
      ],
      "spread": false,
      "description": "the matching stand-alone style"
    },
    "params": []
  },
  {
    "__docId__": 1276,
    "kind": "method",
    "name": "asNormal",
    "memberof": "packages/core/src/format/TextStyle.js~TextStyle",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/TextStyle.js~TextStyle#asNormal",
    "access": "public",
    "description": "Converts the style to the equivalent normal style.",
    "lineNumber": 70,
    "return": {
      "nullable": null,
      "types": [
        "TextStyle"
      ],
      "spread": false,
      "description": "the matching normal style"
    },
    "params": []
  },
  {
    "__docId__": 1277,
    "kind": "file",
    "name": "packages/core/src/format/parser/CharLiteralPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { IllegalArgumentException } from '../../errors';\n\n/**\n * Prints or parses a char literal.\n * @private\n */\nexport class CharLiteralPrinterParser {\n\n    constructor(literal) {\n        if (literal.length > 1) {\n            throw new IllegalArgumentException(`invalid literal, too long: \"${literal}\"`);\n        }\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        const ch = text.charAt(position);\n        if (context.charEquals(this._literal, ch) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        if (this._literal === '\\'') {\n            return \"''\";\n        }\n        return `'${this._literal}'`;\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/CharLiteralPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1278,
    "kind": "class",
    "name": "CharLiteralPrinterParser",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/CharLiteralPrinterParser.js",
    "importStyle": "{CharLiteralPrinterParser}",
    "description": "Prints or parses a char literal.",
    "lineNumber": 13,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1279,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true
  },
  {
    "__docId__": 1280,
    "kind": "member",
    "name": "_literal",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser#_literal",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1281,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1282,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1283,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CharLiteralPrinterParser.js~CharLiteralPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1284,
    "kind": "file",
    "name": "packages/core/src/format/parser/CompositePrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * @private\n */\nexport class CompositePrinterParser {\n\n    constructor(printerParsers, optional) {\n        this._printerParsers = printerParsers;\n        this._optional = optional;\n    }\n\n    /**\n     * Returns a copy of this printer-parser with the optional flag changed.\n     *\n     * @param {boolean} optional  the optional flag to set in the copy\n     * @return {CompositePrinterParser} the new printer-parser, not null\n     */\n    withOptional(optional) {\n        if (optional === this._optional) {\n            return this;\n        }\n        return new CompositePrinterParser(this._printerParsers, optional);\n    }\n\n    print(context, buf) {\n        const length = buf.length();\n        if (this._optional) {\n            context.startOptional();\n        }\n        try {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                if (pp.print(context, buf) === false) {\n                    buf.setLength(length);  // reset buffer\n                    return true;\n                }\n            }\n        } finally {\n            if (this._optional) {\n                context.endOptional();\n            }\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        if (this._optional) {\n            context.startOptional();\n            let pos = position;\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                pos = pp.parse(context, text, pos);\n                if (pos < 0) {\n                    context.endOptional(false);\n                    return position;  // return original position\n                }\n            }\n            context.endOptional(true);\n            return pos;\n        } else {\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                position = pp.parse(context, text, position);\n                if (position < 0) {\n                    break;\n                }\n            }\n            return position;\n        }\n    }\n\n    toString() {\n        let buf = '';\n        if (this._printerParsers != null) {\n            buf += this._optional ? '[' : '(';\n            for (let i=0; i<this._printerParsers.length; i++) {\n                const pp = this._printerParsers[i];\n                buf += pp.toString();\n            }\n            buf += this._optional ? ']' : ')';\n        }\n        return buf;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/CompositePrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1285,
    "kind": "class",
    "name": "CompositePrinterParser",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/CompositePrinterParser.js",
    "importStyle": "{CompositePrinterParser}",
    "description": "",
    "lineNumber": 10,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1286,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 1287,
    "kind": "member",
    "name": "_printerParsers",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#_printerParsers",
    "access": "private",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1288,
    "kind": "member",
    "name": "_optional",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#_optional",
    "access": "private",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1289,
    "kind": "method",
    "name": "withOptional",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#withOptional",
    "access": "public",
    "description": "Returns a copy of this printer-parser with the optional flag changed.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "optional",
        "description": "the optional flag to set in the copy"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompositePrinterParser"
      ],
      "spread": false,
      "description": "the new printer-parser, not null"
    }
  },
  {
    "__docId__": 1290,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1291,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1292,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/CompositePrinterParser.js~CompositePrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1293,
    "kind": "file",
    "name": "packages/core/src/format/parser/FractionPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../../assert';\nimport { IllegalArgumentException } from '../../errors';\nimport { MathUtil } from '../../MathUtil';\n\n/**\n * TODO optimize FractionPrinterParser, fix documentation\n *\n * Prints and parses a numeric date-time field with optional padding.\n * @private\n */\nexport class FractionPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to output, not null\n     * @param {Number} minWidth  the minimum width to output, from 0 to 9\n     * @param {Number} maxWidth  the maximum width to output, from 0 to 9\n     * @param {boolean} decimalPoint  whether to output the localized decimal point symbol\n     */\n    constructor(field, minWidth, maxWidth, decimalPoint) {\n        requireNonNull(field, 'field');\n        if (field.range().isFixed() === false) {\n            throw new IllegalArgumentException(`Field must have a fixed set of values: ${field}`);\n        }\n        if (minWidth < 0 || minWidth > 9) {\n            throw new IllegalArgumentException(`Minimum width must be from 0 to 9 inclusive but was ${minWidth}`);\n        }\n        if (maxWidth < 1 || maxWidth > 9) {\n            throw new IllegalArgumentException(`Maximum width must be from 1 to 9 inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(`Maximum width must exceed or equal the minimum width but ${ \n                maxWidth} < ${minWidth}`);\n        }\n        this.field = field;\n        this.minWidth = minWidth;\n        this.maxWidth = maxWidth;\n        this.decimalPoint = decimalPoint;\n    }\n\n    print(context, buf) {\n        const value = context.getValue(this.field);\n        if (value === null) {\n            return false;\n        }\n        const symbols = context.symbols();\n        if (value === 0) {  // scale is zero if value is zero\n            if (this.minWidth > 0) {\n                if (this.decimalPoint) {\n                    buf.append(symbols.decimalSeparator());\n                }\n                for (let i = 0; i < this.minWidth; i++) {\n                    buf.append(symbols.zeroDigit());\n                }\n            }\n        } else {\n            let fraction = this.convertToFraction(value, symbols.zeroDigit());\n            const outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n            fraction = fraction.substr(0, outputScale);\n            if(fraction * 1 > 0 ) {\n                while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n                    fraction = fraction.substr(0, fraction.length - 1);\n                }\n            }\n            let str = fraction;\n            str = symbols.convertNumberToI18N(str);\n            if (this.decimalPoint) {\n                buf.append(symbols.decimalSeparator());\n            }\n            buf.append(str);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        const effectiveMin = (context.isStrict() ? this.minWidth : 0);\n        const effectiveMax = (context.isStrict() ? this.maxWidth : 9);\n        const length = text.length;\n        if (position === length) {\n            // valid if whole field is optional, invalid if minimum width\n            return (effectiveMin > 0 ? ~position : position);\n        }\n        if (this.decimalPoint) {\n            if (text[position] !== context.symbols().decimalSeparator()) {\n                // valid if whole field is optional, invalid if minimum width\n                return (effectiveMin > 0 ? ~position : position);\n            }\n            position++;\n        }\n        const minEndPos = position + effectiveMin;\n        if (minEndPos > length) {\n            return ~position;  // need at least min width digits\n        }\n        const maxEndPos = Math.min(position + effectiveMax, length);\n        let total = 0;  // can use int because we are only parsing up to 9 digits\n        let pos = position;\n        while (pos < maxEndPos) {\n            const ch = text.charAt(pos++);\n            const digit = context.symbols().convertToDigit(ch);\n            if (digit < 0) {\n                if (pos < minEndPos) {\n                    return ~position;  // need at least min width digits\n                }\n                pos--;\n                break;\n            }\n            total = total * 10 + digit;\n        }\n        const moveLeft = pos - position;\n        const scale = Math.pow(10, moveLeft);\n        const value = this.convertFromFraction(total, scale);\n        return context.setParsedField(this.field, value, position, pos);\n    }\n\n    /**\n     *\n     * @param {Number} value  the value to convert, must be valid for this rule\n     * @param {String} zeroDigit  the character for zero\n     * @return {String} the value as a fraction within the range, from 0 to 1, not null\n     */\n    convertToFraction(value, zeroDigit) {\n        const range = this.field.range();\n        range.checkValidValue(value, this.field);\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = value - _min;\n        const _scaled = MathUtil.intDiv((_value * 1000000000),  _range);\n        let fraction = `${_scaled}`;\n        while(fraction.length < 9){\n            fraction = zeroDigit + fraction;\n        }\n        return fraction;\n    }\n\n    /**\n     *\n     * @param {Number} total  the fraction to convert, not null\n     * @param {Number} scale  the scale, not null\n     * @return {Number} the value of the field, valid for this rule\n     * @throws DateTimeException if the value cannot be converted\n     */\n    convertFromFraction(total, scale) {\n        const range = this.field.range();\n        const _min = range.minimum();\n        const _range = range.maximum() - _min + 1;\n        const _value = MathUtil.intDiv((total * _range), scale);\n        return _value;\n    }\n\n    toString() {\n        const decimal = (this.decimalPoint ? ',DecimalPoint' : '');\n        return `Fraction(${this.field},${this.minWidth},${this.maxWidth}${decimal})`;\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/FractionPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1294,
    "kind": "class",
    "name": "FractionPrinterParser",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/FractionPrinterParser.js",
    "importStyle": "{FractionPrinterParser}",
    "description": "TODO optimize FractionPrinterParser, fix documentation\n\nPrints and parses a numeric date-time field with optional padding.",
    "lineNumber": 17,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1295,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to output, not null"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minWidth",
        "description": "the minimum width to output, from 0 to 9"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum width to output, from 0 to 9"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "decimalPoint",
        "description": "whether to output the localized decimal point symbol"
      }
    ]
  },
  {
    "__docId__": 1296,
    "kind": "member",
    "name": "field",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#field",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1297,
    "kind": "member",
    "name": "minWidth",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#minWidth",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1298,
    "kind": "member",
    "name": "maxWidth",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#maxWidth",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1299,
    "kind": "member",
    "name": "decimalPoint",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#decimalPoint",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1300,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1301,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1302,
    "kind": "method",
    "name": "convertToFraction",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#convertToFraction",
    "access": "public",
    "description": "",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to convert, must be valid for this rule"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "zeroDigit",
        "description": "the character for zero"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "the value as a fraction within the range, from 0 to 1, not null"
    }
  },
  {
    "__docId__": 1303,
    "kind": "method",
    "name": "convertFromFraction",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#convertFromFraction",
    "access": "public",
    "description": "",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "total",
        "description": "the fraction to convert, not null"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "scale",
        "description": "the scale, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "the value of the field, valid for this rule"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value cannot be converted"
      }
    ]
  },
  {
    "__docId__": 1304,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/FractionPrinterParser.js~FractionPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1305,
    "kind": "file",
    "name": "packages/core/src/format/parser/NumberPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert } from '../../assert';\nimport { ArithmeticException, DateTimeException, IllegalArgumentException } from '../../errors';\nimport { MathUtil } from '../../MathUtil';\n\nimport { IsoChronology } from '../../chrono/IsoChronology';\n\nimport { SignStyle } from '../SignStyle';\n\n\nconst MAX_WIDTH = 15; // can't parse all numbers with more then 15 digits in javascript\n\nconst EXCEED_POINTS = [\n    0,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n];\n\n/**\n * @private\n */\nexport class NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param field  the field to print, not null\n     * @param minWidth  the minimum field width, from 1 to 19\n     * @param maxWidth  the maximum field width, from minWidth to 19\n     * @param signStyle  the positive/negative sign style, not null\n     * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,\n     *  -1 if fixed width due to active adjacent parsing\n     */\n    constructor(field, minWidth, maxWidth, signStyle, subsequentWidth=0){\n        this._field = field;\n        this._minWidth = minWidth;\n        this._maxWidth = maxWidth;\n        this._signStyle = signStyle;\n        this._subsequentWidth = subsequentWidth;\n    }\n\n    field(){ return this._field;}\n    minWidth(){ return this._minWidth;}\n    maxWidth(){ return this._maxWidth;}\n    signStyle(){ return this._signStyle;}\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n    }\n\n    withSubsequentWidth(subsequentWidth) {\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n    }\n\n    _isFixedWidth() {\n        return this._subsequentWidth === -1 ||\n            (this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE);\n    }\n\n    print(context, buf) {\n        const contextValue = context.getValue(this._field);\n        if (contextValue == null) {\n            return false;\n        }\n        const value = this._getValue(context, contextValue);\n        const symbols = context.symbols();\n        let str = `${Math.abs(value)}`;\n        if (str.length > this._maxWidth) {\n            throw new DateTimeException(`Field ${this._field \n            } cannot be printed as the value ${value \n            } exceeds the maximum print width of ${this._maxWidth}`);\n        }\n        str = symbols.convertNumberToI18N(str);\n\n        if (value >= 0) {\n            switch (this._signStyle) {\n                case SignStyle.EXCEEDS_PAD:\n                    if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n                        buf.append(symbols.positiveSign());\n                    }\n                    break;\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.positiveSign());\n                    break;\n            }\n        } else {\n            switch (this._signStyle) {\n                case SignStyle.NORMAL:\n                case SignStyle.EXCEEDS_PAD:\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.negativeSign());\n                    break;\n                case SignStyle.NOT_NEGATIVE:\n                    throw new DateTimeException(`Field ${this._field \n                    } cannot be printed as the value ${value \n                    } cannot be negative according to the SignStyle`);\n            }\n        }\n        for (let i = 0; i < this._minWidth - str.length; i++) {\n            buf.append(symbols.zeroDigit());\n        }\n        buf.append(str);\n        return true;\n    }\n\n    parse(context, text, position){\n        const length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        assert(position>=0 && position<length);\n        const sign = text.charAt(position);  // IOOBE if invalid position\n        let negative = false;\n        let positive = false;\n        if (sign === context.symbols().positiveSign()) {\n            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            positive = true;\n            position++;\n        } else if (sign === context.symbols().negativeSign()) {\n            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            negative = true;\n            position++;\n        } else {\n            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n                return ~position;\n            }\n        }\n        const effMinWidth = (context.isStrict() || this._isFixedWidth() ? this._minWidth : 1);\n        const minEndPos = position + effMinWidth;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        let effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n        let total = 0;\n        let pos = position;\n        for (let pass = 0; pass < 2; pass++) {\n            const maxEndPos = Math.min(pos + effMaxWidth, length);\n            while (pos < maxEndPos) {\n                const ch = text.charAt(pos++);\n                const digit = context.symbols().convertToDigit(ch);\n                if (digit < 0) {\n                    pos--;\n                    if (pos < minEndPos) {\n                        return ~position;  // need at least min width digits\n                    }\n                    break;\n                }\n                if ((pos - position) > MAX_WIDTH) {\n                    throw new ArithmeticException('number text exceeds length');\n                } else {\n                    total = total * 10 + digit;\n                }\n            }\n            if (this._subsequentWidth > 0 && pass === 0) {\n                // re-parse now we know the correct width\n                const parseLen = pos - position;\n                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n                pos = position;\n                total = 0;\n            } else {\n                break;\n            }\n        }\n        if (negative) {\n            if (total === 0 && context.isStrict()) {\n                return ~(position - 1);  // minus zero not allowed\n            }\n            if(total !== 0) {\n                total = -total;\n            }\n        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n            const parseLen = pos - position;\n            if (positive) {\n                if (parseLen <= this._minWidth) {\n                    return ~(position - 1);  // '+' only parsed if minWidth exceeded\n                }\n            } else {\n                if (parseLen > this._minWidth) {\n                    return ~position;  // '+' must be parsed if minWidth exceeded\n                }\n            }\n        }\n        return this._setValue(context, total, position, pos);\n    }\n\n    /**\n     * Gets the value to output.\n     * (This is needed to allow e.g. ReducedPrinterParser to override this and change the value!\n     *\n     * @param context  the context\n     * @param value  the value of the field, not null\n     * @return the value\n     * @private\n     */\n    _getValue(context, value) {\n        return value;\n    }\n\n    /**\n     * Stores the value.\n     *\n     * @param context  the context to store into, not null\n     * @param value  the value\n     * @param errorPos  the position of the field being parsed\n     * @param successPos  the position after the field being parsed\n     * @return the new position\n     */\n    _setValue(context, value, errorPos, successPos) {\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    toString() {\n        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n            return `Value(${this._field})`;\n        }\n        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n            return `Value(${this._field},${this._minWidth})`;\n        }\n        return `Value(${this._field},${this._minWidth},${this._maxWidth},${this._signStyle})`;\n    }\n\n}\n//-----------------------------------------------------------------------\n/**\n * Prints and parses a reduced numeric date-time field.\n * @private\n */\nexport class ReducedPrinterParser extends NumberPrinterParser {\n\n    /**\n     * Constructor.\n     *\n     * @param {TemporalField} field  the field to print, validated not null\n     * @param {number} width  the field width, from 1 to 10\n     * @param {number} maxWidth  the field max width, from 1 to 10\n     * @param {number} baseValue  the base value\n     * @param {ChronoLocalDate} baseDate  the base date\n     */\n    constructor(field, width, maxWidth, baseValue, baseDate) {\n        super(field, width, maxWidth, SignStyle.NOT_NEGATIVE);\n        if (width < 1 || width > 10) {\n            throw new IllegalArgumentException(`The width must be from 1 to 10 inclusive but was ${width}`);\n        }\n        if (maxWidth < 1 || maxWidth > 10) {\n            throw new IllegalArgumentException(`The maxWidth must be from 1 to 10 inclusive but was ${maxWidth}`);\n        }\n        if (maxWidth < width) {\n            throw new IllegalArgumentException('The maxWidth must be greater than the width');\n        }\n        if (baseDate === null) {\n            if (field.range().isValidValue(baseValue) === false) {\n                throw new IllegalArgumentException('The base value must be within the range of the field');\n            }\n            if ((baseValue + EXCEED_POINTS[width]) > MathUtil.MAX_SAFE_INTEGER) {\n                throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n            }\n        }\n        this._baseValue = baseValue;\n        this._baseDate = baseDate;\n    }\n\n    /**\n     *\n     * @param {DateTimePrintContext} context\n     * @param {number} value\n     */\n    _getValue(context, value) {\n        const absValue = Math.abs(value);\n        let baseValue = this._baseValue;\n        if (this._baseDate !== null) {\n            // TODO: in threetenbp the following line is used, but we dont have Chronology yet,\n            // let chrono = Chronology.from(context.getTemporal());\n            // so let's use IsoChronology for now\n            context.temporal();\n            const chrono = IsoChronology.INSTANCE;\n            baseValue = chrono.date(this._baseDate).get(this._field);\n        }\n        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n            return absValue % EXCEED_POINTS[this._minWidth];\n        }\n        return absValue % EXCEED_POINTS[this._maxWidth];\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {number} value\n     * @param {number} errorPos\n     * @param {number} successPos\n     */\n    _setValue(context, value, errorPos, successPos) {\n        let baseValue = this._baseValue;\n        if (this._baseDate != null) {\n            const chrono = context.getEffectiveChronology();\n            baseValue = chrono.date(this._baseDate).get(this._field);\n            // TODO: not implemented??\n            // context.addChronologyChangedParser(this, value, errorPos, successPos);\n        }\n        const parseLen = successPos - errorPos;\n        if (parseLen === this._minWidth && value >= 0) {\n            const range = EXCEED_POINTS[this._minWidth];\n            const lastPart = baseValue % range;\n            const basePart = baseValue - lastPart;\n            if (baseValue > 0) {\n                value = basePart + value;\n            } else {\n                value = basePart - value;\n            }\n            if (value < baseValue) {\n                value += range;\n            }\n        }\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    }\n\n    withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n    }\n\n    /**\n     *\n     * @param {number} subsequentWidth\n     * @returns {ReducedPrinterParser}\n     */\n    withSubsequentWidth(subsequentWidth) {\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate,\n            this._subsequentWidth + subsequentWidth);\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     */\n    isFixedWidth(context) {\n        if (context.isStrict() === false) {\n            return false;\n        }\n        return super.isFixedWidth(context);\n    }\n\n    toString() {\n        return `ReducedValue(${this._field},${this._minWidth},${this._maxWidth},${this._baseDate != null ? this._baseDate : this._baseValue})`;\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/NumberPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1306,
    "kind": "variable",
    "name": "MAX_WIDTH",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~MAX_WIDTH",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/NumberPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1307,
    "kind": "variable",
    "name": "EXCEED_POINTS",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~EXCEED_POINTS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/NumberPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "number[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1308,
    "kind": "class",
    "name": "NumberPrinterParser",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/NumberPrinterParser.js",
    "importStyle": "{NumberPrinterParser}",
    "description": "",
    "lineNumber": 34,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1309,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to print, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "minWidth",
        "description": "the minimum field width, from 1 to 19"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the maximum field width, from minWidth to 19"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signStyle",
        "description": "the positive/negative sign style, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "subsequentWidth",
        "description": "the width of subsequent non-negative numbers, 0 or greater,\n -1 if fixed width due to active adjacent parsing"
      }
    ]
  },
  {
    "__docId__": 1310,
    "kind": "member",
    "name": "_field",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_field",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1311,
    "kind": "member",
    "name": "_minWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_minWidth",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1312,
    "kind": "member",
    "name": "_maxWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_maxWidth",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1313,
    "kind": "member",
    "name": "_signStyle",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_signStyle",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1314,
    "kind": "member",
    "name": "_subsequentWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_subsequentWidth",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1315,
    "kind": "method",
    "name": "field",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#field",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1316,
    "kind": "method",
    "name": "minWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#minWidth",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1317,
    "kind": "method",
    "name": "maxWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#maxWidth",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1318,
    "kind": "method",
    "name": "signStyle",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#signStyle",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1319,
    "kind": "method",
    "name": "withFixedWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#withFixedWidth",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1320,
    "kind": "method",
    "name": "withSubsequentWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#withSubsequentWidth",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "subsequentWidth",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1321,
    "kind": "method",
    "name": "_isFixedWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_isFixedWidth",
    "access": "private",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1322,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1323,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1324,
    "kind": "method",
    "name": "_getValue",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_getValue",
    "access": "private",
    "description": "Gets the value to output.\n(This is needed to allow e.g. ReducedPrinterParser to override this and change the value!",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "the context"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value of the field, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the value"
    },
    "ignore": true
  },
  {
    "__docId__": 1325,
    "kind": "method",
    "name": "_setValue",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#_setValue",
    "access": "private",
    "description": "Stores the value.",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "the context to store into, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "errorPos",
        "description": "the position of the field being parsed"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "successPos",
        "description": "the position after the field being parsed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the new position"
    },
    "ignore": true
  },
  {
    "__docId__": 1326,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~NumberPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 231,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1327,
    "kind": "class",
    "name": "ReducedPrinterParser",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/NumberPrinterParser.js",
    "importStyle": "{ReducedPrinterParser}",
    "description": "Prints and parses a reduced numeric date-time field.",
    "lineNumber": 247,
    "interface": false,
    "extends": [
      "NumberPrinterParser"
    ],
    "ignore": true
  },
  {
    "__docId__": 1328,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to print, validated not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "width",
        "description": "the field width, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxWidth",
        "description": "the field max width, from 1 to 10"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "baseValue",
        "description": "the base value"
      },
      {
        "nullable": null,
        "types": [
          "ChronoLocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "baseDate",
        "description": "the base date"
      }
    ]
  },
  {
    "__docId__": 1329,
    "kind": "member",
    "name": "_baseValue",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#_baseValue",
    "access": "private",
    "description": null,
    "lineNumber": 277,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1330,
    "kind": "member",
    "name": "_baseDate",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#_baseDate",
    "access": "private",
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1331,
    "kind": "method",
    "name": "_getValue",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#_getValue",
    "access": "private",
    "description": "",
    "lineNumber": 286,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimePrintContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1332,
    "kind": "method",
    "name": "_setValue",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#_setValue",
    "access": "private",
    "description": "",
    "lineNumber": 310,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "errorPos",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "successPos",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1333,
    "kind": "method",
    "name": "withFixedWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#withFixedWidth",
    "access": "public",
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1334,
    "kind": "method",
    "name": "withSubsequentWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#withSubsequentWidth",
    "access": "public",
    "description": "",
    "lineNumber": 347,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ReducedPrinterParser}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "subsequentWidth",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ReducedPrinterParser"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1335,
    "kind": "method",
    "name": "isFixedWidth",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#isFixedWidth",
    "access": "public",
    "description": "",
    "lineNumber": 356,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1336,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/NumberPrinterParser.js~ReducedPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 363,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1337,
    "kind": "file",
    "name": "packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../../assert';\nimport { IllegalArgumentException } from '../../errors';\nimport { MathUtil } from '../../MathUtil';\n\nimport { ChronoField } from '../../temporal/ChronoField';\n\n//-----------------------------------------------------------------------\nconst PATTERNS = [\n    '+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'\n];\n/**\n * Prints or parses an offset ID.\n * @private\n */\nexport class OffsetIdPrinterParser  {\n\n    /**\n     * Constructor.\n     *\n     * @param {string} noOffsetText  the text to use for UTC, not null\n     * @param {string} pattern  the pattern\n     */\n    constructor(noOffsetText, pattern) {\n        requireNonNull(noOffsetText, 'noOffsetText');\n        requireNonNull(pattern, 'pattern');\n        this.noOffsetText = noOffsetText;\n        this.type = this._checkPattern(pattern);\n    }\n\n    /**\n     * @param {String} pattern\n     * @return {number}\n     */\n    _checkPattern(pattern) {\n        for (let i = 0; i < PATTERNS.length; i++) {\n            if (PATTERNS[i] === pattern) {\n                return i;\n            }\n        }\n        throw new IllegalArgumentException(`Invalid zone offset pattern: ${pattern}`);\n    }\n\n    /**\n     * @param {DateTimePrintContext} context\n     * @param {StringBuilder} buf\n     * @return {boolean}\n     */\n    print(context, buf) {\n        const offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        if (offsetSecs == null) {\n            return false;\n        }\n        const totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs === 0) {\n            buf.append(this.noOffsetText);\n        } else {\n            const absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped\n            const absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n            const absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            const bufPos = buf.length();\n            let output = absHours;\n            buf.append(totalSecs < 0 ? '-' : '+')\n                .appendChar((`${MathUtil.intDiv(absHours, 10)}0`)).appendChar(`${MathUtil.intMod(absHours, 10)}0`);\n            if (this.type >= 3 || (this.type >= 1 && absMinutes > 0)) {\n                buf.append((this.type % 2) === 0 ? ':' : '')\n                    .appendChar((`${MathUtil.intDiv(absMinutes, 10)}0`)).appendChar((`${absMinutes % 10}0`));\n                output += absMinutes;\n                if (this.type >= 7 || (this.type >= 5 && absSeconds > 0)) {\n                    buf.append((this.type % 2) === 0 ? ':' : '')\n                        .appendChar((`${MathUtil.intDiv(absSeconds, 10)}0`)).appendChar((`${absSeconds % 10}0`));\n                    output += absSeconds;\n                }\n            }\n            if (output === 0) {\n                buf.setLength(bufPos);\n                buf.append(this.noOffsetText);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        const noOffsetLen = this.noOffsetText.length;\n        if (noOffsetLen === 0) {\n            if (position === length) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n            }\n        } else {\n            if (position === length) {\n                return ~position;\n            }\n            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n            }\n        }\n\n        // parse normal plus/minus offset\n        const sign = text[position];  // IOOBE if invalid position\n        if (sign === '+' || sign === '-') {\n            // starts\n            const negative = (sign === '-' ? -1 : 1);\n            const array = [0,0,0,0];\n            array[0] = position + 1;\n            if ((this._parseNumber(array, 1, text, true) ||\n                this._parseNumber(array, 2, text, this.type >=3) ||\n                this._parseNumber(array, 3, text, false)) === false) {\n                // success\n                const offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n            }\n        }\n        // handle special case of empty no offset text\n        if (noOffsetLen === 0) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n        }\n        return ~position;\n    }\n\n    /**\n     * Parse a two digit zero-prefixed number.\n     *\n     * @param {number[]} array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null\n     * @param {number} arrayIndex  the index to parse the value into\n     * @param {string} parseText  the offset ID, not null\n     * @param {boolean} required  whether this number is required\n     * @return {boolean} true if an error occurred\n     */\n    _parseNumber(array, arrayIndex, parseText, required) {\n        if ((this.type + 3) / 2 < arrayIndex) {\n            return false;  // ignore seconds/minutes\n        }\n        let pos = array[0];\n        if ((this.type % 2) === 0 && arrayIndex > 1) {\n            if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n                return required;\n            }\n            pos++;\n        }\n        if (pos + 2 > parseText.length) {\n            return required;\n        }\n        const ch1 = parseText[pos++];\n        const ch2 = parseText[pos++];\n        if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n            return required;\n        }\n        const value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n        if (value < 0 || value > 59) {\n            return required;\n        }\n        array[arrayIndex] = value;\n        array[0] = pos;\n        return false;\n    }\n\n\n    toString() {\n        const converted = this.noOffsetText.replace('\\'', '\\'\\'');\n        return `Offset(${PATTERNS[this.type]},'${converted}')`;\n    }\n}\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1338,
    "kind": "variable",
    "name": "PATTERNS",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~PATTERNS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1339,
    "kind": "class",
    "name": "OffsetIdPrinterParser",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/OffsetIdPrinterParser.js",
    "importStyle": "{OffsetIdPrinterParser}",
    "description": "Prints or parses an offset ID.",
    "lineNumber": 21,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1340,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "noOffsetText",
        "description": "the text to use for UTC, not null"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": "the pattern"
      }
    ]
  },
  {
    "__docId__": 1341,
    "kind": "member",
    "name": "noOffsetText",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#noOffsetText",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1342,
    "kind": "member",
    "name": "type",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#type",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1343,
    "kind": "method",
    "name": "_checkPattern",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#_checkPattern",
    "access": "private",
    "description": "",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "pattern",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1344,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#print",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimePrintContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "StringBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1345,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#parse",
    "access": "public",
    "description": "",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1346,
    "kind": "method",
    "name": "_parseNumber",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#_parseNumber",
    "access": "private",
    "description": "Parse a two digit zero-prefixed number.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": "the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arrayIndex",
        "description": "the index to parse the value into"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parseText",
        "description": "the offset ID, not null"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "required",
        "description": "whether this number is required"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if an error occurred"
    },
    "ignore": true
  },
  {
    "__docId__": 1347,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/OffsetIdPrinterParser.js~OffsetIdPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1348,
    "kind": "file",
    "name": "packages/core/src/format/parser/PadPrinterParserDecorator.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert } from '../../assert';\n\nimport { DateTimeException } from '../../errors';\n\n/**\n * Pads the output to a fixed width.\n * @private\n */\nexport class PadPrinterParserDecorator {\n\n    /**\n     * Constructor.\n     *\n     * @param printerParser  the printer, not null\n     * @param padWidth  the width to pad to, 1 or greater\n     * @param padChar  the pad character\n     */\n    constructor(printerParser, padWidth, padChar) {\n        // input checked by DateTimeFormatterBuilder\n        this._printerParser = printerParser;\n        this._padWidth = padWidth;\n        this._padChar = padChar;\n    }\n\n    print(context, buf) {\n        const preLen = buf.length();\n        if (this._printerParser.print(context, buf) === false) {\n            return false;\n        }\n        const len = buf.length() - preLen;\n        if (len > this._padWidth) {\n            throw new DateTimeException(\n                `Cannot print as output of ${len} characters exceeds pad width of ${this._padWidth}`);\n        }\n        for (let i = 0; i < this._padWidth - len; i++) {\n            buf.insert(preLen, this._padChar);\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        // cache context before changed by decorated parser\n        const strict = context.isStrict();\n        const caseSensitive = context.isCaseSensitive();\n        // parse\n        assert(!(position > text.length));\n        assert(position >= 0);\n        if (position === text.length) {\n            return ~position;  // no more characters in the string\n        }\n        let endPos = position + this._padWidth;\n        if (endPos > text.length) {\n            if (strict) {\n                return ~position;  // not enough characters in the string to meet the parse width\n            }\n            endPos = text.length;\n        }\n        let pos = position;\n        while (pos < endPos &&\n        (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n            pos++;\n        }\n        text = text.substring(0, endPos);\n        const resultPos = this._printerParser.parse(context, text, pos);\n        if (resultPos !== endPos && strict) {\n            return ~(position + pos);  // parse of decorated field didn't parse to the end\n        }\n        return resultPos;\n    }\n\n    toString() {\n        return `Pad(${this._printerParser},${this._padWidth}${(this._padChar === ' ' ? ')' : `,'${this._padChar}')`)}`;\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/PadPrinterParserDecorator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1349,
    "kind": "class",
    "name": "PadPrinterParserDecorator",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js",
    "static": true,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/PadPrinterParserDecorator.js",
    "importStyle": "{PadPrinterParserDecorator}",
    "description": "Pads the output to a fixed width.",
    "lineNumber": 15,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1350,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "printerParser",
        "description": "the printer, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "padWidth",
        "description": "the width to pad to, 1 or greater"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "padChar",
        "description": "the pad character"
      }
    ]
  },
  {
    "__docId__": 1351,
    "kind": "member",
    "name": "_printerParser",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#_printerParser",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1352,
    "kind": "member",
    "name": "_padWidth",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#_padWidth",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1353,
    "kind": "member",
    "name": "_padChar",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#_padChar",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1354,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#print",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1355,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#parse",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1356,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/PadPrinterParserDecorator.js~PadPrinterParserDecorator#toString",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1357,
    "kind": "file",
    "name": "packages/core/src/format/parser/SettingsParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { Enum } from '../../Enum';\n\n/**\n * @private\n */\nexport class SettingsParser extends Enum {\n\n    print(/*context, buf*/) {\n        return true;  // nothing to do here\n    }\n\n    parse(context, text, position) {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   context.setCaseSensitive(true); break;\n            case SettingsParser.INSENSITIVE: context.setCaseSensitive(false); break;\n            case SettingsParser.STRICT:      context.setStrict(true); break;\n            case SettingsParser.LENIENT:     context.setStrict(false); break;\n        }\n        return position;\n    }\n\n    toString() {\n        // using ordinals to avoid javac synthetic inner class\n        switch (this) {\n            case SettingsParser.SENSITIVE:   return 'ParseCaseSensitive(true)';\n            case SettingsParser.INSENSITIVE: return 'ParseCaseSensitive(false)';\n            case SettingsParser.STRICT:      return 'ParseStrict(true)';\n            case SettingsParser.LENIENT:     return 'ParseStrict(false)';\n        }\n    }\n}\n\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/SettingsParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1358,
    "kind": "class",
    "name": "SettingsParser",
    "memberof": "packages/core/src/format/parser/SettingsParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/SettingsParser.js~SettingsParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/SettingsParser.js",
    "importStyle": "{SettingsParser}",
    "description": "",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ],
    "ignore": true
  },
  {
    "__docId__": 1359,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/SettingsParser.js~SettingsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/SettingsParser.js~SettingsParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1360,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/SettingsParser.js~SettingsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/SettingsParser.js~SettingsParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1361,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/SettingsParser.js~SettingsParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/SettingsParser.js~SettingsParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1362,
    "kind": "file",
    "name": "packages/core/src/format/parser/StringLiteralPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert } from '../../assert';\n\n/**\n * Prints or parses a string literal.\n * @private\n */\nexport class StringLiteralPrinterParser {\n\n    constructor(literal) {\n        this._literal = literal;\n    }\n\n    print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    }\n\n    parse(context, text, position) {\n        const length = text.length;\n        assert(!(position > length || position < 0));\n\n        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    }\n\n    toString() {\n        const converted = this._literal.replace(\"'\", \"''\");\n        return `'${converted}'`;\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/StringLiteralPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1363,
    "kind": "class",
    "name": "StringLiteralPrinterParser",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/StringLiteralPrinterParser.js",
    "importStyle": "{StringLiteralPrinterParser}",
    "description": "Prints or parses a string literal.",
    "lineNumber": 13,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1364,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true
  },
  {
    "__docId__": 1365,
    "kind": "member",
    "name": "_literal",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser#_literal",
    "access": "private",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1366,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1367,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1368,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/StringLiteralPrinterParser.js~StringLiteralPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1369,
    "kind": "file",
    "name": "packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ZoneOffset } from '../../ZoneOffset';\nimport { ZoneId } from '../../ZoneId';\nimport { ZoneRegion } from '../../ZoneRegion';\n\nimport { ChronoField } from '../../temporal/ChronoField';\n\nimport { ZoneRulesProvider } from '../../zone/ZoneRulesProvider';\n\nimport { OffsetIdPrinterParser } from './OffsetIdPrinterParser';\n\n/**\n * Prints or parses a zone ID.\n * @private\n */\nexport class ZoneIdPrinterParser {\n\n    /**\n     *\n     * @param {TemporalQuery} query\n     * @param {string} description\n     */\n    constructor(query, description) {\n        this.query = query;\n        this.description = description;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {DateTimePrintContext } context\n     * @param {StringBuilder} buf\n     * @returns {boolean}\n     */\n    print(context, buf) {\n        const zone = context.getValueQuery(this.query);\n        if (zone == null) {\n            return false;\n        }\n        buf.append(zone.id());\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * This implementation looks for the longest matching string.\n     * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just\n     * Etc/GMC although both are valid.\n     *\n     * This implementation uses a tree to search for valid time-zone names in\n     * the parseText. The top level node of the tree has a length equal to the\n     * length of the shortest time-zone as well as the beginning characters of\n     * all other time-zones.\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} position\n     * @return {number}\n     */\n    parse(context, text, position) {\n        const length = text.length;\n        if (position > length) {\n            return ~position;\n        }\n        if (position === length) {\n            return ~position;\n        }\n\n        // handle fixed time-zone IDs\n        const nextChar = text.charAt(position);\n        if (nextChar === '+' || nextChar === '-') {\n            const newContext = context.copy();\n            const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n            if (endPos < 0) {\n                return endPos;\n            }\n            const offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n            const zone = ZoneOffset.ofTotalSeconds(offset);\n            context.setParsedZone(zone);\n            return endPos;\n        } else if (length >= position + 2) {\n            const nextNextChar = text.charAt(position + 1);\n            if (context.charEquals(nextChar, 'U') &&\n                context.charEquals(nextNextChar, 'T')) {\n                if (length >= position + 3 &&\n                    context.charEquals(text.charAt(position + 2), 'C')) {\n                    return this._parsePrefixedOffset(context, text, position, position + 3);\n                }\n                return this._parsePrefixedOffset(context, text, position, position + 2);\n            } else if (context.charEquals(nextChar, 'G') &&\n                length >= position + 3 &&\n                context.charEquals(nextNextChar, 'M') &&\n                context.charEquals(text.charAt(position + 2), 'T')) {\n                return this._parsePrefixedOffset(context, text, position, position + 3);\n            }\n        }\n        // javascript special case\n        if(text.substr(position, 6) === 'SYSTEM'){\n            context.setParsedZone(ZoneId.systemDefault());\n            return position + 6;\n        }\n\n        // ...\n        if (context.charEquals(nextChar, 'Z')) {\n            context.setParsedZone(ZoneOffset.UTC);\n            return position + 1;\n        }\n\n        const availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n        if (zoneIdTree.size !== availableZoneIds.length) {\n            zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n        }\n\n        const maxParseLength = length - position;\n        let treeMap = zoneIdTree.treeMap;\n        let parsedZoneId = null;\n        let parseLength = 0;\n        while(treeMap != null) {\n            const parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n            treeMap = treeMap.get(parsedSubZoneId);\n            if (treeMap != null && treeMap.isLeaf) {\n                parsedZoneId = parsedSubZoneId;\n                parseLength = treeMap.length;\n            }\n        }\n        if (parsedZoneId != null) {\n            context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n            return position + parseLength;\n        }\n\n        return ~position;\n    }\n\n    /**\n     *\n     * @param {DateTimeParseContext} context\n     * @param {String} text\n     * @param {number} prefixPos\n     * @param {number} position\n     * @return {number}\n     */\n    _parsePrefixedOffset(context, text, prefixPos, position) {\n        const prefix = text.substring(prefixPos, position).toUpperCase();\n        const newContext = context.copy();\n        if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n        if (endPos < 0) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        const offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n        const offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n        return endPos;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this.description;\n    }\n}\n\nclass ZoneIdTree {\n\n    static createTreeMap(availableZoneIds) {\n        const sortedZoneIds =  availableZoneIds.sort((a, b) => a.length - b.length);\n        const treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n        for (let i=0; i<sortedZoneIds.length; i++){\n            treeMap.add(sortedZoneIds[i]);\n        }\n        return new ZoneIdTree(sortedZoneIds.length, treeMap);\n    }\n\n    constructor(size, treeMap) {\n        this.size = size;\n        this.treeMap = treeMap;\n    }\n}\n\nclass ZoneIdTreeMap {\n    constructor(length = 0, isLeaf = false){\n        this.length = length;\n        this.isLeaf = isLeaf;\n        this._treeMap = {};\n    }\n\n    add(zoneId){\n        const idLength = zoneId.length;\n        if(idLength === this.length) {\n            this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n        } else if (idLength > this.length) {\n            const subZoneId = zoneId.substr(0, this.length);\n            let subTreeMap = this._treeMap[subZoneId];\n            if (subTreeMap == null) {\n                subTreeMap = new ZoneIdTreeMap(idLength, false);\n                this._treeMap[subZoneId] = subTreeMap;\n            }\n            subTreeMap.add(zoneId);\n        }\n    }\n\n    get(zoneId){\n        return this._treeMap[zoneId];\n    }\n}\n\nlet zoneIdTree = new ZoneIdTree([]);",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1370,
    "kind": "class",
    "name": "ZoneIdPrinterParser",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "importStyle": "{ZoneIdPrinterParser}",
    "description": "Prints or parses a zone ID.",
    "lineNumber": 21,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1371,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 1372,
    "kind": "member",
    "name": "query",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#query",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1373,
    "kind": "member",
    "name": "description",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#description",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1374,
    "kind": "method",
    "name": "print",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#print",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimePrintContext "
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "StringBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1375,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#parse",
    "access": "public",
    "description": "This implementation looks for the longest matching string.\nFor example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just\nEtc/GMC although both are valid.\n\nThis implementation uses a tree to search for valid time-zone names in\nthe parseText. The top level node of the tree has a length equal to the\nlength of the shortest time-zone as well as the beginning characters of\nall other time-zones.",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1376,
    "kind": "method",
    "name": "_parsePrefixedOffset",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#_parsePrefixedOffset",
    "access": "private",
    "description": "",
    "lineNumber": 147,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeParseContext"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "prefixPos",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1377,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdPrinterParser#toString",
    "access": "public",
    "description": "",
    "lineNumber": 169,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1378,
    "kind": "class",
    "name": "ZoneIdTree",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1379,
    "kind": "method",
    "name": "createTreeMap",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree.createTreeMap",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "availableZoneIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1380,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true
  },
  {
    "__docId__": 1381,
    "kind": "member",
    "name": "size",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree#size",
    "access": "public",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1382,
    "kind": "member",
    "name": "treeMap",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree#treeMap",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1383,
    "kind": "class",
    "name": "ZoneIdTreeMap",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 1384,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true
  },
  {
    "__docId__": 1385,
    "kind": "member",
    "name": "length",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#length",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1386,
    "kind": "member",
    "name": "isLeaf",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#isLeaf",
    "access": "public",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1387,
    "kind": "member",
    "name": "_treeMap",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#_treeMap",
    "access": "private",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 1388,
    "kind": "method",
    "name": "add",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#add",
    "access": "public",
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "params": [
      {
        "name": "zoneId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1389,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTreeMap#get",
    "access": "public",
    "description": null,
    "lineNumber": 213,
    "undocument": true,
    "params": [
      {
        "name": "zoneId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1390,
    "kind": "variable",
    "name": "zoneIdTree",
    "memberof": "packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "static": true,
    "longname": "packages/core/src/format/parser/ZoneIdPrinterParser.js~zoneIdTree",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/format/parser/ZoneIdPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "type": {
      "types": [
        "packages/core/src/format/parser/ZoneIdPrinterParser.js~ZoneIdTree"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1391,
    "kind": "file",
    "name": "packages/core/src/js-joda.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException\n} from './errors';\n\nimport { Clock } from './Clock';\nimport { DayOfWeek } from './DayOfWeek';\nimport { Duration } from './Duration';\nimport { Instant } from './Instant';\nimport { LocalDate } from './LocalDate';\nimport { LocalTime } from './LocalTime';\nimport { LocalDateTime } from './LocalDateTime';\nimport { Month } from './Month';\nimport { MonthDay } from './MonthDay';\nimport { OffsetDateTime } from './OffsetDateTime';\nimport { OffsetTime } from './OffsetTime';\nimport { Period } from './Period';\nimport { Year } from './Year';\nimport { YearConstants } from './YearConstants';\nimport { YearMonth } from './YearMonth';\nimport { ZonedDateTime } from './ZonedDateTime';\nimport { ZoneOffset } from './ZoneOffset';\nimport { ZoneId } from './ZoneId';\nimport { ZoneRegion } from './ZoneRegion';\n\nimport { ZoneOffsetTransition } from './zone/ZoneOffsetTransition';\nimport { ZoneRules } from './zone/ZoneRules';\nimport { ZoneRulesProvider } from './zone/ZoneRulesProvider';\n\nimport { ChronoLocalDate } from './chrono/ChronoLocalDate';\nimport { ChronoLocalDateTime } from './chrono/ChronoLocalDateTime';\nimport { ChronoZonedDateTime } from './chrono/ChronoZonedDateTime';\nimport { IsoChronology } from './chrono/IsoChronology';\n\nimport { ChronoField } from './temporal/ChronoField';\nimport { ChronoUnit } from './temporal/ChronoUnit';\nimport { IsoFields } from './temporal/IsoFields';\nimport { Temporal } from './temporal/Temporal';\nimport { TemporalAccessor } from './temporal/TemporalAccessor';\nimport { TemporalAdjuster } from './temporal/TemporalAdjuster';\nimport { TemporalAdjusters } from './temporal/TemporalAdjusters';\nimport { TemporalAmount } from './temporal/TemporalAmount';\nimport { TemporalField } from './temporal/TemporalField';\nimport { TemporalQueries } from './temporal/TemporalQueries';\nimport { TemporalQuery } from './temporal/TemporalQuery';\nimport { TemporalUnit } from './temporal/TemporalUnit';\nimport { ValueRange } from './temporal/ValueRange';\n\nimport { DateTimeFormatter } from './format/DateTimeFormatter';\nimport { DateTimeFormatterBuilder } from './format/DateTimeFormatterBuilder';\nimport { DecimalStyle } from './format/DecimalStyle';\nimport { ParsePosition } from './format/ParsePosition';\nimport { ResolverStyle } from './format/ResolverStyle';\nimport { SignStyle } from './format/SignStyle';\nimport { TextStyle } from './format/TextStyle';\n\n// init static properties\nimport './_init';\n\n// private/internal exports, e.g. for use in plugins\nimport { MathUtil } from './MathUtil';\nimport { StringUtil } from './StringUtil';\nimport { DateTimeBuilder } from './format/DateTimeBuilder';\nimport { DateTimeParseContext } from './format/DateTimeParseContext';\nimport { DateTimePrintContext } from './format/DateTimePrintContext';\nimport { StringBuilder } from './format/StringBuilder';\nimport * as assert from './assert';\n\nimport { convert } from './convert';\nimport { nativeJs } from './nativeJs';\nimport { bindUse } from './use';\n\nconst _ = {\n    assert,\n    DateTimeBuilder,\n    DateTimeParseContext,\n    DateTimePrintContext,\n    MathUtil,\n    StringUtil,\n    StringBuilder,\n};\n\nconst jsJodaExports = {\n    _,\n    convert,\n    nativeJs,\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException,\n    Clock,\n    DayOfWeek,\n    Duration,\n    Instant,\n    LocalDate,\n    LocalTime,\n    LocalDateTime,\n    OffsetTime,\n    OffsetDateTime,\n    Month,\n    MonthDay,\n    ParsePosition,\n    Period,\n    Year,\n    YearConstants,\n    YearMonth,\n    ZonedDateTime,\n    ZoneOffset,\n    ZoneId,\n    ZoneRegion,\n    ZoneOffsetTransition,\n    ZoneRules,\n    ZoneRulesProvider,\n    ChronoLocalDate,\n    ChronoLocalDateTime,\n    ChronoZonedDateTime,\n    IsoChronology,\n    ChronoField,\n    ChronoUnit,\n    IsoFields,\n    Temporal,\n    TemporalAccessor,\n    TemporalAdjuster,\n    TemporalAdjusters,\n    TemporalAmount,\n    TemporalField,\n    TemporalQueries,\n    TemporalQuery,\n    TemporalUnit,\n    ValueRange,\n    DateTimeFormatter,\n    DateTimeFormatterBuilder,\n    DecimalStyle,\n    ResolverStyle,\n    SignStyle,\n    TextStyle,\n};\n\n/**\n * @private\n *\n * @type { function(function(jsJoda: JsJoda) }\n */\nconst use = bindUse(jsJodaExports);\njsJodaExports.use = use;\n\nexport {\n    _,\n    use,\n    convert,\n    nativeJs,\n    ArithmeticException,\n    DateTimeException,\n    DateTimeParseException,\n    IllegalArgumentException,\n    IllegalStateException,\n    UnsupportedTemporalTypeException,\n    NullPointerException,\n    Clock,\n    DayOfWeek,\n    Duration,\n    Instant,\n    LocalDate,\n    LocalTime,\n    LocalDateTime,\n    Month,\n    MonthDay,\n    OffsetTime,\n    OffsetDateTime,\n    Period,\n    ParsePosition,\n    Year,\n    YearConstants,\n    YearMonth,\n    ZonedDateTime,\n    ZoneOffset,\n    ZoneId,\n    ZoneRegion,\n    ZoneOffsetTransition,\n    ZoneRules,\n    ZoneRulesProvider,\n    ChronoLocalDate,\n    ChronoLocalDateTime,\n    ChronoZonedDateTime,\n    IsoChronology,\n    ChronoField,\n    ChronoUnit,\n    IsoFields,\n    Temporal,\n    TemporalAccessor,\n    TemporalAdjuster,\n    TemporalAdjusters,\n    TemporalAmount,\n    TemporalField,\n    TemporalQueries,\n    TemporalQuery,\n    TemporalUnit,\n    ValueRange,\n    DateTimeFormatter,\n    DateTimeFormatterBuilder,\n    DecimalStyle,\n    ResolverStyle,\n    SignStyle,\n    TextStyle,\n};\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/js-joda.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1392,
    "kind": "variable",
    "name": "jsJodaExports",
    "memberof": "packages/core/src/js-joda.js",
    "static": true,
    "longname": "packages/core/src/js-joda.js~jsJodaExports",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/js-joda.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "{\"_\": *, \"convert\": *, \"nativeJs\": *, \"ArithmeticException\": *, \"DateTimeException\": *, \"DateTimeParseException\": *, \"IllegalArgumentException\": *, \"IllegalStateException\": *, \"UnsupportedTemporalTypeException\": *, \"NullPointerException\": *, \"Clock\": *, \"DayOfWeek\": *, \"Duration\": *, \"Instant\": *, \"LocalDate\": *, \"LocalTime\": *, \"LocalDateTime\": *, \"OffsetTime\": *, \"OffsetDateTime\": *, \"Month\": *, \"MonthDay\": *, \"ParsePosition\": *, \"Period\": *, \"Year\": *, \"YearConstants\": *, \"YearMonth\": *, \"ZonedDateTime\": *, \"ZoneOffset\": *, \"ZoneId\": *, \"ZoneRegion\": *, \"ZoneOffsetTransition\": *, \"ZoneRules\": *, \"ZoneRulesProvider\": *, \"ChronoLocalDate\": *, \"ChronoLocalDateTime\": *, \"ChronoZonedDateTime\": *, \"IsoChronology\": *, \"ChronoField\": *, \"ChronoUnit\": *, \"IsoFields\": *, \"Temporal\": *, \"TemporalAccessor\": *, \"TemporalAdjuster\": *, \"TemporalAdjusters\": *, \"TemporalAmount\": *, \"TemporalField\": *, \"TemporalQueries\": *, \"TemporalQuery\": *, \"TemporalUnit\": *, \"ValueRange\": *, \"DateTimeFormatter\": *, \"DateTimeFormatterBuilder\": *, \"DecimalStyle\": *, \"ResolverStyle\": *, \"SignStyle\": *, \"TextStyle\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1393,
    "kind": "variable",
    "name": "_",
    "memberof": "packages/core/src/js-joda.js",
    "static": true,
    "longname": "packages/core/src/js-joda.js~_",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/js-joda.js",
    "importStyle": "{_}",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{\"assert\": *, \"DateTimeBuilder\": *, \"DateTimeParseContext\": *, \"DateTimePrintContext\": *, \"MathUtil\": *, \"StringUtil\": *, \"StringBuilder\": *}"
      ]
    }
  },
  {
    "__docId__": 1394,
    "kind": "variable",
    "name": "use",
    "memberof": "packages/core/src/js-joda.js",
    "static": true,
    "longname": "packages/core/src/js-joda.js~use",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/js-joda.js",
    "importStyle": "{use}",
    "description": "",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        " function(function(jsJoda: JsJoda) "
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 1395,
    "kind": "file",
    "name": "packages/core/src/nativeJs.js",
    "content": "/*\n * @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from './assert';\nimport { IllegalArgumentException } from './errors';\nimport { Instant, ZoneId } from './js-joda';\n\n/**\n * Creates ZonedDateTime from a javascript Date or a moment instance.\n * @param {!(Date|moment)} date - a javascript Date or a moment instance\n * @param {ZoneId} [zone = ZoneId.systemDefault()] - the zone of the returned ZonedDateTime, defaults to ZoneId.systemDefault()\n * @returns {ZonedDateTime}\n */\nexport function nativeJs(date, zone = ZoneId.systemDefault()) {\n    requireNonNull(date, 'date');\n    requireNonNull(zone, 'zone');\n    if(date instanceof Date) {\n        return Instant.ofEpochMilli(date.getTime()).atZone(zone);\n    } else if(typeof date.toDate === 'function' &&  date.toDate() instanceof Date) {\n        return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);\n    }\n    throw new IllegalArgumentException('date must be a javascript Date or a moment instance');\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/nativeJs.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1396,
    "kind": "function",
    "name": "nativeJs",
    "memberof": "packages/core/src/nativeJs.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/nativeJs.js~nativeJs",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/nativeJs.js",
    "importStyle": "{nativeJs}",
    "description": "Creates ZonedDateTime from a javascript Date or a moment instance.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZonedDateTime}"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "Date",
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "a javascript Date or a moment instance"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": " ZoneId.systemDefault()",
        "defaultRaw": " ZoneId.systemDefault()",
        "name": "zone",
        "description": "the zone of the returned ZonedDateTime, defaults to ZoneId.systemDefault()"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZonedDateTime"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1397,
    "kind": "file",
    "name": "packages/core/src/temporal/ChronoField.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MAX_SAFE_INTEGER, MIN_SAFE_INTEGER } from '../MathUtil';\n\nimport { ChronoUnit } from './ChronoUnit';\nimport { TemporalField } from './TemporalField';\nimport { ValueRange } from './ValueRange';\nimport { YearConstants } from '../YearConstants';\n\n/**\n * A standard set of fields.\n *\n * This set of fields provide field-based access to manipulate a date, time or date-time.\n * The standard set of fields can be extended by implementing {@link TemporalField}.\n *\n * These fields are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define dates as a year, month and day,\n * just with slightly different rules.\n * The documentation of each field explains how it operates.\n *\n * ### Static properties:\n *\n * - `ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH`: This represents concept of the count of\n * days within the period of a week where the weeks are aligned to the start of the month.\n * This field is typically used with `ALIGNED_WEEK_OF_MONTH`.\n * \n * - `ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR`: This represents concept of the count of days\n * within the period of a week where the weeks are aligned to the start of the year.\n * This field is typically used with `ALIGNED_WEEK_OF_YEAR`.\n * \n * - `ChronoField.ALIGNED_WEEK_OF_MONTH`: This represents concept of the count of weeks within\n * the period of a month where the weeks are aligned to the start of the month. This field\n * is typically used with `ALIGNED_DAY_OF_WEEK_IN_MONTH`.\n * \n * - `ChronoField.ALIGNED_WEEK_OF_YEAR`: This represents concept of the count of weeks within\n * the period of a year where the weeks are aligned to the start of the year. This field\n * is typically used with `ALIGNED_DAY_OF_WEEK_IN_YEAR`.\n * \n * - `ChronoField.AMPM_OF_DAY`: This counts the AM/PM within the day, from 0 (AM) to 1 (PM).\n * \n * - `ChronoField.CLOCK_HOUR_OF_AMPM`: This counts the hour within the AM/PM, from 1 to 12.\n * This is the hour that would be observed on a standard 12-hour analog wall clock.\n * \n * - `ChronoField.CLOCK_HOUR_OF_DAY`: This counts the hour within the AM/PM, from 1 to 24.\n * This is the hour that would be observed on a 24-hour analog wall clock.\n * \n * - `ChronoField.DAY_OF_MONTH`: This represents the concept of the day within the month.\n * In the default ISO calendar system, this has values from 1 to 31 in most months.\n * April, June, September, November have days from 1 to 30, while February has days from\n * 1 to 28, or 29 in a leap year.\n * \n * - `ChronoField.DAY_OF_WEEK`: This represents the standard concept of the day of the week.\n * In the default ISO calendar system, this has values from Monday (1) to Sunday (7).\n * The {@link DayOfWeek} class can be used to interpret the result.\n * \n * - `ChronoField.DAY_OF_YEAR`: This represents the concept of the day within the year.\n * In the default ISO calendar system, this has values from 1 to 365 in standard years and\n * 1 to 366 in leap years.\n * \n * - `ChronoField.EPOCH_DAY`: This field is the sequential count of days where\n * 1970-01-01 (ISO) is zero. Note that this uses the local time-line, ignoring offset and\n * time-zone.\n * \n * - `ChronoField.ERA`: This represents the concept of the era, which is the largest\n * division of the time-line. This field is typically used with `YEAR_OF_ERA`.\n * \n *     In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era\n * 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.\n * The era 'BCE' is the previous era, and the year-of-era runs backwards.\n * \n * - `ChronoField.HOUR_OF_AMPM`: This counts the hour within the AM/PM, from 0 to 11.\n * This is the hour that would be observed on a standard 12-hour digital clock.\n * \n * - `ChronoField.HOUR_OF_DAY`: This counts the hour within the day, from 0 to 23. This is\n * the hour that would be observed on a standard 24-hour digital clock.\n * \n * - `ChronoField.INSTANT_SECONDS`: This represents the concept of the sequential count of\n * seconds where 1970-01-01T00:00Z (ISO) is zero. This field may be used with `NANO_OF_DAY`\n * to represent the fraction of the day.\n * \n *     An Instant represents an instantaneous point on the time-line. On their own they have\n * no elements which allow a local date-time to be obtained. Only when paired with an offset\n * or time-zone can the local date or time be found. This field allows the seconds part of\n * the instant to be queried.\n * \n * - `ChronoField.MICRO_OF_DAY`: This counts the microsecond within the day, from 0 to\n * (24 * 60 * 60 * 1,000,000) - 1.\n * \n *     This field is used to represent the micro-of-day handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they\n * can return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n * \n *     When this field is used for setting a value, it should behave in the same way as\n * setting `NANO_OF_DAY` with the value multiplied by 1,000.\n * \n * - `ChronoField.MICRO_OF_SECOND`: This counts the microsecond within the second, from 0\n * to 999,999.\n * \n *     This field is used to represent the micro-of-second handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they\n * can return a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling\n * unknown precision with zero.\n * \n * - `ChronoField.MILLI_OF_DAY`: This counts the millisecond within the day, from 0 to\n * (24 * 60 * 60 * 1,000) - 1.\n * \n *     This field is used to represent the milli-of-day handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they\n * can return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n * \n *     When this field is used for setting a value, it should behave in the same way as\n * setting `NANO_OF_DAY` with the value multiplied by 1,000,000.\n * \n * - `ChronoField.MILLI_OF_SECOND`: This counts the millisecond within the second, from 0 to\n * 999.\n * \n *     This field is used to represent the milli-of-second handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they can\n * return a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling unknown\n * precision with zero.\n * \n *     When this field is used for setting a value, it should behave in the same way as\n * setting `NANO_OF_SECOND` with the value multiplied by 1,000,000.\n * \n * - `ChronoField.MINUTE_OF_DAY`: This counts the minute within the day, from 0 to (24 * 60) - 1.\n * \n * - `ChronoField.MINUTE_OF_HOUR`: This counts the minute within the hour, from 0 to 59.\n * \n * - `ChronoField.MONTH_OF_YEAR`: The month-of-year, such as March. This represents the concept\n * of the month within the year. In the default ISO calendar system, this has values from\n * January (1) to December (12).\n * \n * - `ChronoField.NANO_OF_DAY`: This counts the nanosecond within the day, from 0 to\n * (24 * 60 * 60 * 1,000,000,000) - 1.\n * \n *     This field is used to represent the nano-of-day handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they\n * can return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n * \n * - `ChronoField.NANO_OF_SECOND`: This counts the nanosecond within the second, from 0\n * to 999,999,999.\n * \n *     This field is used to represent the nano-of-second handling any fraction of the second.\n * Implementations of {@link TemporalAccessor} should provide a value for this field if they\n * can return a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling\n * unknown precision with zero.\n * \n *     When this field is used for setting a value, it should set as much precision as the\n * object stores, using integer division to remove excess precision. For example, if the\n * {@link TemporalAccessor} stores time to millisecond precision, then the nano-of-second must\n * be divided by 1,000,000 before replacing the milli-of-second.\n * \n * - `ChronoField.OFFSET_SECONDS`: This represents the concept of the offset in seconds of\n * local time from UTC/Greenwich.\n * \n *     A {@link ZoneOffset} represents the period of time that local time differs from\n * UTC/Greenwich. This is usually a fixed number of hours and minutes. It is equivalent to\n * the total amount of the offset in seconds. For example, during the winter Paris has an\n * offset of +01:00, which is 3600 seconds.\n * \n * - `ChronoField.PROLEPTIC_MONTH`: The proleptic-month, which counts months sequentially\n * from year 0.\n * \n *     The first month in year zero has the value zero. The value increase for later months\n * and decrease for earlier ones. Note that this uses the local time-line, ignoring offset\n * and time-zone.\n * \n * - `ChronoField.SECOND_OF_DAY`: This counts the second within the day, from 0 to\n * (24 * 60 * 60) - 1.\n * \n * - `ChronoField.SECOND_OF_MINUTE`: This counts the second within the minute, from 0 to 59.\n * \n * - `ChronoField.YEAR`: The proleptic year, such as 2012. This represents the concept of\n * the year, counting sequentially and using negative numbers. The proleptic year is not\n * interpreted in terms of the era.\n * \n *     The standard mental model for a date is based on three concepts - year, month and day.\n * These map onto the `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields. Note that there is no\n * reference to eras. The full model for a date requires four concepts - era, year, month and\n * day. These map onto the `ERA`, `YEAR_OF_ERA`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.\n * Whether this field or `YEAR_OF_ERA` is used depends on which mental model is being used.\n * \n * - `ChronoField.YEAR_OF_ERA`: This represents the concept of the year within the era. This\n * field is typically used with `ERA`. The standard mental model for a date is based on three\n * concepts - year, month and day. These map onto the `YEAR`, `MONTH_OF_YEAR` and\n * `DAY_OF_MONTH` fields. Note that there is no reference to eras. The full model for a date\n * requires four concepts - era, year, month and day. These map onto the `ERA`, `YEAR_OF_ERA`,\n * `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields. Whether this field or `YEAR` is used depends on\n * which mental model is being used.\n * \n *     In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'.\n * The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.\n * The era 'BCE' is the previous era, and the year-of-era runs backwards.\n * \n *     For example, subtracting a year each time yield the following:\n *    - year-proleptic 2 = 'CE' year-of-era 2\n *    - year-proleptic 1 = 'CE' year-of-era 1\n *    - year-proleptic 0 = 'BCE' year-of-era 1\n *    - year-proleptic -1 = 'BCE' year-of-era 2\n * \n *     Note that the ISO-8601 standard does not actually define eras. Note also that the\n * ISO eras do not align with the well-known AD/BC eras due to the change between the Julian\n * and Gregorian calendar systems.\n */\nexport class ChronoField extends TemporalField {\n\n    /**\n     * helper function to get one of the static ChronoField defines by name, needed to resolve ChronoField from EnumMap\n     *\n     * @param {String} fieldName\n     * @return {ChronoField | null}\n     * @private\n     */\n    static byName(fieldName) {\n        for (const prop in ChronoField) {\n            if (ChronoField[prop]) {\n                if ((ChronoField[prop] instanceof ChronoField) && ChronoField[prop].name() === fieldName) {\n                    return ChronoField[prop];\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {!string} name\n     * @param {!TemporalUnit} baseUnit\n     * @param {!TemporalUnit} rangeUnit\n     * @param {!ValueRange} range\n     * @private\n     */\n    constructor(name, baseUnit, rangeUnit, range) {\n        super();\n        this._name = name;\n        this._baseUnit = baseUnit;\n        this._rangeUnit = rangeUnit;\n        this._range = range;\n    }\n\n    /**\n     * @return {string}\n     */\n    name(){\n        return this._name;\n    }\n\n    /**\n     * @return {TemporalUnit} the period unit defining the base unit of the field.\n     */\n    baseUnit(){\n        return this._baseUnit;\n    }\n\n    /**\n     * @return {TemporalUnit} the period unit defining the range of the field.\n     */\n    rangeUnit(){\n        return this._rangeUnit;\n    }\n\n    /**\n     * @return {ValueRange} the range of valid values for the field.\n     */\n    range(){\n        return this._range;\n    }\n\n    /**\n     * @returns {string}\n     */\n    displayName(){\n        return this.toString();\n    }\n\n    /**\n     * Checks that the specified value is valid for this field.\n     *\n     * This validates that the value is within the outer range of valid values\n     * returned by {@link range}.\n     *\n     * This method checks against the range of the field in the ISO-8601 calendar system.\n     *\n     * @param {!number} value the value to check.\n     * @returns {number} the value that was passed in.\n     */\n    checkValidValue(value) {\n        return this.range().checkValidValue(value, this);\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the outer range of valid values\n     * returned by {@link range}.\n     * It also checks that all valid values are within the bounds of an `int`.\n     *\n     * This method checks against the range of the field in the ISO-8601 calendar system.\n     *\n     * @param {number} value the value to check.\n     * @return {number} the value that was passed in.\n     */\n    checkValidIntValue(value) {\n        return this.range().checkValidIntValue(value, this);\n    }\n\n    /**\n     * @return {boolean} `true` if it is a component of a date, `false` otherwise.\n     */\n    isDateBased() {\n        const dateBased =\n            this === ChronoField.DAY_OF_WEEK ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH ||\n            this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR ||\n            this === ChronoField.DAY_OF_MONTH ||\n            this === ChronoField.DAY_OF_YEAR ||\n            this === ChronoField.EPOCH_DAY ||\n            this === ChronoField.ALIGNED_WEEK_OF_MONTH ||\n            this === ChronoField.ALIGNED_WEEK_OF_YEAR ||\n            this === ChronoField.MONTH_OF_YEAR ||\n            this === ChronoField.PROLEPTIC_MONTH ||\n            this === ChronoField.YEAR_OF_ERA ||\n            this === ChronoField.YEAR ||\n            this === ChronoField.ERA;\n        return dateBased;\n    }\n\n    /**\n     * @return {boolean} `true` if it is a component of a time, `false` otherwise.\n     */\n    isTimeBased() {\n        const timeBased =\n            this === ChronoField.NANO_OF_SECOND     ||\n            this === ChronoField.NANO_OF_DAY        ||\n            this === ChronoField.MICRO_OF_SECOND    ||\n            this === ChronoField.MICRO_OF_DAY       ||\n            this === ChronoField.MILLI_OF_SECOND    ||\n            this === ChronoField.MILLI_OF_DAY       ||\n            this === ChronoField.SECOND_OF_MINUTE   ||\n            this === ChronoField.SECOND_OF_DAY      ||\n            this === ChronoField.MINUTE_OF_HOUR     ||\n            this === ChronoField.MINUTE_OF_DAY      ||\n            this === ChronoField.HOUR_OF_AMPM       ||\n            this === ChronoField.CLOCK_HOUR_OF_AMPM ||\n            this === ChronoField.HOUR_OF_DAY        ||\n            this === ChronoField.CLOCK_HOUR_OF_DAY  ||\n            this === ChronoField.AMPM_OF_DAY;\n        return timeBased;\n    }\n\n    /**\n     * @param {!TemporalAccessor} temporal the temporal object used to refine the result.\n     * @return {ValueRange} the range of valid values for this field.\n     * @throws {DateTimeException} if the range for the field cannot be obtained.\n     */\n    rangeRefinedBy(temporal) {\n        return temporal.range(this);\n    }\n\n    \n\n    /**\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {number} the value of this field.\n     * @throws {DateTimeException} if a value for the field cannot be obtained.\n     */\n    getFrom(temporal) {\n        return temporal.getLong(this);\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString(){\n        return this.name();\n    }\n\n    /**\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n\n    /**\n     * @param {!Temporal} temporal the temporal object to adjust.\n     * @param {!number} newValue the new value of the field.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws {DateTimeException} if the field cannot be set.\n     */\n    adjustInto(temporal, newValue) {\n        return temporal.with(this, newValue);\n    }\n\n    /**\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {boolean} `true` if the date-time can be queried for this field, `false` if not.\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(this);\n    }\n}\n\nexport function _init() {\n\n    ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n\n    ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n\n    ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n\n    ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n\n    ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n\n    ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n\n    ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n\n    ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n\n    ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n\n    ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, (24 * 60) - 1));\n\n    ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n\n    ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n\n    ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n\n    ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n\n    ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n\n    ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n\n    ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n\n    ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n\n    ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971)); // [LocalDate.MIN.toEpochDay() .. LocalDate.MAX.toEpochDay()]\n\n    ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n\n    ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n\n    ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n\n    ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n\n    ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n\n    ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n\n    ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n\n    ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n\n    ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/ChronoField.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1398,
    "kind": "class",
    "name": "ChronoField",
    "memberof": "packages/core/src/temporal/ChronoField.js",
    "static": true,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/ChronoField.js",
    "importStyle": "{ChronoField}",
    "description": "A standard set of fields.\n\nThis set of fields provide field-based access to manipulate a date, time or date-time.\nThe standard set of fields can be extended by implementing {@link TemporalField}.\n\nThese fields are intended to be applicable in multiple calendar systems.\nFor example, most non-ISO calendar systems define dates as a year, month and day,\njust with slightly different rules.\nThe documentation of each field explains how it operates.\n\n### Static properties:\n\n- `ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH`: This represents concept of the count of\ndays within the period of a week where the weeks are aligned to the start of the month.\nThis field is typically used with `ALIGNED_WEEK_OF_MONTH`.\n\n- `ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR`: This represents concept of the count of days\nwithin the period of a week where the weeks are aligned to the start of the year.\nThis field is typically used with `ALIGNED_WEEK_OF_YEAR`.\n\n- `ChronoField.ALIGNED_WEEK_OF_MONTH`: This represents concept of the count of weeks within\nthe period of a month where the weeks are aligned to the start of the month. This field\nis typically used with `ALIGNED_DAY_OF_WEEK_IN_MONTH`.\n\n- `ChronoField.ALIGNED_WEEK_OF_YEAR`: This represents concept of the count of weeks within\nthe period of a year where the weeks are aligned to the start of the year. This field\nis typically used with `ALIGNED_DAY_OF_WEEK_IN_YEAR`.\n\n- `ChronoField.AMPM_OF_DAY`: This counts the AM/PM within the day, from 0 (AM) to 1 (PM).\n\n- `ChronoField.CLOCK_HOUR_OF_AMPM`: This counts the hour within the AM/PM, from 1 to 12.\nThis is the hour that would be observed on a standard 12-hour analog wall clock.\n\n- `ChronoField.CLOCK_HOUR_OF_DAY`: This counts the hour within the AM/PM, from 1 to 24.\nThis is the hour that would be observed on a 24-hour analog wall clock.\n\n- `ChronoField.DAY_OF_MONTH`: This represents the concept of the day within the month.\nIn the default ISO calendar system, this has values from 1 to 31 in most months.\nApril, June, September, November have days from 1 to 30, while February has days from\n1 to 28, or 29 in a leap year.\n\n- `ChronoField.DAY_OF_WEEK`: This represents the standard concept of the day of the week.\nIn the default ISO calendar system, this has values from Monday (1) to Sunday (7).\nThe {@link DayOfWeek} class can be used to interpret the result.\n\n- `ChronoField.DAY_OF_YEAR`: This represents the concept of the day within the year.\nIn the default ISO calendar system, this has values from 1 to 365 in standard years and\n1 to 366 in leap years.\n\n- `ChronoField.EPOCH_DAY`: This field is the sequential count of days where\n1970-01-01 (ISO) is zero. Note that this uses the local time-line, ignoring offset and\ntime-zone.\n\n- `ChronoField.ERA`: This represents the concept of the era, which is the largest\ndivision of the time-line. This field is typically used with `YEAR_OF_ERA`.\n\n    In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'. The era\n'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.\nThe era 'BCE' is the previous era, and the year-of-era runs backwards.\n\n- `ChronoField.HOUR_OF_AMPM`: This counts the hour within the AM/PM, from 0 to 11.\nThis is the hour that would be observed on a standard 12-hour digital clock.\n\n- `ChronoField.HOUR_OF_DAY`: This counts the hour within the day, from 0 to 23. This is\nthe hour that would be observed on a standard 24-hour digital clock.\n\n- `ChronoField.INSTANT_SECONDS`: This represents the concept of the sequential count of\nseconds where 1970-01-01T00:00Z (ISO) is zero. This field may be used with `NANO_OF_DAY`\nto represent the fraction of the day.\n\n    An Instant represents an instantaneous point on the time-line. On their own they have\nno elements which allow a local date-time to be obtained. Only when paired with an offset\nor time-zone can the local date or time be found. This field allows the seconds part of\nthe instant to be queried.\n\n- `ChronoField.MICRO_OF_DAY`: This counts the microsecond within the day, from 0 to\n(24 * 60 * 60 * 1,000,000) - 1.\n\n    This field is used to represent the micro-of-day handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they\ncan return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n\n    When this field is used for setting a value, it should behave in the same way as\nsetting `NANO_OF_DAY` with the value multiplied by 1,000.\n\n- `ChronoField.MICRO_OF_SECOND`: This counts the microsecond within the second, from 0\nto 999,999.\n\n    This field is used to represent the micro-of-second handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they\ncan return a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling\nunknown precision with zero.\n\n- `ChronoField.MILLI_OF_DAY`: This counts the millisecond within the day, from 0 to\n(24 * 60 * 60 * 1,000) - 1.\n\n    This field is used to represent the milli-of-day handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they\ncan return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n\n    When this field is used for setting a value, it should behave in the same way as\nsetting `NANO_OF_DAY` with the value multiplied by 1,000,000.\n\n- `ChronoField.MILLI_OF_SECOND`: This counts the millisecond within the second, from 0 to\n999.\n\n    This field is used to represent the milli-of-second handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they can\nreturn a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling unknown\nprecision with zero.\n\n    When this field is used for setting a value, it should behave in the same way as\nsetting `NANO_OF_SECOND` with the value multiplied by 1,000,000.\n\n- `ChronoField.MINUTE_OF_DAY`: This counts the minute within the day, from 0 to (24 * 60) - 1.\n\n- `ChronoField.MINUTE_OF_HOUR`: This counts the minute within the hour, from 0 to 59.\n\n- `ChronoField.MONTH_OF_YEAR`: The month-of-year, such as March. This represents the concept\nof the month within the year. In the default ISO calendar system, this has values from\nJanuary (1) to December (12).\n\n- `ChronoField.NANO_OF_DAY`: This counts the nanosecond within the day, from 0 to\n(24 * 60 * 60 * 1,000,000,000) - 1.\n\n    This field is used to represent the nano-of-day handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they\ncan return a value for `SECOND_OF_DAY` filling unknown precision with zero.\n\n- `ChronoField.NANO_OF_SECOND`: This counts the nanosecond within the second, from 0\nto 999,999,999.\n\n    This field is used to represent the nano-of-second handling any fraction of the second.\nImplementations of {@link TemporalAccessor} should provide a value for this field if they\ncan return a value for `SECOND_OF_MINUTE`, `SECOND_OF_DAY` or `INSTANT_SECONDS` filling\nunknown precision with zero.\n\n    When this field is used for setting a value, it should set as much precision as the\nobject stores, using integer division to remove excess precision. For example, if the\n{@link TemporalAccessor} stores time to millisecond precision, then the nano-of-second must\nbe divided by 1,000,000 before replacing the milli-of-second.\n\n- `ChronoField.OFFSET_SECONDS`: This represents the concept of the offset in seconds of\nlocal time from UTC/Greenwich.\n\n    A {@link ZoneOffset} represents the period of time that local time differs from\nUTC/Greenwich. This is usually a fixed number of hours and minutes. It is equivalent to\nthe total amount of the offset in seconds. For example, during the winter Paris has an\noffset of +01:00, which is 3600 seconds.\n\n- `ChronoField.PROLEPTIC_MONTH`: The proleptic-month, which counts months sequentially\nfrom year 0.\n\n    The first month in year zero has the value zero. The value increase for later months\nand decrease for earlier ones. Note that this uses the local time-line, ignoring offset\nand time-zone.\n\n- `ChronoField.SECOND_OF_DAY`: This counts the second within the day, from 0 to\n(24 * 60 * 60) - 1.\n\n- `ChronoField.SECOND_OF_MINUTE`: This counts the second within the minute, from 0 to 59.\n\n- `ChronoField.YEAR`: The proleptic year, such as 2012. This represents the concept of\nthe year, counting sequentially and using negative numbers. The proleptic year is not\ninterpreted in terms of the era.\n\n    The standard mental model for a date is based on three concepts - year, month and day.\nThese map onto the `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields. Note that there is no\nreference to eras. The full model for a date requires four concepts - era, year, month and\nday. These map onto the `ERA`, `YEAR_OF_ERA`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.\nWhether this field or `YEAR_OF_ERA` is used depends on which mental model is being used.\n\n- `ChronoField.YEAR_OF_ERA`: This represents the concept of the year within the era. This\nfield is typically used with `ERA`. The standard mental model for a date is based on three\nconcepts - year, month and day. These map onto the `YEAR`, `MONTH_OF_YEAR` and\n`DAY_OF_MONTH` fields. Note that there is no reference to eras. The full model for a date\nrequires four concepts - era, year, month and day. These map onto the `ERA`, `YEAR_OF_ERA`,\n`MONTH_OF_YEAR` and `DAY_OF_MONTH` fields. Whether this field or `YEAR` is used depends on\nwhich mental model is being used.\n\n    In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'.\nThe era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.\nThe era 'BCE' is the previous era, and the year-of-era runs backwards.\n\n    For example, subtracting a year each time yield the following:\n   - year-proleptic 2 = 'CE' year-of-era 2\n   - year-proleptic 1 = 'CE' year-of-era 1\n   - year-proleptic 0 = 'BCE' year-of-era 1\n   - year-proleptic -1 = 'BCE' year-of-era 2\n\n    Note that the ISO-8601 standard does not actually define eras. Note also that the\nISO eras do not align with the well-known AD/BC eras due to the change between the Julian\nand Gregorian calendar systems.",
    "lineNumber": 209,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalField.js~TemporalField"
    ]
  },
  {
    "__docId__": 1399,
    "kind": "method",
    "name": "byName",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField.byName",
    "access": "private",
    "description": "helper function to get one of the static ChronoField defines by name, needed to resolve ChronoField from EnumMap",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ChronoField ",
        " null"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1400,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 236,
    "params": [
      {
        "nullable": false,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "baseUnit",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "rangeUnit",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "ValueRange"
        ],
        "spread": false,
        "optional": false,
        "name": "range",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1401,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#_name",
    "access": "private",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1402,
    "kind": "member",
    "name": "_baseUnit",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#_baseUnit",
    "access": "private",
    "description": null,
    "lineNumber": 239,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1403,
    "kind": "member",
    "name": "_rangeUnit",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#_rangeUnit",
    "access": "private",
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1404,
    "kind": "member",
    "name": "_range",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#_range",
    "access": "private",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1405,
    "kind": "method",
    "name": "name",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#name",
    "access": "public",
    "description": "",
    "lineNumber": 247,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1406,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#baseUnit",
    "access": "public",
    "description": "",
    "lineNumber": 254,
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": "the period unit defining the base unit of the field."
    },
    "params": []
  },
  {
    "__docId__": 1407,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#rangeUnit",
    "access": "public",
    "description": "",
    "lineNumber": 261,
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": "the period unit defining the range of the field."
    },
    "params": []
  },
  {
    "__docId__": 1408,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#range",
    "access": "public",
    "description": "",
    "lineNumber": 268,
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field."
    },
    "params": []
  },
  {
    "__docId__": 1409,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#displayName",
    "access": "public",
    "description": "",
    "lineNumber": 275,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1410,
    "kind": "method",
    "name": "checkValidValue",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#checkValidValue",
    "access": "public",
    "description": "Checks that the specified value is valid for this field.\n\nThis validates that the value is within the outer range of valid values\nreturned by {@link range}.\n\nThis method checks against the range of the field in the ISO-8601 calendar system.",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the value that was passed in."
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value that was passed in."
    }
  },
  {
    "__docId__": 1411,
    "kind": "method",
    "name": "checkValidIntValue",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#checkValidIntValue",
    "access": "public",
    "description": "Checks that the specified value is valid and fits in an `int`.\n\nThis validates that the value is within the outer range of valid values\nreturned by {@link range}.\nIt also checks that all valid values are within the bounds of an `int`.\n\nThis method checks against the range of the field in the ISO-8601 calendar system.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value that was passed in."
    }
  },
  {
    "__docId__": 1412,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#isDateBased",
    "access": "public",
    "description": "",
    "lineNumber": 313,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if it is a component of a date, `false` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 1413,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#isTimeBased",
    "access": "public",
    "description": "",
    "lineNumber": 334,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if it is a component of a time, `false` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 1414,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#rangeRefinedBy",
    "access": "public",
    "description": "",
    "lineNumber": 359,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object used to refine the result."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for this field."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained."
      }
    ]
  },
  {
    "__docId__": 1415,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#getFrom",
    "access": "public",
    "description": "",
    "lineNumber": 370,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccesor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value of this field."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained."
      }
    ]
  },
  {
    "__docId__": 1416,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#toString",
    "access": "public",
    "description": "",
    "lineNumber": 377,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1417,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#equals",
    "access": "public",
    "description": "",
    "lineNumber": 385,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1418,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 395,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust."
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted temporal object."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set."
      }
    ]
  },
  {
    "__docId__": 1419,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/ChronoField.js~ChronoField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoField.js~ChronoField#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 403,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccesor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the date-time can be queried for this field, `false` if not."
    }
  },
  {
    "__docId__": 1420,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/temporal/ChronoField.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/ChronoField.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/ChronoField.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 408,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1421,
    "kind": "file",
    "name": "packages/core/src/temporal/ChronoUnit.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MathUtil } from '../MathUtil';\n\nimport { Duration } from '../Duration';\nimport { YearConstants } from '../YearConstants';\nimport { TemporalUnit } from './TemporalUnit';\n\n/**\n * A standard set of date periods units.\n *\n * This set of units provide unit-based access to manipulate a date, time or date-time.\n * The standard set of units can be extended by implementing {@link TemporalUnit}.\n *\n * These units are intended to be applicable in multiple calendar systems.\n * For example, most non-ISO calendar systems define units of years, months and days,\n * just with slightly different rules.\n * The documentation of each unit explains how it operates.\n *\n * ### Static properties:\n * \n * - `ChronoUnit.CENTURIES`: Unit that represents the concept of a century. For the ISO calendar\n * system, it is equal to 100 years.\n * \n * - `ChronoUnit.DAYS`: Unit that represents the concept of a day. For the ISO calendar system, it\n * is the standard day from midnight to midnight. The estimated duration of a day is 24 Hours.\n * \n * - `ChronoUnit.DECADES`: Unit that represents the concept of a decade. For the ISO calendar system,\n * it is equal to 10 years.\n * \n * - `ChronoUnit.ERAS`: Unit that represents the concept of an era. The ISO calendar system doesn't\n * have eras thus it is impossible to add an era to a date or date-time. The estimated duration of the\n * era is artificially defined as 1,000,000,000 Years.\n * \n * - `ChronoUnit.FOREVER`: Artificial unit that represents the concept of forever. This is primarily\n * used with {@link TemporalField} to represent unbounded fields such as the year or era. The\n * estimated duration of the era is artificially defined as the largest duration supported by\n * {@link Duration}.\n * \n * - `ChronoUnit.HALF_DAYS`: Unit that represents the concept of half a day, as used in AM/PM. For\n * the ISO calendar system, it is equal to 12 hours.\n *\n * - `ChronoUnit.HOURS`: Unit that represents the concept of an hour. For the ISO calendar system,\n * it is equal to 60 minutes.\n * \n * - `ChronoUnit.MICROS`: Unit that represents the concept of a microsecond. For the ISO calendar\n * system, it is equal to the 1,000,000th part of the second unit.\n * \n * - `ChronoUnit.MILLENNIA`: Unit that represents the concept of a millennium. For the ISO calendar\n * system, it is equal to 1,000 years.\n * \n * - `ChronoUnit.MILLIS`: Unit that represents the concept of a millisecond. For the ISO calendar\n * system, it is equal to the 1000th part of the second unit.\n * \n * - `ChronoUnit.MINUTES`: Unit that represents the concept of a minute. For the ISO calendar system,\n * it is equal to 60 seconds.\n * \n * - `ChronoUnit.MONTHS`: Unit that represents the concept of a month. For the ISO calendar system,\n * the length of the month varies by month-of-year. The estimated duration of a month is one twelfth\n * of 365.2425 Days.\n * \n * - `ChronoUnit.NANOS`: Unit that represents the concept of a nanosecond, the smallest supported unit\n * of time. For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n * \n * - `ChronoUnit.SECONDS`: Unit that represents the concept of a second. For the ISO calendar system,\n * it is equal to the second in the SI system of units, except around a leap-second.\n * \n * - `ChronoUnit.WEEKS`: Unit that represents the concept of a week. For the ISO calendar system,\n * it is equal to 7 Days.\n * \n * - `ChronoUnit.YEARS`: Unit that represents the concept of a year. For the ISO calendar system, it\n * is equal to 12 months. The estimated duration of a year is 365.2425 Days.\n */\nexport class ChronoUnit extends TemporalUnit {\n\n    /**\n     *\n     * @param {String} name\n     * @param {Duration} estimatedDuration\n     * @private\n     */\n    constructor (name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @return {Duration} the duration of this unit, which may be an estimate.\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     * @return {boolean} `true` if the duration is estimated, `false` if accurate.\n     */\n    isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @return {boolean} `true` if date unit, `false` if a time unit.\n     */\n    isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    }\n\n    /**\n     * Checks if this unit is a time unit.\n     *\n     * @return {boolean} `true` if time unit, `false` if a date unit.\n     */\n    isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param {!Temporal} temporal the temporal object to check.\n     * @return {boolean} `true` if the unit is supported.\n     */\n    isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        /* TODO: classes not implemented yet */\n        /*\n        if (temporal instanceof ChronoLocalDate) {\n            return isDateBased();\n        }\n        if (temporal instanceof ChronoLocalDateTime || temporal instanceof ChronoZonedDateTime) {\n            return true;\n        }\n*/\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @param {!Temporal} temporal the temporal object to adjust.\n     * @param {number} amount the period of this unit to add, positive or negative.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws DateTimeException if the period cannot be added.\n     */\n    addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * @param {!Temporal} temporal1 the base temporal object.\n     * @param {!Temporal} temporal2 the other temporal object.\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier.\n     * @throws DateTimeException if the period cannot be calculated.\n     * @throws ArithmeticException if numeric overflow occurs.\n     */\n    between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return this._name;\n    }\n\n    /**\n     * Compares this ChronoUnit to the specified {@link TemporalUnit}.\n     *\n     * The comparison is based on the total length of the durations.\n     *\n     * @param {!TemporalUnit} other the other unit to compare to.\n     * @return the comparator value, negative if less, positive if greater.\n     */\n    compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Unit that represents the concept of a nanosecond, the smallest supported unit of time.\n     * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n     */\n    ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n    /**\n     * Unit that represents the concept of a microsecond.\n     * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.\n     */\n    ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n    /**\n     * Unit that represents the concept of a millisecond.\n     * For the ISO calendar system, it is equal to the 1000th part of the second unit.\n     */\n    ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n    /**\n     * Unit that represents the concept of a second.\n     * For the ISO calendar system, it is equal to the second in the SI system\n     * of units, except around a leap-second.\n     */\n    ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n    /**\n     * Unit that represents the concept of a minute.\n     * For the ISO calendar system, it is equal to 60 seconds.\n     */\n    ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n    /**\n     * Unit that represents the concept of an hour.\n     * For the ISO calendar system, it is equal to 60 minutes.\n     */\n    ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n    /**\n     * Unit that represents the concept of half a day, as used in AM/PM.\n     * For the ISO calendar system, it is equal to 12 hours.\n     */\n    ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n    /**\n     * Unit that represents the concept of a day.\n     * For the ISO calendar system, it is the standard day from midnight to midnight.\n     * The estimated duration of a day is 24 hours.\n     *\n     * When used with other calendar systems it must correspond to the day defined by\n     * the rising and setting of the Sun on Earth. It is not required that days begin\n     * at midnight - when converting between calendar systems, the date should be\n     * equivalent at midday.\n     */\n    ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n    /**\n     * Unit that represents the concept of a week.\n     * For the ISO calendar system, it is equal to 7 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n    /**\n     * Unit that represents the concept of a month.\n     * For the ISO calendar system, the length of the month varies by month-of-year.\n     * The estimated duration of a month is one twelfth of 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days.\n     */\n    ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n    /**\n     * Unit that represents the concept of a year.\n     * For the ISO calendar system, it is equal to 12 months.\n     * The estimated duration of a year is 365.2425 days.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * or months roughly equal to a year defined by the passage of the Earth around the Sun.\n     */\n    ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n    /**\n     * Unit that represents the concept of a decade.\n     * For the ISO calendar system, it is equal to 10 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n    /**\n     * Unit that represents the concept of a century.\n     * For the ISO calendar system, it is equal to 100 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n    /**\n     * Unit that represents the concept of a millennium.\n     * For the ISO calendar system, it is equal to 1000 years.\n     *\n     * When used with other calendar systems it must correspond to an integral number of days\n     * and is normally an integral number of years.\n     */\n    ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n    /**\n     * Unit that represents the concept of an era.\n     * The ISO calendar system doesn't have eras thus it is impossible to add\n     * an era to a date or date-time.\n     * The estimated duration of the era is artificially defined as {Year.MAX_VALUE} + 1.\n     *\n     * When used with other calendar systems there are no restrictions on the unit.\n     */\n    ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n    /**\n     * Artificial unit that represents the concept of forever.\n     * This is primarily used with {@link TemporalField} to represent unbounded fields\n     * such as the year or era.\n     * The estimated duration of the era is artificially defined as the largest duration\n     * supported by {@link Duration}.\n     */\n    ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/ChronoUnit.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1422,
    "kind": "class",
    "name": "ChronoUnit",
    "memberof": "packages/core/src/temporal/ChronoUnit.js",
    "static": true,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/ChronoUnit.js",
    "importStyle": "{ChronoUnit}",
    "description": "A standard set of date periods units.\n\nThis set of units provide unit-based access to manipulate a date, time or date-time.\nThe standard set of units can be extended by implementing {@link TemporalUnit}.\n\nThese units are intended to be applicable in multiple calendar systems.\nFor example, most non-ISO calendar systems define units of years, months and days,\njust with slightly different rules.\nThe documentation of each unit explains how it operates.\n\n### Static properties:\n\n- `ChronoUnit.CENTURIES`: Unit that represents the concept of a century. For the ISO calendar\nsystem, it is equal to 100 years.\n\n- `ChronoUnit.DAYS`: Unit that represents the concept of a day. For the ISO calendar system, it\nis the standard day from midnight to midnight. The estimated duration of a day is 24 Hours.\n\n- `ChronoUnit.DECADES`: Unit that represents the concept of a decade. For the ISO calendar system,\nit is equal to 10 years.\n\n- `ChronoUnit.ERAS`: Unit that represents the concept of an era. The ISO calendar system doesn't\nhave eras thus it is impossible to add an era to a date or date-time. The estimated duration of the\nera is artificially defined as 1,000,000,000 Years.\n\n- `ChronoUnit.FOREVER`: Artificial unit that represents the concept of forever. This is primarily\nused with {@link TemporalField} to represent unbounded fields such as the year or era. The\nestimated duration of the era is artificially defined as the largest duration supported by\n{@link Duration}.\n\n- `ChronoUnit.HALF_DAYS`: Unit that represents the concept of half a day, as used in AM/PM. For\nthe ISO calendar system, it is equal to 12 hours.\n\n- `ChronoUnit.HOURS`: Unit that represents the concept of an hour. For the ISO calendar system,\nit is equal to 60 minutes.\n\n- `ChronoUnit.MICROS`: Unit that represents the concept of a microsecond. For the ISO calendar\nsystem, it is equal to the 1,000,000th part of the second unit.\n\n- `ChronoUnit.MILLENNIA`: Unit that represents the concept of a millennium. For the ISO calendar\nsystem, it is equal to 1,000 years.\n\n- `ChronoUnit.MILLIS`: Unit that represents the concept of a millisecond. For the ISO calendar\nsystem, it is equal to the 1000th part of the second unit.\n\n- `ChronoUnit.MINUTES`: Unit that represents the concept of a minute. For the ISO calendar system,\nit is equal to 60 seconds.\n\n- `ChronoUnit.MONTHS`: Unit that represents the concept of a month. For the ISO calendar system,\nthe length of the month varies by month-of-year. The estimated duration of a month is one twelfth\nof 365.2425 Days.\n\n- `ChronoUnit.NANOS`: Unit that represents the concept of a nanosecond, the smallest supported unit\nof time. For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.\n\n- `ChronoUnit.SECONDS`: Unit that represents the concept of a second. For the ISO calendar system,\nit is equal to the second in the SI system of units, except around a leap-second.\n\n- `ChronoUnit.WEEKS`: Unit that represents the concept of a week. For the ISO calendar system,\nit is equal to 7 Days.\n\n- `ChronoUnit.YEARS`: Unit that represents the concept of a year. For the ISO calendar system, it\nis equal to 12 months. The estimated duration of a year is 365.2425 Days.",
    "lineNumber": 78,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalUnit.js~TemporalUnit"
    ]
  },
  {
    "__docId__": 1423,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "estimatedDuration",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1424,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#_name",
    "access": "private",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1425,
    "kind": "member",
    "name": "_duration",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#_duration",
    "access": "private",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1426,
    "kind": "method",
    "name": "duration",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#duration",
    "access": "public",
    "description": "",
    "lineNumber": 96,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the duration of this unit, which may be an estimate."
    },
    "params": []
  },
  {
    "__docId__": 1427,
    "kind": "method",
    "name": "isDurationEstimated",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#isDurationEstimated",
    "access": "public",
    "description": "",
    "lineNumber": 103,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the duration is estimated, `false` if accurate."
    },
    "params": []
  },
  {
    "__docId__": 1428,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#isDateBased",
    "access": "public",
    "description": "",
    "lineNumber": 111,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if date unit, `false` if a time unit."
    },
    "params": []
  },
  {
    "__docId__": 1429,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#isTimeBased",
    "access": "public",
    "description": "Checks if this unit is a time unit.",
    "lineNumber": 120,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if time unit, `false` if a date unit."
    },
    "params": []
  },
  {
    "__docId__": 1430,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 129,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the unit is supported."
    }
  },
  {
    "__docId__": 1431,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#addTo",
    "access": "public",
    "description": "",
    "lineNumber": 161,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the period of this unit to add, positive or negative."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted temporal object."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be added."
      }
    ]
  },
  {
    "__docId__": 1432,
    "kind": "method",
    "name": "between",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#between",
    "access": "public",
    "description": "",
    "lineNumber": 174,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal1",
        "description": "the base temporal object."
      },
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal2",
        "description": "the other temporal object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the period between temporal1 and temporal2 in terms of this unit;\n positive if temporal2 is later than temporal1, negative if earlier."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be calculated."
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs."
      }
    ]
  },
  {
    "__docId__": 1433,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#toString",
    "access": "public",
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1434,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ChronoUnit.js~ChronoUnit#compareTo",
    "access": "public",
    "description": "Compares this ChronoUnit to the specified {@link TemporalUnit}.\n\nThe comparison is based on the total length of the durations.",
    "lineNumber": 191,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other unit to compare to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater."
    }
  },
  {
    "__docId__": 1435,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/temporal/ChronoUnit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/ChronoUnit.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/ChronoUnit.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1436,
    "kind": "file",
    "name": "packages/core/src/temporal/IsoFields.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { UnsupportedTemporalTypeException, IllegalStateException } from '../errors';\n\nimport { DayOfWeek } from '../DayOfWeek';\nimport { Duration } from '../Duration';\nimport { MathUtil } from '../MathUtil';\nimport { LocalDate } from '../LocalDate';\n\nimport { ChronoField } from './ChronoField';\nimport { ChronoUnit } from './ChronoUnit';\nimport { TemporalField } from './TemporalField';\nimport { TemporalUnit } from './TemporalUnit';\nimport { ValueRange } from './ValueRange';\n\nimport { IsoChronology } from '../chrono/IsoChronology';\n\nimport { ResolverStyle } from '../format/ResolverStyle';\n\n/**\n * Fields and units specific to the ISO-8601 calendar system,\n * including quarter-of-year and week-based-year.\n *\n * This class defines fields and units that are specific to the ISO calendar system.\n *\n * ### Quarter of year\n *\n * The ISO-8601 standard is based on the standard civic 12 month year.\n * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.\n *\n * January, February and March are in Q1.\n * April, May and June are in Q2.\n * July, August and September are in Q3.\n * October, November and December are in Q4.\n *\n * The complete date is expressed using three fields:\n *\n * * `IsoFields.DAY_OF_QUARTER` - the day within the quarter, from 1 to 90, 91 or 92\n * * `QUARTER_OF_YEAR` - the week within the week-based-year\n * * `ChronoField.YEAR` - the standard ISO year (see {@link ChronoField})\n *\n * ### Week based years\n *\n * The ISO-8601 standard was originally intended as a data interchange format,\n * defining a string format for dates and times. However, it also defines an\n * alternate way of expressing the date, based on the concept of week-based-year.\n *\n * The date is expressed using three fields:\n *\n * * `ChronoField.DAY_OF_WEEK` - the standard field defining the\n *   day-of-week from Monday (1) to Sunday (7) (see {@link ChronoField})\n * * `WEEK_OF_WEEK_BASED_YEAR` - the week within the week-based-year\n * * `WEEK_BASED_YEAR` - the week-based-year \n *\n * The week-based-year itself is defined relative to the standard ISO proleptic year.\n * It differs from the standard year in that it always starts on a Monday.\n *\n * The first week of a week-based-year is the first Monday-based week of the standard\n * ISO year that has at least 4 days in the new year.\n *\n * * If January 1st is Monday then week 1 starts on January 1st\n * * If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year\n * * If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year\n * * If January 1st is Thursday then week 1 starts on December 29th of the previous standard year\n * * If January 1st is Friday then week 1 starts on January 4th\n * * If January 1st is Saturday then week 1 starts on January 3rd\n * * If January 1st is Sunday then week 1 starts on January 2nd\n *\n * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.\n *\n * For example:\n *\n * * Sunday, 2008-12-28: Week 52 of week-based-year 2008\n * * Monday, 2008-12-29: Week 1 of week-based-year 2009\n * * Wednesday, 2008-12-31: Week 1 of week-based-year 2009\n * * Thursday, 2009-01-01: Week 1 of week-based-year 2009\n * * Sunday, 2009-01-04: Week 1 of week-based-year 2009\n * * Monday, 2009-01-05: Week 2 of week-based-year 2009\n *\n * @property {TemporalField} DAY_OF_QUARTER The field that represents the day-of-quarter.\n *\n * This field allows the day-of-quarter value to be queried and set.\n * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91\n * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.\n *\n * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year\n * are available.\n *\n * When setting this field, the value is allowed to be partially lenient, taking any\n * value from 1 to 92. If the quarter has less than 92 days, then day 92, and\n * potentially day 91, is in the following quarter.\n *\n * @property {TemporalField} QUARTER_OF_YEAR The field that represents the quarter-of-year.\n *\n * This field allows the quarter-of-year value to be queried and set.\n * The quarter-of-year has values from 1 to 4.\n *\n * The day-of-quarter can only be calculated if the month-of-year is available.\n *\n * @property {TemporalField} WEEK_OF_WEEK_BASED_YEAR The field that represents the\n * week-of-week-based-year.\n *\n * This field allows the week of the week-based-year value to be queried and set.\n *\n * @property {TemporalField} WEEK_BASED_YEAR The field that represents the week-based-year.\n *\n * This field allows the week-based-year value to be queried and set.\n *\n * @property {TemporalField} WEEK_BASED_YEARS The unit that represents week-based-years for\n * the purpose of addition and subtraction.\n *\n * This allows a number of week-based-years to be added to, or subtracted from, a date.\n * The unit is equal to either 52 or 53 weeks.\n * The estimated duration of a week-based-year is the same as that of a standard ISO\n * year at 365.2425 days.\n *\n * The rules for addition add the number of week-based-years to the existing value\n * for the week-based-year field. If the resulting week-based-year only has 52 weeks,\n * then the date will be in week 1 of the following week-based-year.\n *\n * @property {TemporalField} QUARTER_YEARS Unit that represents the concept of a quarter-year.\n * For the ISO calendar system, it is equal to 3 months.\n * The estimated duration of a quarter-year is one quarter of 365.2425 days.\n * \n * @typedef {Object} IsoFields\n * @type {Object}\n */\nexport const IsoFields = {};\n\n//-----------------------------------------------------------------------\n\nconst QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\n/**\n * Implementation of the field.\n * @private\n */\nclass Field extends TemporalField{\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    _isIso() {\n        return true;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {ValueRange}\n     */\n    static _getWeekRangeByLocalDate(date) {\n        const wby = Field._getWeekBasedYear(date);\n        return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n    }\n\n    /**\n     *\n     * @param {number} wby\n     * @returns {number}\n     */\n    static _getWeekRangeByYear(wby) {\n        const date = LocalDate.of(wby, 1, 1);\n        // 53 weeks if standard year starts on Thursday, or Wed in a leap year\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || (date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear())) {\n            return 53;\n        }\n        return 52;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeek(date) {\n        const dow0 = date.dayOfWeek().ordinal();\n        const doy0 = date.dayOfYear() - 1;\n        const doyThu0 = doy0 + (3 - dow0);  // adjust to mid-week Thursday (which is 3 indexed from zero)\n        const alignedWeek = MathUtil.intDiv(doyThu0, 7);\n        const firstThuDoy0 = doyThu0 - (alignedWeek * 7);\n        let firstMonDoy0 = firstThuDoy0 - 3;\n        if (firstMonDoy0 < -3) {\n            firstMonDoy0 += 7;\n        }\n        if (doy0 < firstMonDoy0) {\n            return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n        }\n        let week = MathUtil.intDiv((doy0 - firstMonDoy0), 7) + 1;\n        if (week === 53) {\n            if ((firstMonDoy0 === -3 || (firstMonDoy0 === -2 && date.isLeapYear())) === false) {\n                week = 1;\n            }\n        }\n        return week;\n    }\n\n    /**\n     *\n     * @param {LocalDate} date\n     * @returns {number}\n     */\n    static _getWeekBasedYear(date) {\n        let year = date.year();\n        let doy = date.dayOfYear();\n        if (doy <= 3) {\n            const dow = date.dayOfWeek().ordinal();\n            if (doy - dow < -2) {\n                year--;\n            }\n        } else if (doy >= 363) {\n            const dow = date.dayOfWeek().ordinal();\n            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n            if (doy - dow >= 0) {\n                year++;\n            }\n        }\n        return year;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    displayName(/*locale*/) {\n        return this.toString();\n    }\n\n    /**\n     *\n     * @returns {null}\n     */\n    resolve() {\n        return null;\n    }\n\n    name(){\n        return this.toString();\n    }\n\n}\n\n/**\n * @private\n */\nclass DAY_OF_QUARTER_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'DayOfQuarter';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.DAYS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 90, 92);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) &&\n            temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const qoy = temporal.getLong(QUARTER_OF_YEAR);\n        if (qoy === 1) {\n            const year = temporal.getLong(ChronoField.YEAR);\n            return (IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90));\n        } else if (qoy === 2) {\n            return ValueRange.of(1, 91);\n        } else if (qoy === 3 || qoy === 4) {\n            return ValueRange.of(1, 92);\n        } // else value not from 1 to 4, so drop through\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n        }\n        const doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        const moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n        const year = temporal.getLong(ChronoField.YEAR);\n        return doy - QUARTER_DAYS[MathUtil.intDiv((moy - 1), 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const yearLong = fieldValues.get(ChronoField.YEAR);\n        const qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n        if (yearLong == null || qoyLong == null) {\n            return null;\n        }\n        const y = ChronoField.YEAR.checkValidIntValue(yearLong);\n        const doq = fieldValues.get(DAY_OF_QUARTER);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            const qoy = qoyLong;\n            date = LocalDate.of(y, 1, 1);\n            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n            date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n        } else {\n            const qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                let max = 92;\n                if (qoy === 1) {\n                    max = (IsoChronology.isLeapYear(y) ? 91 : 90);\n                } else if (qoy === 2) {\n                    max = 91;\n                }\n                ValueRange.of(1, max).checkValidValue(doq, this);\n            } else {\n                this.range().checkValidValue(doq, this);  // leniently check from 1 to 92\n            }\n            date = LocalDate.of(y, ((qoy - 1) * 3) + 1, 1).plusDays(doq - 1);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(ChronoField.YEAR);\n        fieldValues.remove(QUARTER_OF_YEAR);\n        return date;\n    }\n}\n\n/**\n * @private\n */\nclass QUARTER_OF_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'QuarterOfYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return QUARTER_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 4);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return this.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n        }\n        const moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n        return MathUtil.intDiv((moy + 2), 3);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        const curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n    }\n\n}\n\n/**\n * @private\n */\nclass WEEK_OF_WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekOfWeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return ChronoUnit.WEEKS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ValueRange.of(1, 52, 53);\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n        }\n        return Field._getWeek(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        this.range().checkValidValue(newValue, this);\n        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n    }\n\n    /**\n     *\n     * @param {Map<TemporalField, number>} fieldValues\n     * @param {TemporalAccessor} partialTemporal\n     * @param {ResolverStyle} resolverStyle\n     * @returns {ValueRange}\n     */\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n        const dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n        if (wbyLong == null || dowLong == null) {\n            return null;\n        }\n        const wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n        const wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n        let date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            let dow = dowLong;\n            let weeks = 0;\n            if (dow > 7) {\n                weeks = MathUtil.intDiv((dow - 1), 7);\n                dow = (MathUtil.intMod((dow - 1), 7) + 1);\n            } else if (dow < 1) {\n                weeks = MathUtil.intDiv(dow, 7) - 1;\n                dow = MathUtil.intMod(dow, 7) + 7;\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n        } else {\n            const dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                const temp = LocalDate.of(wby, 1, 4);\n                const range = Field._getWeekRangeByLocalDate(temp);\n                range.checkValidValue(wowby, this);\n            } else {\n                this.range().checkValidValue(wowby, this);  // leniently check from 1 to 53\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, dow);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(WEEK_BASED_YEAR);\n        fieldValues.remove(ChronoField.DAY_OF_WEEK);\n        return date;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    displayName() {\n        return 'Week';\n    }\n\n}\n\n/**\n * @private\n */\nclass WEEK_BASED_YEAR_FIELD extends Field {\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'WeekBasedYear';\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    baseUnit() {\n        return WEEK_BASED_YEARS;\n    }\n\n    /**\n     *\n     * @returns {TemporalUnit}\n     */\n    rangeUnit() {\n        return ChronoUnit.FOREVER;\n    }\n\n    /**\n     *\n     * @returns {ValueRange}\n     */\n    range() {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    }\n\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {ValueRange}\n     */\n    //eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        return ChronoField.YEAR.range();\n    }\n\n    /**\n     *\n     * @param {TemporalAccessor} temporal\n     * @returns {number}\n     */\n    getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        return Field._getWeekBasedYear(LocalDate.from(temporal));\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} newValue\n     * @returns {temporal}\n     */\n    adjustInto(temporal, newValue) {\n        if (this.isSupportedBy(temporal) === false) {\n            throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n        }\n        const newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);  // strict check\n        const date = LocalDate.from(temporal);\n        const dow = date.get(ChronoField.DAY_OF_WEEK);\n        let week = Field._getWeek(date);\n        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n            week = 52;\n        }\n        let resolved = LocalDate.of(newWby, 1, 4);  // 4th is guaranteed to be in week one\n        const days = (dow - resolved.get(ChronoField.DAY_OF_WEEK)) + ((week - 1) * 7);\n        resolved = resolved.plusDays(days);\n        return temporal.with(resolved);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Implementation of the period unit.\n * @private\n */\nclass Unit extends TemporalUnit {\n\n    /**\n     *\n     * @param {string} name\n     * @param {Duration} estimatedDuration\n     * @private\n     */\n    constructor(name, estimatedDuration) {\n        super();\n        this._name = name;\n        this._duration = estimatedDuration;\n    }\n\n    /**\n     *\n     * @returns {Duration}\n     */\n    duration() {\n        return this._duration;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDurationEstimated() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isDateBased() {\n        return true;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isTimeBased() {\n        return false;\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @returns {boolean}\n     */\n    isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY);\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal\n     * @param {number} periodToAdd\n     * @returns {number}\n     */\n    addTo(temporal, periodToAdd) {\n        switch(this) {\n            case WEEK_BASED_YEARS: {\n                const added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n                return temporal.with(WEEK_BASED_YEAR, added);\n            }\n            case QUARTER_YEARS:\n                // no overflow (256 is multiple of 4)\n                return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    /**\n     *\n     * @param {Temporal} temporal1\n     * @param {Temporal} temporal2\n     * @returns {number}\n     */\n    between(temporal1, temporal2) {\n        switch(this) {\n            case WEEK_BASED_YEARS:\n                return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n            case QUARTER_YEARS:\n                return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    toString() {\n        return this._name;\n    }\n}\n\nlet DAY_OF_QUARTER = null;\nlet QUARTER_OF_YEAR = null;\nlet WEEK_OF_WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEAR = null;\nlet WEEK_BASED_YEARS = null;\nlet QUARTER_YEARS = null;\n\nexport function _init() {\n    DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n    QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n    WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n\n    WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n    QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n\n    IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n    IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n    IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n    IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n\n    // this differs from threeten, but for ease of use we bring back good old joda time functionality\n    /**\n     * the week of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the week a the week based year\n     */\n    LocalDate.prototype.isoWeekOfWeekyear = function () {\n        return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n    };\n    /**\n     * the year of the week based year as defined by the ISO8601 Standard with a Monday-based week\n     *\n     * @returns {number} the year a the week based year\n     */\n    LocalDate.prototype.isoWeekyear = function () {\n        return this.get(IsoFields.WEEK_BASED_YEAR);\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/IsoFields.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1437,
    "kind": "typedef",
    "name": "IsoFields",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~IsoFields",
    "access": "public",
    "description": "Fields and units specific to the ISO-8601 calendar system,\nincluding quarter-of-year and week-based-year.\n\nThis class defines fields and units that are specific to the ISO calendar system.\n\n### Quarter of year\n\nThe ISO-8601 standard is based on the standard civic 12 month year.\nThis is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.\n\nJanuary, February and March are in Q1.\nApril, May and June are in Q2.\nJuly, August and September are in Q3.\nOctober, November and December are in Q4.\n\nThe complete date is expressed using three fields:\n\n* `IsoFields.DAY_OF_QUARTER` - the day within the quarter, from 1 to 90, 91 or 92\n* `QUARTER_OF_YEAR` - the week within the week-based-year\n* `ChronoField.YEAR` - the standard ISO year (see {@link ChronoField})\n\n### Week based years\n\nThe ISO-8601 standard was originally intended as a data interchange format,\ndefining a string format for dates and times. However, it also defines an\nalternate way of expressing the date, based on the concept of week-based-year.\n\nThe date is expressed using three fields:\n\n* `ChronoField.DAY_OF_WEEK` - the standard field defining the\n  day-of-week from Monday (1) to Sunday (7) (see {@link ChronoField})\n* `WEEK_OF_WEEK_BASED_YEAR` - the week within the week-based-year\n* `WEEK_BASED_YEAR` - the week-based-year \n\nThe week-based-year itself is defined relative to the standard ISO proleptic year.\nIt differs from the standard year in that it always starts on a Monday.\n\nThe first week of a week-based-year is the first Monday-based week of the standard\nISO year that has at least 4 days in the new year.\n\n* If January 1st is Monday then week 1 starts on January 1st\n* If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year\n* If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year\n* If January 1st is Thursday then week 1 starts on December 29th of the previous standard year\n* If January 1st is Friday then week 1 starts on January 4th\n* If January 1st is Saturday then week 1 starts on January 3rd\n* If January 1st is Sunday then week 1 starts on January 2nd\n\nThere are 52 weeks in most week-based years, however on occasion there are 53 weeks.\n\nFor example:\n\n* Sunday, 2008-12-28: Week 52 of week-based-year 2008\n* Monday, 2008-12-29: Week 1 of week-based-year 2009\n* Wednesday, 2008-12-31: Week 1 of week-based-year 2009\n* Thursday, 2009-01-01: Week 1 of week-based-year 2009\n* Sunday, 2009-01-04: Week 1 of week-based-year 2009\n* Monday, 2009-01-05: Week 2 of week-based-year 2009",
    "lineNumber": 132,
    "properties": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "DAY_OF_QUARTER",
        "description": "The field that represents the day-of-quarter.\n\nThis field allows the day-of-quarter value to be queried and set.\nThe day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91\nin Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.\n\nThe day-of-quarter can only be calculated if the day-of-year, month-of-year and year\nare available.\n\nWhen setting this field, the value is allowed to be partially lenient, taking any\nvalue from 1 to 92. If the quarter has less than 92 days, then day 92, and\npotentially day 91, is in the following quarter."
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "QUARTER_OF_YEAR",
        "description": "The field that represents the quarter-of-year.\n\nThis field allows the quarter-of-year value to be queried and set.\nThe quarter-of-year has values from 1 to 4.\n\nThe day-of-quarter can only be calculated if the month-of-year is available."
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "WEEK_OF_WEEK_BASED_YEAR",
        "description": "The field that represents the\nweek-of-week-based-year.\n\nThis field allows the week of the week-based-year value to be queried and set."
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "WEEK_BASED_YEAR",
        "description": "The field that represents the week-based-year.\n\nThis field allows the week-based-year value to be queried and set."
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "WEEK_BASED_YEARS",
        "description": "The unit that represents week-based-years for\nthe purpose of addition and subtraction.\n\nThis allows a number of week-based-years to be added to, or subtracted from, a date.\nThe unit is equal to either 52 or 53 weeks.\nThe estimated duration of a week-based-year is the same as that of a standard ISO\nyear at 365.2425 days.\n\nThe rules for addition add the number of week-based-years to the existing value\nfor the week-based-year field. If the resulting week-based-year only has 52 weeks,\nthen the date will be in week 1 of the following week-based-year."
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "QUARTER_YEARS",
        "description": "Unit that represents the concept of a quarter-year.\nFor the ISO calendar system, it is equal to 3 months.\nThe estimated duration of a quarter-year is one quarter of 365.2425 days."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "IsoFields"
    }
  },
  {
    "__docId__": 1438,
    "kind": "variable",
    "name": "QUARTER_DAYS",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_DAYS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "type": {
      "types": [
        "number[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1439,
    "kind": "class",
    "name": "Field",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Field",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "Implementation of the field.",
    "lineNumber": 142,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalField.js~TemporalField"
    ],
    "ignore": true
  },
  {
    "__docId__": 1440,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#isDateBased",
    "access": "public",
    "description": "",
    "lineNumber": 148,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1441,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#isTimeBased",
    "access": "public",
    "description": "",
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1442,
    "kind": "method",
    "name": "_isIso",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#_isIso",
    "access": "private",
    "description": "",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1443,
    "kind": "method",
    "name": "_getWeekRangeByLocalDate",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Field._getWeekRangeByLocalDate",
    "access": "private",
    "description": "",
    "lineNumber": 173,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1444,
    "kind": "method",
    "name": "_getWeekRangeByYear",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Field._getWeekRangeByYear",
    "access": "private",
    "description": "",
    "lineNumber": 183,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "wby",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1445,
    "kind": "method",
    "name": "_getWeek",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Field._getWeek",
    "access": "private",
    "description": "",
    "lineNumber": 197,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1446,
    "kind": "method",
    "name": "_getWeekBasedYear",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Field._getWeekBasedYear",
    "access": "private",
    "description": "",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1447,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#displayName",
    "access": "public",
    "description": "",
    "lineNumber": 246,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1448,
    "kind": "method",
    "name": "resolve",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#resolve",
    "access": "public",
    "description": "",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{null}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "null"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1449,
    "kind": "method",
    "name": "name",
    "memberof": "packages/core/src/temporal/IsoFields.js~Field",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Field#name",
    "access": "public",
    "description": null,
    "lineNumber": 258,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1450,
    "kind": "class",
    "name": "DAY_OF_QUARTER_FIELD",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 267,
    "interface": false,
    "extends": [
      "Field"
    ],
    "ignore": true
  },
  {
    "__docId__": 1451,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#toString",
    "access": "public",
    "description": "",
    "lineNumber": 273,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1452,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#baseUnit",
    "access": "public",
    "description": "",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1453,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#rangeUnit",
    "access": "public",
    "description": "",
    "lineNumber": 289,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1454,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#range",
    "access": "public",
    "description": "",
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1455,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 306,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1456,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#rangeRefinedBy",
    "access": "public",
    "description": "",
    "lineNumber": 317,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1457,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#getFrom",
    "access": "public",
    "description": "",
    "lineNumber": 338,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1458,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 354,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{temporal}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1459,
    "kind": "method",
    "name": "resolve",
    "memberof": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER_FIELD#resolve",
    "access": "public",
    "description": "",
    "lineNumber": 367,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Map<TemporalField, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldValues",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "partialTemporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1460,
    "kind": "class",
    "name": "QUARTER_OF_YEAR_FIELD",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 406,
    "interface": false,
    "extends": [
      "Field"
    ],
    "ignore": true
  },
  {
    "__docId__": 1461,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#toString",
    "access": "public",
    "description": "",
    "lineNumber": 412,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1462,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#baseUnit",
    "access": "public",
    "description": "",
    "lineNumber": 420,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1463,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#rangeUnit",
    "access": "public",
    "description": "",
    "lineNumber": 428,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1464,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#range",
    "access": "public",
    "description": "",
    "lineNumber": 436,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1465,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 445,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1466,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#rangeRefinedBy",
    "access": "public",
    "description": "",
    "lineNumber": 456,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1467,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#getFrom",
    "access": "public",
    "description": "",
    "lineNumber": 465,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1468,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR_FIELD#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 479,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{temporal}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1469,
    "kind": "class",
    "name": "WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 490,
    "interface": false,
    "extends": [
      "Field"
    ],
    "ignore": true
  },
  {
    "__docId__": 1470,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#toString",
    "access": "public",
    "description": "",
    "lineNumber": 496,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1471,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#baseUnit",
    "access": "public",
    "description": "",
    "lineNumber": 504,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1472,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#rangeUnit",
    "access": "public",
    "description": "",
    "lineNumber": 512,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1473,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#range",
    "access": "public",
    "description": "",
    "lineNumber": 520,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1474,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 529,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1475,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#rangeRefinedBy",
    "access": "public",
    "description": "",
    "lineNumber": 539,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1476,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#getFrom",
    "access": "public",
    "description": "",
    "lineNumber": 551,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1477,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 564,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{temporal}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1478,
    "kind": "method",
    "name": "resolve",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#resolve",
    "access": "public",
    "description": "",
    "lineNumber": 576,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Map<TemporalField, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldValues",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "partialTemporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ResolverStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "resolverStyle",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1479,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR_FIELD#displayName",
    "access": "public",
    "description": "",
    "lineNumber": 617,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1480,
    "kind": "class",
    "name": "WEEK_BASED_YEAR_FIELD",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 626,
    "interface": false,
    "extends": [
      "Field"
    ],
    "ignore": true
  },
  {
    "__docId__": 1481,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#toString",
    "access": "public",
    "description": "",
    "lineNumber": 632,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1482,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#baseUnit",
    "access": "public",
    "description": "",
    "lineNumber": 640,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1483,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#rangeUnit",
    "access": "public",
    "description": "",
    "lineNumber": 648,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{TemporalUnit}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1484,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#range",
    "access": "public",
    "description": "",
    "lineNumber": 656,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1485,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 665,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1486,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#rangeRefinedBy",
    "access": "public",
    "description": "",
    "lineNumber": 676,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ValueRange}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1487,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#getFrom",
    "access": "public",
    "description": "",
    "lineNumber": 685,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1488,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR_FIELD#adjustInto",
    "access": "public",
    "description": "",
    "lineNumber": 698,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{temporal}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1489,
    "kind": "class",
    "name": "Unit",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": "Implementation of the period unit.",
    "lineNumber": 722,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalUnit.js~TemporalUnit"
    ],
    "ignore": true
  },
  {
    "__docId__": 1490,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 730,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "estimatedDuration",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1491,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#_name",
    "access": "private",
    "description": null,
    "lineNumber": 732,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1492,
    "kind": "member",
    "name": "_duration",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#_duration",
    "access": "private",
    "description": null,
    "lineNumber": 733,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1493,
    "kind": "method",
    "name": "duration",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#duration",
    "access": "public",
    "description": "",
    "lineNumber": 740,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Duration}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1494,
    "kind": "method",
    "name": "isDurationEstimated",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#isDurationEstimated",
    "access": "public",
    "description": "",
    "lineNumber": 748,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1495,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#isDateBased",
    "access": "public",
    "description": "",
    "lineNumber": 756,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1496,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#isTimeBased",
    "access": "public",
    "description": "",
    "lineNumber": 764,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1497,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#isSupportedBy",
    "access": "public",
    "description": "",
    "lineNumber": 773,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1498,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#addTo",
    "access": "public",
    "description": "",
    "lineNumber": 783,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "periodToAdd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1499,
    "kind": "method",
    "name": "between",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#between",
    "access": "public",
    "description": "",
    "lineNumber": 803,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1500,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/IsoFields.js~Unit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/IsoFields.js~Unit#toString",
    "access": "public",
    "description": null,
    "lineNumber": 814,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1501,
    "kind": "variable",
    "name": "DAY_OF_QUARTER",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~DAY_OF_QUARTER",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 819,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1502,
    "kind": "variable",
    "name": "QUARTER_OF_YEAR",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_OF_YEAR",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 820,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1503,
    "kind": "variable",
    "name": "WEEK_OF_WEEK_BASED_YEAR",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_OF_WEEK_BASED_YEAR",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 821,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1504,
    "kind": "variable",
    "name": "WEEK_BASED_YEAR",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEAR",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 822,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1505,
    "kind": "variable",
    "name": "WEEK_BASED_YEARS",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~WEEK_BASED_YEARS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 823,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1506,
    "kind": "variable",
    "name": "QUARTER_YEARS",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~QUARTER_YEARS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 824,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1507,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/temporal/IsoFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/IsoFields.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/IsoFields.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 826,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1508,
    "kind": "file",
    "name": "packages/core/src/temporal/Temporal.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert, abstractMethodFail, requireInstance, requireNonNull } from '../assert';\nimport { IllegalArgumentException } from '../errors';\nimport { TemporalAccessor } from './TemporalAccessor';\nimport { TemporalAmount } from './TemporalAmount';\nimport { TemporalUnit } from './TemporalUnit';\n\n/**\n * Framework-level interface defining read-write access to a temporal object,\n * such as a date, time, offset or some combination of these.\n *\n * This is the base interface type for date, time and offset objects that\n * are complete enough to be manipulated using plus and minus.\n * It is implemented by those classes that can provide and manipulate information\n * as fields (see {@link TemporalField}) or queries (see {@link TemporalQuery}).\n * See {@link TemporalAccessor} for the read-only version of this interface.\n *\n * Most date and time information can be represented as a number.\n * These are modeled using {@link TemporalField} with the number held using\n * a `long` to handle large values. Year, month and day-of-month are\n * simple examples of fields, but they also include instant and offsets.\n * See {@link ChronoField} for the standard set of fields.\n *\n * Two pieces of date/time information cannot be represented by numbers,\n * the {@link Chronology} and the {@link ZoneId}.\n * These can be accessed using the static methods defined on {@link TemporalQueries}.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link LocalDate}.\n * There are many reasons for this, part of which is that implementations\n * of this interface may be in calendar systems other than ISO.\n * See {@link ChronoLocalDate} for a fuller discussion of the issues.\n *\n * ### When to implement\n *\n * A class should implement this interface if it meets three criteria:\n *\n * * it provides access to date/time/offset information, as per {@link TemporalAccessor}\n * * the set of fields are contiguous from the largest to the smallest\n * * the set of fields are complete, such that no other field is needed to define the\n *   valid range of values for the fields that are represented\n *\n * Four examples make this clear:\n *\n * * {@link LocalDate} implements this interface as it represents a set of fields\n *   that are contiguous from days to forever and require no external information to determine\n *   the validity of each date. It is therefore able to implement plus/minus correctly.\n * * {@link LocalTime} implements this interface as it represents a set of fields\n *   that are contiguous from nanos to within days and require no external information to determine\n *   validity. It is able to implement plus/minus correctly, by wrapping around the day.\n * * {@link MonthDay}, the combination of month-of-year and day-of-month, does not implement\n *   this interface.  While the combination is contiguous, from days to months within years,\n *   the combination does not have sufficient information to define the valid range of values\n *   for day-of-month.  As such, it is unable to implement plus/minus correctly.\n * * The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n *   this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n *   days to months.\n *\n * @interface\n */\nexport class Temporal extends TemporalAccessor {\n    /**\n     * Checks if the specified unit is supported.\n     * This checks if the date-time can be queried for the specified unit. If false, then calling the plus and minus methods will throw an exception.\n\n     * ### Specification for implementors\n     * Implementations must check and handle all fields defined in {@link ChronoUnit}. If the field is supported, then true is returned, otherwise false\n     * If the field is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)` passing this as the argument.\n\n     * Implementations must not alter this object.\n\n     * @param {TemporalUnit} fieldOrUnit - the unit to check, null returns false\n     * @return {boolean} true if this date-time can be queried for the unit, false if not\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupported(fieldOrUnit) {\n        abstractMethodFail('isSupported');\n    }\n\n    /**\n     * function overloading for {@link Temporal.plus}\n     *\n     * Called with 1 (or less) arguments, p1 is expected to be a {@link TemporalAmount} and {@link Temporal.minusAmount} is called.\n     *\n     * Otherwise {@link Temporal.minusAmountUnit} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @return {Temporal}\n     */\n    minus(amount, unit) {\n        if (arguments.length < 2) {\n            return this._minusAmount(amount);\n        } else {\n            return this._minusUnit(amount, unit);\n        }\n    }\n\n    /**\n     * Returns an object of the same type as this object with an amount subtracted.\n     * This adjusts this temporal, subtracting according to the rules of the specified amount. The\n     * amount is typically a {@link Period} but may be any other type implementing the {@link TemporalAmount} interface, such as Duration.\n     *\n     * Some example code indicating how and why this method is used:\n     *\n     * <pre>\n     *   date = date.minus(period);                  // subtract a Period instance\n     *   date = date.minus(duration);                // subtract a Duration instance\n     *   date = date.minus(workingDays(6));          // example user-written workingDays method\n     * </pre>\n     *\n     * Note that calling plus followed by minus is not guaranteed to return the same date-time.\n     *\n     * ### Specification for implementors\n     * Implementations must not alter either this object. Instead, an adjusted copy of the original\n     * must be returned. This provides equivalent, safe behavior for immutable and mutable\n     * implementations.\n     *\n     * @param {TemporalAmount} amount - the amount to subtract, not null\n     * @return {Temporal} an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException - if the subtraction cannot be made\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    _minusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.subtractFrom(this);\n    }\n\n    /**\n     * Returns an object of the same type as this object with the specified period subtracted.\n     * This method returns a new object based on this one with the specified period subtracted. For example, on a {@link LocalDate}, this could be used to subtract a number of years, months or days. The returned object will have the same observable type as this object.\n     *\n     * In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st March, then subtracting one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the implementation represents a date-time that has boundaries, such {@link as} LocalTime, then the permitted units must include the boundary unit, but no multiples of the boundary unit. For example, {@link LocalTime} must accept `DAYS` but not `WEEKS` or `MONTHS`.\n     *\n     * ### Specification for implementors\n     * Implementations must behave in a manor equivalent to the default method behavior.\n     * Implementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {number} amountToSubtract - the amount of the specified unit to subtract, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to subtract, not null\n     * @return {Temporal} an object of the same type with the specified period subtracted, not null\n     * @throws DateTimeException - if the unit cannot be subtracted\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    _minusUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        requireInstance(unit, TemporalUnit, 'unit');\n        return this._plusUnit(-amountToSubtract, unit);\n    }\n\n    /**\n     * function overloading for {@link Temporal.plus}\n     *\n     * Called with 1 (or less) arguments, p1 is expected to be a {@link TemporalAmount} and {@link Temporal.plusAmount} is called.\n     *\n     * Otherwise {@link Temporal.plusAmountUnit} is called.\n     *\n     * @param {!(TemporalAmount|number)} amount\n     * @param {TemporalUnit} unit\n     * @return {Temporal}\n     */\n    plus(amount, unit) {\n        if (arguments.length < 2) {\n            return this._plusAmount(amount);\n        } else {\n            return this._plusUnit(amount, unit);\n        }\n    }\n\n    /**\n     * Returns an object of the same type as this object with an amount added.\n     * This adjusts this temporal, adding according to the rules of the specified amount. The amount is typically a {@link Period} but may be any other type implementing the {@link TemporalAmount} interface, such as {@link Duration}.\n     *\n     * Some example code indicating how and why this method is used:\n     *\n     * <pre>\n     *   date = date.plus(period);                  // add a Period instance\n     *   date = date.plus(duration);                // add a Duration instance\n     *   date = date.plus(workingDays(6));          // example user-written workingDays method\n     * </pre>\n     *\n     * Note that calling plus followed by minus is not guaranteed to return the same date-time.\n     *\n     * ### Specification for implementors\n     * Implementations must not alter either this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {TemporalAmount} amount - the amount to add, not null\n     * @return {Temporal} an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException - if the addition cannot be made\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    _plusAmount(amount) {\n        requireNonNull(amount, 'amount');\n        requireInstance(amount, TemporalAmount, 'amount');\n        return amount.addTo(this);\n    }\n\n    /**\n     * Returns an object of the same type as this object with the specified period added.\n     * This method returns a new object based on this one with the specified period added. For example, on a {@link LocalDate}, this could be used to add a number of years, months or days. The returned object will have the same observable type as this object.\n     *\n     * In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then adding one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n     *\n     * If the implementation represents a date-time that has boundaries, such as {@link LocalTime}, then the permitted units must include the boundary unit, but no multiples of the boundary unit. For example, {@link LocalTime} must accept `DAYS` but not `WEEKS` or `MONTHS`.\n     *\n     * ### Specification for implementors\n     * Implementations must check and handle all units defined in {@link ChronoUnit}. If the unit is supported, then the addition must be performed. If unsupported, then a {@link DateTimeException} must be thrown.\n     * If the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.addTo(Temporal, long)` passing this as the first argument.\n     *\n     * Implementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {number} amountToAdd - the amount of the specified unit to add, may be negative\n     * @param {TemporalUnit} unit - the unit of the period to add, not null\n     * @return {Temporal} an object of the same type with the specified period added, not null\n     * @throws DateTimeException - if the unit cannot be added\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    _plusUnit(amountToAdd, unit) {\n        abstractMethodFail('_plusUnit');\n    }\n\n    /**\n     * Calculates the period between this temporal and another temporal in terms of the specified unit.\n     * This calculates the period between two temporals in terms of a single unit. The start and end points are this and the specified temporal. The result will be negative if the end is before the start. For example, the period in hours between two temporal objects can be calculated using `startTime.until(endTime, HOURS)`.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals. For example, the period in hours between the times 11:30 and 13:29 will only be one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use `TemporalUnit.between(Temporal, Temporal)`:\n     *\n     * <pre>\n     *    // these two lines are equivalent\n     *    between = thisUnit.between(start, end);\n     *    between = start.until(end, thisUnit);\n     * </pre>\n     *\n     * The choice should be made based on which makes the code more readable.\n     * For example, this method allows the number of days between two dates to be calculated:\n     *\n     * <pre>\n     *    long daysBetween = DAYS.between(start, end);\n     *    // or alternatively\n     *    long daysBetween = start.until(end, DAYS);\n     * </pre>\n     *\n     * ### Specification for implementors\n     * Implementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of {@link ChronoUnit}. A {@link DateTimeException} must be thrown for {@link ChronoUnit} instances that are unsupported.\n     * If the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.between(Temporal, Temporal)` passing this as the first argument and the input temporal as the second argument.\n     *\n     * In summary, implementations must behave in a manner equivalent to this code:\n     *\n     * <pre>\n     *   // check input temporal is the same type as this class\n     *   if (unit instanceof ChronoUnit) {\n     *     // if unit is supported, then calculate and return result\n     *     // else throw DateTimeException for unsupported units\n     *   }\n     *   return unit.between(this, endTemporal);\n     * </pre>\n     *\n     * The target object must not be altered by this method.\n     *\n     * @param {Temporal} endTemporal - the end temporal, of the same type as this object, not null\n     * @param {TemporalUnit} unit - the unit to measure the period in, not null\n     * @return {number} the amount of the period between this and the end\n     * @throws DateTimeException - if the period cannot be calculated\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    until(endTemporal, unit) {\n        abstractMethodFail('until');\n    }\n\n    /**\n     * function overloading for {@link Temporal.with}\n     *\n     * Called with 1 (or less) arguments, p1 is expected to be a {@link TemporalAdjuster} and {@link Temporal.withAdjuster} is called.\n     *\n     * Otherwise {@link Temporal.withFieldValue} is called.\n     *\n     * @param {!(TemporalAdjuster|TemporalField)} adjusterOrField\n     * @param {number} newValue\n     * @return {Temporal}\n     */\n    with(adjusterOrField, newValue) {\n        if (arguments.length < 2) {\n            return this._withAdjuster(adjusterOrField);\n        } else {\n            return this._withField(adjusterOrField, newValue);\n        }\n    }\n\n    /**\n     * Returns an adjusted object of the same type as this object with the adjustment made.\n     * This adjusts this date-time according to the rules of the specified adjuster. A simple adjuster might simply set the one of the fields, such as the year field. A more complex adjuster might set the date to the last day of the month. A selection of common adjustments is provided in {@link TemporalAdjusters}. These include finding the \"last day of the month\" and \"next Wednesday\". The adjuster is responsible for handling special cases, such as the varying lengths of month and leap years.\n     *\n     * Some example code indicating how and why this method is used:\n     *\n     * <pre>\n     *   date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster\n     *   date = date.with(lastDayOfMonth());  // static import from TemporalAdjusters\n     *   date = date.with(next(WEDNESDAY));   // static import from TemporalAdjusters and DayOfWeek\n     * </pre>\n     *\n     * ### Specification for implementors\n     * Implementations must not alter either this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {Temporal} an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException - if unable to make the adjustment\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        requireNonNull(adjuster, 'adjuster');\n        assert(typeof adjuster.adjustInto === 'function',\n            'adjuster must be a TemporalAdjuster',\n            IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    }\n\n    /**\n     * Returns an object of the same type as this object with the specified field altered.\n     * This returns a new object based on this one with the value for the specified field changed. For example, on a {@link LocalDate}, this could be used to set the year, month or day-of-month. The returned object will have the same observable type as this object.\n     *\n     * In some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n     *\n     * ### Specification for implementors\n     * Implementations must check and handle all fields defined in {@link ChronoField}. If the field is supported, then the adjustment must be performed. If unsupported, then a {@link DateTimeException} must be thrown.\n     * If the field is not a {@link ChronoField}, then the result of this method is obtained by invoking `TemporalField.adjustInto(Temporal, long)` passing this as the first argument.\n     *\n     * Implementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {Temporal} an object of the same type with the specified field set, not null\n     * @throws DateTimeException - if the field cannot be set\n     * @throws ArithmeticException - if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    _withField(field, newValue) {\n        abstractMethodFail('_withField');\n    }\n}\n\nif (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {\n    Temporal.prototype[Symbol.toPrimitive] = function (hint) {\n        // hint could be 'number', 'string' or 'default'. Only 'number'\n        // should throw and 'default' is treated as 'string'.\n        if (hint !== 'number') {\n            return this.toString();\n        }\n\n        throw new TypeError(\n            'A conversion from Temporal to a number is not allowed. ' +\n            'To compare use the methods .equals(), .compareTo(), .isBefore() ' +\n            'or one that is more suitable to your use case.'\n        );\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/Temporal.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1509,
    "kind": "class",
    "name": "Temporal",
    "memberof": "packages/core/src/temporal/Temporal.js",
    "static": true,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/Temporal.js",
    "importStyle": "{Temporal}",
    "description": "Framework-level interface defining read-write access to a temporal object,\nsuch as a date, time, offset or some combination of these.\n\nThis is the base interface type for date, time and offset objects that\nare complete enough to be manipulated using plus and minus.\nIt is implemented by those classes that can provide and manipulate information\nas fields (see {@link TemporalField}) or queries (see {@link TemporalQuery}).\nSee {@link TemporalAccessor} for the read-only version of this interface.\n\nMost date and time information can be represented as a number.\nThese are modeled using {@link TemporalField} with the number held using\na `long` to handle large values. Year, month and day-of-month are\nsimple examples of fields, but they also include instant and offsets.\nSee {@link ChronoField} for the standard set of fields.\n\nTwo pieces of date/time information cannot be represented by numbers,\nthe {@link Chronology} and the {@link ZoneId}.\nThese can be accessed using the static methods defined on {@link TemporalQueries}.\n\nThis interface is a framework-level interface that should not be widely\nused in application code. Instead, applications should create and pass\naround instances of concrete types, such as {@link LocalDate}.\nThere are many reasons for this, part of which is that implementations\nof this interface may be in calendar systems other than ISO.\nSee {@link ChronoLocalDate} for a fuller discussion of the issues.\n\n### When to implement\n\nA class should implement this interface if it meets three criteria:\n\n* it provides access to date/time/offset information, as per {@link TemporalAccessor}\n* the set of fields are contiguous from the largest to the smallest\n* the set of fields are complete, such that no other field is needed to define the\n  valid range of values for the fields that are represented\n\nFour examples make this clear:\n\n* {@link LocalDate} implements this interface as it represents a set of fields\n  that are contiguous from days to forever and require no external information to determine\n  the validity of each date. It is therefore able to implement plus/minus correctly.\n* {@link LocalTime} implements this interface as it represents a set of fields\n  that are contiguous from nanos to within days and require no external information to determine\n  validity. It is able to implement plus/minus correctly, by wrapping around the day.\n* {@link MonthDay}, the combination of month-of-year and day-of-month, does not implement\n  this interface.  While the combination is contiguous, from days to months within years,\n  the combination does not have sufficient information to define the valid range of values\n  for day-of-month.  As such, it is unable to implement plus/minus correctly.\n* The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n  this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n  days to months.",
    "lineNumber": 67,
    "interface": true,
    "extends": [
      "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor"
    ]
  },
  {
    "__docId__": 1510,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#isSupported",
    "access": "public",
    "description": "Checks if the specified unit is supported.\nThis checks if the date-time can be queried for the specified unit. If false, then calling the plus and minus methods will throw an exception.\n\n### Specification for implementors\nImplementations must check and handle all fields defined in {@link ChronoUnit}. If the field is supported, then true is returned, otherwise false\nIf the field is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)` passing this as the argument.\n\nImplementations must not alter this object.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": "the unit to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this date-time can be queried for the unit, false if not"
    }
  },
  {
    "__docId__": 1511,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#minus",
    "access": "public",
    "description": "function overloading for {@link Temporal.plus}\n\nCalled with 1 (or less) arguments, p1 is expected to be a {@link TemporalAmount} and {@link Temporal.minusAmount} is called.\n\nOtherwise {@link Temporal.minusAmountUnit} is called.",
    "lineNumber": 97,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAmount",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1512,
    "kind": "method",
    "name": "_minusAmount",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_minusAmount",
    "access": "private",
    "description": "Returns an object of the same type as this object with an amount subtracted.\nThis adjusts this temporal, subtracting according to the rules of the specified amount. The\namount is typically a {@link Period} but may be any other type implementing the {@link TemporalAmount} interface, such as Duration.\n\nSome example code indicating how and why this method is used:\n\n<pre>\n  date = date.minus(period);                  // subtract a Period instance\n  date = date.minus(duration);                // subtract a Duration instance\n  date = date.minus(workingDays(6));          // example user-written workingDays method\n</pre>\n\nNote that calling plus followed by minus is not guaranteed to return the same date-time.\n\n### Specification for implementors\nImplementations must not alter either this object. Instead, an adjusted copy of the original\nmust be returned. This provides equivalent, safe behavior for immutable and mutable\nimplementations.",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the amount to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the subtraction cannot be made"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1513,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_minusUnit",
    "access": "private",
    "description": "Returns an object of the same type as this object with the specified period subtracted.\nThis method returns a new object based on this one with the specified period subtracted. For example, on a {@link LocalDate}, this could be used to subtract a number of years, months or days. The returned object will have the same observable type as this object.\n\nIn some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st March, then subtracting one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n\nIf the implementation represents a date-time that has boundaries, such {@link as} LocalTime, then the permitted units must include the boundary unit, but no multiples of the boundary unit. For example, {@link LocalTime} must accept `DAYS` but not `WEEKS` or `MONTHS`.\n\n### Specification for implementors\nImplementations must behave in a manor equivalent to the default method behavior.\nImplementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the specified unit to subtract, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified period subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the unit cannot be subtracted"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1514,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#plus",
    "access": "public",
    "description": "function overloading for {@link Temporal.plus}\n\nCalled with 1 (or less) arguments, p1 is expected to be a {@link TemporalAmount} and {@link Temporal.plusAmount} is called.\n\nOtherwise {@link Temporal.plusAmountUnit} is called.",
    "lineNumber": 172,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAmount",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1515,
    "kind": "method",
    "name": "_plusAmount",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_plusAmount",
    "access": "private",
    "description": "Returns an object of the same type as this object with an amount added.\nThis adjusts this temporal, adding according to the rules of the specified amount. The amount is typically a {@link Period} but may be any other type implementing the {@link TemporalAmount} interface, such as {@link Duration}.\n\nSome example code indicating how and why this method is used:\n\n<pre>\n  date = date.plus(period);                  // add a Period instance\n  date = date.plus(duration);                // add a Duration instance\n  date = date.plus(workingDays(6));          // example user-written workingDays method\n</pre>\n\nNote that calling plus followed by minus is not guaranteed to return the same date-time.\n\n### Specification for implementors\nImplementations must not alter either this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAmount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the amount to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the addition cannot be made"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1516,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_plusUnit",
    "access": "private",
    "description": "Returns an object of the same type as this object with the specified period added.\nThis method returns a new object based on this one with the specified period added. For example, on a {@link LocalDate}, this could be used to add a number of years, months or days. The returned object will have the same observable type as this object.\n\nIn some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then adding one month would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n\nIf the implementation represents a date-time that has boundaries, such as {@link LocalTime}, then the permitted units must include the boundary unit, but no multiples of the boundary unit. For example, {@link LocalTime} must accept `DAYS` but not `WEEKS` or `MONTHS`.\n\n### Specification for implementors\nImplementations must check and handle all units defined in {@link ChronoUnit}. If the unit is supported, then the addition must be performed. If unsupported, then a {@link DateTimeException} must be thrown.\nIf the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.addTo(Temporal, long)` passing this as the first argument.\n\nImplementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 229,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the specified unit to add, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the period to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified period added, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the unit cannot be added"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1517,
    "kind": "method",
    "name": "until",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#until",
    "access": "public",
    "description": "Calculates the period between this temporal and another temporal in terms of the specified unit.\nThis calculates the period between two temporals in terms of a single unit. The start and end points are this and the specified temporal. The result will be negative if the end is before the start. For example, the period in hours between two temporal objects can be calculated using `startTime.until(endTime, HOURS)`.\n\nThe calculation returns a whole number, representing the number of complete units between the two temporals. For example, the period in hours between the times 11:30 and 13:29 will only be one hour as it is one minute short of two hours.\n\nThere are two equivalent ways of using this method. The first is to invoke this method directly. The second is to use `TemporalUnit.between(Temporal, Temporal)`:\n\n<pre>\n   // these two lines are equivalent\n   between = thisUnit.between(start, end);\n   between = start.until(end, thisUnit);\n</pre>\n\nThe choice should be made based on which makes the code more readable.\nFor example, this method allows the number of days between two dates to be calculated:\n\n<pre>\n   long daysBetween = DAYS.between(start, end);\n   // or alternatively\n   long daysBetween = start.until(end, DAYS);\n</pre>\n\n### Specification for implementors\nImplementations must begin by checking to ensure that the input temporal object is of the same observable type as the implementation. They must then perform the calculation for all instances of {@link ChronoUnit}. A {@link DateTimeException} must be thrown for {@link ChronoUnit} instances that are unsupported.\nIf the unit is not a {@link ChronoUnit}, then the result of this method is obtained by invoking `TemporalUnit.between(Temporal, Temporal)` passing this as the first argument and the input temporal as the second argument.\n\nIn summary, implementations must behave in a manner equivalent to this code:\n\n<pre>\n  // check input temporal is the same type as this class\n  if (unit instanceof ChronoUnit) {\n    // if unit is supported, then calculate and return result\n    // else throw DateTimeException for unsupported units\n  }\n  return unit.between(this, endTemporal);\n</pre>\n\nThe target object must not be altered by this method.",
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endTemporal",
        "description": "the end temporal, of the same type as this object, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the period in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of the period between this and the end"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the period cannot be calculated"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1518,
    "kind": "method",
    "name": "with",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#with",
    "access": "public",
    "description": "function overloading for {@link Temporal.with}\n\nCalled with 1 (or less) arguments, p1 is expected to be a {@link TemporalAdjuster} and {@link Temporal.withAdjuster} is called.\n\nOtherwise {@link Temporal.withFieldValue} is called.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAdjuster",
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "adjusterOrField",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1519,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted object of the same type as this object with the adjustment made.\nThis adjusts this date-time according to the rules of the specified adjuster. A simple adjuster might simply set the one of the fields, such as the year field. A more complex adjuster might set the date to the last day of the month. A selection of common adjustments is provided in {@link TemporalAdjusters}. These include finding the \"last day of the month\" and \"next Wednesday\". The adjuster is responsible for handling special cases, such as the varying lengths of month and leap years.\n\nSome example code indicating how and why this method is used:\n\n<pre>\n  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster\n  date = date.with(lastDayOfMonth());  // static import from TemporalAdjusters\n  date = date.with(next(WEDNESDAY));   // static import from TemporalAdjusters and DayOfWeek\n</pre>\n\n### Specification for implementors\nImplementations must not alter either this object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 323,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1520,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/core/src/temporal/Temporal.js~Temporal",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/Temporal.js~Temporal#_withField",
    "access": "private",
    "description": "Returns an object of the same type as this object with the specified field altered.\nThis returns a new object based on this one with the value for the specified field changed. For example, on a {@link LocalDate}, this could be used to set the year, month or day-of-month. The returned object will have the same observable type as this object.\n\nIn some cases, changing a field is not fully defined. For example, if the target object is a date representing the 31st January, then changing the month to February would be unclear. In cases like this, the field is responsible for resolving the result. Typically it will choose the previous valid date, which would be the last valid day of February in this example.\n\n### Specification for implementors\nImplementations must check and handle all fields defined in {@link ChronoField}. If the field is supported, then the adjustment must be performed. If unsupported, then a {@link DateTimeException} must be thrown.\nIf the field is not a {@link ChronoField}, then the result of this method is obtained by invoking `TemporalField.adjustInto(Temporal, long)` passing this as the first argument.\n\nImplementations must not alter either this object or the specified temporal object. Instead, an adjusted copy of the original must be returned. This provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 350,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same type with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException - if the field cannot be set"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException - if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1521,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalAccessor.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { UnsupportedTemporalTypeException } from '../errors';\nimport { abstractMethodFail } from '../assert';\n\nimport { ChronoField } from './ChronoField';\nimport { TemporalQueries } from './TemporalQueries';\n\nexport class TemporalAccessor {\n    /**\n     * Queries this date-time.\n     *\n     * This queries this date-time using the specified query strategy object.\n     *\n     * Queries are a key tool for extracting information from date-times.\n     * They exists to externalize the process of querying, permitting different\n     * approaches, as per the strategy design pattern.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * The most common query implementations are method references, such as\n     * {@link LocalDate::from} and {@link ZoneId::from}.\n     * Further implementations are on {@link TemporalQueries}.\n     * Queries may also be defined by applications.\n     *\n     * @implSpec\n     * Implementations of this method must behave as follows:\n     * <pre>\n        if (query == TemporalQueries.zoneId()\n            || query == TemporalQueries.chronology()\n            || query == TemporalQueries.precision()) {\n                return null;\n        }\n        return query.queryFrom(this);\n     * </pre>\n     *\n     * @param {TemporalQuery} query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    query(query) {\n        if (query === TemporalQueries.zoneId()\n                || query === TemporalQueries.chronology()\n                || query === TemporalQueries.precision()) {\n            return null;\n        }\n        return query.queryFrom(this);\n    }\n\n    /**\n     * Gets the value of the specified field as an `int`.\n     *\n     * This queries the date-time for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If the date-time cannot return the value, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported and has an `int` range, then the value of\n     * the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws DateTimeException if the range of valid values for the field exceeds an `int`\n     * @throws DateTimeException if the value is outside the range of valid values for the field\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    getLong(field) {\n        abstractMethodFail('getLong');\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * All fields can be expressed as a `long` integer.\n     * This method returns an object that describes the valid range for that value.\n     * The value of this temporal object is used to enhance the accuracy of the returned range.\n     * If the date-time cannot return the range, because the field is unsupported or for\n     * some other reason, an exception will be thrown.\n     *\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * ### Specification for implementors\n     *\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported, then the range of the field must be returned.\n     * If unsupported, then a {@link DateTimeException} must be thrown.\n     *\n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing `this` as the argument.\n     *\n     * Implementations must not alter either this object.\n     *\n     * @param {TemporalField} field  the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     */\n    range(field) {\n        if (field instanceof ChronoField) {\n            if (this.isSupported(field)) {\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    isSupported(field) {\n        abstractMethodFail('isSupported');\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalAccessor.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1522,
    "kind": "class",
    "name": "TemporalAccessor",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAccessor.js",
    "importStyle": "{TemporalAccessor}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 1523,
    "kind": "method",
    "name": "query",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor#query",
    "access": "public",
    "description": "Queries this date-time.\n\nThis queries this date-time using the specified query strategy object.\n\nQueries are a key tool for extracting information from date-times.\nThey exists to externalize the process of querying, permitting different\napproaches, as per the strategy design pattern.\nExamples might be a query that checks if the date is the day before February 29th\nin a leap year, or calculates the number of days to your next birthday.\n\nThe most common query implementations are method references, such as\n{@link LocalDate::from} and {@link ZoneId::from}.\nFurther implementations are on {@link TemporalQueries}.\nQueries may also be defined by applications.",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@implSpec",
        "tagValue": "Implementations of this method must behave as follows:\n<pre>\nif (query == TemporalQueries.zoneId()\n|| query == TemporalQueries.chronology()\n|| query == TemporalQueries.precision()) {\nreturn null;\n}\nreturn query.queryFrom(this);\n</pre>"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1524,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor#get",
    "access": "public",
    "description": "Gets the value of the specified field as an `int`.\n\nThis queries the date-time for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf the date-time cannot return the value, because the field is unsupported or for\nsome other reason, an exception will be thrown.\n\n### Specification for implementors\n\nImplementations must check and handle all fields defined in {@link ChronoField}.\nIf the field is supported and has an `int` range, then the value of\nthe field must be returned.\nIf unsupported, then a {@link DateTimeException} must be thrown.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing `this` as the argument.\n\nImplementations must not alter either this object.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field, within the valid range of values"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the field cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range of valid values for the field exceeds an `int`"
      },
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1525,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor#getLong",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1526,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nAll fields can be expressed as a `long` integer.\nThis method returns an object that describes the valid range for that value.\nThe value of this temporal object is used to enhance the accuracy of the returned range.\nIf the date-time cannot return the range, because the field is unsupported or for\nsome other reason, an exception will be thrown.\n\nNote that the result only describes the minimum and maximum valid values\nand it is important not to read too much into them. For example, there\ncould be values within the range that are invalid for the field.\n\n### Specification for implementors\n\nImplementations must check and handle all fields defined in {@link ChronoField}.\nIf the field is supported, then the range of the field must be returned.\nIf unsupported, then a {@link DateTimeException} must be thrown.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing `this` as the argument.\n\nImplementations must not alter either this object.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the range for the field cannot be obtained"
      }
    ]
  },
  {
    "__docId__": 1527,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAccessor.js~TemporalAccessor#isSupported",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1528,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalAdjuster.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\n\n/**\n * Strategy for adjusting a temporal object.\n *\n * Adjusters are a key tool for modifying temporal objects.\n * They exist to externalize the process of adjustment, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be an adjuster that sets the date avoiding weekends, or one that\n * sets the date to the last day of the month.\n *\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisAdjuster.adjustInto(temporal);\n *   temporal = temporal.with(thisAdjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * See {@link TemporalAdjusters} for a standard set of adjusters, including finding the\n * last day of the month.\n * Adjusters may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalAdjuster {\n\n    /**\n     * Adjusts the specified temporal object.\n     *\n     * This adjusts the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be an adjuster that sets the date avoiding weekends, or one that\n     * sets the date to the last day of the month.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisAdjuster.adjustInto(temporal);\n     *   temporal = temporal.with(thisAdjuster);\n     * </pre>\n     * It is recommended to use the second approach, {@link with},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and adjust it.\n     * The implementation defines the logic of the adjustment and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the adjustment.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal  the temporal object to adjust, not null\n     * @return {Temporal} an object of the same observable type with the adjustment made, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     *\n     * @abstract\n     */\n    // eslint-disable-next-line no-unused-vars\n    adjustInto(temporal){\n        abstractMethodFail('adjustInto');\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalAdjuster.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1529,
    "kind": "class",
    "name": "TemporalAdjuster",
    "memberof": "packages/core/src/temporal/TemporalAdjuster.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAdjuster.js",
    "importStyle": "{TemporalAdjuster}",
    "description": "Strategy for adjusting a temporal object.\n\nAdjusters are a key tool for modifying temporal objects.\nThey exist to externalize the process of adjustment, permitting different\napproaches, as per the strategy design pattern.\nExamples might be an adjuster that sets the date avoiding weekends, or one that\nsets the date to the last day of the month.\n\nThere are two equivalent ways of using a {@link TemporalAdjuster}.\nThe first is to invoke the method on this interface directly.\nThe second is to use {@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisAdjuster.adjustInto(temporal);\n  temporal = temporal.with(thisAdjuster);\n</pre>\nIt is recommended to use the second approach, {@link with},\nas it is a lot clearer to read in code.\n\nSee {@link TemporalAdjusters} for a standard set of adjusters, including finding the\nlast day of the month.\nAdjusters may also be defined by applications.\n\n### Specification for implementors\n\nThis interface places no restrictions on the mutability of implementations,\nhowever immutability is strongly recommended.",
    "lineNumber": 40,
    "interface": true
  },
  {
    "__docId__": 1530,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object.\n\nThis adjusts the specified temporal object using the logic\nencapsulated in the implementing class.\nExamples might be an adjuster that sets the date avoiding weekends, or one that\nsets the date to the last day of the month.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisAdjuster.adjustInto(temporal);\n  temporal = temporal.with(thisAdjuster);\n</pre>\nIt is recommended to use the second approach, {@link with},\nas it is a lot clearer to read in code.\n\n### Specification for implementors\n\nThe implementation must take the input object and adjust it.\nThe implementation defines the logic of the adjustment and is responsible for\ndocumenting that logic. It may use any method on {@link Temporal} to\nquery the temporal object and perform the adjustment.\nThe returned object must have the same observable type as the input object\n\nThe input object must not be altered.\nInstead, an adjusted copy of the original must be returned.\nThis provides equivalent, safe behavior for immutable and mutable temporal objects.\n\nThe input temporal object may be in a calendar system other than ISO.\nImplementations may choose to document compatibility with other calendar systems,\nor reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n\nThis method may be called from multiple threads in parallel.\nIt must be thread-safe when invoked.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same observable type with the adjustment made, not null"
    },
    "abstract": true,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to make the adjustment"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1531,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalAdjusters.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../assert';\nimport { IllegalStateException } from '../errors';\n\nimport { TemporalAdjuster } from './TemporalAdjuster';\nimport { ChronoField } from '../temporal/ChronoField';\nimport { ChronoUnit } from '../temporal/ChronoUnit';\nimport { MathUtil } from '../MathUtil';\n\n/**\n * Common implementations of {@link TemporalAdjuster}.\n *\n * This class provides common implementations of {@link TemporalAdjuster}.\n * They are especially useful to document the intent of business logic and\n * often link well to requirements.\n * For example, these two pieces of code do the same thing, but the second\n * one is clearer (assuming that there is a static import of this class):\n * <pre>\n *  // direct manipulation\n *  date.withDayOfMonth(1).plusMonths(1).minusDays(1);\n *  // use of an adjuster from this class\n *  date.with(lastDayOfMonth());\n * </pre>\n * There are two equivalent ways of using a {@link TemporalAdjuster}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link Temporal#with}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = adjuster.adjustInto(dateTime);\n *   dateTime = dateTime.with(adjuster);\n * </pre>\n * It is recommended to use the second approach, {@link with},\n * as it is a lot clearer to read in code.\n *\n * ### Specification for implementors\n *\n * This is a thread-safe utility class.\n * All returned adjusters are immutable and thread-safe.\n *\n * The JDK 8 ofDateAdjuster(UnaryOperator) method is not backported.\n */\nexport class TemporalAdjusters {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of month' adjuster, which returns a new date set to\n     * the first day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-02-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-month adjuster, not null\n     */\n    static firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'last day of month' adjuster, which returns a new date set to\n     * the last day of the current month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-31.\n     * * The input 2011-02-15 will return 2011-02-28.\n     * * The input 2012-02-15 will return 2012-02-29 (leap year).\n     * * The input 2011-04-15 will return 2011-04-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();\n     *  temporal.with(DAY_OF_MONTH, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-month adjuster, not null\n     */\n    static lastDayOfMonth() {\n        return Impl.LAST_DAY_OF_MONTH;\n    }\n\n    /**\n     * Returns the 'first day of next month' adjuster, which returns a new date set to\n     * the first day of the next month.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-02-01.\n     * * The input 2011-02-15 will return 2011-03-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextMonth() {\n        return Impl.FIRST_DAY_OF_NEXT_MONTH;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the 'first day of year' adjuster, which returns a new date set to\n     * the first day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-01-01.\n     * * The input 2011-02-15 will return 2011-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day-of-year adjuster, not null\n     */\n    static firstDayOfYear() {\n        return Impl.FIRST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'last day of year' adjuster, which returns a new date set to\n     * the last day of the current year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2011-12-31.\n     * * The input 2011-02-15 will return 2011-12-31.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();\n     *  temporal.with(DAY_OF_YEAR, lastDay);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the last day-of-year adjuster, not null\n     */\n    static lastDayOfYear() {\n        return Impl.LAST_DAY_OF_YEAR;\n    }\n\n    /**\n     * Returns the 'first day of next year' adjuster, which returns a new date set to\n     * the first day of the next year.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 will return 2012-01-01.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It is equivalent to:\n     * <pre>\n     *  temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);\n     * </pre>\n     *\n     * @return {TemporalAdjuster} the first day of next month adjuster, not null\n     */\n    static firstDayOfNextYear() {\n        return Impl.FIRST_DAY_OF_NEXT_YEAR;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the first in month adjuster, which returns a new date\n     * in the same month with the first matching day-of-week.\n     * This is used for expressions like 'first Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-05.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-02.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static firstInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(1, dayOfWeek);\n    }\n\n    /**\n     * Returns the last in month adjuster, which returns a new date\n     * in the same month with the last matching day-of-week.\n     * This is used for expressions like 'last Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (MONDAY) will return 2011-12-26.\n     * * The input 2011-12-15 for (FRIDAY) will return 2011-12-30.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the first in month adjuster, not null\n     */\n    static lastInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(-1, dayOfWeek);\n    }\n\n    /**\n     * Returns the day-of-week in month adjuster, which returns a new date\n     * in the same month with the ordinal day-of-week.\n     * This is used for expressions like the 'second Tuesday in March'.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.\n     * * The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.\n     * * The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.\n     * * The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.\n     * * The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.\n     * * The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).\n     * * The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).\n     * * The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).\n     * * The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).\n     *\n     * For a positive or zero ordinal, the algorithm is equivalent to finding the first\n     * day-of-week that matches within the month and then adding a number of weeks to it.\n     * For a negative ordinal, the algorithm is equivalent to finding the last\n     * day-of-week that matches within the month and then subtracting a number of weeks to it.\n     * The ordinal number of weeks is not validated and is interpreted leniently\n     * according to this algorithm. This definition means that an ordinal of zero finds\n     * the last matching day-of-week in the previous month.\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\n     * and the {@link DAYS} unit, and assumes a seven day week.\n     *\n     * @param {Number} ordinal  the week within the month, unbounded but typically from -5 to 5\n     * @param {DayOfWeek} dayOfWeek  the day-of-week, not null\n     * @return {TemporalAdjuster} the day-of-week in month adjuster, not null\n     */\n    static dayOfWeekInMonth(ordinal, dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        return new DayOfWeekInMonth(ordinal, dayOfWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the next day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the next day-of-week adjuster, not null\n     */\n    static next(dayOfWeek) {\n        return new RelativeDayOfWeek(2, dayOfWeek);\n    }\n\n    /**\n     * Returns the next-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week after the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the next-or-same day-of-week adjuster, not null\n     */\n    static nextOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(0, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek  the day-of-week to move the date to, not null\n     * @return {TemporalAdjuster} the previous day-of-week adjuster, not null\n     */\n    static previous(dayOfWeek) {\n        return new RelativeDayOfWeek(3, dayOfWeek);\n    }\n\n    /**\n     * Returns the previous-or-same day-of-week adjuster, which adjusts the date to the\n     * first occurrence of the specified day-of-week before the date being adjusted\n     * unless it is already on that day in which case the same object is returned.\n     *\n     * The ISO calendar system behaves as follows:\n     *\n     * * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n     * * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n     *\n     * The behavior is suitable for use with most calendar systems.\n     * It uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\n     * and assumes a seven day week.\n     *\n     * @param {DayOfWeek} dayOfWeek the day-of-week to check for or move the date to, not null\n     * @return {TemporalAdjuster} the previous-or-same day-of-week adjuster, not null\n     */\n    static previousOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(1, dayOfWeek);\n    }\n\n}\n\n//-----------------------------------------------------------------------\n/**\n * Enum implementing the adjusters.\n */\nclass Impl extends TemporalAdjuster {\n\n    /**\n     *\n     * @param ordinal\n     * @private\n     */\n    constructor(ordinal) {\n        super();\n        this._ordinal = ordinal;\n    }\n\n    adjustInto(temporal) {\n        switch (this._ordinal) {\n            case 0: return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            case 1: return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            case 2: return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n            case 3: return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n            case 4: return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n            case 5: return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n        }\n        throw new IllegalStateException('Unreachable');\n    }\n\n}\n\n/** First day of month adjuster. */\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\n/** Last day of month adjuster. */\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\n/** First day of year adjuster. */\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\n/** Last day of year adjuster. */\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\n/** First day of next month adjuster. */\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\n\n/**\n * Class implementing day-of-week in month adjuster.\n */\nclass DayOfWeekInMonth extends TemporalAdjuster {\n\n    /**\n     *\n     * @param ordinal\n     * @param dow\n     * @private\n     */\n    constructor(ordinal, dow) {\n        super();\n        this._ordinal = ordinal;\n        this._dowValue = dow.value();\n    }\n\n    adjustInto(temporal) {\n        if (this._ordinal >= 0) {\n            const temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            const curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let dowDiff = MathUtil.intMod((this._dowValue - curDow + 7), 7);\n            dowDiff += (this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(dowDiff, ChronoUnit.DAYS);\n        } else {\n            const temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            const curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            let daysDiff = this._dowValue - curDow;\n            daysDiff = (daysDiff === 0 ? 0 : (daysDiff > 0 ? daysDiff - 7 : daysDiff));\n            daysDiff -= (-this._ordinal - 1) * 7;  // safe from overflow\n            return temp.plus(daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n\n/**\n * Implementation of next, previous or current day-of-week.\n */\nclass RelativeDayOfWeek extends TemporalAdjuster {\n\n    /**\n     *\n     * @param relative\n     * @param dayOfWeek\n     * @private\n     */\n    constructor(relative, dayOfWeek) {\n        super();\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        /** Whether the current date is a valid answer. */\n        this._relative = relative;\n        /** The day-of-week value, from 1 to 7. */\n        this._dowValue = dayOfWeek.value();\n    }\n\n    adjustInto(temporal) {\n        const calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        if (this._relative < 2 && calDow === this._dowValue) {\n            return temporal;\n        }\n        if ((this._relative & 1) === 0) {\n            const daysDiff = calDow - this._dowValue;\n            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        } else {\n            const daysDiff = this._dowValue - calDow;\n            return temporal.minus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalAdjusters.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1532,
    "kind": "class",
    "name": "TemporalAdjusters",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAdjusters.js",
    "importStyle": "{TemporalAdjusters}",
    "description": "Common implementations of {@link TemporalAdjuster}.\n\nThis class provides common implementations of {@link TemporalAdjuster}.\nThey are especially useful to document the intent of business logic and\noften link well to requirements.\nFor example, these two pieces of code do the same thing, but the second\none is clearer (assuming that there is a static import of this class):\n<pre>\n // direct manipulation\n date.withDayOfMonth(1).plusMonths(1).minusDays(1);\n // use of an adjuster from this class\n date.with(lastDayOfMonth());\n</pre>\nThere are two equivalent ways of using a {@link TemporalAdjuster}.\nThe first is to invoke the method on the interface directly.\nThe second is to use {@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = adjuster.adjustInto(dateTime);\n  dateTime = dateTime.with(adjuster);\n</pre>\nIt is recommended to use the second approach, {@link with},\nas it is a lot clearer to read in code.\n\n### Specification for implementors\n\nThis is a thread-safe utility class.\nAll returned adjusters are immutable and thread-safe.\n\nThe JDK 8 ofDateAdjuster(UnaryOperator) method is not backported.",
    "lineNumber": 47,
    "interface": false
  },
  {
    "__docId__": 1533,
    "kind": "method",
    "name": "firstDayOfMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.firstDayOfMonth",
    "access": "public",
    "description": "Returns the 'first day of month' adjuster, which returns a new date set to\nthe first day of the current month.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2011-01-01.\n* The input 2011-02-15 will return 2011-02-01.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n temporal.with(DAY_OF_MONTH, 1);\n</pre>",
    "lineNumber": 67,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first day-of-month adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1534,
    "kind": "method",
    "name": "lastDayOfMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.lastDayOfMonth",
    "access": "public",
    "description": "Returns the 'last day of month' adjuster, which returns a new date set to\nthe last day of the current month.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2011-01-31.\n* The input 2011-02-15 will return 2011-02-28.\n* The input 2012-02-15 will return 2012-02-29 (leap year).\n* The input 2011-04-15 will return 2011-04-30.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();\n temporal.with(DAY_OF_MONTH, lastDay);\n</pre>",
    "lineNumber": 91,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the last day-of-month adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1535,
    "kind": "method",
    "name": "firstDayOfNextMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.firstDayOfNextMonth",
    "access": "public",
    "description": "Returns the 'first day of next month' adjuster, which returns a new date set to\nthe first day of the next month.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2011-02-01.\n* The input 2011-02-15 will return 2011-03-01.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);\n</pre>",
    "lineNumber": 112,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first day of next month adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1536,
    "kind": "method",
    "name": "firstDayOfYear",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.firstDayOfYear",
    "access": "public",
    "description": "Returns the 'first day of year' adjuster, which returns a new date set to\nthe first day of the current year.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2011-01-01.\n* The input 2011-02-15 will return 2011-01-01.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n temporal.with(DAY_OF_YEAR, 1);\n</pre>",
    "lineNumber": 134,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first day-of-year adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1537,
    "kind": "method",
    "name": "lastDayOfYear",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.lastDayOfYear",
    "access": "public",
    "description": "Returns the 'last day of year' adjuster, which returns a new date set to\nthe last day of the current year.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2011-12-31.\n* The input 2011-02-15 will return 2011-12-31.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();\n temporal.with(DAY_OF_YEAR, lastDay);\n</pre>",
    "lineNumber": 156,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the last day-of-year adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1538,
    "kind": "method",
    "name": "firstDayOfNextYear",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.firstDayOfNextYear",
    "access": "public",
    "description": "Returns the 'first day of next year' adjuster, which returns a new date set to\nthe first day of the next year.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 will return 2012-01-01.\n\nThe behavior is suitable for use with most calendar systems.\nIt is equivalent to:\n<pre>\n temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);\n</pre>",
    "lineNumber": 176,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first day of next month adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1539,
    "kind": "method",
    "name": "firstInMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.firstInMonth",
    "access": "public",
    "description": "Returns the first in month adjuster, which returns a new date\nin the same month with the first matching day-of-week.\nThis is used for expressions like 'first Tuesday in March'.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-12-15 for (MONDAY) will return 2011-12-05.\n* The input 2011-12-15 for (FRIDAY) will return 2011-12-02.\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\nand the {@link DAYS} unit, and assumes a seven day week.",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first in month adjuster, not null"
    }
  },
  {
    "__docId__": 1540,
    "kind": "method",
    "name": "lastInMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.lastInMonth",
    "access": "public",
    "description": "Returns the last in month adjuster, which returns a new date\nin the same month with the last matching day-of-week.\nThis is used for expressions like 'last Tuesday in March'.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-12-15 for (MONDAY) will return 2011-12-26.\n* The input 2011-12-15 for (FRIDAY) will return 2011-12-30.\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\nand the {@link DAYS} unit, and assumes a seven day week.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the first in month adjuster, not null"
    }
  },
  {
    "__docId__": 1541,
    "kind": "method",
    "name": "dayOfWeekInMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.dayOfWeekInMonth",
    "access": "public",
    "description": "Returns the day-of-week in month adjuster, which returns a new date\nin the same month with the ordinal day-of-week.\nThis is used for expressions like the 'second Tuesday in March'.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.\n* The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.\n* The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.\n* The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.\n* The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.\n* The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).\n* The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).\n* The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).\n* The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).\n\nFor a positive or zero ordinal, the algorithm is equivalent to finding the first\nday-of-week that matches within the month and then adding a number of weeks to it.\nFor a negative ordinal, the algorithm is equivalent to finding the last\nday-of-week that matches within the month and then subtracting a number of weeks to it.\nThe ordinal number of weeks is not validated and is interpreted leniently\naccording to this algorithm. This definition means that an ordinal of zero finds\nthe last matching day-of-week in the previous month.\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} and {@link DAY_OF_MONTH} fields\nand the {@link DAYS} unit, and assumes a seven day week.",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "ordinal",
        "description": "the week within the month, unbounded but typically from -5 to 5"
      },
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the day-of-week in month adjuster, not null"
    }
  },
  {
    "__docId__": 1542,
    "kind": "method",
    "name": "next",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.next",
    "access": "public",
    "description": "Returns the next day-of-week adjuster, which adjusts the date to the\nfirst occurrence of the specified day-of-week after the date being adjusted.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n* The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n* The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\nand assumes a seven day week.",
    "lineNumber": 281,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to move the date to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the next day-of-week adjuster, not null"
    }
  },
  {
    "__docId__": 1543,
    "kind": "method",
    "name": "nextOrSame",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.nextOrSame",
    "access": "public",
    "description": "Returns the next-or-same day-of-week adjuster, which adjusts the date to the\nfirst occurrence of the specified day-of-week after the date being adjusted\nunless it is already on that day in which case the same object is returned.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).\n* The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).\n* The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\nand assumes a seven day week.",
    "lineNumber": 303,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to check for or move the date to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the next-or-same day-of-week adjuster, not null"
    }
  },
  {
    "__docId__": 1544,
    "kind": "method",
    "name": "previous",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.previous",
    "access": "public",
    "description": "Returns the previous day-of-week adjuster, which adjusts the date to the\nfirst occurrence of the specified day-of-week before the date being adjusted.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n* The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n* The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\nand assumes a seven day week.",
    "lineNumber": 324,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to move the date to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the previous day-of-week adjuster, not null"
    }
  },
  {
    "__docId__": 1545,
    "kind": "method",
    "name": "previousOrSame",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~TemporalAdjusters.previousOrSame",
    "access": "public",
    "description": "Returns the previous-or-same day-of-week adjuster, which adjusts the date to the\nfirst occurrence of the specified day-of-week before the date being adjusted\nunless it is already on that day in which case the same object is returned.\n\nThe ISO calendar system behaves as follows:\n\n* The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).\n* The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).\n* The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).\n\nThe behavior is suitable for use with most calendar systems.\nIt uses the {@link DAY_OF_WEEK} field and the {@link DAYS} unit,\nand assumes a seven day week.",
    "lineNumber": 346,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to check for or move the date to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the previous-or-same day-of-week adjuster, not null"
    }
  },
  {
    "__docId__": 1546,
    "kind": "class",
    "name": "Impl",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~Impl",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAdjusters.js",
    "importStyle": null,
    "description": "Enum implementing the adjusters.",
    "lineNumber": 356,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster"
    ],
    "ignore": true
  },
  {
    "__docId__": 1547,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~Impl",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~Impl#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 363,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ordinal",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1548,
    "kind": "member",
    "name": "_ordinal",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~Impl",
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~Impl#_ordinal",
    "access": "private",
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1549,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~Impl",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~Impl#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 368,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1550,
    "kind": "class",
    "name": "DayOfWeekInMonth",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAdjusters.js",
    "importStyle": null,
    "description": "Class implementing day-of-week in month adjuster.",
    "lineNumber": 399,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster"
    ],
    "ignore": true
  },
  {
    "__docId__": 1551,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 407,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ordinal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dow",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1552,
    "kind": "member",
    "name": "_ordinal",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth",
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth#_ordinal",
    "access": "private",
    "description": null,
    "lineNumber": 409,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1553,
    "kind": "member",
    "name": "_dowValue",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth",
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth#_dowValue",
    "access": "private",
    "description": null,
    "lineNumber": 410,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1554,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~DayOfWeekInMonth#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 413,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1555,
    "kind": "class",
    "name": "RelativeDayOfWeek",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAdjusters.js",
    "importStyle": null,
    "description": "Implementation of next, previous or current day-of-week.",
    "lineNumber": 434,
    "interface": false,
    "extends": [
      "packages/core/src/temporal/TemporalAdjuster.js~TemporalAdjuster"
    ],
    "ignore": true
  },
  {
    "__docId__": 1556,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 442,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "relative",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1557,
    "kind": "member",
    "name": "_relative",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek",
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek#_relative",
    "access": "private",
    "description": "Whether the current date is a valid answer.",
    "lineNumber": 446,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1558,
    "kind": "member",
    "name": "_dowValue",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek",
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek#_dowValue",
    "access": "private",
    "description": "The day-of-week value, from 1 to 7.",
    "lineNumber": 448,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1559,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAdjusters.js~RelativeDayOfWeek#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1560,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalAmount.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\n\n/**\n * Framework-level interface defining an amount of time, such as\n * \"6 hours\", \"8 days\" or \"2 years and 3 months\".\n *\n * This is the base interface type for amounts of time.\n * An amount is distinct from a date or time-of-day in that it is not tied\n * to any specific point on the time-line.\n *\n * The amount can be thought of as a {@link Map} of {@link TemporalUnit} to\n * `long`, exposed via {@link getUnits} and {@link get}.\n * A simple case might have a single unit-value pair, such as \"6 hours\".\n * A more complex case may have multiple unit-value pairs, such as\n * \"7 years, 3 months and 5 days\".\n *\n * There are two common implementations.\n * {@link Period} is a date-based implementation, storing years, months and days.\n * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,\n * but providing some access using other duration based units such as minutes,\n * hours and fixed 24-hour days.\n *\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@link Period} and {@link Duration}.\n *\n * @interface\n */\nexport class TemporalAmount {\n    /**\n     * Returns the value of the requested unit.\n     * The units returned from {@link getUnits} uniquely define the\n     * value of the {@link TemporalAmount}.  A value must be returned\n     * for each unit listed in {@link getUnits}.\n     *\n     * @implSpec\n     * Implementations may declare support for units not listed by {@link getUnits}.\n     * Typically, the implementation would define additional units\n     * as conversions for the convenience of developers.\n     *\n     * @param {TemporalUnit} unit - the {@link TemporalUnit} for which to return the value\n     * @return {number} the long value of the unit\n     * @throws DateTimeException if a value for the unit cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the {@link unit} is not supported\n     */\n    // eslint-disable-next-line no-unused-vars\n    get(unit) {\n        abstractMethodFail('get');\n    }\n    \n    /**\n     * Returns the list of units uniquely defining the value of this TemporalAmount.\n     * The list of {@link TemporalUnits} is defined by the implementation class.\n     * The list is a snapshot of the units at the time {@link getUnits}\n     * is called and is not mutable.\n     * The units are ordered from longest duration to the shortest duration\n     * of the unit.\n     *\n     * @implSpec\n     * The list of units completely and uniquely represents the\n     * state of the object without omissions, overlaps or duplication.\n     * The units are in order from longest duration to shortest.\n     *\n     * @return {TemporalUnit[]} the List of {@link TemporalUnits}; not null\n     */\n    units() {\n        abstractMethodFail('units');\n    }\n    \n    /**\n     * Adds to the specified temporal object.\n     *\n     * Adds the amount to the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // These two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.addTo(dateTime);\n     *   dateTime = dateTime.plus(adder);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and add to it.\n     * The implementation defines the logic of the addition and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the addition.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to add the amount to, not null\n     * @return {Temporal} an object of the same observable type with the addition made, not null\n     * @throws DateTimeException if unable to add\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(temporal) {\n        abstractMethodFail('addTo');\n    }\n    \n    /**\n     * Subtracts this object from the specified temporal object.\n     *\n     * Subtracts the amount from the specified temporal object using the logic\n     * encapsulated in the implementing class.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#minus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   dateTime = amount.subtractFrom(dateTime);\n     *   dateTime = dateTime.minus(amount);\n     * </pre>\n     * It is recommended to use the second approach, {@link minus},\n     * as it is a lot clearer to read in code.\n     *\n     * @implSpec\n     * The implementation must take the input object and subtract from it.\n     * The implementation defines the logic of the subtraction and is responsible for\n     * documenting that logic. It may use any method on {@link Temporal} to\n     * query the temporal object and perform the subtraction.\n     * The returned object must have the same observable type as the input object\n     *\n     * The input object must not be altered.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable temporal objects.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {Temporal} temporal - the temporal object to subtract the amount from, not null\n     * @return {Temporal} an object of the same observable type with the subtraction made, not null\n     * @throws DateTimeException if unable to subtract\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    subtractFrom(temporal) {\n        abstractMethodFail('subtractFrom');\n    }\n    \n}\n\nif (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {\n    TemporalAmount.prototype[Symbol.toPrimitive] = function (hint) {\n        // hint could be 'number', 'string' or 'default'. Only 'number'\n        // should throw and 'default' is treated as 'string'.\n        if (hint !== 'number') {\n            return this.toString();\n        }\n\n        throw new TypeError(\n            'A conversion from TemporalAmount to a number is not allowed. ' +\n            'To compare use the methods .equals(), .compareTo(), .isBefore() ' +\n            'or one that is more suitable to your use case.'\n        );\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalAmount.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1561,
    "kind": "class",
    "name": "TemporalAmount",
    "memberof": "packages/core/src/temporal/TemporalAmount.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalAmount.js",
    "importStyle": "{TemporalAmount}",
    "description": "Framework-level interface defining an amount of time, such as\n\"6 hours\", \"8 days\" or \"2 years and 3 months\".\n\nThis is the base interface type for amounts of time.\nAn amount is distinct from a date or time-of-day in that it is not tied\nto any specific point on the time-line.\n\nThe amount can be thought of as a {@link Map} of {@link TemporalUnit} to\n`long`, exposed via {@link getUnits} and {@link get}.\nA simple case might have a single unit-value pair, such as \"6 hours\".\nA more complex case may have multiple unit-value pairs, such as\n\"7 years, 3 months and 5 days\".\n\nThere are two common implementations.\n{@link Period} is a date-based implementation, storing years, months and days.\n{@link Duration} is a time-based implementation, storing seconds and nanoseconds,\nbut providing some access using other duration based units such as minutes,\nhours and fixed 24-hour days.\n\nThis interface is a framework-level interface that should not be widely\nused in application code. Instead, applications should create and pass\naround instances of concrete types, such as {@link Period} and {@link Duration}.",
    "lineNumber": 35,
    "interface": true
  },
  {
    "__docId__": 1562,
    "kind": "method",
    "name": "get",
    "memberof": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount#get",
    "access": "public",
    "description": "Returns the value of the requested unit.\nThe units returned from {@link getUnits} uniquely define the\nvalue of the {@link TemporalAmount}.  A value must be returned\nfor each unit listed in {@link getUnits}.",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@implSpec",
        "tagValue": "Implementations may declare support for units not listed by {@link getUnits}.\nTypically, the implementation would define additional units\nas conversions for the convenience of developers."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the {@link TemporalUnit} for which to return the value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the long value of the unit"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if a value for the unit cannot be obtained"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the {@link unit} is not supported"
      }
    ]
  },
  {
    "__docId__": 1563,
    "kind": "method",
    "name": "units",
    "memberof": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount#units",
    "access": "public",
    "description": "Returns the list of units uniquely defining the value of this TemporalAmount.\nThe list of {@link TemporalUnits} is defined by the implementation class.\nThe list is a snapshot of the units at the time {@link getUnits}\nis called and is not mutable.\nThe units are ordered from longest duration to the shortest duration\nof the unit.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@implSpec",
        "tagValue": "The list of units completely and uniquely represents the\nstate of the object without omissions, overlaps or duplication.\nThe units are in order from longest duration to shortest."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit[]"
      ],
      "spread": false,
      "description": "the List of {@link TemporalUnits}; not null"
    },
    "params": []
  },
  {
    "__docId__": 1564,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount#addTo",
    "access": "public",
    "description": "Adds to the specified temporal object.\n\nAdds the amount to the specified temporal object using the logic\nencapsulated in the implementing class.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#plus}:\n<pre>\n  // These two lines are equivalent, but the second approach is recommended\n  dateTime = amount.addTo(dateTime);\n  dateTime = dateTime.plus(adder);\n</pre>\nIt is recommended to use the second approach, {@link plus},\nas it is a lot clearer to read in code.",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@implSpec",
        "tagValue": "The implementation must take the input object and add to it.\nThe implementation defines the logic of the addition and is responsible for\ndocumenting that logic. It may use any method on {@link Temporal} to\nquery the temporal object and perform the addition.\nThe returned object must have the same observable type as the input object\n\nThe input object must not be altered.\nInstead, an adjusted copy of the original must be returned.\nThis provides equivalent, safe behavior for immutable and mutable temporal objects.\n\nThe input temporal object may be in a calendar system other than ISO.\nImplementations may choose to document compatibility with other calendar systems,\nor reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n\nThis method may be called from multiple threads in parallel.\nIt must be thread-safe when invoked."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to add the amount to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same observable type with the addition made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to add"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1565,
    "kind": "method",
    "name": "subtractFrom",
    "memberof": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalAmount.js~TemporalAmount#subtractFrom",
    "access": "public",
    "description": "Subtracts this object from the specified temporal object.\n\nSubtracts the amount from the specified temporal object using the logic\nencapsulated in the implementing class.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#minus}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = amount.subtractFrom(dateTime);\n  dateTime = dateTime.minus(amount);\n</pre>\nIt is recommended to use the second approach, {@link minus},\nas it is a lot clearer to read in code.",
    "lineNumber": 162,
    "unknown": [
      {
        "tagName": "@implSpec",
        "tagValue": "The implementation must take the input object and subtract from it.\nThe implementation defines the logic of the subtraction and is responsible for\ndocumenting that logic. It may use any method on {@link Temporal} to\nquery the temporal object and perform the subtraction.\nThe returned object must have the same observable type as the input object\n\nThe input object must not be altered.\nInstead, an adjusted copy of the original must be returned.\nThis provides equivalent, safe behavior for immutable and mutable temporal objects.\n\nThe input temporal object may be in a calendar system other than ISO.\nImplementations may choose to document compatibility with other calendar systems,\nor reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n\nThis method may be called from multiple threads in parallel.\nIt must be thread-safe when invoked."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to subtract the amount from, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "an object of the same observable type with the subtraction made, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to subtract"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1566,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalField.js",
    "content": "import { abstractMethodFail } from '../assert';\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * A field of date-time, such as month-of-year or hour-of-minute.\n *\n * Date and time is expressed using fields which partition the time-line into something\n * meaningful for humans. Implementations of this interface represent those fields.\n *\n * The most commonly used units are defined in {@link ChronoField}.\n * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\n * Fields can also be written by application code by implementing this interface.\n *\n * The field works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the field is a {@link ChronoField}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalField {\n    /**\n     * Checks if this field represents a component of a date.\n     *\n     * @return {boolean} `true` if it is a component of a date, `false` otherwise.\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this field represents a component of a time.\n     *\n     * @return {boolean} `true` if it is a component of a time, `false` otherwise.\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    /**\n     * Gets the unit that the field is measured in.\n     *\n     * The unit of the field is the period that varies within the range.\n     * For example, in the field 'MonthOfYear', the unit is 'Months'.\n     * See also {@link rangeUnit}.\n     *\n     * @return {TemporalUnit} the period unit defining the base unit of the field.\n     */\n    baseUnit() {\n        abstractMethodFail('baseUnit');\n    }\n\n    /**\n     * Gets the range that the field is bound by.\n     * \n     * The range of the field is the period that the field varies within.\n     * For example, in the field 'MonthOfYear', the range is 'Years'.\n     * See also {@link baseUnit}.\n     * \n     * The range is never null. For example, the 'Year' field is shorthand for\n     * 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.\n     *\n     * @return {TemporalUnit} the period unit defining the range of the field.\n     */\n    rangeUnit() {\n        abstractMethodFail('rangeUnit');\n    }\n\n    /**\n     * Gets the range of valid values for the field.\n     *\n     * All fields can be expressed as an integer.\n     * This method returns an object that describes the valid range for that value.\n     * This method is generally only applicable to the ISO-8601 calendar system.\n     *\n     * Note that the result only describes the minimum and maximum valid values\n     * and it is important not to read too much into them. For example, there\n     * could be values within the range that are invalid for the field.\n     *\n     * @return {ValueRange} the range of valid values for the field.\n     */\n    range() {\n        abstractMethodFail('range');\n    }\n\n    /**\n     * Get the range of valid values for this field using the temporal object to\n     * refine the result.\n     *\n     * This uses the temporal object to find the range of valid values for the field.\n     * This is similar to {@link range}, however this method refines the result\n     * using the temporal. For example, if the field is {@link DAY_OF_MONTH} the\n     * {@link range} method is not accurate as there are four possible month lengths,\n     * 28, 29, 30 and 31 days. Using this method with a date allows the range to be\n     * accurate, returning just one of those four options.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#range}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.rangeRefinedBy(temporal);\n     *   temporal = temporal.range(thisField);\n     * </pre>\n     * It is recommended to use the second approach, {@link range},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccessor} temporal the temporal object used to refine the result.\n     * @return {ValueRange} the range of valid values for this field.\n     * @throws {DateTimeException} if the range for the field cannot be obtained.\n     * \n     */\n    // eslint-disable-next-line no-unused-vars\n    rangeRefinedBy(temporal) {\n        abstractMethodFail('rangeRefinedBy');\n    }\n\n    /**\n     * Gets the value of this field from the specified temporal object.\n     *\n     * This queries the temporal object for the value of this field.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#get}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.getFrom(temporal);\n     *   temporal = temporal.get(thisField);\n     * </pre>\n     * It is recommended to use the second approach, as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {number} the value of this field.\n     * @throws {DateTimeException} if a value for the field cannot be obtained.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getFrom(temporal) {\n        abstractMethodFail('getFrom');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the value of this field set.\n     *\n     * This returns a new temporal object based on the specified one with the value for\n     * this field changed. For example, on a {@link LocalDate}, this could be used to\n     * set the year, month or day-of-month.\n     * The returned object has the same observable type as the specified object.\n     *\n     * In some cases, changing a field is not fully defined. For example, if the target object is\n     * a date representing the 31st January, then changing the month to February would be unclear.\n     * In cases like this, the implementation is responsible for resolving the result.\n     * Typically it will choose the previous valid date, which would be the last valid\n     * day of February in this example.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#with}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.adjustInto(temporal);\n     *   temporal = temporal.with(thisField);\n     * </pre>\n     * It is recommended to use the second approach, `with(temporal)`,\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the fields\n     * available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {!Temporal} temporal the temporal object to adjust.\n     * @param {!number} newValue the new value of the field.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws {DateTimeException} if the field cannot be set.\n     */\n    // eslint-disable-next-line no-unused-vars\n    adjustInto(temporal, newValue) {\n        abstractMethodFail('adjustInto');\n    }\n\n    /**\n     * Checks if this field is supported by the temporal object.\n     *\n     * This determines whether the temporal accessor supports this field.\n     * If this returns false, the the temporal cannot be queried for this field.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#isSupported}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisField.isSupportedBy(temporal);\n     *   temporal = temporal.isSupported(thisField);\n     * </pre>\n     * It is recommended to use the second approach, `isSupported(temporal)`,\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should determine whether they are supported using the fields\n     * available in {@link ChronoField}.\n     *\n     * @param {!TemporalAccesor} temporal the temporal object to query.\n     * @return {boolean} `true` if the date-time can be queried for this field, `false` if not.\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * @return {string}\n     */\n    displayName(/* TODO: locale */) {\n        abstractMethodFail('displayName');\n    }\n\n    /**\n    * @param {*} other\n    * @returns {boolean}\n    */\n    // eslint-disable-next-line no-unused-vars\n    equals(other) {\n        abstractMethodFail('equals');\n    }\n\n    /**\n     * @returns {string}\n     */\n    name() {\n        abstractMethodFail('name');\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalField.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1567,
    "kind": "class",
    "name": "TemporalField",
    "memberof": "packages/core/src/temporal/TemporalField.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalField.js",
    "importStyle": "{TemporalField}",
    "description": "A field of date-time, such as month-of-year or hour-of-minute.\n\nDate and time is expressed using fields which partition the time-line into something\nmeaningful for humans. Implementations of this interface represent those fields.\n\nThe most commonly used units are defined in {@link ChronoField}.\nFurther fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.\nFields can also be written by application code by implementing this interface.\n\nThe field works using double dispatch. Client code calls methods on a date-time like\n{@link LocalDateTime} which check if the field is a {@link ChronoField}.\nIf it is, then the date-time must handle it.\nOtherwise, the method call is re-dispatched to the matching method in this interface.",
    "lineNumber": 26,
    "interface": true
  },
  {
    "__docId__": 1568,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#isDateBased",
    "access": "public",
    "description": "Checks if this field represents a component of a date.",
    "lineNumber": 32,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if it is a component of a date, `false` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 1569,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#isTimeBased",
    "access": "public",
    "description": "Checks if this field represents a component of a time.",
    "lineNumber": 41,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if it is a component of a time, `false` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 1570,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#baseUnit",
    "access": "public",
    "description": "Gets the unit that the field is measured in.\n\nThe unit of the field is the period that varies within the range.\nFor example, in the field 'MonthOfYear', the unit is 'Months'.\nSee also {@link rangeUnit}.",
    "lineNumber": 54,
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": "the period unit defining the base unit of the field."
    },
    "params": []
  },
  {
    "__docId__": 1571,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#rangeUnit",
    "access": "public",
    "description": "Gets the range that the field is bound by.\n\nThe range of the field is the period that the field varies within.\nFor example, in the field 'MonthOfYear', the range is 'Years'.\nSee also {@link baseUnit}.\n\nThe range is never null. For example, the 'Year' field is shorthand for\n'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.",
    "lineNumber": 70,
    "return": {
      "nullable": null,
      "types": [
        "TemporalUnit"
      ],
      "spread": false,
      "description": "the period unit defining the range of the field."
    },
    "params": []
  },
  {
    "__docId__": 1572,
    "kind": "method",
    "name": "range",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#range",
    "access": "public",
    "description": "Gets the range of valid values for the field.\n\nAll fields can be expressed as an integer.\nThis method returns an object that describes the valid range for that value.\nThis method is generally only applicable to the ISO-8601 calendar system.\n\nNote that the result only describes the minimum and maximum valid values\nand it is important not to read too much into them. For example, there\ncould be values within the range that are invalid for the field.",
    "lineNumber": 87,
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field."
    },
    "params": []
  },
  {
    "__docId__": 1573,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#rangeRefinedBy",
    "access": "public",
    "description": "Get the range of valid values for this field using the temporal object to\nrefine the result.\n\nThis uses the temporal object to find the range of valid values for the field.\nThis is similar to {@link range}, however this method refines the result\nusing the temporal. For example, if the field is {@link DAY_OF_MONTH} the\n{@link range} method is not accurate as there are four possible month lengths,\n28, 29, 30 and 31 days. Using this method with a date allows the range to be\naccurate, returning just one of those four options.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link TemporalAccessor#range}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisField.rangeRefinedBy(temporal);\n  temporal = temporal.range(thisField);\n</pre>\nIt is recommended to use the second approach, {@link range},\nas it is a lot clearer to read in code.\n\nImplementations should perform any queries or calculations using the fields\navailable in {@link ChronoField}.\nIf the field is not supported a {@link DateTimeException} must be thrown.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object used to refine the result."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for this field."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained."
      }
    ]
  },
  {
    "__docId__": 1574,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#getFrom",
    "access": "public",
    "description": "Gets the value of this field from the specified temporal object.\n\nThis queries the temporal object for the value of this field.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link TemporalAccessor#get}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisField.getFrom(temporal);\n  temporal = temporal.get(thisField);\n</pre>\nIt is recommended to use the second approach, as it is a lot clearer to read in code.\n\nImplementations should perform any queries or calculations using the fields\navailable in {@link ChronoField}.\nIf the field is not supported a {@link DateTimeException} must be thrown.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccesor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value of this field."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained."
      }
    ]
  },
  {
    "__docId__": 1575,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#adjustInto",
    "access": "public",
    "description": "Returns a copy of the specified temporal object with the value of this field set.\n\nThis returns a new temporal object based on the specified one with the value for\nthis field changed. For example, on a {@link LocalDate}, this could be used to\nset the year, month or day-of-month.\nThe returned object has the same observable type as the specified object.\n\nIn some cases, changing a field is not fully defined. For example, if the target object is\na date representing the 31st January, then changing the month to February would be unclear.\nIn cases like this, the implementation is responsible for resolving the result.\nTypically it will choose the previous valid date, which would be the last valid\nday of February in this example.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#with}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisField.adjustInto(temporal);\n  temporal = temporal.with(thisField);\n</pre>\nIt is recommended to use the second approach, `with(temporal)`,\nas it is a lot clearer to read in code.\n\nImplementations should perform any queries or calculations using the fields\navailable in {@link ChronoField}.\nIf the field is not supported a {@link DateTimeException} must be thrown.\n\nImplementations must not alter the specified temporal object.\nInstead, an adjusted copy of the original must be returned.\nThis provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 194,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to adjust."
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted temporal object."
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set."
      }
    ]
  },
  {
    "__docId__": 1576,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#isSupportedBy",
    "access": "public",
    "description": "Checks if this field is supported by the temporal object.\n\nThis determines whether the temporal accessor supports this field.\nIf this returns false, the the temporal cannot be queried for this field.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link TemporalAccessor#isSupported}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisField.isSupportedBy(temporal);\n  temporal = temporal.isSupported(thisField);\n</pre>\nIt is recommended to use the second approach, `isSupported(temporal)`,\nas it is a lot clearer to read in code.\n\nImplementations should determine whether they are supported using the fields\navailable in {@link ChronoField}.",
    "lineNumber": 222,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalAccesor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the date-time can be queried for this field, `false` if not."
    }
  },
  {
    "__docId__": 1577,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#displayName",
    "access": "public",
    "description": "",
    "lineNumber": 229,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1578,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#equals",
    "access": "public",
    "description": "",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1579,
    "kind": "method",
    "name": "name",
    "memberof": "packages/core/src/temporal/TemporalField.js~TemporalField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalField.js~TemporalField#name",
    "access": "public",
    "description": "",
    "lineNumber": 245,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1580,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalQueries.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n/**\n * Common implementations of {@link TemporalQuery}.\n *\n * This class provides common implementations of {@link TemporalQuery}.\n * These queries are primarily used as optimizations, allowing the internals\n * of other objects to be extracted effectively. Note that application code\n * can also use the {@link from} method on most temporal\n * objects as a method reference matching the query interface, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on the interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   dateTime = query.queryFrom(dateTime);\n *   dateTime = dateTime.query(query);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n */\nexport class TemporalQueries {\n\n    /**\n     * A strict query for the {@link ZoneId}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * The zone is only returned if the date-time conceptually contains a {@link ZoneId}.\n     * It will not be returned if the date-time only conceptually has an {@link ZoneOffset}.\n     * Thus a {@link ZonedDateTime} will return the result of\n     * {@link getZone}, but an {@link OffsetDateTime} will\n     * return null.\n     *\n     * In most cases, applications should use {@link ZONE} as this query is too strict.\n     *\n     * The result from JDK classes implementing {@link TemporalAccessor} is as follows:\n     * * * {@link LocalDate} returns null\n     * * {@link LocalTime} returns null\n     * * {@link LocalDateTime} returns null\n     * * {@link ZonedDateTime} returns the associated zone\n     * * {@link OffsetTime} returns null\n     * * {@link OffsetDateTime} returns null\n     * * {@link ChronoLocalDate} returns null\n     * * {@link ChronoLocalDateTime} returns null\n     * * {@link ChronoZonedDateTime} returns the associated zone\n     * * {@link Era} returns null\n     * * {@link DayOfWeek} returns null\n     * * {@link Month} returns null\n     * * {@link Year} returns null\n     * * {@link YearMonth} returns null\n     * * {@link MonthDay} returns null\n     * * {@link ZoneOffset} returns null\n     * * {@link Instant} returns null\n     *\n     * @return a query that can obtain the zone ID of a temporal, not null\n     */\n    static zoneId() {\n        return TemporalQueries.ZONE_ID;\n    }\n\n    /**\n     * A query for the {@link Chronology}.\n     *\n     * This queries a {@link TemporalAccessor} for the chronology.\n     * If the target {@link TemporalAccessor} represents a date, or part of a date,\n     * then it should return the chronology that the date is expressed in.\n     * As a result of this definition, objects only representing time, such as\n     * {@link LocalTime}, will return null.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * * {@link LocalDate} returns * {@link IsoChronology.INSTANCE}\n     * * {@link LocalTime} returns null (does not represent a date)\n     * * {@link LocalDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ZonedDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link OffsetTime} returns null (does not represent a date)\n     * * {@link OffsetDateTime} returns * {@link IsoChronology.INSTANCE}\n     * * {@link ChronoLocalDate} returns the associated chronology\n     * * {@link ChronoLocalDateTime} returns the associated chronology\n     * * {@link ChronoZonedDateTime} returns the associated chronology\n     * * {@link Era} returns the associated chronology\n     * * {@link DayOfWeek} returns null (shared across chronologies)\n     * * {@link Month} returns * {@link IsoChronology.INSTANCE}\n     * * {@link Year} returns * {@link IsoChronology.INSTANCE}\n     * * {@link YearMonth} returns * {@link IsoChronology.INSTANCE}\n     * * {@link MonthDay} returns null * {@link IsoChronology.INSTANCE}\n     * * {@link ZoneOffset} returns null (does not represent a date)\n     * * {@link Instant} returns null (does not represent a date)\n     *\n     * The method {@link Chronology#from} can be used as a\n     * {@link TemporalQuery}\n     * That method is equivalent to this query, except that it throws an\n     * exception if a chronology cannot be obtained.\n     *\n     * @return {TemporalQuery} a query that can obtain the chronology of a temporal, not null\n     */\n    static chronology() {\n        return TemporalQueries.CHRONO;\n    }\n\n    /**\n     * A query for the smallest supported unit.\n     *\n     * This queries a {@link TemporalAccessor} for the time precision.\n     * If the target {@link TemporalAccessor} represents a consistent or complete date-time,\n     * date or time then this must return the smallest precision actually supported.\n     * Note that fields such as {@link NANO_OF_DAY} and {@link NANO_OF_SECOND}\n     * are defined to always return ignoring the precision, thus this is the only\n     * way to find the actual smallest supported unit.\n     * For example, were {@link GregorianCalendar} to implement {@link TemporalAccessor}\n     * it would return a precision of {@link MILLIS}.\n     *\n     * The result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n     *\n     * {@link LocalDate} returns {@link DAYS}\n     * {@link LocalTime} returns {@link NANOS}\n     * {@link LocalDateTime} returns {@link NANOS}\n     * {@link ZonedDateTime} returns {@link NANOS}\n     * {@link OffsetTime} returns {@link NANOS}\n     * {@link OffsetDateTime} returns {@link NANOS}\n     * {@link ChronoLocalDate} returns {@link DAYS}\n     * {@link ChronoLocalDateTime} returns {@link NANOS}\n     * {@link ChronoZonedDateTime} returns {@link NANOS}\n     * {@link Era} returns {@link ERAS}\n     * {@link DayOfWeek} returns {@link DAYS}\n     * {@link Month} returns {@link MONTHS}\n     * {@link Year} returns {@link YEARS}\n     * {@link YearMonth} returns {@link MONTHS}\n     * {@link MonthDay} returns null (does not represent a complete date or time)\n     * {@link ZoneOffset} returns null (does not represent a date or time)\n     * {@link Instant} returns {@link NANOS}\n     *\n     * @return a query that can obtain the precision of a temporal, not null\n     */\n    static precision() {\n        return TemporalQueries.PRECISION;\n    }\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     *\n     * This queries a {@link TemporalAccessor} for the zone.\n     * It first tries to obtain the zone, using {@link zoneId}.\n     * If that is not found it tries to obtain the {@link offset}.\n     *\n     * In most cases, applications should use this query rather than {@link zoneId}.\n     *\n     * This query examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link ZoneId#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneId::from}.\n     * That method is equivalent to this query, except that it throws an\n     * exception if a zone cannot be obtained.\n     *\n     * @return a query that can obtain the zone ID or offset of a temporal, not null\n     */\n    static zone() {\n        return TemporalQueries.ZONE;\n    }\n\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the offset. The query will return null if the temporal\n     * object cannot supply an offset.\n     *\n     * The query implementation examines the {@link ChronoField#OFFSET_SECONDS}\n     * field and uses it to create a {@link ZoneOffset}.\n     *\n     * The method {@link java.time.ZoneOffset#from} can be used as a\n     * {@link TemporalQuery} via a method reference, {@link ZoneOffset::from}.\n     * This query and {@link ZoneOffset::from} will return the same result if the\n     * temporal object contains an offset. If the temporal object does not contain\n     * an offset, then the method reference will throw an exception, whereas this\n     * query will return null.\n     *\n     * @return a query that can obtain the offset of a temporal, not null\n     */\n    static offset() {\n        return TemporalQueries.OFFSET;\n    }\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local date. The query will return null if the temporal\n     * object cannot supply a local date.\n     *\n     * The query implementation examines the {@link ChronoField#EPOCH_DAY}\n     * field and uses it to create a {@link LocalDate}.\n     *\n     * @return a query that can obtain the date of a temporal, not null\n     */\n    static localDate() {\n        return TemporalQueries.LOCAL_DATE;\n    }\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     *\n     * This returns a {@link TemporalQuery} that can be used to query a temporal\n     * object for the local time. The query will return null if the temporal\n     * object cannot supply a local time.\n     *\n     * The query implementation examines the {@link ChronoField#NANO_OF_DAY}\n     * field and uses it to create a {@link LocalTime}.\n     *\n     * @return a query that can obtain the time of a temporal, not null\n     */\n    static localTime() {\n        return TemporalQueries.LOCAL_TIME;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalQueries.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1581,
    "kind": "class",
    "name": "TemporalQueries",
    "memberof": "packages/core/src/temporal/TemporalQueries.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalQueries.js",
    "importStyle": "{TemporalQueries}",
    "description": "Common implementations of {@link TemporalQuery}.\n\nThis class provides common implementations of {@link TemporalQuery}.\nThese queries are primarily used as optimizations, allowing the internals\nof other objects to be extracted effectively. Note that application code\ncan also use the {@link from} method on most temporal\nobjects as a method reference matching the query interface, such as\n{@link LocalDate::from} and {@link ZoneId::from}.\n\nThere are two equivalent ways of using a {@link TemporalQuery}.\nThe first is to invoke the method on the interface directly.\nThe second is to use {@link TemporalAccessor#query}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  dateTime = query.queryFrom(dateTime);\n  dateTime = dateTime.query(query);\n</pre>\nIt is recommended to use the second approach, {@link query},\nas it is a lot clearer to read in code.",
    "lineNumber": 29,
    "interface": false
  },
  {
    "__docId__": 1582,
    "kind": "method",
    "name": "zoneId",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.zoneId",
    "access": "public",
    "description": "A strict query for the {@link ZoneId}.\n\nThis queries a {@link TemporalAccessor} for the zone.\nThe zone is only returned if the date-time conceptually contains a {@link ZoneId}.\nIt will not be returned if the date-time only conceptually has an {@link ZoneOffset}.\nThus a {@link ZonedDateTime} will return the result of\n{@link getZone}, but an {@link OffsetDateTime} will\nreturn null.\n\nIn most cases, applications should use {@link ZONE} as this query is too strict.\n\nThe result from JDK classes implementing {@link TemporalAccessor} is as follows:\n* * {@link LocalDate} returns null\n* {@link LocalTime} returns null\n* {@link LocalDateTime} returns null\n* {@link ZonedDateTime} returns the associated zone\n* {@link OffsetTime} returns null\n* {@link OffsetDateTime} returns null\n* {@link ChronoLocalDate} returns null\n* {@link ChronoLocalDateTime} returns null\n* {@link ChronoZonedDateTime} returns the associated zone\n* {@link Era} returns null\n* {@link DayOfWeek} returns null\n* {@link Month} returns null\n* {@link Year} returns null\n* {@link YearMonth} returns null\n* {@link MonthDay} returns null\n* {@link ZoneOffset} returns null\n* {@link Instant} returns null",
    "lineNumber": 64,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the zone ID of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1583,
    "kind": "method",
    "name": "chronology",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.chronology",
    "access": "public",
    "description": "A query for the {@link Chronology}.\n\nThis queries a {@link TemporalAccessor} for the chronology.\nIf the target {@link TemporalAccessor} represents a date, or part of a date,\nthen it should return the chronology that the date is expressed in.\nAs a result of this definition, objects only representing time, such as\n{@link LocalTime}, will return null.\n\nThe result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n\n* {@link LocalDate} returns * {@link IsoChronology.INSTANCE}\n* {@link LocalTime} returns null (does not represent a date)\n* {@link LocalDateTime} returns * {@link IsoChronology.INSTANCE}\n* {@link ZonedDateTime} returns * {@link IsoChronology.INSTANCE}\n* {@link OffsetTime} returns null (does not represent a date)\n* {@link OffsetDateTime} returns * {@link IsoChronology.INSTANCE}\n* {@link ChronoLocalDate} returns the associated chronology\n* {@link ChronoLocalDateTime} returns the associated chronology\n* {@link ChronoZonedDateTime} returns the associated chronology\n* {@link Era} returns the associated chronology\n* {@link DayOfWeek} returns null (shared across chronologies)\n* {@link Month} returns * {@link IsoChronology.INSTANCE}\n* {@link Year} returns * {@link IsoChronology.INSTANCE}\n* {@link YearMonth} returns * {@link IsoChronology.INSTANCE}\n* {@link MonthDay} returns null * {@link IsoChronology.INSTANCE}\n* {@link ZoneOffset} returns null (does not represent a date)\n* {@link Instant} returns null (does not represent a date)\n\nThe method {@link Chronology#from} can be used as a\n{@link TemporalQuery}\nThat method is equivalent to this query, except that it throws an\nexception if a chronology cannot be obtained.",
    "lineNumber": 104,
    "return": {
      "nullable": null,
      "types": [
        "TemporalQuery"
      ],
      "spread": false,
      "description": "a query that can obtain the chronology of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1584,
    "kind": "method",
    "name": "precision",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.precision",
    "access": "public",
    "description": "A query for the smallest supported unit.\n\nThis queries a {@link TemporalAccessor} for the time precision.\nIf the target {@link TemporalAccessor} represents a consistent or complete date-time,\ndate or time then this must return the smallest precision actually supported.\nNote that fields such as {@link NANO_OF_DAY} and {@link NANO_OF_SECOND}\nare defined to always return ignoring the precision, thus this is the only\nway to find the actual smallest supported unit.\nFor example, were {@link GregorianCalendar} to implement {@link TemporalAccessor}\nit would return a precision of {@link MILLIS}.\n\nThe result from js-joda classes implementing {@link TemporalAccessor} is as follows:\n\n{@link LocalDate} returns {@link DAYS}\n{@link LocalTime} returns {@link NANOS}\n{@link LocalDateTime} returns {@link NANOS}\n{@link ZonedDateTime} returns {@link NANOS}\n{@link OffsetTime} returns {@link NANOS}\n{@link OffsetDateTime} returns {@link NANOS}\n{@link ChronoLocalDate} returns {@link DAYS}\n{@link ChronoLocalDateTime} returns {@link NANOS}\n{@link ChronoZonedDateTime} returns {@link NANOS}\n{@link Era} returns {@link ERAS}\n{@link DayOfWeek} returns {@link DAYS}\n{@link Month} returns {@link MONTHS}\n{@link Year} returns {@link YEARS}\n{@link YearMonth} returns {@link MONTHS}\n{@link MonthDay} returns null (does not represent a complete date or time)\n{@link ZoneOffset} returns null (does not represent a date or time)\n{@link Instant} returns {@link NANOS}",
    "lineNumber": 142,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the precision of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1585,
    "kind": "method",
    "name": "zone",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.zone",
    "access": "public",
    "description": "A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n\nThis queries a {@link TemporalAccessor} for the zone.\nIt first tries to obtain the zone, using {@link zoneId}.\nIf that is not found it tries to obtain the {@link offset}.\n\nIn most cases, applications should use this query rather than {@link zoneId}.\n\nThis query examines the {@link ChronoField#OFFSET_SECONDS}\nfield and uses it to create a {@link ZoneOffset}.\n\nThe method {@link ZoneId#from} can be used as a\n{@link TemporalQuery} via a method reference, {@link ZoneId::from}.\nThat method is equivalent to this query, except that it throws an\nexception if a zone cannot be obtained.",
    "lineNumber": 165,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the zone ID or offset of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1586,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.offset",
    "access": "public",
    "description": "A query for {@link ZoneOffset} returning null if not found.\n\nThis returns a {@link TemporalQuery} that can be used to query a temporal\nobject for the offset. The query will return null if the temporal\nobject cannot supply an offset.\n\nThe query implementation examines the {@link ChronoField#OFFSET_SECONDS}\nfield and uses it to create a {@link ZoneOffset}.\n\nThe method {@link java.time.ZoneOffset#from} can be used as a\n{@link TemporalQuery} via a method reference, {@link ZoneOffset::from}.\nThis query and {@link ZoneOffset::from} will return the same result if the\ntemporal object contains an offset. If the temporal object does not contain\nan offset, then the method reference will throw an exception, whereas this\nquery will return null.",
    "lineNumber": 188,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the offset of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1587,
    "kind": "method",
    "name": "localDate",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.localDate",
    "access": "public",
    "description": "A query for {@link LocalDate} returning null if not found.\n\nThis returns a {@link TemporalQuery} that can be used to query a temporal\nobject for the local date. The query will return null if the temporal\nobject cannot supply a local date.\n\nThe query implementation examines the {@link ChronoField#EPOCH_DAY}\nfield and uses it to create a {@link LocalDate}.",
    "lineNumber": 204,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the date of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1588,
    "kind": "method",
    "name": "localTime",
    "memberof": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueries.js~TemporalQueries.localTime",
    "access": "public",
    "description": "A query for {@link LocalTime} returning null if not found.\n\nThis returns a {@link TemporalQuery} that can be used to query a temporal\nobject for the local time. The query will return null if the temporal\nobject cannot supply a local time.\n\nThe query implementation examines the {@link ChronoField#NANO_OF_DAY}\nfield and uses it to create a {@link LocalTime}.",
    "lineNumber": 220,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a query that can obtain the time of a temporal, not null"
    },
    "params": []
  },
  {
    "__docId__": 1589,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalQueriesFactory.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField } from './ChronoField';\nimport { createTemporalQuery } from './TemporalQuery';\nimport { TemporalQueries } from './TemporalQueries';\n\nimport { LocalDate } from '../LocalDate';\nimport { LocalTime } from '../LocalTime';\nimport { ZoneOffset } from '../ZoneOffset';\n\n\nexport function _init() {\n    //-----------------------------------------------------------------------\n    /**\n     * A strict query for the {@link ZoneId}.\n     */\n    TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', (temporal) => {\n        return temporal.query(TemporalQueries.ZONE_ID);\n    });\n\n    /**\n     * A query for the {@link Chronology}.\n     */\n    TemporalQueries.CHRONO = createTemporalQuery('CHRONO', (temporal) => {\n        return temporal.query(TemporalQueries.CHRONO);\n    });\n\n    /**\n     * A query for the smallest supported unit.\n     */\n    TemporalQueries.PRECISION = createTemporalQuery('PRECISION', (temporal) => {\n        return temporal.query(TemporalQueries.PRECISION);\n    });\n\n    //-----------------------------------------------------------------------\n    /**\n     * A query for {@link ZoneOffset} returning null if not found.\n     */\n    TemporalQueries.OFFSET = createTemporalQuery('OFFSET', (temporal) => {\n        if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n        }\n        return null;\n    });\n\n    /**\n     * A lenient query for the {@link ZoneId}, falling back to the {@link ZoneOffset}.\n     */\n    TemporalQueries.ZONE = createTemporalQuery('ZONE', (temporal) => {\n        const zone = temporal.query(TemporalQueries.ZONE_ID);\n        return (zone != null ? zone : temporal.query(TemporalQueries.OFFSET));\n    });\n\n    /**\n     * A query for {@link LocalDate} returning null if not found.\n     */\n    TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', (temporal) => {\n        if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n        }\n        return null;\n    });\n\n    /**\n     * A query for {@link LocalTime} returning null if not found.\n     */\n    TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', (temporal) => {\n        if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n        }\n        return null;\n    });\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalQueriesFactory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1590,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/core/src/temporal/TemporalQueriesFactory.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQueriesFactory.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalQueriesFactory.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1591,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalQuery.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\nimport { Enum } from '../Enum';\n\n\n/**\n * Strategy for querying a temporal object.\n *\n * Queries are a key tool for extracting information from temporal objects.\n * They exist to externalize the process of querying, permitting different\n * approaches, as per the strategy design pattern.\n * Examples might be a query that checks if the date is the day before February 29th\n * in a leap year, or calculates the number of days to your next birthday.\n *\n * The {@link TemporalField} interface provides another mechanism for querying\n * temporal objects. That interface is limited to returning a `long`.\n * By contrast, queries can return any type.\n *\n * There are two equivalent ways of using a {@link TemporalQuery}.\n * The first is to invoke the method on this interface directly.\n * The second is to use {@link TemporalAccessor#query}:\n * <pre>\n *   // these two lines are equivalent, but the second approach is recommended\n *   temporal = thisQuery.queryFrom(temporal);\n *   temporal = temporal.query(thisQuery);\n * </pre>\n * It is recommended to use the second approach, {@link query},\n * as it is a lot clearer to read in code.\n *\n * The most common implementations are method references, such as\n * {@link LocalDate::from} and {@link ZoneId::from}.\n * Further implementations are on {@link TemporalQueries}.\n * Queries may also be defined by applications.\n *\n * ### Specification for implementors\n *\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n *\n * @interface\n */\nexport class TemporalQuery  extends Enum {\n    /**\n     * Queries the specified temporal object.\n     *\n     * This queries the specified temporal object to return an object using the logic\n     * encapsulated in the implementing class.\n     * Examples might be a query that checks if the date is the day before February 29th\n     * in a leap year, or calculates the number of days to your next birthday.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalAccessor#query}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisQuery.queryFrom(temporal);\n     *   temporal = temporal.query(thisQuery);\n     * </pre>\n     * It is recommended to use the second approach, {@link query},\n     * as it is a lot clearer to read in code.\n     *\n     * ### Specification for implementors\n     *\n     * The implementation must take the input object and query it.\n     * The implementation defines the logic of the query and is responsible for\n     * documenting that logic.\n     * It may use any method on {@link TemporalAccessor} to determine the result.\n     * The input object must not be altered.\n     *\n     * The input temporal object may be in a calendar system other than ISO.\n     * Implementations may choose to document compatibility with other calendar systems,\n     * or reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n     *\n     * This method may be called from multiple threads in parallel.\n     * It must be thread-safe when invoked.\n     *\n     * @param {TemporalAccessor} temporal  the temporal object to query, not null\n     * @return the queried value, may return null to indicate not found\n     * @throws DateTimeException if unable to query\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    // eslint-disable-next-line no-unused-vars\n    queryFrom(temporal){\n        abstractMethodFail('queryFrom');\n    }\n\n}\n\n/**\n * @private\n *\n * Factory to create something similar to the JSR-310 {TemporalQuery} interface, takes a function and returns a new TemporalQuery object that presents that function\n * as the queryFrom() function.\n * @param name for the underlying Enum\n * @param queryFromFunction\n */\nexport function createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalQuery.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1592,
    "kind": "class",
    "name": "TemporalQuery",
    "memberof": "packages/core/src/temporal/TemporalQuery.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQuery.js~TemporalQuery",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalQuery.js",
    "importStyle": "{TemporalQuery}",
    "description": "Strategy for querying a temporal object.\n\nQueries are a key tool for extracting information from temporal objects.\nThey exist to externalize the process of querying, permitting different\napproaches, as per the strategy design pattern.\nExamples might be a query that checks if the date is the day before February 29th\nin a leap year, or calculates the number of days to your next birthday.\n\nThe {@link TemporalField} interface provides another mechanism for querying\ntemporal objects. That interface is limited to returning a `long`.\nBy contrast, queries can return any type.\n\nThere are two equivalent ways of using a {@link TemporalQuery}.\nThe first is to invoke the method on this interface directly.\nThe second is to use {@link TemporalAccessor#query}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisQuery.queryFrom(temporal);\n  temporal = temporal.query(thisQuery);\n</pre>\nIt is recommended to use the second approach, {@link query},\nas it is a lot clearer to read in code.\n\nThe most common implementations are method references, such as\n{@link LocalDate::from} and {@link ZoneId::from}.\nFurther implementations are on {@link TemporalQueries}.\nQueries may also be defined by applications.\n\n### Specification for implementors\n\nThis interface places no restrictions on the mutability of implementations,\nhowever immutability is strongly recommended.",
    "lineNumber": 47,
    "interface": true,
    "extends": [
      "packages/core/src/Enum.js~Enum"
    ]
  },
  {
    "__docId__": 1593,
    "kind": "method",
    "name": "queryFrom",
    "memberof": "packages/core/src/temporal/TemporalQuery.js~TemporalQuery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalQuery.js~TemporalQuery#queryFrom",
    "access": "public",
    "description": "Queries the specified temporal object.\n\nThis queries the specified temporal object to return an object using the logic\nencapsulated in the implementing class.\nExamples might be a query that checks if the date is the day before February 29th\nin a leap year, or calculates the number of days to your next birthday.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link TemporalAccessor#query}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisQuery.queryFrom(temporal);\n  temporal = temporal.query(thisQuery);\n</pre>\nIt is recommended to use the second approach, {@link query},\nas it is a lot clearer to read in code.\n\n### Specification for implementors\n\nThe implementation must take the input object and query it.\nThe implementation defines the logic of the query and is responsible for\ndocumenting that logic.\nIt may use any method on {@link TemporalAccessor} to determine the result.\nThe input object must not be altered.\n\nThe input temporal object may be in a calendar system other than ISO.\nImplementations may choose to document compatibility with other calendar systems,\nor reject non-ISO temporal objects by querying the chronology (see {@link TemporalQueries#chronology}).\n\nThis method may be called from multiple threads in parallel.\nIt must be thread-safe when invoked.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to query, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the queried value, may return null to indicate not found"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if unable to query"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1594,
    "kind": "function",
    "name": "createTemporalQuery",
    "memberof": "packages/core/src/temporal/TemporalQuery.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/TemporalQuery.js~createTemporalQuery",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalQuery.js",
    "importStyle": "{createTemporalQuery}",
    "description": "",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "for the underlying Enum"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "queryFromFunction",
        "description": ""
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1595,
    "kind": "file",
    "name": "packages/core/src/temporal/TemporalUnit.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { abstractMethodFail } from '../assert';\n\n/**\n * A unit of date-time, such as Days or Hours.\n *\n * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.\n * Implementations of this interface represent those units.\n *\n * An instance of this interface represents the unit itself, rather than an amount of the unit.\n * See {@link Period} for a class that represents an amount in terms of the common units.\n *\n * The most commonly used units are defined in {@link ChronoUnit}.\n * Further units are supplied in {@link IsoFields}.\n * Units can also be written by application code by implementing this interface.\n *\n * The unit works using double dispatch. Client code calls methods on a date-time like\n * {@link LocalDateTime} which check if the unit is a {@link ChronoUnit}.\n * If it is, then the date-time must handle it.\n * Otherwise, the method call is re-dispatched to the matching method in this interface.\n *\n * @interface\n */\nexport class TemporalUnit {\n    /**\n     * Gets the duration of this unit, which may be an estimate.\n     *\n     * All units return a duration measured in standard nanoseconds from this method.\n     * The duration will be positive and non-zero.\n     * For example, an hour has a duration of `60 * 60 * 1,000,000,000 ns`.\n     *\n     * Some units may return an accurate duration while others return an estimate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * To determine if the duration is an estimate, use {@link isDurationEstimated}.\n     *\n     * @return {Duration} the duration of this unit, which may be an estimate.\n     */\n    duration() {\n        abstractMethodFail('duration');\n    }\n\n    /**\n     * Checks if the duration of the unit is an estimate.\n     *\n     * All units have a duration, however the duration is not always accurate.\n     * For example, days have an estimated duration due to the possibility of\n     * daylight saving time changes.\n     * This method returns true if the duration is an estimate and false if it is\n     * accurate. Note that accurate/estimated ignores leap seconds.\n     *\n     * @return {boolean} `true` if the duration is estimated, `false` if accurate.\n     */\n    isDurationEstimated() {\n        abstractMethodFail('isDurationEstimated');\n    }\n\n    /**\n     * Checks if this unit is date-based.\n     *\n     * @return {boolean} `true` if date unit, `false` if a time unit.\n     */\n    isDateBased() {\n        abstractMethodFail('isDateBased');\n    }\n\n    /**\n     * Checks if this unit is time-based.\n     *\n     * @return {boolean} `true` if time unit, `false` if a date unit.\n     */\n    isTimeBased() {\n        abstractMethodFail('isTimeBased');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this unit is supported by the specified temporal object.\n     *\n     * This checks that the implementing date-time can add/subtract this unit.\n     * This can be used to avoid throwing an exception.\n     *\n     * @param {!Temporal} temporal the temporal object to check.\n     * @return {boolean} `true` if the unit is supported.\n     */\n    // eslint-disable-next-line no-unused-vars\n    isSupportedBy(temporal) {\n        abstractMethodFail('isSupportedBy');\n    }\n\n    /**\n     * Returns a copy of the specified temporal object with the specified period added.\n     *\n     * The period added is a multiple of this unit. For example, this method\n     * could be used to add \"3 days\" to a date by calling this method on the\n     * instance representing \"days\", passing the date and the period \"3\".\n     * The period to be added may be negative, which is equivalent to subtraction.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#plus}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisUnit.doPlus(temporal);\n     *   temporal = temporal.plus(thisUnit);\n     * </pre>\n     * It is recommended to use the second approach, {@link plus},\n     * as it is a lot clearer to read in code.\n     *\n     * Implementations should perform any queries or calculations using the units\n     * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the field is not supported a {@link DateTimeException} must be thrown.\n     *\n     * Implementations must not alter the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param {!Temporal} dateTime the temporal object to adjust.\n     * @param {number} periodToAdd the period of this unit to add, positive or negative.\n     * @return {Temporal} the adjusted temporal object.\n     * @throws DateTimeException if the period cannot be added.\n     */\n    // eslint-disable-next-line no-unused-vars\n    addTo(dateTime, periodToAdd) {\n        abstractMethodFail('addTo');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the period in terms of this unit between two temporal objects of the same type.\n     *\n     * This calculates the period between two temporals in terms of this unit.\n     * The start and end points are supplied as temporal objects and must be of the same type.\n     * The result will be negative if the end is before the start.\n     * For example, the period in hours between two temporal objects can be calculated\n     * using {@link HOURS.between}.\n     *\n     * The calculation returns a whole number, representing the number of complete units between the two temporals.\n     * For example, the period in hours between the times 11:30 and 13:29 will only be\n     * one hour as it is one minute short of two hours.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link Temporal#until}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   between = thisUnit.between(start, end);\n     *   between = start.until(end, thisUnit);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * For example, this method allows the number of days between two dates to be calculated:\n     * <pre>\n     *   long daysBetween = DAYS.between(start, end);\n     *   // or alternatively\n     *   long daysBetween = start.until(end, DAYS);\n     * </pre>\n     * Implementations should perform any queries or calculations using the units available in\n     * {@link ChronoUnit} or the fields available in {@link ChronoField}.\n     * If the unit is not supported a {@link DateTimeException} must be thrown.\n     * Implementations must not alter the specified temporal objects.\n     *\n     * @param {!Temporal} temporal1 the base temporal object.\n     * @param {!Temporal} temporal2 the other temporal object.\n     * @return {number} the period between temporal1 and temporal2 in terms of this unit;\n     *  positive if temporal2 is later than temporal1, negative if earlier.\n     * @throws DateTimeException if the period cannot be calculated.\n     * @throws ArithmeticException if numeric overflow occurs.\n     */\n    // eslint-disable-next-line no-unused-vars\n    between(temporal1, temporal2) {\n        abstractMethodFail('between');\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/TemporalUnit.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1596,
    "kind": "class",
    "name": "TemporalUnit",
    "memberof": "packages/core/src/temporal/TemporalUnit.js",
    "static": true,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/TemporalUnit.js",
    "importStyle": "{TemporalUnit}",
    "description": "A unit of date-time, such as Days or Hours.\n\nMeasurement of time is built on units, such as years, months, days, hours, minutes and seconds.\nImplementations of this interface represent those units.\n\nAn instance of this interface represents the unit itself, rather than an amount of the unit.\nSee {@link Period} for a class that represents an amount in terms of the common units.\n\nThe most commonly used units are defined in {@link ChronoUnit}.\nFurther units are supplied in {@link IsoFields}.\nUnits can also be written by application code by implementing this interface.\n\nThe unit works using double dispatch. Client code calls methods on a date-time like\n{@link LocalDateTime} which check if the unit is a {@link ChronoUnit}.\nIf it is, then the date-time must handle it.\nOtherwise, the method call is re-dispatched to the matching method in this interface.",
    "lineNumber": 29,
    "interface": true
  },
  {
    "__docId__": 1597,
    "kind": "method",
    "name": "duration",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#duration",
    "access": "public",
    "description": "Gets the duration of this unit, which may be an estimate.\n\nAll units return a duration measured in standard nanoseconds from this method.\nThe duration will be positive and non-zero.\nFor example, an hour has a duration of `60 * 60 * 1,000,000,000 ns`.\n\nSome units may return an accurate duration while others return an estimate.\nFor example, days have an estimated duration due to the possibility of\ndaylight saving time changes.\nTo determine if the duration is an estimate, use {@link isDurationEstimated}.",
    "lineNumber": 44,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the duration of this unit, which may be an estimate."
    },
    "params": []
  },
  {
    "__docId__": 1598,
    "kind": "method",
    "name": "isDurationEstimated",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#isDurationEstimated",
    "access": "public",
    "description": "Checks if the duration of the unit is an estimate.\n\nAll units have a duration, however the duration is not always accurate.\nFor example, days have an estimated duration due to the possibility of\ndaylight saving time changes.\nThis method returns true if the duration is an estimate and false if it is\naccurate. Note that accurate/estimated ignores leap seconds.",
    "lineNumber": 59,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the duration is estimated, `false` if accurate."
    },
    "params": []
  },
  {
    "__docId__": 1599,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#isDateBased",
    "access": "public",
    "description": "Checks if this unit is date-based.",
    "lineNumber": 68,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if date unit, `false` if a time unit."
    },
    "params": []
  },
  {
    "__docId__": 1600,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#isTimeBased",
    "access": "public",
    "description": "Checks if this unit is time-based.",
    "lineNumber": 77,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if time unit, `false` if a date unit."
    },
    "params": []
  },
  {
    "__docId__": 1601,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#isSupportedBy",
    "access": "public",
    "description": "Checks if this unit is supported by the specified temporal object.\n\nThis checks that the implementing date-time can add/subtract this unit.\nThis can be used to avoid throwing an exception.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "`true` if the unit is supported."
    }
  },
  {
    "__docId__": 1602,
    "kind": "method",
    "name": "addTo",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#addTo",
    "access": "public",
    "description": "Returns a copy of the specified temporal object with the specified period added.\n\nThe period added is a multiple of this unit. For example, this method\ncould be used to add \"3 days\" to a date by calling this method on the\ninstance representing \"days\", passing the date and the period \"3\".\nThe period to be added may be negative, which is equivalent to subtraction.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#plus}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisUnit.doPlus(temporal);\n  temporal = temporal.plus(thisUnit);\n</pre>\nIt is recommended to use the second approach, {@link plus},\nas it is a lot clearer to read in code.\n\nImplementations should perform any queries or calculations using the units\navailable in {@link ChronoUnit} or the fields available in {@link ChronoField}.\nIf the field is not supported a {@link DateTimeException} must be thrown.\n\nImplementations must not alter the specified temporal object.\nInstead, an adjusted copy of the original must be returned.\nThis provides equivalent, safe behavior for immutable and mutable implementations.",
    "lineNumber": 129,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": "the temporal object to adjust."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "periodToAdd",
        "description": "the period of this unit to add, positive or negative."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted temporal object."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be added."
      }
    ]
  },
  {
    "__docId__": 1603,
    "kind": "method",
    "name": "between",
    "memberof": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/TemporalUnit.js~TemporalUnit#between",
    "access": "public",
    "description": "Calculates the period in terms of this unit between two temporal objects of the same type.\n\nThis calculates the period between two temporals in terms of this unit.\nThe start and end points are supplied as temporal objects and must be of the same type.\nThe result will be negative if the end is before the start.\nFor example, the period in hours between two temporal objects can be calculated\nusing {@link HOURS.between}.\n\nThe calculation returns a whole number, representing the number of complete units between the two temporals.\nFor example, the period in hours between the times 11:30 and 13:29 will only be\none hour as it is one minute short of two hours.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method directly.\nThe second is to use {@link Temporal#until}:\n<pre>\n  // these two lines are equivalent\n  between = thisUnit.between(start, end);\n  between = start.until(end, thisUnit);\n</pre>\nThe choice should be made based on which makes the code more readable.\n\nFor example, this method allows the number of days between two dates to be calculated:\n<pre>\n  long daysBetween = DAYS.between(start, end);\n  // or alternatively\n  long daysBetween = start.until(end, DAYS);\n</pre>\nImplementations should perform any queries or calculations using the units available in\n{@link ChronoUnit} or the fields available in {@link ChronoField}.\nIf the unit is not supported a {@link DateTimeException} must be thrown.\nImplementations must not alter the specified temporal objects.",
    "lineNumber": 176,
    "params": [
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal1",
        "description": "the base temporal object."
      },
      {
        "nullable": false,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal2",
        "description": "the other temporal object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the period between temporal1 and temporal2 in terms of this unit;\n positive if temporal2 is later than temporal1, negative if earlier."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the period cannot be calculated."
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs."
      }
    ]
  },
  {
    "__docId__": 1604,
    "kind": "file",
    "name": "packages/core/src/temporal/ValueRange.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { assert } from '../assert';\nimport { DateTimeException, IllegalArgumentException } from '../errors';\nimport { MathUtil } from '../MathUtil';\n\n/**\n * The range of valid values for a date-time field.\n *\n * All TemporalField instances have a valid range of values.\n * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\n * This class captures that valid range.\n *\n * It is important to be aware of the limitations of this class.\n * Only the minimum and maximum values are provided.\n * It is possible for there to be invalid values within the outer range.\n * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\n * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n *\n * Instances of this class are not tied to a specific field.\n */\nexport class ValueRange {\n\n    /**\n     *\n     * @param {!number} minSmallest\n     * @param {!number} minLargest\n     * @param {!number} maxSmallest\n     * @param {!number} maxLargest\n     * @private\n     */\n    constructor(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), `Smallest minimum value '${minSmallest \n        }' must be less than largest minimum value '${minLargest}'`, IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), `Smallest maximum value '${maxSmallest \n        }' must be less than largest maximum value '${maxLargest}'`, IllegalArgumentException);\n        assert(!(minLargest > maxLargest), `Minimum value '${minLargest \n        }' must be less than maximum value '${maxLargest}'`, IllegalArgumentException);\n\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n\n    /**\n     * Is the value range fixed and fully known.\n     *\n     * For example, the ISO day-of-month runs from 1 to between 28 and 31.\n     * Since there is uncertainty about the maximum value, the range is not fixed.\n     * However, for the month of January, the range is always 1 to 31, thus it is fixed.\n     *\n     * @return {boolean} true if the set of values is fixed\n     */\n    isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    minimum(){\n        return this._minSmallest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    largestMinimum(){\n        return this._minLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    maximum(){\n        return this._maxLargest;\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n    smallestMaximum(){\n        return this._maxSmallest;\n    }\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    isValidValue(value) {\n        return (this.minimum() <= value && value <= this.maximum());\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @param {TemporalField} field\n     */\n    checkValidValue(value, field) {\n        let msg;\n        if (!this.isValidValue(value)) {\n            if (field != null) {\n                msg = `Invalid value for ${field} (valid values ${this.toString()}): ${value}`;\n            } else {\n                msg = `Invalid value (valid values ${this.toString()}): ${value}`;\n            }\n            return assert(false, msg, DateTimeException);\n        }\n        return value;\n    }\n\n    /**\n     * Checks that the specified value is valid and fits in an `int`.\n     *\n     * This validates that the value is within the valid range of values and that\n     * all valid values are within the bounds of an `int`.\n     * The field is only used to improve the error message.\n     *\n     * @param {number} value - the value to check\n     * @param {TemporalField} field - the field being checked, may be null\n     * @return {number} the value that was passed in\n     * @see #isValidIntValue(long)\n     */\n    checkValidIntValue(value, field) {\n        if (this.isValidIntValue(value) === false) {\n            throw new DateTimeException(`Invalid int value for ${field}: ${value}`);\n        }\n        return value;\n    }\n\n    /**\n     * Checks if the value is within the valid range and that all values\n     * in the range fit in an `int`.\n     *\n     * This method combines {@link isIntValue} and {@link isValidValue}.\n     *\n     * @param {number} value - the value to check\n     * @return true if the value is valid and fits in an `int`\n     */\n    isValidIntValue(value) {\n        return this.isIntValue() && this.isValidValue(value);\n    }\n\n    /**\n     * Checks if all values in the range fit in an `int`.\n     *\n     * This checks that all valid values are within the bounds of an `int`.\n     *\n     * For example, the ISO month-of-year has values from 1 to 12, which fits in an `int`.\n     * By comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an `int`.\n     *\n     * This implementation uses {@link getMinimum} and {@link getMaximum}.\n     *\n     * @return boolean if a valid value always fits in an `int`\n     */\n    isIntValue() { // should be isSafeIntegerValue\n        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if this range is equal to another range.\n     *\n     * The comparison is based on the four values, minimum, largest minimum,\n     * smallest maximum and maximum.\n     * Only objects of type {@link ValueRange} are compared, other types return false.\n     *\n     * @param {*} other - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other range\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ValueRange) {\n            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest &&\n                this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this range.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n    }\n\n    /*\n     * Outputs this range as a String.\n     *\n     * The format will be '{min}/{largestMin} - {smallestMax}/{max}',\n     * where the largestMin or smallestMax sections may be omitted, together\n     * with associated slash, if they are the same as the min or max.\n     *\n     * @return {string} a string representation of this range, not null\n     */\n    toString() {\n        let str = this.minimum() + (this.minimum() !== this.largestMinimum() ? `/${this.largestMinimum()}` : '');\n        str += ' - ';\n        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? `/${this.maximum()}` : '');\n        return str;\n    }\n\n    /*\n     * called with 2 params: Obtains a fixed value range.\n     *\n     * This factory obtains a range where the minimum and maximum values are fixed.\n     * For example, the ISO month-of-year always runs from 1 to 12.\n     *\n     * @param min  the minimum value\n     * @param max  the maximum value\n     * @return the ValueRange for min, max, not null\n\n     * called with 3 params: Obtains a variable value range.\n     *\n     * This factory obtains a range where the minimum value is fixed and the maximum value may vary.\n     * For example, the ISO day-of-month always starts at 1, but ends between 28 and 31.\n     *\n     * @param min  the minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     * @return the ValueRange for min, smallest max, largest max, not null\n\n     * called with 4 params: Obtains a fully variable value range.\n     *\n     * This factory obtains a range where both the minimum and maximum value may vary.\n     *\n     * @param minSmallest  the smallest minimum value\n     * @param minLargest  the largest minimum value\n     * @param maxSmallest  the smallest maximum value\n     * @param maxLargest  the largest maximum value\n     *\n     * @return {ValueRange} the ValueRange for smallest min, largest min, smallest max, largest max, not null\n     */\n    static of() {\n        if (arguments.length === 2) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n        } else if (arguments.length === 3) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n        } else if (arguments.length === 4) {\n            return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n        } else {\n            return assert(false, `Invalid number of arguments ${arguments.length}`, IllegalArgumentException);\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/temporal/ValueRange.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1605,
    "kind": "class",
    "name": "ValueRange",
    "memberof": "packages/core/src/temporal/ValueRange.js",
    "static": true,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/temporal/ValueRange.js",
    "importStyle": "{ValueRange}",
    "description": "The range of valid values for a date-time field.\n\nAll TemporalField instances have a valid range of values.\nFor example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.\nThis class captures that valid range.\n\nIt is important to be aware of the limitations of this class.\nOnly the minimum and maximum values are provided.\nIt is possible for there to be invalid values within the outer range.\nFor example, a weird field may have valid values of 1, 2, 4, 6, 7, thus\nhave a range of '1 - 7', despite that fact that values 3 and 5 are invalid.\n\nInstances of this class are not tied to a specific field.",
    "lineNumber": 26,
    "interface": false
  },
  {
    "__docId__": 1606,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 36,
    "params": [
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minSmallest",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "minLargest",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxSmallest",
        "description": ""
      },
      {
        "nullable": false,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxLargest",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1607,
    "kind": "member",
    "name": "_minSmallest",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#_minSmallest",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1608,
    "kind": "member",
    "name": "_minLargest",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#_minLargest",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1609,
    "kind": "member",
    "name": "_maxLargest",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#_maxLargest",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1610,
    "kind": "member",
    "name": "_maxSmallest",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#_maxSmallest",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1611,
    "kind": "method",
    "name": "isFixed",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#isFixed",
    "access": "public",
    "description": "Is the value range fixed and fully known.\n\nFor example, the ISO day-of-month runs from 1 to between 28 and 31.\nSince there is uncertainty about the maximum value, the range is not fixed.\nHowever, for the month of January, the range is always 1 to 31, thus it is fixed.",
    "lineNumber": 59,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the set of values is fixed"
    },
    "params": []
  },
  {
    "__docId__": 1612,
    "kind": "method",
    "name": "minimum",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#minimum",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1613,
    "kind": "method",
    "name": "largestMinimum",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#largestMinimum",
    "access": "public",
    "description": "",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1614,
    "kind": "method",
    "name": "maximum",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#maximum",
    "access": "public",
    "description": "",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1615,
    "kind": "method",
    "name": "smallestMaximum",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#smallestMaximum",
    "access": "public",
    "description": "",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1616,
    "kind": "method",
    "name": "isValidValue",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#isValidValue",
    "access": "public",
    "description": "",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 1617,
    "kind": "method",
    "name": "checkValidValue",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#checkValidValue",
    "access": "public",
    "description": "",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1618,
    "kind": "method",
    "name": "checkValidIntValue",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#checkValidIntValue",
    "access": "public",
    "description": "Checks that the specified value is valid and fits in an `int`.\n\nThis validates that the value is within the valid range of values and that\nall valid values are within the bounds of an `int`.\nThe field is only used to improve the error message.",
    "see": [
      "#isValidIntValue(long)"
    ],
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to check"
      },
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field being checked, may be null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value that was passed in"
    }
  },
  {
    "__docId__": 1619,
    "kind": "method",
    "name": "isValidIntValue",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#isValidIntValue",
    "access": "public",
    "description": "Checks if the value is within the valid range and that all values\nin the range fit in an `int`.\n\nThis method combines {@link isIntValue} and {@link isValidValue}.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to check"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if the value is valid and fits in an `int`"
    }
  },
  {
    "__docId__": 1620,
    "kind": "method",
    "name": "isIntValue",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#isIntValue",
    "access": "public",
    "description": "Checks if all values in the range fit in an `int`.\n\nThis checks that all valid values are within the bounds of an `int`.\n\nFor example, the ISO month-of-year has values from 1 to 12, which fits in an `int`.\nBy comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an `int`.\n\nThis implementation uses {@link getMinimum} and {@link getMaximum}.",
    "lineNumber": 165,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "boolean if a valid value always fits in an `int`"
    },
    "params": []
  },
  {
    "__docId__": 1621,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#equals",
    "access": "public",
    "description": "Checks if this range is equal to another range.\n\nThe comparison is based on the four values, minimum, largest minimum,\nsmallest maximum and maximum.\nOnly objects of type {@link ValueRange} are compared, other types return false.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other range"
    }
  },
  {
    "__docId__": 1622,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#hashCode",
    "access": "public",
    "description": "A hash code for this range.",
    "lineNumber": 195,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1623,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange#toString",
    "access": "public",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1624,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/temporal/ValueRange.js~ValueRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/temporal/ValueRange.js~ValueRange.of",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1625,
    "kind": "file",
    "name": "packages/core/src/use.js",
    "content": "/**\n * @private\n *\n * @param jsJoda\n * @returns { function(jsJoda: JsJoda) }\n */\nexport function bindUse(jsJoda) {\n    const used = [];\n\n    /**\n     * use\n     *\n     * Provides a way to extend the internals of js-joda\n     *\n     * @param {function} fn - function to extend js-joda public api\n     * @returns {this} for chaining\n     */\n    return function use(fn) {\n        if (!~used.indexOf(fn)) {\n            fn(jsJoda);\n            used.push(fn);\n        }\n        return jsJoda;\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/use.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1626,
    "kind": "function",
    "name": "bindUse",
    "memberof": "packages/core/src/use.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/use.js~bindUse",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/use.js",
    "importStyle": "{bindUse}",
    "description": "",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ function(jsJoda: JsJoda) }"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jsJoda",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " function(jsJoda: JsJoda) "
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1627,
    "kind": "file",
    "name": "packages/core/src/zone/SystemDefaultZoneId.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { SystemDefaultZoneRules } from './SystemDefaultZoneRules';\nimport { ZoneId } from '../ZoneId';\n\nexport class SystemDefaultZoneId extends ZoneId {\n\n    constructor(){\n        super();\n        this._rules = new SystemDefaultZoneRules();\n    }\n\n    rules(){\n        return this._rules;\n    }\n\n    equals(other){\n        if(this === other){\n            return true;\n        }\n        return false;\n    }\n\n    id(){\n        return 'SYSTEM';\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/zone/SystemDefaultZoneId.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1628,
    "kind": "class",
    "name": "SystemDefaultZoneId",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js",
    "static": true,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/zone/SystemDefaultZoneId.js",
    "importStyle": "{SystemDefaultZoneId}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/ZoneId.js~ZoneId"
    ]
  },
  {
    "__docId__": 1629,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 1630,
    "kind": "member",
    "name": "_rules",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId#_rules",
    "access": "private",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1631,
    "kind": "method",
    "name": "rules",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId#rules",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1632,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId#equals",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1633,
    "kind": "method",
    "name": "id",
    "memberof": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneId.js~SystemDefaultZoneId#id",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1634,
    "kind": "file",
    "name": "packages/core/src/zone/SystemDefaultZoneRules.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ZoneRules } from './ZoneRules';\nimport { ZoneOffset } from '../ZoneOffset';\nimport { DateTimeException } from '../errors';\n\nexport class SystemDefaultZoneRules extends ZoneRules {\n\n    isFixedOffset(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {Instant} instant\n     * @returns {ZoneOffset}\n     */\n    offsetOfInstant(instant){\n        const offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     *\n     * @param {number} epochMilli\n     * @returns {ZoneOffset}\n     */\n    offsetOfEpochMilli(epochMilli){\n        const offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    }\n\n    /**\n     * This implementation is NOT returning the best value in a gap or overlap situation\n     * as specified at {@link ZoneRules.offsetOfLocalDateTime}.\n     *\n     * The calculated offset depends Date.prototype.getTimezoneOffset and its not specified\n     * at the ECMA-262 specification how to handle daylight savings gaps/ overlaps.\n     *\n     * The Chrome Browser version 49 is returning the next transition offset in a gap/overlap situation,\n     * other browsers/ engines might do it in the same way.\n     *\n     * @param {LocalDateTime} localDateTime\n     * @returns {ZoneOffset}\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n        const offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n        const epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n        const offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n    }\n\n    /**\n     *\n     * @param localDateTime\n     * @return {ZoneOffset[]}\n     */\n    validOffsets(localDateTime){\n        return [this.offsetOfLocalDateTime(localDateTime)];\n    }\n\n    /**\n     * @return null, not supported\n     */\n    transition(){\n        return null;\n    }\n\n    /**\n     *\n     * @param instant\n     * @return {ZoneOffset}\n     */\n    standardOffset(instant){\n        return this.offsetOfInstant(instant);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    daylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    isDaylightSavings(){\n        this._throwNotSupported();\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} dateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(dateTime, offset) {\n        return this.offsetOfLocalDateTime(dateTime).equals(offset);\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    nextTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    previousTransition(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitions(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    transitionRules(){\n        this._throwNotSupported();\n    }\n\n    /**\n     * @throws DateTimeException not supported\n     */\n    _throwNotSupported(){\n        throw new DateTimeException('not supported operation');\n    }\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other || other instanceof SystemDefaultZoneRules) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return 'SYSTEM';\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/zone/SystemDefaultZoneRules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1635,
    "kind": "class",
    "name": "SystemDefaultZoneRules",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js",
    "static": true,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/zone/SystemDefaultZoneRules.js",
    "importStyle": "{SystemDefaultZoneRules}",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "interface": false,
    "extends": [
      "packages/core/src/zone/ZoneRules.js~ZoneRules"
    ]
  },
  {
    "__docId__": 1636,
    "kind": "method",
    "name": "isFixedOffset",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#isFixedOffset",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1637,
    "kind": "method",
    "name": "offsetOfInstant",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#offsetOfInstant",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1638,
    "kind": "method",
    "name": "offsetOfEpochMilli",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#offsetOfEpochMilli",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMilli",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1639,
    "kind": "method",
    "name": "offsetOfLocalDateTime",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#offsetOfLocalDateTime",
    "access": "public",
    "description": "This implementation is NOT returning the best value in a gap or overlap situation\nas specified at {@link ZoneRules.offsetOfLocalDateTime}.\n\nThe calculated offset depends Date.prototype.getTimezoneOffset and its not specified\nat the ECMA-262 specification how to handle daylight savings gaps/ overlaps.\n\nThe Chrome Browser version 49 is returning the next transition offset in a gap/overlap situation,\nother browsers/ engines might do it in the same way.",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1640,
    "kind": "method",
    "name": "validOffsets",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#validOffsets",
    "access": "public",
    "description": "",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1641,
    "kind": "method",
    "name": "transition",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#transition",
    "access": "public",
    "description": "",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "null, not supported"
    },
    "params": []
  },
  {
    "__docId__": 1642,
    "kind": "method",
    "name": "standardOffset",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#standardOffset",
    "access": "public",
    "description": "",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1643,
    "kind": "method",
    "name": "daylightSavings",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#daylightSavings",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1644,
    "kind": "method",
    "name": "isDaylightSavings",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#isDaylightSavings",
    "access": "public",
    "description": "",
    "lineNumber": 92,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1645,
    "kind": "method",
    "name": "isValidOffset",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#isValidOffset",
    "access": "public",
    "description": "",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "dateTime",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1646,
    "kind": "method",
    "name": "nextTransition",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#nextTransition",
    "access": "public",
    "description": "",
    "lineNumber": 109,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1647,
    "kind": "method",
    "name": "previousTransition",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#previousTransition",
    "access": "public",
    "description": "",
    "lineNumber": 116,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1648,
    "kind": "method",
    "name": "transitions",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#transitions",
    "access": "public",
    "description": "",
    "lineNumber": 123,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1649,
    "kind": "method",
    "name": "transitionRules",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#transitionRules",
    "access": "public",
    "description": "",
    "lineNumber": 130,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 1650,
    "kind": "method",
    "name": "_throwNotSupported",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#_throwNotSupported",
    "access": "private",
    "description": "",
    "lineNumber": 137,
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException not supported"
      }
    ],
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1651,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#equals",
    "access": "public",
    "description": "",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1652,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/SystemDefaultZoneRules.js~SystemDefaultZoneRules#toString",
    "access": "public",
    "description": "",
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1653,
    "kind": "file",
    "name": "packages/core/src/zone/ZoneOffsetTransition.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from '../assert';\nimport { IllegalArgumentException } from '../errors';\n\nimport { Duration } from '../Duration';\nimport { LocalDateTime } from '../LocalDateTime';\n\n/**\n * A transition between two offsets caused by a discontinuity in the local time-line.\n *\n * A transition between two offsets is normally the result of a daylight savings cutover.\n * The discontinuity is normally a gap in spring and an overlap in autumn.\n * {@link ZoneOffsetTransition} models the transition between the two offsets.\n *\n * Gaps occur where there are local date-times that simply do not not exist.\n * An example would be when the offset changes from `+03:00` to `+04:00`.\n * This might be described as 'the clocks will move forward one hour tonight at 1am'.\n *\n * Overlaps occur where there are local date-times that exist twice.\n * An example would be when the offset changes from `+04:00` to `+03:00`.\n * This might be described as 'the clocks will move back one hour tonight at 2am'.\n *\n */\nexport class ZoneOffsetTransition {\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance defining a transition between two offsets.\n     *\n     * Applications should normally obtain an instance from {@link ZoneRules}.\n     * This factory is only intended for use when creating {@link ZoneRules}.\n     *\n     * @param {LocalDateTime} transition - the transition date-time at the transition, which never\n     *  actually occurs, expressed local to the before offset, not null\n     * @param {ZoneOffset} offsetBefore - the offset before the transition, not null\n     * @param {ZoneOffset} offsetAfter - the offset at and after the transition, not null\n     * @return {ZoneOffsetTransition} the transition, not null\n     * @throws IllegalArgumentException if {@link offsetBefore} and {@link offsetAfter}\n     *         are equal, or {@link transition.getNano} returns non-zero value\n     */\n    static of(transition, offsetBefore, offsetAfter) {\n        return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n    }\n\n    /**\n     * Creates an instance defining a transition between two offsets.\n     * Creates an instance from epoch-second if transition is not a LocalDateTimeInstance\n     *\n     * @param {(LocalDateTime \\ number)} transition - the transition date-time with the offset before the transition, not null\n     * @param {ZoneOffset} offsetBefore - the offset before the transition, not null\n     * @param {ZoneOffset} offsetAfter - the offset at and after the transition, not null\n     * @private\n     */\n    constructor(transition, offsetBefore, offsetAfter) {\n        requireNonNull(transition, 'transition');\n        requireNonNull(offsetBefore, 'offsetBefore');\n        requireNonNull(offsetAfter, 'offsetAfter');\n        if (offsetBefore.equals(offsetAfter)) {\n            throw new IllegalArgumentException('Offsets must not be equal');\n        }\n        if (transition.nano() !== 0) {\n            throw new IllegalArgumentException('Nano-of-second must be zero');\n        }\n        if(transition instanceof LocalDateTime) {\n            this._transition = transition;\n        } else {\n            this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n        }\n        this._offsetBefore = offsetBefore;\n        this._offsetAfter = offsetAfter;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the transition instant.\n     *\n     * This is the instant of the discontinuity, which is defined as the first\n     * instant that the 'after' offset applies.\n     *\n     * The methods {@link getInstant}, {@link getDateTimeBefore} and {@link getDateTimeAfter}\n     * all represent the same instant.\n     *\n     * @return {Instant} the transition instant, not null\n     */\n    instant() {\n        return this._transition.toInstant(this._offsetBefore);\n    }\n\n    /**\n     * Gets the transition instant as an epoch second.\n     *\n     * @return {number} the transition epoch second\n     */\n    toEpochSecond() {\n        return this._transition.toEpochSecond(this._offsetBefore);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Gets the local transition date-time, as would be expressed with the 'before' offset.\n     *\n     * This is the date-time where the discontinuity begins expressed with the 'before' offset.\n     * At this instant, the 'after' offset is actually used, therefore the combination of this\n     * date-time and the 'before' offset will never occur.\n     *\n     * The combination of the 'before' date-time and offset represents the same instant\n     * as the 'after' date-time and offset.\n     *\n     * @return {LocalDateTime} the transition date-time expressed with the before offset, not null\n     */\n    dateTimeBefore(){\n        return this._transition;\n    }\n\n    /**\n     * Gets the local transition date-time, as would be expressed with the 'after' offset.\n     *\n     * This is the first date-time after the discontinuity, when the new offset applies.\n     *\n     * The combination of the 'before' date-time and offset represents the same instant\n     * as the 'after' date-time and offset.\n     *\n     * @return {LocalDateTime} the transition date-time expressed with the after offset, not null\n     */\n    dateTimeAfter() {\n        return this._transition.plusSeconds(this.durationSeconds());\n    }\n\n    /**\n     * Gets the offset before the transition.\n     *\n     * This is the offset in use before the instant of the transition.\n     *\n     * @return {ZoneOffset} the offset before the transition, not null\n     */\n    offsetBefore() {\n        return this._offsetBefore;\n    }\n\n    /**\n     * Gets the offset after the transition.\n     *\n     * This is the offset in use on and after the instant of the transition.\n     *\n     * @return {ZoneOffset} the offset after the transition, not null\n     */\n    offsetAfter() {\n        return this._offsetAfter;\n    }\n\n    /**\n     * Gets the duration of the transition.\n     *\n     * In most cases, the transition duration is one hour, however this is not always the case.\n     * The duration will be positive for a gap and negative for an overlap.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @return {Duration} the duration of the transition, positive for gaps, negative for overlaps\n     */\n    duration() {\n        return Duration.ofSeconds(this.durationSeconds());\n    }\n\n    /**\n     * Gets the duration of the transition in seconds.\n     *\n     * @return {number} the duration in seconds\n     */\n    durationSeconds() {\n        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Does this transition represent a gap in the local time-line.\n     *\n     * Gaps occur where there are local date-times that simply do not not exist.\n     * An example would be when the offset changes from `+01:00` to `+02:00`.\n     * This might be described as 'the clocks will move forward one hour tonight at 1am'.\n     *\n     * @return {boolean} true if this transition is a gap, false if it is an overlap\n     */\n    isGap() {\n        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Does this transition represent a gap in the local time-line.\n     *\n     * Overlaps occur where there are local date-times that exist twice.\n     * An example would be when the offset changes from `+02:00` to `+01:00`.\n     * This might be described as 'the clocks will move back one hour tonight at 2am'.\n     *\n     * @return {boolean} true if this transition is an overlap, false if it is a gap\n     */\n    isOverlap() {\n        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n    }\n\n    /**\n     * Checks if the specified offset is valid during this transition.\n     *\n     * This checks to see if the given offset will be valid at some point in the transition.\n     * A gap will always return false.\n     * An overlap will return true if the offset is either the before or after offset.\n     *\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset is valid during the transition\n     */\n    isValidOffset(offset) {\n        return this.isGap() ? false : (this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset));\n    }\n\n    /**\n     * Gets the valid offsets during this transition.\n     *\n     * A gap will return an empty list, while an overlap will return both offsets.\n     *\n     * @return {ZoneOffset[]} the list of valid offsets\n     */\n    validOffsets() {\n        if (this.isGap()){\n            return [];\n        } else {\n            return [this._offsetBefore, this._offsetAfter];\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this transition to another based on the transition instant.\n     *\n     * This compares the instants of each transition.\n     * The offsets are ignored, making this order inconsistent with equals.\n     *\n     * @param {ZoneOffsetTransition} transition - the transition to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(transition) {\n        return this.instant().compareTo(transition.instant());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this object equals another.\n     *\n     * The entire state of the object is compared.\n     *\n     * @param {*} other - the other object to compare to, null returns false\n     * @return true if equal\n     */\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ZoneOffsetTransition) {\n            const d = other;\n            return this._transition.equals(d._transition) &&\n                this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n        }\n        return false;\n    }\n\n    /**\n     * Returns a suitable hash code.\n     *\n     * @return {number} the hash code\n     */\n    hashCode() {\n        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ (this._offsetAfter.hashCode()>>>16);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a string describing this object.\n     *\n     * @return {string} a string for debugging, not null\n     */\n    toString() {\n        return `Transition[${this.isGap() ? 'Gap' : 'Overlap' \n        } at ${this._transition.toString()}${this._offsetBefore.toString() \n        } to ${this._offsetAfter}]`;\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/zone/ZoneOffsetTransition.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1654,
    "kind": "class",
    "name": "ZoneOffsetTransition",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js",
    "static": true,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/zone/ZoneOffsetTransition.js",
    "importStyle": "{ZoneOffsetTransition}",
    "description": "A transition between two offsets caused by a discontinuity in the local time-line.\n\nA transition between two offsets is normally the result of a daylight savings cutover.\nThe discontinuity is normally a gap in spring and an overlap in autumn.\n{@link ZoneOffsetTransition} models the transition between the two offsets.\n\nGaps occur where there are local date-times that simply do not not exist.\nAn example would be when the offset changes from `+03:00` to `+04:00`.\nThis might be described as 'the clocks will move forward one hour tonight at 1am'.\n\nOverlaps occur where there are local date-times that exist twice.\nAn example would be when the offset changes from `+04:00` to `+03:00`.\nThis might be described as 'the clocks will move back one hour tonight at 2am'.",
    "lineNumber": 29,
    "interface": false
  },
  {
    "__docId__": 1655,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition.of",
    "access": "public",
    "description": "Obtains an instance defining a transition between two offsets.\n\nApplications should normally obtain an instance from {@link ZoneRules}.\nThis factory is only intended for use when creating {@link ZoneRules}.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "transition",
        "description": "the transition date-time at the transition, which never\n actually occurs, expressed local to the before offset, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetBefore",
        "description": "the offset before the transition, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetAfter",
        "description": "the offset at and after the transition, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the transition, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if {@link offsetBefore} and {@link offsetAfter}\n        are equal, or {@link transition.getNano} returns non-zero value"
      }
    ]
  },
  {
    "__docId__": 1656,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#constructor",
    "access": "private",
    "description": "Creates an instance defining a transition between two offsets.\nCreates an instance from epoch-second if transition is not a LocalDateTimeInstance",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime \\ number"
        ],
        "spread": false,
        "optional": false,
        "name": "transition",
        "description": "the transition date-time with the offset before the transition, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetBefore",
        "description": "the offset before the transition, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offsetAfter",
        "description": "the offset at and after the transition, not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1657,
    "kind": "member",
    "name": "_transition",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#_transition",
    "access": "private",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1659,
    "kind": "member",
    "name": "_offsetBefore",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#_offsetBefore",
    "access": "private",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1660,
    "kind": "member",
    "name": "_offsetAfter",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#_offsetAfter",
    "access": "private",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1661,
    "kind": "method",
    "name": "instant",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#instant",
    "access": "public",
    "description": "Gets the transition instant.\n\nThis is the instant of the discontinuity, which is defined as the first\ninstant that the 'after' offset applies.\n\nThe methods {@link getInstant}, {@link getDateTimeBefore} and {@link getDateTimeAfter}\nall represent the same instant.",
    "lineNumber": 90,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the transition instant, not null"
    },
    "params": []
  },
  {
    "__docId__": 1662,
    "kind": "method",
    "name": "toEpochSecond",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#toEpochSecond",
    "access": "public",
    "description": "Gets the transition instant as an epoch second.",
    "lineNumber": 99,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the transition epoch second"
    },
    "params": []
  },
  {
    "__docId__": 1663,
    "kind": "method",
    "name": "dateTimeBefore",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#dateTimeBefore",
    "access": "public",
    "description": "Gets the local transition date-time, as would be expressed with the 'before' offset.\n\nThis is the date-time where the discontinuity begins expressed with the 'before' offset.\nAt this instant, the 'after' offset is actually used, therefore the combination of this\ndate-time and the 'before' offset will never occur.\n\nThe combination of the 'before' date-time and offset represents the same instant\nas the 'after' date-time and offset.",
    "lineNumber": 116,
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the transition date-time expressed with the before offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 1664,
    "kind": "method",
    "name": "dateTimeAfter",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#dateTimeAfter",
    "access": "public",
    "description": "Gets the local transition date-time, as would be expressed with the 'after' offset.\n\nThis is the first date-time after the discontinuity, when the new offset applies.\n\nThe combination of the 'before' date-time and offset represents the same instant\nas the 'after' date-time and offset.",
    "lineNumber": 130,
    "return": {
      "nullable": null,
      "types": [
        "LocalDateTime"
      ],
      "spread": false,
      "description": "the transition date-time expressed with the after offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 1665,
    "kind": "method",
    "name": "offsetBefore",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#offsetBefore",
    "access": "public",
    "description": "Gets the offset before the transition.\n\nThis is the offset in use before the instant of the transition.",
    "lineNumber": 141,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset before the transition, not null"
    },
    "params": []
  },
  {
    "__docId__": 1666,
    "kind": "method",
    "name": "offsetAfter",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#offsetAfter",
    "access": "public",
    "description": "Gets the offset after the transition.\n\nThis is the offset in use on and after the instant of the transition.",
    "lineNumber": 152,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset after the transition, not null"
    },
    "params": []
  },
  {
    "__docId__": 1667,
    "kind": "method",
    "name": "duration",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#duration",
    "access": "public",
    "description": "Gets the duration of the transition.\n\nIn most cases, the transition duration is one hour, however this is not always the case.\nThe duration will be positive for a gap and negative for an overlap.\nTime-zones are second-based, so the nanosecond part of the duration will be zero.",
    "lineNumber": 165,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the duration of the transition, positive for gaps, negative for overlaps"
    },
    "params": []
  },
  {
    "__docId__": 1668,
    "kind": "method",
    "name": "durationSeconds",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#durationSeconds",
    "access": "public",
    "description": "Gets the duration of the transition in seconds.",
    "lineNumber": 174,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the duration in seconds"
    },
    "params": []
  },
  {
    "__docId__": 1669,
    "kind": "method",
    "name": "isGap",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#isGap",
    "access": "public",
    "description": "Does this transition represent a gap in the local time-line.\n\nGaps occur where there are local date-times that simply do not not exist.\nAn example would be when the offset changes from `+01:00` to `+02:00`.\nThis might be described as 'the clocks will move forward one hour tonight at 1am'.",
    "lineNumber": 187,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this transition is a gap, false if it is an overlap"
    },
    "params": []
  },
  {
    "__docId__": 1670,
    "kind": "method",
    "name": "isOverlap",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#isOverlap",
    "access": "public",
    "description": "Does this transition represent a gap in the local time-line.\n\nOverlaps occur where there are local date-times that exist twice.\nAn example would be when the offset changes from `+02:00` to `+01:00`.\nThis might be described as 'the clocks will move back one hour tonight at 2am'.",
    "lineNumber": 200,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this transition is an overlap, false if it is a gap"
    },
    "params": []
  },
  {
    "__docId__": 1671,
    "kind": "method",
    "name": "isValidOffset",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#isValidOffset",
    "access": "public",
    "description": "Checks if the specified offset is valid during this transition.\n\nThis checks to see if the given offset will be valid at some point in the transition.\nA gap will always return false.\nAn overlap will return true if the offset is either the before or after offset.",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the offset is valid during the transition"
    }
  },
  {
    "__docId__": 1672,
    "kind": "method",
    "name": "validOffsets",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#validOffsets",
    "access": "public",
    "description": "Gets the valid offsets during this transition.\n\nA gap will return an empty list, while an overlap will return both offsets.",
    "lineNumber": 225,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset[]"
      ],
      "spread": false,
      "description": "the list of valid offsets"
    },
    "params": []
  },
  {
    "__docId__": 1673,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#compareTo",
    "access": "public",
    "description": "Compares this transition to another based on the transition instant.\n\nThis compares the instants of each transition.\nThe offsets are ignored, making this order inconsistent with equals.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffsetTransition"
        ],
        "spread": false,
        "optional": false,
        "name": "transition",
        "description": "the transition to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 1674,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#equals",
    "access": "public",
    "description": "Checks if this object equals another.\n\nThe entire state of the object is compared.",
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other object to compare to, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if equal"
    }
  },
  {
    "__docId__": 1675,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#hashCode",
    "access": "public",
    "description": "Returns a suitable hash code.",
    "lineNumber": 273,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the hash code"
    },
    "params": []
  },
  {
    "__docId__": 1676,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneOffsetTransition.js~ZoneOffsetTransition#toString",
    "access": "public",
    "description": "Returns a string describing this object.",
    "lineNumber": 283,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string for debugging, not null"
    },
    "params": []
  },
  {
    "__docId__": 1677,
    "kind": "file",
    "name": "packages/core/src/zone/ZoneRules.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull, abstractMethodFail } from '../assert';\n\nimport { Duration } from '../Duration';\nimport { Instant } from '../Instant';\n\nexport class ZoneRules {\n\n    /**\n     * Obtains an instance of {@link ZoneRules} that always uses the same offset.\n     *\n     * The returned rules always have the same offset.\n     *\n     * @param {ZoneOffset} offset - the offset, not null\n     * @return {ZoneRules} the zone rules, not null\n     */\n    static of(offset) {\n        requireNonNull(offset, 'offset');\n        return new Fixed(offset);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        abstractMethodFail('ZoneRules.isFixedOffset');\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @param instantOrLocalDateTime\n     * @returns {ZoneOffset}\n     */\n    offset(instantOrLocalDateTime){\n        if(instantOrLocalDateTime instanceof Instant){\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    }\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     *\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfInstant(instant){\n        abstractMethodFail('ZoneRules.offsetInstant');\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfEpochMilli(epochMilli){\n        abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     *\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link getValidOffsets} and {@link getTransition}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    offsetOfLocalDateTime(localDateTime){\n        abstractMethodFail('ZoneRules.offsetLocalDateTime');\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     *\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    validOffsets(localDateTime){\n        abstractMethodFail('ZoneRules.validOffsets');\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     *\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     *\n     * * Normal, with one valid offset. For the vast majority of the year, the normal\n     *   case applies, where there is a single valid offset for the local date-time.\n     * * Gap, with zero valid offsets. This is when clocks jump forward typically\n     *   due to the spring daylight savings change from \"winter\" to \"summer\".\n     *   In a gap there are local date-time values with no valid offset.\n     * * Overlap, with two valid offsets. This is when clocks are set back typically\n     *   due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *   In an overlap there are local date-time values with two valid offsets.\n     *\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     *\n     * There are various ways to handle the conversion from a {@link LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        abstractMethodFail('ZoneRules.transition');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        abstractMethodFail('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     *\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        abstractMethodFail('ZoneRules.daylightSavings');\n        //    default {\n        //        ZoneOffset standardOffset = getStandardOffset(instant);\n        //        ZoneOffset actualOffset = getOffset(instant);\n        //        return actualOffset.toDuration().minus(standardOffset.toDuration()).normalized();\n        //    }\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     *\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        abstractMethodFail('ZoneRules.isDaylightSavings');\n        //    default {\n        //        return (getStandardOffset(instant).equals(getOffset(instant)) == false);\n        //    }\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     *\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    // eslint-disable-next-line no-unused-vars\n    isValidOffset(localDateTime, offset){\n        abstractMethodFail('ZoneRules.isValidOffset');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     *\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        abstractMethodFail('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     *\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        abstractMethodFail('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitionRules}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        abstractMethodFail('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     *\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link getTransitions}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     *\n     * For any given {@link ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     *\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     *\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        abstractMethodFail('ZoneRules.transitionRules');\n    }\n\n    toString(){\n        abstractMethodFail('ZoneRules.toString');\n    }\n\n    /**\n     * toJSON() use by JSON.stringify\n     * delegates to toString()\n     *\n     * @return {string}\n     */\n    toJSON() {\n        return this.toString();\n    }\n}\n\n\nclass Fixed extends ZoneRules{\n    /**\n     *\n     * @param {ZoneOffset} offset\n     * @private\n     */\n    constructor(offset){\n        super();\n        this._offset = offset;\n    }\n\n    isFixedOffset(){\n        return true;\n    }\n\n    offsetOfInstant(){\n        return this._offset;\n    }\n\n    offsetOfEpochMilli(){\n        return this._offset;\n    }\n\n    offsetOfLocalDateTime(){\n        return this._offset;\n    }\n\n    validOffsets(){\n        return [this._offset];\n    }\n\n    transition(){\n        return null;\n    }\n\n    standardOffset(){\n        return this._offset;\n    }\n\n    daylightSavings(){\n        return Duration.ZERO;\n    }\n\n    isDaylightSavings(){\n        return false;\n    }\n\n    /**\n     *\n     * @param {LocalDateTime} localDateTime\n     * @param {ZoneOffset} offset\n     * @return {boolean}\n     */\n    isValidOffset(localDateTime, offset) {\n        return this._offset.equals(offset);\n    }\n\n    nextTransition(){\n        return null;\n    }\n\n    previousTransition(){\n        return null;\n    }\n\n    transitions(){\n        return [];\n    }\n\n    transitionRules(){\n        return [];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     *\n     * @param {*} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Fixed) {\n            return this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return `FixedRules:${this._offset.toString()}`;\n    }\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/zone/ZoneRules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1678,
    "kind": "class",
    "name": "ZoneRules",
    "memberof": "packages/core/src/zone/ZoneRules.js",
    "static": true,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/zone/ZoneRules.js",
    "importStyle": "{ZoneRules}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 1679,
    "kind": "method",
    "name": "of",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules.of",
    "access": "public",
    "description": "Obtains an instance of {@link ZoneRules} that always uses the same offset.\n\nThe returned rules always have the same offset.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": "the zone rules, not null"
    }
  },
  {
    "__docId__": 1680,
    "kind": "method",
    "name": "isFixedOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#isFixedOffset",
    "access": "public",
    "description": "Checks of the zone rules are fixed, such that the offset never varies.",
    "lineNumber": 34,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the time-zone is fixed and the offset never changes"
    },
    "params": []
  },
  {
    "__docId__": 1681,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#offset",
    "access": "public",
    "description": "",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ZoneOffset}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "instantOrLocalDateTime",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1682,
    "kind": "method",
    "name": "offsetOfInstant",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#offsetOfInstant",
    "access": "public",
    "description": "Gets the offset applicable at the specified instant in these rules.\n\nThe mapping from an instant to an offset is simple, there is only\none valid offset for each instant.\nThis method returns that offset.",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset, not null"
    }
  },
  {
    "__docId__": 1683,
    "kind": "method",
    "name": "offsetOfEpochMilli",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#offsetOfEpochMilli",
    "access": "public",
    "description": "Gets the offset applicable at the specified epochMilli in these rules.\n\nThe method is for javascript performance optimisation.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMilli",
        "description": "the epoch millisecond to find the offset for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset, not null"
    }
  },
  {
    "__docId__": 1684,
    "kind": "method",
    "name": "offsetOfLocalDateTime",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#offsetOfLocalDateTime",
    "access": "public",
    "description": "Gets a suitable offset for the specified local date-time in these rules.\n\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n\n* Normal, with one valid offset. For the vast majority of the year, the normal\n  case applies, where there is a single valid offset for the local date-time.\n* Gap, with zero valid offsets. This is when clocks jump forward typically\n  due to the spring daylight savings change from \"winter\" to \"summer\".\n  In a gap there are local date-time values with no valid offset.\n* Overlap, with two valid offsets. This is when clocks are set back typically\n  due to the autumn daylight savings change from \"summer\" to \"winter\".\n  In an overlap there are local date-time values with two valid offsets.\n\nThus, for any given local date-time there can be zero, one or two valid offsets.\nThis method returns the single offset in the Normal case, and in the Gap or Overlap\ncase it returns the offset before the transition.\n\nSince, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\nthan the \"correct\" value, it should be treated with care. Applications that care\nabout the correct offset should use a combination of this method,\n{@link getValidOffsets} and {@link getTransition}.",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the best available offset for the local date-time, not null"
    }
  },
  {
    "__docId__": 1685,
    "kind": "method",
    "name": "validOffsets",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#validOffsets",
    "access": "public",
    "description": "Gets the offset applicable at the specified local date-time in these rules.\n\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n\n* Normal, with one valid offset. For the vast majority of the year, the normal\n  case applies, where there is a single valid offset for the local date-time.\n* Gap, with zero valid offsets. This is when clocks jump forward typically\n  due to the spring daylight savings change from \"winter\" to \"summer\".\n  In a gap there are local date-time values with no valid offset.\n* Overlap, with two valid offsets. This is when clocks are set back typically\n  due to the autumn daylight savings change from \"summer\" to \"winter\".\n  In an overlap there are local date-time values with two valid offsets.\n\nThus, for any given local date-time there can be zero, one or two valid offsets.\nThis method returns that list of valid offsets, which is a list of size 0, 1 or 2.\nIn the case where there are two offsets, the earlier offset is returned at index 0\nand the later offset at index 1.\n\nThere are various ways to handle the conversion from a {@link LocalDateTime}.\nOne technique, using this method, would be:\n<pre>\n List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n if (validOffsets.size() == 1) {\n   // Normal case: only one valid offset\n   zoneOffset = validOffsets.get(0);\n } else {\n   // Gap or Overlap: determine what to do from transition (which will be non-null)\n   ZoneOffsetTransition trans = rules.getTransition(localDT);\n }\n</pre>\n\nIn theory, it is possible for there to be more than two valid offsets.\nThis would happen if clocks to be put back more than once in quick succession.\nThis has never happened in the history of time-zones and thus has no special handling.\nHowever, if it were to happen, then the list would return more than 2 entries.",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query for valid offsets, not null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset[]"
      ],
      "spread": false,
      "description": "the list of valid offsets, may be immutable, not null"
    }
  },
  {
    "__docId__": 1686,
    "kind": "method",
    "name": "transition",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#transition",
    "access": "public",
    "description": "Gets the offset transition applicable at the specified local date-time in these rules.\n\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n\n* Normal, with one valid offset. For the vast majority of the year, the normal\n  case applies, where there is a single valid offset for the local date-time.\n* Gap, with zero valid offsets. This is when clocks jump forward typically\n  due to the spring daylight savings change from \"winter\" to \"summer\".\n  In a gap there are local date-time values with no valid offset.\n* Overlap, with two valid offsets. This is when clocks are set back typically\n  due to the autumn daylight savings change from \"summer\" to \"winter\".\n  In an overlap there are local date-time values with two valid offsets.\n\nA transition is used to model the cases of a Gap or Overlap.\nThe Normal case will return null.\n\nThere are various ways to handle the conversion from a {@link LocalDateTime}.\nOne technique, using this method, would be:\n<pre>\n ZoneOffsetTransition trans = rules.getTransition(localDT);\n if (trans != null) {\n   // Gap or Overlap: determine what to do from transition\n } else {\n   // Normal case: only one valid offset\n   zoneOffset = rule.getOffset(localDT);\n }\n</pre>",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query for offset transition, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the offset transition, null if the local date-time is not in transition"
    }
  },
  {
    "__docId__": 1687,
    "kind": "method",
    "name": "standardOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#standardOffset",
    "access": "public",
    "description": "Gets the standard offset for the specified instant in this zone.\n\nThis provides access to historic information on how the standard offset\nhas changed over time.\nThe standard offset is the offset before any daylight saving time is applied.\nThis is typically the offset applicable during winter.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset information for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the standard offset, not null"
    }
  },
  {
    "__docId__": 1688,
    "kind": "method",
    "name": "daylightSavings",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#daylightSavings",
    "access": "public",
    "description": "Gets the amount of daylight savings in use for the specified instant in this zone.\n\nThis provides access to historic information on how the amount of daylight\nsavings has changed over time.\nThis is the difference between the standard offset and the actual offset.\nTypically the amount is zero during winter and one hour during summer.\nTime-zones are second-based, so the nanosecond part of the duration will be zero.",
    "lineNumber": 235,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the daylight savings for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the difference between the standard and actual offset, not null"
    }
  },
  {
    "__docId__": 1689,
    "kind": "method",
    "name": "isDaylightSavings",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#isDaylightSavings",
    "access": "public",
    "description": "Checks if the specified instant is in daylight savings.\n\nThis checks if the standard and actual offsets are the same at the specified instant.",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset information for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "the standard offset, not null"
    }
  },
  {
    "__docId__": 1690,
    "kind": "method",
    "name": "isValidOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#isValidOffset",
    "access": "public",
    "description": "Checks if the offset date-time is valid for these rules.\n\nTo be valid, the local date-time must not be in a gap and the offset\nmust match the valid offsets.",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the date-time to check, not null, but null\n may be ignored if the rules have a single offset for all instants"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the offset date-time is valid for these rules"
    }
  },
  {
    "__docId__": 1691,
    "kind": "method",
    "name": "nextTransition",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#nextTransition",
    "access": "public",
    "description": "Gets the next transition after the specified instant.\n\nThis returns details of the next transition after the specified instant.\nFor example, if the instant represents a point where \"Summer\" daylight savings time\napplies, then the method will return the transition to the next \"Winter\" time.",
    "lineNumber": 290,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to get the next transition after, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the next transition after the specified instant, null if this is after the last transition"
    }
  },
  {
    "__docId__": 1692,
    "kind": "method",
    "name": "previousTransition",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#previousTransition",
    "access": "public",
    "description": "Gets the previous transition before the specified instant.\n\nThis returns details of the previous transition after the specified instant.\nFor example, if the instant represents a point where \"summer\" daylight saving time\napplies, then the method will return the transition from the previous \"winter\" time.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to get the previous transition after, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the previous transition after the specified instant, null if this is before the first transition"
    }
  },
  {
    "__docId__": 1693,
    "kind": "method",
    "name": "transitions",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#transitions",
    "access": "public",
    "description": "Gets the complete list of fully defined transitions.\n\nThe complete set of transitions for this rules instance is defined by this method\nand {@link getTransitionRules}. This method returns those transitions that have\nbeen fully defined. These are typically historical, but may be in the future.\n\nThe list will be empty for fixed offset rules and for any time-zone where there has\nonly ever been a single offset. The list will also be empty if the transition rules are unknown.",
    "lineNumber": 322,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition[]"
      ],
      "spread": false,
      "description": "an immutable list of fully defined transitions, not null"
    },
    "params": []
  },
  {
    "__docId__": 1694,
    "kind": "method",
    "name": "transitionRules",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#transitionRules",
    "access": "public",
    "description": "Gets the list of transition rules for years beyond those defined in the transition list.\n\nThe complete set of transitions for this rules instance is defined by this method\nand {@link getTransitions}. This method returns instances of {@link ZoneOffsetTransitionRule}\nthat define an algorithm for when transitions will occur.\n\nFor any given {@link ZoneRules}, this list contains the transition rules for years\nbeyond those years that have been fully defined. These rules typically refer to future\ndaylight saving time rule changes.\n\nIf the zone defines daylight savings into the future, then the list will normally\nbe of size two and hold information about entering and exiting daylight savings.\nIf the zone does not have daylight savings, or information about future changes\nis uncertain, then the list will be empty.\n\nThe list will be empty for fixed offset rules and for any time-zone where there is no\ndaylight saving time. The list will also be empty if the transition rules are unknown.",
    "lineNumber": 347,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransitionRule[]"
      ],
      "spread": false,
      "description": "an immutable list of transition rules, not null"
    },
    "params": []
  },
  {
    "__docId__": 1695,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#toString",
    "access": "public",
    "description": null,
    "lineNumber": 351,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1696,
    "kind": "method",
    "name": "toJSON",
    "memberof": "packages/core/src/zone/ZoneRules.js~ZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~ZoneRules#toJSON",
    "access": "public",
    "description": "toJSON() use by JSON.stringify\ndelegates to toString()",
    "lineNumber": 361,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1697,
    "kind": "class",
    "name": "Fixed",
    "memberof": "packages/core/src/zone/ZoneRules.js",
    "static": true,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/core/src/zone/ZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 367,
    "undocument": true,
    "interface": false,
    "extends": [
      "ZoneRules"
    ],
    "ignore": true
  },
  {
    "__docId__": 1698,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1699,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#_offset",
    "access": "private",
    "description": null,
    "lineNumber": 375,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1700,
    "kind": "method",
    "name": "isFixedOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#isFixedOffset",
    "access": "public",
    "description": null,
    "lineNumber": 378,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1701,
    "kind": "method",
    "name": "offsetOfInstant",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#offsetOfInstant",
    "access": "public",
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1702,
    "kind": "method",
    "name": "offsetOfEpochMilli",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#offsetOfEpochMilli",
    "access": "public",
    "description": null,
    "lineNumber": 386,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1703,
    "kind": "method",
    "name": "offsetOfLocalDateTime",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#offsetOfLocalDateTime",
    "access": "public",
    "description": null,
    "lineNumber": 390,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1704,
    "kind": "method",
    "name": "validOffsets",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#validOffsets",
    "access": "public",
    "description": null,
    "lineNumber": 394,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1705,
    "kind": "method",
    "name": "transition",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#transition",
    "access": "public",
    "description": null,
    "lineNumber": 398,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1706,
    "kind": "method",
    "name": "standardOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#standardOffset",
    "access": "public",
    "description": null,
    "lineNumber": 402,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1707,
    "kind": "method",
    "name": "daylightSavings",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#daylightSavings",
    "access": "public",
    "description": null,
    "lineNumber": 406,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1708,
    "kind": "method",
    "name": "isDaylightSavings",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#isDaylightSavings",
    "access": "public",
    "description": null,
    "lineNumber": 410,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1709,
    "kind": "method",
    "name": "isValidOffset",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#isValidOffset",
    "access": "public",
    "description": "",
    "lineNumber": 420,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1710,
    "kind": "method",
    "name": "nextTransition",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#nextTransition",
    "access": "public",
    "description": null,
    "lineNumber": 424,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1711,
    "kind": "method",
    "name": "previousTransition",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#previousTransition",
    "access": "public",
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1712,
    "kind": "method",
    "name": "transitions",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#transitions",
    "access": "public",
    "description": null,
    "lineNumber": 432,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 1713,
    "kind": "method",
    "name": "transitionRules",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#transitionRules",
    "access": "public",
    "description": null,
    "lineNumber": 436,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 1714,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#equals",
    "access": "public",
    "description": "",
    "lineNumber": 446,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1715,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/core/src/zone/ZoneRules.js~Fixed",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/core/src/zone/ZoneRules.js~Fixed#toString",
    "access": "public",
    "description": "",
    "lineNumber": 460,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1716,
    "kind": "file",
    "name": "packages/core/src/zone/ZoneRulesProvider.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeException } from '../errors';\n\nexport class ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     *\n     * This returns the latest available rules for the zone ID.\n     *\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        throw new DateTimeException(`unsupported ZoneId:${zoneId}`);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     *\n     * These zone IDs are loaded and available for use by {@link ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return [];\n    }\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/core/src/zone/ZoneRulesProvider.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1717,
    "kind": "class",
    "name": "ZoneRulesProvider",
    "memberof": "packages/core/src/zone/ZoneRulesProvider.js",
    "static": true,
    "longname": "packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/core/src/zone/ZoneRulesProvider.js",
    "importStyle": "{ZoneRulesProvider}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 1718,
    "kind": "method",
    "name": "getRules",
    "memberof": "packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider.getRules",
    "access": "public",
    "description": "Gets the rules for the zone ID.\n\nThis returns the latest available rules for the zone ID.\n\nThis method relies on time-zone data provider files that are configured.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1719,
    "kind": "method",
    "name": "getAvailableZoneIds",
    "memberof": "packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider.getAvailableZoneIds",
    "access": "public",
    "description": "Gets the set of available zone IDs.\n\nThese zone IDs are loaded and available for use by {@link ZoneId}.",
    "lineNumber": 32,
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "a modifiable copy of the set of zone IDs, not null"
    },
    "params": []
  },
  {
    "__docId__": 1720,
    "kind": "file",
    "name": "packages/extra/src/DayOfMonth.js",
    "content": "/*\n * @copyright (c) 2022, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField, Clock, DateTimeException, IllegalArgumentException, IsoChronology, LocalDate, Month, MonthDay, TemporalAccessor, TemporalQueries, TemporalQuery, UnsupportedTemporalTypeException, ZoneId } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireInstance, requireNonNull } from './assert';\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * A day-of-month in the ISO-8601 calendar system.\n * \n * {@link DayOfMonth} is an immutable date-time object that represents a day-of-month.\n * It is a type-safe way of representing a day-of-month in an application.\n * Any field that can be derived from a day-of-month can be obtained.\n * \n * This class does not store or represent a year, month, time or time-zone.\n * For example, the value '21' can be stored in a {@link DayOfMonth} and\n * would represent the 21st day of any month.\n */\nexport class DayOfMonth extends TemporalAccessor {\n    //-----------------------------------------------------------------------\n    /**\n     * Function overloading for {@link DayOfMonth.now}:\n     * - if called with no arguments, {@link DayOfMonth._now0} is executed;\n     * - if called with an instance of {@link ZoneId}, then {@link DayOfMonth._nowZoneId} is executed;\n     * - if called with an instance of {@link Clock}, then {@link DayOfMonth._nowClock} is executed;\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     * \n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @return {DayOfMonth}\n     */\n    static now(zoneIdOrClock) {\n        switch (arguments.length) {\n            case 0:\n                return DayOfMonth._now0();\n            case 1:\n                requireNonNull(zoneIdOrClock, 'clockOrZone');\n                if (zoneIdOrClock instanceof ZoneId) {\n                    return DayOfMonth._nowZoneId(zoneIdOrClock);\n                }\n                if (zoneIdOrClock instanceof Clock) {\n                    return DayOfMonth._nowClock(zoneIdOrClock);\n                }\n                throw new IllegalArgumentException(`zoneIdOrClock must be an instance of ZoneId or Clock, but is ${zoneIdOrClock.constructor.name}`);\n            default:\n                throw new IllegalArgumentException(`Invalid number of arguments: ${arguments.length}`);\n        }\n    }\n\n    /**\n     * Obtains the current day-of-month from the system clock in the default time-zone.\n     * \n     * This will query the {@link Clock.systemDefaultZone} system clock in the default\n     * time-zone to obtain the current day-of-month.\n     * The zone and offset will be set based on the time-zone in the clock.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {DayOfMonth} the current day-of-month using the system clock and default time-zone, not null\n     * @protected\n     */\n    static _now0() {\n        return this.now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current day-of-month from the system clock in the specified time-zone.\n     * \n     * This will query the {@link Clock#system(java.time.ZoneId) system clock} to obtain the current day-of-month.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone - the zone ID to use, not null\n     * @return {DayOfMonth} the current day-of-month using the system clock, not null\n     * @protected\n     */\n    static _nowZoneId(zone) {\n        return this.now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current day-of-month from the specified clock.\n     * \n     * This will query the specified clock to obtain the current day-of-month.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock dependency injection}.\n     *\n     * @param {Clock} clock - the clock to use, not null\n     * @return {DayOfMonth} the current day-of-month, not null\n     * @protected\n     */\n    static _nowClock(clock) {\n        const now = LocalDate.now(clock);  // called once\n        return DayOfMonth.of(now.dayOfMonth());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link DayOfMonth}.\n     * \n     * A day-of-month object represents one of the 31 days of the month, from 1 to 31.\n     *\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @return {DayOfMonth} the day-of-month, not null\n     * @throws {DateTimeException} if the day-of-month is invalid\n     */\n    static of(dayOfMonth) {\n        if (1 <= dayOfMonth && dayOfMonth <= 31) {\n            return DayOfMonth.VALUES[dayOfMonth - 1];\n        } else {\n            throw new DateTimeException(`Invalid value for DayOfMonth: ${dayOfMonth}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link DayOfMonth} from a date-time object.\n     * \n     * This obtains a day-of-month based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link DayOfMonth}.\n     * \n     * The conversion extracts the {@link ChronoField#DAY_OF_MONTH} day-of-month field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     * \n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link DayOfMonth.from}.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {DayOfMonth} the day-of-month, not null\n     * @throws {DateTimeException} if unable to convert to a {@link DayOfMonth}\n     */\n    static from(temporal) {\n        if (temporal instanceof DayOfMonth) {\n            return temporal;\n        }\n        requireNonNull(temporal, 'temporal');\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return DayOfMonth.of(temporal.get(ChronoField.DAY_OF_MONTH));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain DayOfMonth from TemporalAccessor: ${temporal} of type ${temporal.constructor.name}`, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} dayOfMonth  the day-of-month to represent, - from 1 to 31.\n     * @private\n     */\n    constructor(dayOfMonth) {\n        super();\n        this._day = MathUtil.safeToInt(dayOfMonth);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the day-of-month value.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    value() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \n     * This checks if this day-of-month can be queried for the specified field.\n     * If false, then calling the {@link DayOfMonth.range} range,\n     * {@link DayOfMonth.get} get and {@link DayOfMonth.getLong} getLong\n     * methods will throw an exception.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * <ul>\n     * <li>{@link ChronoField.DAY_OF_MONTH}\n     * </ul>\n     * All other {@link ChronoField} instances will return false.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-month, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_MONTH;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-month is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfMonth.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        if (field === ChronoField.DAY_OF_MONTH) {\n            return field.range();\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-month as an `int`.\n     * \n     * This queries this day-of-month for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfMonth.isSupported} supported fields will return valid\n     * values based on this day-of-month.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *  the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *  the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-month as a `long`.\n     * \n     * This queries this day-of-month for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfMonth.isSupported(TemporalField) supported fields} will return valid\n     * values based on this day-of-month.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field === ChronoField.DAY_OF_MONTH) {\n            return this._day;\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year-month is valid for this year.\n     * \n     * This method checks whether this day and the input year and month form\n     * a valid date.\n     *\n     * @param {YearMonth} yearMonth - the year month to validate, null returns false\n     * @return {boolean} true if the year and month are valid for this day\n     */\n    isValidYearMonth(yearMonth) {\n        return yearMonth != null && yearMonth.isValidDay(this._day);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-month using the specified query.\n     * \n     * This queries this day-of-month using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-month.\n     * \n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-month changed to be the same as this.\n     * \n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.DAY_OF_MONTH} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     * \n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * ```\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDay.adjustInto(temporal);\n     *   temporal = temporal.with(thisDay);\n     * ```\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n            throw new DateTimeException('Adjustment only supported on ISO date-time');\n        }*/\n        return temporal.with(ChronoField.DAY_OF_MONTH, this._day);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this day-of-month with a month to create a {@link MonthDay}.\n     * \n     * This returns a {@link MonthDay} formed from this day and the specified month.\n     * \n     * This method can be used as part of a chain to produce a date:\n     * ```\n     *  LocalDate date = day.atMonth(month).atYear(year);\n     * ```\n     * \n     * If this day-of-month is invalid for the month then it will be changed\n     * to the last valid date for the month.\n     *\n     * @param {Month | number} month - the month-of-year to use, from 1 (January) to 12 (December), not null\n     * @return {MonthDay} the year-month formed from this year and the specified month, not null\n     */\n    atMonth(month) {\n        requireNonNull(month, 'month');\n        if (month instanceof Month) {\n            return MonthDay.of(month, Math.min(this._day, month.maxLength()));\n        } else {\n            return MonthDay.of(month, Math.min(this._day, Month.of(month).maxLength()));\n        }\n    }\n\n    /**\n     * Combines this day-of-month with a year-month to create a {@link LocalDate}.\n     * \n     * This returns a {@link LocalDate} formed from this year and the specified year-month.\n     * \n     * If this day-of-month is invalid for the year-month then it will be changed\n     * to the last valid date for the month.\n     *\n     * @param {YearMonth} yearMonth - the year-month to use, not null\n     * @return {LocalDate} the local date formed from this year and the specified year-month, not null\n     */\n    atYearMonth(yearMonth) {\n        requireNonNull(yearMonth, 'yearMonth');\n        return yearMonth.atDay(Math.min(this._day, yearMonth.lengthOfMonth()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this day-of-month to another.\n     * \n     * The comparison is based on the value of the day.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {DayOfMonth} other - the other day-of-month instance, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, DayOfMonth, 'other');\n        return this._day - other._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this day-of-month is equal to another day-of-month.\n     *\n     * @param {*} obj - the other day-of-month instance, null returns false\n     * @return {boolean} true if the day-of-month is the same\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof DayOfMonth) {\n            return this._day === obj._day;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this day-of-month.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this day-of-month as a {@link String}.\n     *\n     * @return {string} a string representation of this day-of-month, not null\n     */\n    toString() {\n        return `DayOfMonth:${this._day}`;\n    }\n\n}\n\nexport function _init() {\n    /**\n     * Cache of singleton instances.\n     */\n    DayOfMonth.VALUES = new Array(31);\n    for (let i = 0; i < 31; i++) {\n        DayOfMonth.VALUES[i] = new DayOfMonth(i + 1);\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/DayOfMonth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1721,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/DayOfMonth.js",
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/DayOfMonth.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1722,
    "kind": "class",
    "name": "DayOfMonth",
    "memberof": "packages/extra/src/DayOfMonth.js",
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/DayOfMonth.js",
    "importStyle": "{DayOfMonth}",
    "description": "A day-of-month in the ISO-8601 calendar system.\n\n{@link DayOfMonth} is an immutable date-time object that represents a day-of-month.\nIt is a type-safe way of representing a day-of-month in an application.\nAny field that can be derived from a day-of-month can be obtained.\n\nThis class does not store or represent a year, month, time or time-zone.\nFor example, the value '21' can be stored in a {@link DayOfMonth} and\nwould represent the 21st day of any month.",
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "@js-joda/core~TemporalAccessor"
    ]
  },
  {
    "__docId__": 1723,
    "kind": "method",
    "name": "now",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth.now",
    "access": "public",
    "description": "Function overloading for {@link DayOfMonth.now}:\n- if called with no arguments, {@link DayOfMonth._now0} is executed;\n- if called with an instance of {@link ZoneId}, then {@link DayOfMonth._nowZoneId} is executed;\n- if called with an instance of {@link Clock}, then {@link DayOfMonth._nowClock} is executed;\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1724,
    "kind": "method",
    "name": "_now0",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth._now0",
    "access": "protected",
    "description": "Obtains the current day-of-month from the system clock in the default time-zone.\n\nThis will query the {@link Clock.systemDefaultZone} system clock in the default\ntime-zone to obtain the current day-of-month.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": "the current day-of-month using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 1725,
    "kind": "method",
    "name": "_nowZoneId",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth._nowZoneId",
    "access": "protected",
    "description": "Obtains the current day-of-month from the system clock in the specified time-zone.\n\nThis will query the {@link Clock#system(java.time.ZoneId) system clock} to obtain the current day-of-month.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": "the current day-of-month using the system clock, not null"
    }
  },
  {
    "__docId__": 1726,
    "kind": "method",
    "name": "_nowClock",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth._nowClock",
    "access": "protected",
    "description": "Obtains the current day-of-month from the specified clock.\n\nThis will query the specified clock to obtain the current day-of-month.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using {@link Clock dependency injection}.",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": "the current day-of-month, not null"
    }
  },
  {
    "__docId__": 1727,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth.of",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfMonth}.\n\nA day-of-month object represents one of the 31 days of the month, from 1 to 31.",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": "the day-of-month, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month is invalid"
      }
    ]
  },
  {
    "__docId__": 1728,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth.from",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfMonth} from a date-time object.\n\nThis obtains a day-of-month based on the specified temporal.\nA {@link TemporalAccessor} represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of {@link DayOfMonth}.\n\nThe conversion extracts the {@link ChronoField#DAY_OF_MONTH} day-of-month field.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link DayOfMonth.from}.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfMonth"
      ],
      "spread": false,
      "description": "the day-of-month, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link DayOfMonth}"
      }
    ]
  },
  {
    "__docId__": 1729,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#constructor",
    "access": "private",
    "description": "Constructor, previously validated.",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, - from 1 to 31."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1730,
    "kind": "member",
    "name": "_day",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#_day",
    "access": "private",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1731,
    "kind": "method",
    "name": "value",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#value",
    "access": "public",
    "description": "Gets the day-of-month value.",
    "lineNumber": 177,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 1732,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this day-of-month can be queried for the specified field.\nIf false, then calling the {@link DayOfMonth.range} range,\n{@link DayOfMonth.get} get and {@link DayOfMonth.getLong} getLong\nmethods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n<ul>\n<li>{@link ChronoField.DAY_OF_MONTH}\n</ul>\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing this as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this day-of-month, false if not"
    }
  },
  {
    "__docId__": 1733,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis day-of-month is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfMonth.isSupported} supported fields will return\nappropriate range instances.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing this as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 1734,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#get",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-month as an `int`.\n\nThis queries this day-of-month for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfMonth.isSupported} supported fields will return valid\nvalues based on this day-of-month.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 270,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1735,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-month as a `long`.\n\nThis queries this day-of-month for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfMonth.isSupported(TemporalField) supported fields} will return valid\nvalues based on this day-of-month.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 297,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1736,
    "kind": "method",
    "name": "isValidYearMonth",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#isValidYearMonth",
    "access": "public",
    "description": "Checks if the year-month is valid for this year.\n\nThis method checks whether this day and the input year and month form\na valid date.",
    "lineNumber": 317,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "yearMonth",
        "description": "the year month to validate, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year and month are valid for this day"
    }
  },
  {
    "__docId__": 1737,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#query",
    "access": "public",
    "description": "Queries this day-of-month using the specified query.\n\nThis queries this day-of-month using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom} method on the\nspecified query passing this as the argument.",
    "lineNumber": 339,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 1738,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this day-of-month.\n\nThis returns a temporal object of the same observable type as the input\nwith the day-of-month changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\npassing {@link ChronoField.DAY_OF_MONTH} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n```\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisDay.adjustInto(temporal);\n  temporal = temporal.with(thisDay);\n```\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 374,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1739,
    "kind": "method",
    "name": "atMonth",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#atMonth",
    "access": "public",
    "description": "Combines this day-of-month with a month to create a {@link MonthDay}.\n\nThis returns a {@link MonthDay} formed from this day and the specified month.\n\nThis method can be used as part of a chain to produce a date:\n```\n LocalDate date = day.atMonth(month).atYear(year);\n```\n\nIf this day-of-month is invalid for the month then it will be changed\nto the last valid date for the month.",
    "lineNumber": 400,
    "params": [
      {
        "nullable": null,
        "types": [
          "Month ",
          " number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to use, from 1 (January) to 12 (December), not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MonthDay"
      ],
      "spread": false,
      "description": "the year-month formed from this year and the specified month, not null"
    }
  },
  {
    "__docId__": 1740,
    "kind": "method",
    "name": "atYearMonth",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#atYearMonth",
    "access": "public",
    "description": "Combines this day-of-month with a year-month to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this year and the specified year-month.\n\nIf this day-of-month is invalid for the year-month then it will be changed\nto the last valid date for the month.",
    "lineNumber": 420,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "yearMonth",
        "description": "the year-month to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date formed from this year and the specified year-month, not null"
    }
  },
  {
    "__docId__": 1741,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#compareTo",
    "access": "public",
    "description": "Compares this day-of-month to another.\n\nThe comparison is based on the value of the day.\nIt is 'consistent with equals', as defined by {@link Comparable}.",
    "lineNumber": 435,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfMonth"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other day-of-month instance, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 1742,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#equals",
    "access": "public",
    "description": "Checks if this day-of-month is equal to another day-of-month.",
    "lineNumber": 448,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the other day-of-month instance, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the day-of-month is the same"
    }
  },
  {
    "__docId__": 1743,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#hashCode",
    "access": "public",
    "description": "A hash code for this day-of-month.",
    "lineNumber": 463,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1744,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/DayOfMonth.js~DayOfMonth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfMonth.js~DayOfMonth#toString",
    "access": "public",
    "description": "Outputs this day-of-month as a {@link String}.",
    "lineNumber": 473,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this day-of-month, not null"
    },
    "params": []
  },
  {
    "__docId__": 1745,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/DayOfMonth.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfMonth.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/DayOfMonth.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 479,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1746,
    "kind": "file",
    "name": "packages/extra/src/DayOfYear.js",
    "content": "/*\n * @copyright (c) 2022, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField, Clock, DateTimeException, IllegalArgumentException, IsoChronology, LocalDate, TemporalAccessor, TemporalQueries, TemporalQuery, UnsupportedTemporalTypeException, Year, ZoneId } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireInstance, requireNonNull } from './assert';\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * A day-of-year in the ISO-8601 calendar system.\n * \n * {@link DayOfYear} is an immutable date-time object that represents a day-of-year.\n * It is a type-safe way of representing a day-of-year in an application.\n * Any field that can be derived from a day-of-year can be obtained.\n * \n * This class does not store or represent a year, month, time or time-zone.\n * For example, the value \"51\" can be stored in a {@link DayOfYear} and\n * would represent the 51st day of any year.\n */\nexport class DayOfYear extends TemporalAccessor {\n    /**\n     * Function overloading for {@link DayOfYear.now}:\n     * - if called with no arguments, {@link DayOfYear._now0} is executed;\n     * - if called with an instance of {@link ZoneId}, then {@link DayOfYear._nowZoneId} is executed;\n     * - if called with an instance of {@link Clock}, then {@link DayOfYear._nowClock} is executed;\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     * \n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @return {DayOfYear}\n     */\n    static now(zoneIdOrClock) {\n        switch (arguments.length) {\n            case 0:\n                return DayOfYear._now0();\n            case 1:\n                requireNonNull(zoneIdOrClock, 'clockOrZone');\n                if (zoneIdOrClock instanceof ZoneId) {\n                    return DayOfYear._nowZoneId(zoneIdOrClock);\n                }\n                if (zoneIdOrClock instanceof Clock) {\n                    return DayOfYear._nowClock(zoneIdOrClock);\n                }\n                throw new IllegalArgumentException(`zoneIdOrClock must be an instance of ZoneId or Clock, but is ${zoneIdOrClock.constructor.name}`);\n            default:\n                throw new IllegalArgumentException(`Invalid number of arguments: ${arguments.length}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current day-of-year from the system clock in the default time-zone.\n     * \n     * This will query the {@link Clock.systemDefaultZone} system clock in the default\n     * time-zone to obtain the current day-of-year.\n     * The zone and offset will be set based on the time-zone in the clock.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {DayOfYear} the current day-of-year using the system clock and default time-zone, not null\n     * @protected\n     */\n    static _now0() {\n        return DayOfYear.now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current day-of-year from the system clock in the specified time-zone.\n     * \n     * This will query the {@link Clock.system} system clock to obtain the current day-of-year.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone - the zone ID to use, not null\n     * @return {DayOfYear} the current day-of-year using the system clock, not null\n     * @protected\n     */\n    static _nowZoneId(zone) {\n        return DayOfYear.now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current day-of-year from the specified clock.\n     * \n     * This will query the specified clock to obtain the current day-of-year.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock} dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, not null\n     * @return {DayOfYear} the current day-of-year, not null\n     * @protected\n     */\n    static _nowClock(clock) {\n        const now = LocalDate.now(clock);  // called once\n        return DayOfYear.of(now.dayOfYear());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link DayOfYear}.\n     * \n     * A day-of-year object represents one of the 366 days of the year, from 1 to 366.\n     *\n     * @param {number} dayOfYear - the day-of-year to represent, from 1 to 366\n     * @return {DayOfYear} the day-of-year, not null\n     * @throws {DateTimeException} if the day-of-year is invalid\n     */\n    static of(dayOfYear) {\n        if (1 <= dayOfYear && dayOfYear <= 366) {\n            return DayOfYear.VALUES[dayOfYear - 1];\n        } else {\n            throw new DateTimeException(`Invalid value for DayOfYear: ${dayOfYear}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link DayOfYear} from a date-time object.\n     * \n     * This obtains a day-of-year based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link DayOfYear}.\n     * \n     * The conversion extracts the {@link ChronoField.DAY_OF_YEAR} day-of-year field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     * \n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link DayOfYear.from}.\n     *\n     * @param {Temporal} temporal - the temporal object to convert, not null\n     * @return {DayOfYear} the day-of-year, not null\n     * @throws {DateTimeException} if unable to convert to a {@link DayOfYear}\n     */\n    static from(temporal) {\n        requireNonNull(temporal, 'temporal');\n        requireInstance(temporal, TemporalAccessor, 'temporal');\n        if (temporal instanceof DayOfYear) {\n            return temporal;\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            return DayOfYear.of(temporal.get(ChronoField.DAY_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain DayOfYear from TemporalAccessor: ${temporal} of type ${temporal.constructor.name}`, ex);\n        }\n    }\n\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Constructor, previously validated.\n     *\n     * @param {number} dayOfYear - the day-of-year being represented, from 1 to 366.\n     * @private\n     */\n    constructor(dayOfYear) {\n        super();\n        this._day = MathUtil.safeToInt(dayOfYear);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the day-of-year value.\n     *\n     * @return {number} the day-of-year, from 1 to 366\n     */\n    value() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \n     * This checks if this day-of-year can be queried for the specified field.\n     * If false, then calling the {@link DayOfYear.range} range,\n     * {@link DayOfYear.get} get and {@link DayOfYear.getLong} getLong\n     * methods will throw an exception.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * - {@link ChronoField.DAY_OF_YEAR}\n     * \n     * All other {@link ChronoField} instances will return false.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this day-of-year, false if not\n     */\n    isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \n     * The range object expresses the minimum and maximum valid values for a field.\n     * This day-of-year is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfYear.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other {@code ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.rangeRefinedBy}\n     * passing this as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        if (field === ChronoField.DAY_OF_YEAR) {\n            return field.range();\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-year as an `int`.\n     * \n     * This queries this day-of-year for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfYear.isSupported} supported fields will return valid\n     * values based on this day-of-year.\n     * All other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *  the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *  the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this day-of-year as a `long`.\n     * \n     * This queries this day-of-year for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link DayOfYear.isSupported} supported fields will return valid\n     * values based on this day-of-year.\n     * All other {@code ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.getFrom}\n     * passing this as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field === ChronoField.DAY_OF_YEAR) {\n            return this._day;\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is valid for this day-of-year.\n     * \n     * This method checks whether this day-of-yearand the input year form\n     * a valid date. This can only return false for day-of-year 366.\n     *\n     * @param {number} year - the year to validate\n     * @return {boolean} true if the year is valid for this day-of-year\n     */\n    isValidYear(year) {\n        return (this._day < 366 || Year.isLeap(year));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this day-of-year using the specified query.\n     * \n     * This queries this day-of-year using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this day-of-year.\n     * \n     * This returns a temporal object of the same observable type as the input\n     * with the day-of-year changed to be the same as this.\n     * \n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link ChronoField.DAY_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     * \n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * ```\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisDay.adjustInto(temporal);\n     *   temporal = temporal.with(thisDay);\n     * ```\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) === false) {\n            throw new DateTimeException(\"Adjustment only supported on ISO date-time\");\n        }*/\n        return temporal.with(ChronoField.DAY_OF_YEAR, this._day);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this day-of-year with a year to create a {@link LocalDate}.\n     * \n     * This returns a {@link LocalDate} formed from this day and the specified year.\n     * \n     * This method can be used as part of a chain to produce a date:\n     * ```\n     *  LocalDate date = day.atYear(year);\n     * ```\n     * \n     * The day-of-year value 366 is only valid in a leap year.\n     *\n     * @param {Year|number} year - the year to use ({@link Year} or `int`), not null\n     * @return {LocalDate} the local date formed from this day and the specified year, not null\n     * @throws {DateTimeException} if the year is invalid or this is day 366 and the year is not a leap year\n     */\n    atYear(year) {\n        requireNonNull(year, 'year');\n        if (year instanceof Year) {\n            return year.atDay(this._day);\n        } else {\n            return LocalDate.ofYearDay(year, this._day);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this day-of-year to another.\n     * \n     * The comparison is based on the value of the day.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {DayOfYear} other - the other day-of-year instance, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, DayOfYear, 'other');\n        return this._day - other._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this day-of-year is equal to another day-of-year.\n     *\n     * @param {*} obj - the other day-of-year instance, null returns false\n     * @return {boolean} true if the day-of-year is the same\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof DayOfYear) {\n            return this._day === obj._day;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this day-of-year.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._day;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this day-of-year as a {@link String}.\n     *\n     * @return {string} a string representation of this day-of-year, not null\n     */\n    toString() {\n        return `DayOfYear:${this._day}`;\n    }\n}\n\nexport function _init() {\n    /**\n     * Cache of singleton instances.\n     */\n    DayOfYear.VALUES = new Array(366);\n    for (let i = 0; i < 366; i++) {\n        DayOfYear.VALUES[i] = new DayOfYear(i + 1);\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/DayOfYear.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1747,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/DayOfYear.js",
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/DayOfYear.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1748,
    "kind": "class",
    "name": "DayOfYear",
    "memberof": "packages/extra/src/DayOfYear.js",
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/DayOfYear.js",
    "importStyle": "{DayOfYear}",
    "description": "A day-of-year in the ISO-8601 calendar system.\n\n{@link DayOfYear} is an immutable date-time object that represents a day-of-year.\nIt is a type-safe way of representing a day-of-year in an application.\nAny field that can be derived from a day-of-year can be obtained.\n\nThis class does not store or represent a year, month, time or time-zone.\nFor example, the value \"51\" can be stored in a {@link DayOfYear} and\nwould represent the 51st day of any year.",
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "@js-joda/core~TemporalAccessor"
    ]
  },
  {
    "__docId__": 1749,
    "kind": "method",
    "name": "now",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear.now",
    "access": "public",
    "description": "Function overloading for {@link DayOfYear.now}:\n- if called with no arguments, {@link DayOfYear._now0} is executed;\n- if called with an instance of {@link ZoneId}, then {@link DayOfYear._nowZoneId} is executed;\n- if called with an instance of {@link Clock}, then {@link DayOfYear._nowClock} is executed;\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1750,
    "kind": "method",
    "name": "_now0",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear._now0",
    "access": "protected",
    "description": "Obtains the current day-of-year from the system clock in the default time-zone.\n\nThis will query the {@link Clock.systemDefaultZone} system clock in the default\ntime-zone to obtain the current day-of-year.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": "the current day-of-year using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 1751,
    "kind": "method",
    "name": "_nowZoneId",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear._nowZoneId",
    "access": "protected",
    "description": "Obtains the current day-of-year from the system clock in the specified time-zone.\n\nThis will query the {@link Clock.system} system clock to obtain the current day-of-year.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": "the current day-of-year using the system clock, not null"
    }
  },
  {
    "__docId__": 1752,
    "kind": "method",
    "name": "_nowClock",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear._nowClock",
    "access": "protected",
    "description": "Obtains the current day-of-year from the specified clock.\n\nThis will query the specified clock to obtain the current day-of-year.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using {@link Clock} dependency injection.",
    "lineNumber": 101,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": "the current day-of-year, not null"
    }
  },
  {
    "__docId__": 1753,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear.of",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfYear}.\n\nA day-of-year object represents one of the 366 days of the year, from 1 to 366.",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to represent, from 1 to 366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": "the day-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year is invalid"
      }
    ]
  },
  {
    "__docId__": 1754,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear.from",
    "access": "public",
    "description": "Obtains an instance of {@link DayOfYear} from a date-time object.\n\nThis obtains a day-of-year based on the specified temporal.\nA {@link TemporalAccessor} represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of {@link DayOfYear}.\n\nThe conversion extracts the {@link ChronoField.DAY_OF_YEAR} day-of-year field.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link DayOfYear.from}.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "DayOfYear"
      ],
      "spread": false,
      "description": "the day-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link DayOfYear}"
      }
    ]
  },
  {
    "__docId__": 1755,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#constructor",
    "access": "private",
    "description": "Constructor, previously validated.",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year being represented, from 1 to 366."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1756,
    "kind": "member",
    "name": "_day",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#_day",
    "access": "private",
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1757,
    "kind": "method",
    "name": "value",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#value",
    "access": "public",
    "description": "Gets the day-of-year value.",
    "lineNumber": 179,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 366"
    },
    "params": []
  },
  {
    "__docId__": 1758,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this day-of-year can be queried for the specified field.\nIf false, then calling the {@link DayOfYear.range} range,\n{@link DayOfYear.get} get and {@link DayOfYear.getLong} getLong\nmethods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n- {@link ChronoField.DAY_OF_YEAR}\n\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing this as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this day-of-year, false if not"
    }
  },
  {
    "__docId__": 1759,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis day-of-year is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfYear.isSupported} supported fields will return\nappropriate range instances.\nAll other {@code ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.rangeRefinedBy}\npassing this as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 1760,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#get",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-year as an `int`.\n\nThis queries this day-of-year for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfYear.isSupported} supported fields will return valid\nvalues based on this day-of-year.\nAll other {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1761,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this day-of-year as a `long`.\n\nThis queries this day-of-year for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link DayOfYear.isSupported} supported fields will return valid\nvalues based on this day-of-year.\nAll other {@code ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.getFrom}\npassing this as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 298,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1762,
    "kind": "method",
    "name": "isValidYear",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#isValidYear",
    "access": "public",
    "description": "Checks if the year is valid for this day-of-year.\n\nThis method checks whether this day-of-yearand the input year form\na valid date. This can only return false for day-of-year 366.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to validate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is valid for this day-of-year"
    }
  },
  {
    "__docId__": 1763,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#query",
    "access": "public",
    "description": "Queries this day-of-year using the specified query.\n\nThis queries this day-of-year using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom} method on the\nspecified query passing this as the argument.",
    "lineNumber": 340,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 1764,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this day-of-year.\n\nThis returns a temporal object of the same observable type as the input\nwith the day-of-year changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\npassing {@link ChronoField.DAY_OF_YEAR} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n```\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisDay.adjustInto(temporal);\n  temporal = temporal.with(thisDay);\n```\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 375,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1765,
    "kind": "method",
    "name": "atYear",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#atYear",
    "access": "public",
    "description": "Combines this day-of-year with a year to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this day and the specified year.\n\nThis method can be used as part of a chain to produce a date:\n```\n LocalDate date = day.atYear(year);\n```\n\nThe day-of-year value 366 is only valid in a leap year.",
    "lineNumber": 401,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to use ({@link Year} or `int`), not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the local date formed from this day and the specified year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year is invalid or this is day 366 and the year is not a leap year"
      }
    ]
  },
  {
    "__docId__": 1766,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#compareTo",
    "access": "public",
    "description": "Compares this day-of-year to another.\n\nThe comparison is based on the value of the day.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 420,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfYear"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other day-of-year instance, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 1767,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#equals",
    "access": "public",
    "description": "Checks if this day-of-year is equal to another day-of-year.",
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the other day-of-year instance, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the day-of-year is the same"
    }
  },
  {
    "__docId__": 1768,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#hashCode",
    "access": "public",
    "description": "A hash code for this day-of-year.",
    "lineNumber": 448,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1769,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/DayOfYear.js~DayOfYear",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/DayOfYear.js~DayOfYear#toString",
    "access": "public",
    "description": "Outputs this day-of-year as a {@link String}.",
    "lineNumber": 458,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this day-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 1770,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/DayOfYear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/DayOfYear.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/DayOfYear.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 463,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1771,
    "kind": "file",
    "name": "packages/extra/src/Interval.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeException, DateTimeParseException, Duration, IllegalArgumentException, Instant, ZonedDateTime } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireNonNull, requireInstance } from './assert';\n\n/**\n * An immutable interval of time between two instants.\n * \n * An interval represents the time on the time-line between two {@link Instant}s.\n * The class stores the start and end instants, with the start inclusive and the end exclusive.\n * The end instant is always greater than or equal to the start instant.\n * \n * The {@link Duration} of an interval can be obtained, but is a separate concept.\n * An interval is connected to the time-line, whereas a duration is not.\n * \n * Intervals are not comparable. To compare the length of two intervals, it is\n * generally recommended to compare their durations.\n *\n */\nexport class Interval {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link Interval.of}\n     * - If called without arguments, then {@link Interval.ofInstantInstant} is executed.\n     * - If called with 1 arguments and first argument is an instance of ZoneId, then {@link Interval.ofInstantDuration} is executed.\n     * - Otherwise {@link Interval.ofInstantDuration} is executed.\n     *\n     * @param {Instant} startInstant\n     * @param {Instant|Duration} endInstantOrDuration\n     * @return {Interval}\n     */\n    static of(startInstant, endInstantOrDuration) {\n        if (endInstantOrDuration instanceof Duration) {\n            return Interval.ofInstantDuration(startInstant, endInstantOrDuration);\n        } else {\n            return Interval.ofInstantInstant(startInstant, endInstantOrDuration);\n        }\n    }\n\n    /**\n     * Obtains an instance of `Interval` from the start and end instant.\n     * \n     * The end instant must not be before the start instant.\n     *\n     * @param {Instant} startInclusive - the start instant, inclusive, MIN_DATE treated as unbounded, not null\n     * @param {Instant} endExclusive - the end instant, exclusive, MAX_DATE treated as unbounded, not null\n     * @return {Interval} the half-open interval, not null\n     * @throws {DateTimeException} if the end is before the start\n     * @protected\n     */\n    static ofInstantInstant(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(endExclusive, Instant, 'endExclusive');\n        if (endExclusive.isBefore(startInclusive)) {\n            throw new DateTimeException('End instant must on or after start instant');\n        }\n        return new Interval(startInclusive, endExclusive);\n    }\n\n    /**\n     * Obtains an instance of `Interval` from the start and a duration.\n     * \n     * The end instant is calculated as the start plus the duration.\n     * The duration must not be negative.\n     *\n     * @param {Instant} startInclusive - the start instant, inclusive, not null\n     * @param {Duration} duration - the duration from the start to the end, not null\n     * @return {Interval} the interval, not null\n     * @throws {DateTimeException} if the end is before the start,\n     *  or if the duration addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs when adding the duration\n     * @protected\n     */\n    static ofInstantDuration(startInclusive, duration) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(duration, 'duration');\n        requireInstance(startInclusive, Instant, 'startInclusive');\n        requireInstance(duration, Duration, 'duration');\n        if (duration.isNegative()) {\n            throw new DateTimeException('Duration must not be zero or negative');\n        }\n        return new Interval(startInclusive, startInclusive.plus(duration));\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Obtains an instance of `Interval` from a text string such as\n     * `2007-12-03T10:15:30Z/2007-12-04T10:15:30Z`, where the end instant is exclusive.\n     * \n     * The string must consist of one of the following three formats:\n     * - a representations of an {@link ZonedDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link ZonedDateTime}\n     * - a representation of an {@link ZonedDateTime}, followed by a forward slash,\n     *  followed by a representation of a {@link Duration}\n     * - a representation of a {@link Duration}, followed by a forward slash,\n     *  followed by a representation of an {@link ZonedDateTime}\n     *\n     * NOTE: in contrast to the threeten-extra base we are not using `OffsetDateTime` but `ZonedDateTime` to parse\n     * the string, this does not change the format but adds the possibility to optionally specify a zone\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {Interval} the parsed interval, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        if (!(typeof text === 'string')) {\n            throw new IllegalArgumentException(`text must be a string, but is ${text.constructor.name}`);\n        }\n        for (let i = 0; i < text.length; i += 1) {\n            if (text.charAt(i) === '/') {\n                const firstChar = text.charAt(0);\n                if (firstChar === 'P' || firstChar === 'p') {\n                    // duration followed by instant\n                    const duration = Duration.parse(text.substring(0, i));\n                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();\n                    return Interval.of(end.minus(duration), end);\n                } else {\n                    // instant followed by instant or duration\n                    const start = ZonedDateTime.parse(text.substring(0, i)).toInstant();\n                    if (i + 1 < text.length) {\n                        const c = text.charAt(i + 1);\n                        if (c === 'P' || c === 'p') {\n                            const duration = Duration.parse(text.substring(i + 1, text.length));\n                            return Interval.of(start, start.plus(duration));\n                        }\n                    }\n                    const end = ZonedDateTime.parse(text.substring(i + 1, text.length)).toInstant();\n                    return Interval.of(start, end);\n                }\n            }\n        }\n        throw new DateTimeParseException('Interval cannot be parsed, no forward slash found', text, 0);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {Instant} startInclusive - the start instant, inclusive, validated not null\n     * @param {Instant} endExclusive - the end instant, exclusive, validated not null\n     * @private\n     */\n    constructor(startInclusive, endExclusive) {\n        this._start = startInclusive;\n        this._end = endExclusive;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the start of this time interval, inclusive.\n     * \n     * This will return {@link Instant#MIN} if the range is unbounded at the start.\n     * In this case, the range includes all dates into the far-past.\n     *\n     * @return {Instant} the start of the time interval\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * Gets the end of this time interval, exclusive.\n     * \n     * This will return {@link Instant#MAX} if the range is unbounded at the end.\n     * In this case, the range includes all dates into the far-future.\n     *\n     * @return {Instant} the end of the time interval, exclusive\n     */\n    end() {\n        return this._end;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the range is empty.\n     * \n     * An empty range occurs when the start date equals the inclusive end date.\n     *\n     * @return {boolean} true if the range is empty\n     */\n    isEmpty() {\n        return this._start.equals(this._end);\n    }\n\n    /**\n     * Checks if the start of the interval is unbounded.\n     *\n     * @return {boolean} true if start is unbounded\n     */\n    isUnboundedStart() {\n        return this._start.equals(Instant.MIN);\n    }\n\n    /**\n     * Checks if the end of the interval is unbounded.\n     *\n     * @return {boolean} true if end is unbounded\n     */\n    isUnboundedEnd() {\n        return this._end.equals(Instant.MAX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this range with the specified start instant.\n     *\n     * @param {Instant} start - the start instant for the new interval, not null\n     * @return {Interval} an interval with the end from this interval and the specified start\n     * @throws {DateTimeException} if the resulting interval has end before start\n     */\n    withStart(start) {\n        return Interval.of(start, this._end);\n    }\n\n    /**\n     * Returns a copy of this range with the specified end instant.\n     *\n     * @param {Instant} end - the end instant for the new interval, not null\n     * @return {Interval} an interval with the start from this interval and the specified end\n     * @throws {DateTimeException} if the resulting interval has end before start\n     */\n    withEnd(end) {\n        return Interval.of(this._start, end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval contains the specified instant.\n     * \n     * This checks if the specified instant is within the bounds of this interval.\n     * If this range has an unbounded start then `contains(Instant.MIN)` returns true.\n     * If this range has an unbounded end then `contains(Instant.MAX)` returns true.\n     * If this range is empty then this method always returns false.\n     *\n     * @param {Instant} instant - the instant, not null\n     * @return {boolean} true if this interval contains the instant\n     */\n    contains(instant) {\n        requireNonNull(instant, 'instant');\n        requireInstance(instant, Instant, 'instant');\n        return this._start.compareTo(instant) <= 0 && (instant.compareTo(this._end) < 0 || this.isUnboundedEnd());\n    }\n\n    /**\n     * Checks if this interval encloses the specified interval.\n     * \n     * This checks if the bounds of the specified interval are within the bounds of this interval.\n     * An empty interval encloses itself.\n     *\n     * @param {Interval} other - the other interval, not null\n     * @return {boolean} true if this interval contains the other interval\n     */\n    encloses(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this._start.compareTo(other.start()) <= 0 && other.end().compareTo(this._end) <= 0;\n    }\n\n    /**\n     * Checks if this interval abuts the specified interval.\n     * \n     * The result is true if the end of this interval is the start of the other, or vice versa.\n     * An empty interval does not abut itself.\n     *\n     * @param {Interval} other - the other interval, not null\n     * @return {boolean} true if this interval abuts the other interval\n     */\n    abuts(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return !this._end.equals(other.start()) !== !this._start.equals(other.end());\n    }\n\n    /**\n     * Checks if this interval is connected to the specified interval.\n     * \n     * The result is true if the two intervals have an enclosed interval in common, even if that interval is empty.\n     * An empty interval is connected to itself.\n     * \n     * This is equivalent to `(overlaps(other) || abuts(other))`.\n     *\n     * @param {Interval} other - the other interval, not null\n     * @return {boolean} true if this interval is connected to the other interval\n     */\n    isConnected(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return this.equals(other) || (this._start.compareTo(other.end()) <= 0 && other.start().compareTo(this._end) <= 0);\n    }\n\n    /**\n     * Checks if this interval overlaps the specified interval.\n     * \n     * The result is true if the the two intervals share some part of the time-line.\n     * An empty interval overlaps itself.\n     * \n     * This is equivalent to `(isConnected(other) && !abuts(other))`.\n     *\n     * @param {Interval} other - the time interval to compare to, null means a zero length interval now\n     * @return {boolean} true if the time intervals overlap\n     */\n    overlaps(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        return other.equals(this) || (this._start.compareTo(other.end()) < 0 && other.start().compareTo(this._end) < 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the interval that is the intersection of this interval and the specified interval.\n     * \n     * This finds the intersection of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other - the other interval to check for, not null\n     * @return {Interval} the interval that is the intersection of the two intervals\n     * @throws {DateTimeException} if the intervals do not connect\n     */\n    intersection(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return this;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return other;\n        } else {\n            const newStart = (cmpStart >= 0 ? this._start : other.start());\n            const newEnd = (cmpEnd <= 0 ? this._end : other.end());\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the interval that is the union of this interval and the specified interval.\n     * \n     * This finds the union of two intervals.\n     * This throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.\n     *\n     * @param {Interval} other - the other interval to check for, not null\n     * @return {Interval} the interval that is the union of the two intervals\n     * @throws {DateTimeException} if the intervals do not connect\n     */\n    union(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Intervals do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return other;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return this;\n        } else {\n            const newStart = (cmpStart >= 0 ? other.start() : this._start);\n            const newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n            return Interval.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the smallest interval that encloses this interval and the specified interval.\n     * \n     * The result of this method will {@linkplain #encloses(Interval) enclose}\n     * this interval and the specified interval.\n     *\n     * @param {Interval} other - the other interval to check for, not null\n     * @return {Interval} the interval that spans the two intervals\n     */\n    span(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Interval, 'other');\n        const cmpStart = this._start.compareTo(other.start());\n        const cmpEnd = this._end.compareTo(other.end());\n        const newStart = (cmpStart >= 0 ? other.start() : this._start);\n        const newEnd = (cmpEnd <= 0 ? other.end() : this._end);\n        return Interval.of(newStart, newEnd);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Function overloading for {@link Interval#isAfter}\n     * - If called with an Instant, then {@link Interval#isAfterInstant} is executed.\n     * - Otherwise {@link Interval#isAfterInterval} is executed.\n     *\n     * @param {Instant|Interval} instantOrInterval\n     * @return {boolean}\n     */\n    isAfter(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isAfterInstant(instantOrInterval);\n        } else {\n            return this.isAfterInterval(instantOrInterval);\n        }\n    }\n\n    /**\n     * Function overloading for {@link Interval#isBefore}\n     * - If called with an Instant, then {@link Interval#isBeforeInstant} is executed.\n     * - Otherwise {@link Interval#isBeforeInterval} is executed.\n     *\n     * @param {Instant|Interval} instantOrInterval\n     * @return {boolean}\n     */\n    isBefore(instantOrInterval) {\n        if (instantOrInterval instanceof Instant) {\n            return this.isBeforeInstant(instantOrInterval);\n        } else {\n            return this.isBeforeInterval(instantOrInterval);\n        }\n    }\n\n    /**\n     * Checks if this interval is after the specified instant.\n     * \n     * The result is true if the this instant starts after the specified instant.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant - the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is after the specified instant\n     */\n    isAfterInstant(instant) {\n        return this._start.compareTo(instant) > 0;\n    }\n\n    /**\n     * Checks if this interval is before the specified instant.\n     * \n     * The result is true if the this instant ends before the specified instant.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Instant} instant - the other instant to compare to, not null\n     * @return {boolean} true if the start of this interval is before the specified instant\n     */\n    isBeforeInstant(instant) {\n        return this._end.compareTo(instant) <= 0 && this._start.compareTo(instant) < 0;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Checks if this interval is after the specified interval.\n     * \n     * The result is true if the this instant starts after the end of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * instant equals the end of the interval.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval - the other interval to compare to, not null\n     * @return {boolean} true if this instant is after the specified instant\n     */\n    isAfterInterval(interval) {\n        return this._start.compareTo(interval.end()) >= 0 && !interval.equals(this);\n    }\n\n    /**\n     * Checks if this interval is before the specified interval.\n     * \n     * The result is true if the this instant ends before the start of the specified interval.\n     * Since intervals do not include their end points, this will return true if the\n     * two intervals abut.\n     * An empty interval behaves as though it is an instant for comparison purposes.\n     *\n     * @param {Interval} interval - the other interval to compare to, not null\n     * @return {boolean} true if this instant is before the specified instant\n     */\n    isBeforeInterval(interval) {\n        return this._end.compareTo(interval.start()) <= 0 && !interval.equals(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the duration of this interval.\n     * \n     * An `Interval` is associated with two specific instants on the time-line.\n     * A `Duration` is simply an amount of time, separate from the time-line.\n     *\n     * @return {Duration} the duration of the time interval\n     * @throws {ArithmeticException} if the calculation exceeds the capacity of `Duration`\n     */\n    toDuration() {\n        return Duration.between(this._start, this._end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this interval is equal to another interval.\n     * \n     * Compares this `Interval` with another ensuring that the two instants are the same.\n     * Only objects of type `Interval` are compared, other types return false.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other interval\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Interval) {\n            return this._start.equals(obj.start()) && this._end.equals(obj.end());\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this interval.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        // eslint-disable-next-line no-bitwise\n        return this._start.hashCode() ^ this._end.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this interval as a `String`, such as `2007-12-03T10:15:30/2007-12-04T10:15:30`.\n     * \n     * The output will be the ISO-8601 format formed by combining the\n     * `toString()` methods of the two instants, separated by a forward slash.\n     *\n     * @return {string} a string representation of this instant, not null\n     */\n    toString() {\n        return `${this._start.toString()}/${this._end.toString()}`;\n    }\n}\n\nexport function _init() {\n    Interval.ALL = Interval.of(Instant.MIN, Instant.MAX);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/Interval.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1772,
    "kind": "class",
    "name": "Interval",
    "memberof": "packages/extra/src/Interval.js",
    "static": true,
    "longname": "packages/extra/src/Interval.js~Interval",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Interval.js",
    "importStyle": "{Interval}",
    "description": "An immutable interval of time between two instants.\n\nAn interval represents the time on the time-line between two {@link Instant}s.\nThe class stores the start and end instants, with the start inclusive and the end exclusive.\nThe end instant is always greater than or equal to the start instant.\n\nThe {@link Duration} of an interval can be obtained, but is a separate concept.\nAn interval is connected to the time-line, whereas a duration is not.\n\nIntervals are not comparable. To compare the length of two intervals, it is\ngenerally recommended to compare their durations.",
    "lineNumber": 26,
    "interface": false
  },
  {
    "__docId__": 1773,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Interval.js~Interval.of",
    "access": "public",
    "description": "function overloading for {@link Interval.of}\n- If called without arguments, then {@link Interval.ofInstantInstant} is executed.\n- If called with 1 arguments and first argument is an instance of ZoneId, then {@link Interval.ofInstantDuration} is executed.\n- Otherwise {@link Interval.ofInstantDuration} is executed.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "startInstant",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Instant",
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "endInstantOrDuration",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1774,
    "kind": "method",
    "name": "ofInstantInstant",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Interval.js~Interval.ofInstantInstant",
    "access": "protected",
    "description": "Obtains an instance of `Interval` from the start and end instant.\n\nThe end instant must not be before the start instant.",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the start instant, inclusive, MIN_DATE treated as unbounded, not null"
      },
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end instant, exclusive, MAX_DATE treated as unbounded, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the half-open interval, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end is before the start"
      }
    ]
  },
  {
    "__docId__": 1775,
    "kind": "method",
    "name": "ofInstantDuration",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Interval.js~Interval.ofInstantDuration",
    "access": "protected",
    "description": "Obtains an instance of `Interval` from the start and a duration.\n\nThe end instant is calculated as the start plus the duration.\nThe duration must not be negative.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the start instant, inclusive, not null"
      },
      {
        "nullable": null,
        "types": [
          "Duration"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "the duration from the start to the end, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the interval, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end is before the start,\n or if the duration addition cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs when adding the duration"
      }
    ]
  },
  {
    "__docId__": 1776,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Interval.js~Interval.parse",
    "access": "public",
    "description": "Obtains an instance of `Interval` from a text string such as\n`2007-12-03T10:15:30Z/2007-12-04T10:15:30Z`, where the end instant is exclusive.\n\nThe string must consist of one of the following three formats:\n- a representations of an {@link ZonedDateTime}, followed by a forward slash,\n followed by a representation of a {@link ZonedDateTime}\n- a representation of an {@link ZonedDateTime}, followed by a forward slash,\n followed by a representation of a {@link Duration}\n- a representation of a {@link Duration}, followed by a forward slash,\n followed by a representation of an {@link ZonedDateTime}\n\nNOTE: in contrast to the threeten-extra base we are not using `OffsetDateTime` but `ZonedDateTime` to parse\nthe string, this does not change the format but adds the possibility to optionally specify a zone",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the parsed interval, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 1777,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the start instant, inclusive, validated not null"
      },
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end instant, exclusive, validated not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1778,
    "kind": "member",
    "name": "_start",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#_start",
    "access": "private",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1779,
    "kind": "member",
    "name": "_end",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#_end",
    "access": "private",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1780,
    "kind": "method",
    "name": "start",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#start",
    "access": "public",
    "description": "Gets the start of this time interval, inclusive.\n\nThis will return {@link Instant#MIN} if the range is unbounded at the start.\nIn this case, the range includes all dates into the far-past.",
    "lineNumber": 166,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the start of the time interval"
    },
    "params": []
  },
  {
    "__docId__": 1781,
    "kind": "method",
    "name": "end",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#end",
    "access": "public",
    "description": "Gets the end of this time interval, exclusive.\n\nThis will return {@link Instant#MAX} if the range is unbounded at the end.\nIn this case, the range includes all dates into the far-future.",
    "lineNumber": 178,
    "return": {
      "nullable": null,
      "types": [
        "Instant"
      ],
      "spread": false,
      "description": "the end of the time interval, exclusive"
    },
    "params": []
  },
  {
    "__docId__": 1782,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isEmpty",
    "access": "public",
    "description": "Checks if the range is empty.\n\nAn empty range occurs when the start date equals the inclusive end date.",
    "lineNumber": 190,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the range is empty"
    },
    "params": []
  },
  {
    "__docId__": 1783,
    "kind": "method",
    "name": "isUnboundedStart",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isUnboundedStart",
    "access": "public",
    "description": "Checks if the start of the interval is unbounded.",
    "lineNumber": 199,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if start is unbounded"
    },
    "params": []
  },
  {
    "__docId__": 1784,
    "kind": "method",
    "name": "isUnboundedEnd",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isUnboundedEnd",
    "access": "public",
    "description": "Checks if the end of the interval is unbounded.",
    "lineNumber": 208,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if end is unbounded"
    },
    "params": []
  },
  {
    "__docId__": 1785,
    "kind": "method",
    "name": "withStart",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#withStart",
    "access": "public",
    "description": "Returns a copy of this range with the specified start instant.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "the start instant for the new interval, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "an interval with the end from this interval and the specified start"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the resulting interval has end before start"
      }
    ]
  },
  {
    "__docId__": 1786,
    "kind": "method",
    "name": "withEnd",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#withEnd",
    "access": "public",
    "description": "Returns a copy of this range with the specified end instant.",
    "lineNumber": 231,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "the end instant for the new interval, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "an interval with the start from this interval and the specified end"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the resulting interval has end before start"
      }
    ]
  },
  {
    "__docId__": 1787,
    "kind": "method",
    "name": "contains",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#contains",
    "access": "public",
    "description": "Checks if this interval contains the specified instant.\n\nThis checks if the specified instant is within the bounds of this interval.\nIf this range has an unbounded start then `contains(Instant.MIN)` returns true.\nIf this range has an unbounded end then `contains(Instant.MAX)` returns true.\nIf this range is empty then this method always returns false.",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this interval contains the instant"
    }
  },
  {
    "__docId__": 1788,
    "kind": "method",
    "name": "encloses",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#encloses",
    "access": "public",
    "description": "Checks if this interval encloses the specified interval.\n\nThis checks if the bounds of the specified interval are within the bounds of this interval.\nAn empty interval encloses itself.",
    "lineNumber": 262,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this interval contains the other interval"
    }
  },
  {
    "__docId__": 1789,
    "kind": "method",
    "name": "abuts",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#abuts",
    "access": "public",
    "description": "Checks if this interval abuts the specified interval.\n\nThe result is true if the end of this interval is the start of the other, or vice versa.\nAn empty interval does not abut itself.",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this interval abuts the other interval"
    }
  },
  {
    "__docId__": 1790,
    "kind": "method",
    "name": "isConnected",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isConnected",
    "access": "public",
    "description": "Checks if this interval is connected to the specified interval.\n\nThe result is true if the two intervals have an enclosed interval in common, even if that interval is empty.\nAn empty interval is connected to itself.\n\nThis is equivalent to `(overlaps(other) || abuts(other))`.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this interval is connected to the other interval"
    }
  },
  {
    "__docId__": 1791,
    "kind": "method",
    "name": "overlaps",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#overlaps",
    "access": "public",
    "description": "Checks if this interval overlaps the specified interval.\n\nThe result is true if the the two intervals share some part of the time-line.\nAn empty interval overlaps itself.\n\nThis is equivalent to `(isConnected(other) && !abuts(other))`.",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the time interval to compare to, null means a zero length interval now"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the time intervals overlap"
    }
  },
  {
    "__docId__": 1792,
    "kind": "method",
    "name": "intersection",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#intersection",
    "access": "public",
    "description": "Calculates the interval that is the intersection of this interval and the specified interval.\n\nThis finds the intersection of two intervals.\nThis throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.",
    "lineNumber": 328,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the interval that is the intersection of the two intervals"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the intervals do not connect"
      }
    ]
  },
  {
    "__docId__": 1793,
    "kind": "method",
    "name": "union",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#union",
    "access": "public",
    "description": "Calculates the interval that is the union of this interval and the specified interval.\n\nThis finds the union of two intervals.\nThis throws an exception if the two intervals are not {@linkplain #isConnected(Interval) connected}.",
    "lineNumber": 357,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the interval that is the union of the two intervals"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the intervals do not connect"
      }
    ]
  },
  {
    "__docId__": 1794,
    "kind": "method",
    "name": "span",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#span",
    "access": "public",
    "description": "Calculates the smallest interval that encloses this interval and the specified interval.\n\nThe result of this method will {@linkplain #encloses(Interval) enclose}\nthis interval and the specified interval.",
    "lineNumber": 385,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other interval to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Interval"
      ],
      "spread": false,
      "description": "the interval that spans the two intervals"
    }
  },
  {
    "__docId__": 1795,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isAfter",
    "access": "public",
    "description": "Function overloading for {@link Interval#isAfter}\n- If called with an Instant, then {@link Interval#isAfterInstant} is executed.\n- Otherwise {@link Interval#isAfterInterval} is executed.",
    "lineNumber": 404,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant",
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "instantOrInterval",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1796,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isBefore",
    "access": "public",
    "description": "Function overloading for {@link Interval#isBefore}\n- If called with an Instant, then {@link Interval#isBeforeInstant} is executed.\n- Otherwise {@link Interval#isBeforeInterval} is executed.",
    "lineNumber": 420,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant",
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "instantOrInterval",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1797,
    "kind": "method",
    "name": "isAfterInstant",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isAfterInstant",
    "access": "public",
    "description": "Checks if this interval is after the specified instant.\n\nThe result is true if the this instant starts after the specified instant.\nAn empty interval behaves as though it is an instant for comparison purposes.",
    "lineNumber": 437,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the other instant to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the start of this interval is after the specified instant"
    }
  },
  {
    "__docId__": 1798,
    "kind": "method",
    "name": "isBeforeInstant",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isBeforeInstant",
    "access": "public",
    "description": "Checks if this interval is before the specified instant.\n\nThe result is true if the this instant ends before the specified instant.\nSince intervals do not include their end points, this will return true if the\ninstant equals the end of the interval.\nAn empty interval behaves as though it is an instant for comparison purposes.",
    "lineNumber": 452,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the other instant to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the start of this interval is before the specified instant"
    }
  },
  {
    "__docId__": 1799,
    "kind": "method",
    "name": "isAfterInterval",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isAfterInterval",
    "access": "public",
    "description": "Checks if this interval is after the specified interval.\n\nThe result is true if the this instant starts after the end of the specified interval.\nSince intervals do not include their end points, this will return true if the\ninstant equals the end of the interval.\nAn empty interval behaves as though it is an instant for comparison purposes.",
    "lineNumber": 468,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": "the other interval to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this instant is after the specified instant"
    }
  },
  {
    "__docId__": 1800,
    "kind": "method",
    "name": "isBeforeInterval",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#isBeforeInterval",
    "access": "public",
    "description": "Checks if this interval is before the specified interval.\n\nThe result is true if the this instant ends before the start of the specified interval.\nSince intervals do not include their end points, this will return true if the\ntwo intervals abut.\nAn empty interval behaves as though it is an instant for comparison purposes.",
    "lineNumber": 483,
    "params": [
      {
        "nullable": null,
        "types": [
          "Interval"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": "the other interval to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this instant is before the specified instant"
    }
  },
  {
    "__docId__": 1801,
    "kind": "method",
    "name": "toDuration",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#toDuration",
    "access": "public",
    "description": "Obtains the duration of this interval.\n\nAn `Interval` is associated with two specific instants on the time-line.\nA `Duration` is simply an amount of time, separate from the time-line.",
    "lineNumber": 497,
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the duration of the time interval"
    },
    "throws": [
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if the calculation exceeds the capacity of `Duration`"
      }
    ],
    "params": []
  },
  {
    "__docId__": 1802,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#equals",
    "access": "public",
    "description": "Checks if this interval is equal to another interval.\n\nCompares this `Interval` with another ensuring that the two instants are the same.\nOnly objects of type `Interval` are compared, other types return false.",
    "lineNumber": 511,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other interval"
    }
  },
  {
    "__docId__": 1803,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#hashCode",
    "access": "public",
    "description": "A hash code for this interval.",
    "lineNumber": 526,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1804,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/Interval.js~Interval",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Interval.js~Interval#toString",
    "access": "public",
    "description": "Outputs this interval as a `String`, such as `2007-12-03T10:15:30/2007-12-04T10:15:30`.\n\nThe output will be the ISO-8601 format formed by combining the\n`toString()` methods of the two instants, separated by a forward slash.",
    "lineNumber": 540,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this instant, not null"
    },
    "params": []
  },
  {
    "__docId__": 1805,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/Interval.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Interval.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Interval.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 545,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1806,
    "kind": "file",
    "name": "packages/extra/src/LocalDateRange.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ArithmeticException, DateTimeException, DateTimeParseException, IllegalArgumentException, LocalDate, Period } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireInstance, requireNonNull } from './assert';\n\n/**\n * The day after the MIN date.\n */\nconst MINP1 = LocalDate.MIN.plusDays(1);\n/**\n * The day before the MAX date.\n */\nconst MAXM1 = LocalDate.MAX.minusDays(1);\n\n/**\n * A range of local dates.\n * \n * A `LocalDateRange` represents a range of dates, from a start date to an end date.\n * Instances can be constructed from either a half-open or a closed range of dates.\n * Internally, the class stores the start and end dates, with the start inclusive and the end exclusive.\n * The end date is always greater than or equal to the start date.\n * \n * The constants `LocalDate.MIN` and `LocalDate.MAX` can be used\n * to indicate an unbounded far-past or far-future. Note that there is no difference\n * between a half-open and a closed range when the end is `LocalDate.MAX`.\n * Empty ranges are allowed.\n * \n * No range can end at `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\n * No range can start at `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n * No empty range can exist at `LocalDate.MIN` or `LocalDate.MAX`.\n * \n * Date ranges are not comparable. To compare the length of two ranges, it is\n * generally recommended to compare the number of days they contain.\n *\n */\nexport class LocalDateRange {\n    /**\n     * function overloading for {@link LocalDateRange.of}\n     * - if called with `LocalDate` and `LocalDate`, {@link LocalDateRange._ofLocalDateLocalDate} is executed,\n     * - if called with `LocalDate` and `Period`, {@link LocalDateRange._ofLocalDatePeriod} is executed,\n     * - otherwise throws IllegalArgumentException.\n     *\n     * @param {LocalDate} startInclusive\n     * @param {LocalDate|Period} endExclusiveOrPeriod\n     * @return {LocalDateRange}\n     */\n    static of(startInclusive, endExclusiveOrPeriod) {\n        if (startInclusive instanceof LocalDate && endExclusiveOrPeriod instanceof LocalDate) {\n            return LocalDateRange._ofLocalDateLocalDate(startInclusive, endExclusiveOrPeriod);\n        }\n        if (startInclusive instanceof LocalDate && endExclusiveOrPeriod instanceof Period) {\n            return LocalDateRange._ofLocalDatePeriod(startInclusive, endExclusiveOrPeriod);\n        }\n        const messageParts = [];\n        if (!(startInclusive instanceof LocalDate)) {\n            messageParts.push(`startInclusive must be an instance of LocalDate but is ${startInclusive.constructor.name}`);\n        }\n        if (!(endExclusiveOrPeriod instanceof LocalDate || endExclusiveOrPeriod instanceof Period)) {\n            messageParts.push(`endExclusiveOrPeriod must be an instance of LocalDate or Period but is ${endExclusiveOrPeriod.constructor.name}`);\n        }\n        throw new IllegalArgumentException(messageParts.join(' and '));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains a half-open range of dates, including the start and excluding the end.\n     * \n     * The range includes the start date and excludes the end date, unless the end is `LocalDate.MAX`.\n     * The end date must be equal to or after the start date.\n     * This definition permits an empty range located at a specific date.\n     * \n     * The constants `LocalDate.MIN` and `LocalDate.MAX` can be used\n     * to indicate an unbounded far-past or far-future.\n     * \n     * The start inclusive date must not be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n     * The end inclusive date must not be `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\n     * No empty range can exist at `LocalDate.MIN` or `LocalDate.MAX`.\n     *\n     * @param {LocalDate} startInclusive - the inclusive start date, not null\n     * @param {LocalDate} endExclusive - the exclusive end date, not null\n     * @return {LocalDateRange} the half-open range, not null\n     * @throws {DateTimeException} if the end is before the start,\n     *   or the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`,\n     *   or the end date is `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`\n     * @protected\n     */\n    static _ofLocalDateLocalDate(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(startInclusive, LocalDate, 'startInclusive');\n        requireInstance(endExclusive, LocalDate, 'endExclusive');\n        return new LocalDateRange(startInclusive, endExclusive);\n    }\n\n    /**\n     * Obtains an instance of `LocalDateRange` from the start and a period.\n     * \n     * The end date is calculated as the start plus the duration.\n     * The period must not be negative.\n     * \n     * The constant `LocalDate.MIN` can be used to indicate an unbounded far-past.\n     * \n     * The period must not be zero or one day when the start date is `LocalDate.MIN`.\n     *\n     * @param {LocalDate} startInclusive - the inclusive start date, not null\n     * @param {Period} period - the period from the start to the end, not null\n     * @return {LocalDateRange} the range, not null\n     * @throws {DateTimeException} if the end is before the start,\n     *  or if the period addition cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs when adding the period\n     * @protected\n     */\n    static _ofLocalDatePeriod(startInclusive, period) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(period, 'period');\n        requireInstance(startInclusive, LocalDate, 'startInclusive');\n        requireInstance(period, Period, 'period');\n        if (period.isNegative()) {\n            throw new DateTimeException('Period must not be zero or negative');\n        }\n        return new LocalDateRange(startInclusive, startInclusive.plus(period));\n    }\n\n    /**\n     * Obtains a closed range of dates, including the start and end.\n     * \n     * The range includes the start date and the end date.\n     * The end date must be equal to or after the start date.\n     * \n     * The constants `LocalDate.MIN` and `LocalDate.MAX` can be used\n     * to indicate an unbounded far-past or far-future. In addition, an end date of\n     * `LocalDate.MAX.minusDays(1)` will also create an unbounded far-future range.\n     * \n     * The start inclusive date must not be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n     * The end inclusive date must not be `LocalDate.MIN`.\n     * \n     * @param {LocalDate} startInclusive - the inclusive start date, not null\n     * @param {LocalDate} endInclusive - the inclusive end date, not null\n     * @return {LocalDateRange} the closed range\n     * @throws {DateTimeException} if the end is before the start,\n     *   or the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`,\n     *   or the end date is `LocalDate.MIN`\n     */\n    static ofClosed(startInclusive, endInclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endInclusive, 'endInclusive');\n        requireInstance(startInclusive, LocalDate, 'startInclusive');\n        requireInstance(endInclusive, LocalDate, 'endInclusive');\n        if (endInclusive.isBefore(startInclusive)) {\n            throw new DateTimeException('Start date must be on or before end date');\n        }\n        const end = (endInclusive.equals(LocalDate.MAX) ? LocalDate.MAX : endInclusive.plusDays(1));\n        return new LocalDateRange(startInclusive, end);\n    }\n\n    /**\n     * Obtains an empty date range located at the specified date.\n     * \n     * The empty range has zero length and contains no other dates or ranges.\n     * An empty range cannot be located at `LocalDate.MIN`, `LocalDate.MIN.plusDays(1)`,\n     * `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n     *\n     * @param {LocalDate} date - the date where the empty range is located, not null\n     * @return {LocalDateRange} the empty range, not null\n     * @throws {DateTimeException} if the date is `LocalDate.MIN`, `LocalDate.MIN.plusDays(1)`,\n     *   `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`\n     */\n    static ofEmpty(date) {\n        requireNonNull(date, 'date');\n        requireInstance(date, LocalDate, 'date');\n        return new LocalDateRange(date, date);\n    }\n\n    /**\n     * Obtains a range that is unbounded at the start and end.\n     * \n     * @return {LocalDateRange} the range, with an unbounded start and unbounded end\n     */\n    static ofUnbounded() {\n        return LocalDateRange.ALL;\n    }\n\n    /**\n     * Obtains a range up to, but not including, the specified end date.\n     * \n     * The range includes all dates from the unbounded start, denoted by `LocalDate.MIN`, to the end date.\n     * The end date is exclusive and cannot be `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\n     * \n     * @param {LocalDate} endExclusive - the exclusive end date, `LocalDate.MAX` treated as unbounded, not null\n     * @return {LocalDateRange} the range, with an unbounded start\n     * @throws {DateTimeException} if the end date is `LocalDate.MIN` or  `LocalDate.MIN.plusDays(1)`\n     */\n    static ofUnboundedStart(endExclusive) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(endExclusive, LocalDate, 'endExclusive');\n        return LocalDateRange.of(LocalDate.MIN, endExclusive);\n    }\n\n    /**\n     * Obtains a range from and including the specified start date.\n     * \n     * The range includes all dates from the start date to the unbounded end, denoted by `LocalDate.MAX`.\n     * The start date is inclusive and cannot be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n     * \n     * @param {LocalDate} startInclusive - the inclusive start date, `LocalDate.MIN` treated as unbounded, not null\n     * @return {LocalDateRange} the range, with an unbounded end\n     * @throws {DateTimeException} if the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`\n     */\n    static ofUnboundedEnd(startInclusive) {\n        return LocalDateRange.of(startInclusive, LocalDate.MAX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `LocalDateRange` from a text string such as\n     * `2007-12-03/2007-12-04`, where the end date is exclusive.\n     * \n     * The string must consist of one of the following three formats:\n     * <ul>\n     * <li>a representations of an {@link LocalDate}, followed by a forward slash,\n     *  followed by a representation of a {@link LocalDate}\n     * <li>a representation of an {@link LocalDate}, followed by a forward slash,\n     *  followed by a representation of a {@link Period}\n     * <li>a representation of a {@link Period}, followed by a forward slash,\n     *  followed by a representation of an {@link LocalDate}\n     * </ul>\n     *\n     * @param {string} text - the text to parse, not null\n     * @return {LocalDateRange} the parsed range, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text) {\n        requireNonNull(text, 'text');\n        for (let i = 0; i < text.length; i++) {\n            if (text[i] === '/') {\n                const firstChar = text.charAt(0);\n                if (firstChar === 'P' || firstChar === 'p') {\n                    // period followed by date\n                    const duration = Period.parse(text.slice(0, i));\n                    const end = LocalDate.parse(text.slice(i + 1, text.length));\n                    return LocalDateRange.of(end.minus(duration), end);\n                } else {\n                    // date followed by date or period\n                    const start = LocalDate.parse(text.slice(0, i));\n                    if (i + 1 < text.length) {\n                        const c = text[i + 1];\n                        if (c === 'P' || c === 'p') {\n                            const duration = Period.parse(text.slice(i + 1, text.length));\n                            return LocalDateRange.of(start, start.plus(duration));\n                        }\n                    }\n                    const end = LocalDate.parse(text.slice(i + 1, text.length));\n                    return LocalDateRange.of(start, end);\n                }\n            }\n        }\n        throw new DateTimeParseException('LocalDateRange cannot be parsed, no forward slash found', text, 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} startInclusive - the start date, inclusive, validated not null\n     * @param {LocalDate} endExclusive - the end date, exclusive, validated not null\n     * @private\n     */\n    constructor(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, 'startInclusive');\n        requireNonNull(endExclusive, 'endExclusive');\n        requireInstance(startInclusive, LocalDate, 'startInclusive');\n        requireInstance(endExclusive, LocalDate, 'endExclusive');\n        if (endExclusive.isBefore(startInclusive)) {\n            throw new DateTimeException('End date must be on or after start date');\n        }\n        if (startInclusive.equals(MAXM1)) {\n            throw new DateTimeException('Range must not start at LocalDate.MAX.minusDays(1)');\n        }\n        if (endExclusive.equals(MINP1)) {\n            throw new DateTimeException('Range must not end at LocalDate.MIN.plusDays(1)');\n        }\n        if (endExclusive.equals(LocalDate.MIN) || startInclusive.equals(LocalDate.MAX)) {\n            throw new DateTimeException('Empty range must not be at LocalDate.MIN or LocalDate.MAX');\n        }\n        this._start = startInclusive;\n        this._end = endExclusive;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the start date of this range, inclusive.\n     * \n     * This will return `LocalDate#MIN` if the range is unbounded at the start.\n     * In this case, the range includes all dates into the far-past.\n     * \n     * This never returns `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\n     *\n     * @return {LocalDate} the start date\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * Gets the end date of this range, exclusive.\n     * \n     * This will return `LocalDate.MAX` if the range is unbounded at the end.\n     * In this case, the range includes all dates into the far-future.\n     * \n     * This never returns `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\n     *\n     * @return {LocalDate} the end date, exclusive\n     */\n    end() {\n        return this._end;\n    }\n\n    /**\n     * Gets the end date of this range, inclusive.\n     * \n     * This will return `LocalDate.MAX` if the range is unbounded at the end.\n     * In this case, the range includes all dates into the far-future.\n     * \n     * This returns the date before the end date.\n     * \n     * This never returns `LocalDate.MIN`.\n     * \n     * @return {LocalDate} the end date, inclusive\n     */\n    endInclusive() {\n        if (this.isUnboundedEnd()) {\n            return LocalDate.MAX;\n        }\n        return this._end.minusDays(1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the range is empty.\n     * \n     * An empty range occurs when the start date equals the end date.\n     * \n     * An empty range is never unbounded.\n     * \n     * @return {boolean} true if the range is empty\n     */\n    isEmpty() {\n        return this._start.equals(this._end);\n    }\n\n    /**\n     * Checks if the start of the range is unbounded.\n     * \n     * An unbounded range is never empty.\n     * \n     * @return {boolean} true if start is unbounded\n     */\n    isUnboundedStart() {\n        return this._start.equals(LocalDate.MIN);\n    }\n\n    /**\n     * Checks if the end of the range is unbounded.\n     * \n     * An unbounded range is never empty.\n     * \n     * @return {boolean} true if end is unbounded\n     */\n    isUnboundedEnd() {\n        return this._end.equals(LocalDate.MAX);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this range with the start date adjusted.\n     * \n     * This returns a new instance with the start date altered.\n     * Since `LocalDate` implements `TemporalAdjuster` any\n     * local date can simply be passed in.\n     * \n     * For example, to adjust the start to one week earlier:\n     * <pre>\n     *  range = range.withStart(date -&gt; date.minus(1, ChronoUnit.WEEKS));\n     * </pre>\n     * \n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDateRange} a copy of this range with the start date adjusted\n     * @throws {DateTimeException} if the new start date is after the current end date\n     */\n    withStart(adjuster) {\n        return LocalDateRange.of(this._start.with(adjuster), this._end);\n    }\n\n    /**\n     * Returns a copy of this range with the end date adjusted.\n     * \n     * This returns a new instance with the exclusive end date altered.\n     * Since `LocalDate` implements `TemporalAdjuster` any\n     * local date can simply be passed in.\n     * \n     * For example, to adjust the end to one week later:\n     * <pre>\n     *  range = range.withEnd(date -&gt; date.plus(1, ChronoUnit.WEEKS));\n     * </pre>\n     * \n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {LocalDateRange} a copy of this range with the end date adjusted\n     * @throws {DateTimeException} if the new end date is before the current start date\n     */\n    withEnd(adjuster) {\n        return LocalDateRange.of(this._start, this._end.with(adjuster));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this range contains the specified date.\n     * \n     * This checks if the specified date is within the bounds of this range.\n     * If this range is empty then this method always returns false.\n     * Else if this range has an unbounded start then `contains(LocalDate#MIN)` returns true.\n     * Else if this range has an unbounded end then `contains(LocalDate#MAX)` returns true.\n     * \n     * @param {LocalDate} date - the date to check for, not null\n     * @return {boolean} true if this range contains the date\n     */\n    contains(date) {\n        requireNonNull(date, 'date');\n        return this._start.compareTo(date) <= 0 && (date.compareTo(this._end) < 0 || this.isUnboundedEnd());\n    }\n\n    /**\n     * Checks if this range encloses the specified range.\n     * \n     * This checks if the bounds of the specified range are within the bounds of this range.\n     * An empty range encloses itself.\n     * \n     * @param {LocalDateRange} other - the other range to check for, not null\n     * @return {boolean} true if this range contains all dates in the other range\n     */\n    encloses(other) {\n        requireNonNull(other, 'other');\n        return this._start.compareTo(other._start) <= 0 && other._end.compareTo(this._end) <= 0;\n    }\n\n    /**\n     * Checks if this range abuts the specified range.\n     * \n     * The result is true if the end of this range is the start of the other, or vice versa.\n     * An empty range does not abut itself.\n     *\n     * @param {LocalDateRange} other - the other range, not null\n     * @return {boolean} true if this range abuts the other range\n     */\n    abuts(other) {\n        requireNonNull(other, 'other');\n        return this._end.equals(other._start) !== this._start.equals(other._end);\n    }\n\n    /**\n     * Checks if this range is connected to the specified range.\n     * \n     * The result is true if the two ranges have an enclosed range in common, even if that range is empty.\n     * An empty range is connected to itself.\n     * \n     * This is equivalent to `(overlaps(other) || abuts(other))`.\n     *\n     * @param {LocalDateRange} other - the other range, not null\n     * @return {boolean} true if this range is connected to the other range\n     */\n    isConnected(other) {\n        requireNonNull(other, 'other');\n        return this.equals(other) || (this._start.compareTo(other._end) <= 0 && other._start.compareTo(this._end) <= 0);\n    }\n\n    /**\n     * Checks if this range overlaps the specified range.\n     * \n     * The result is true if the two ranges share some part of the time-line.\n     * An empty range overlaps itself.\n     * \n     * This is equivalent to `(isConnected(other) && !abuts(other))`.\n     *\n     * @param {LocalDateRange} other - the time range to compare to, null means a zero length range now\n     * @return {boolean} true if the time ranges overlap\n     */\n    overlaps(other) {\n        requireNonNull(other, 'other');\n        return other.equals(this) || (this._start.compareTo(other._end) < 0 && other._start.compareTo(this._end) < 0);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the range that is the intersection of this range and the specified range.\n     * \n     * This finds the intersection of two ranges.\n     * This throws an exception if the two ranges are not {@linkplain #isConnected(LocalDateRange) connected}.\n     * \n     * @param {LocalDateRange} other - the other range to check for, not null\n     * @return {LocalDateRange} the range that is the intersection of the two ranges\n     * @throws {DateTimeException} if the ranges do not connect\n     */\n    intersection(other) {\n        requireNonNull(other, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Ranges do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other._start);\n        const cmpEnd = this._end.compareTo(other._end);\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return this;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return other;\n        } else {\n            const newStart = (cmpStart >= 0 ? this._start : other._start);\n            const newEnd = (cmpEnd <= 0 ? this._end : other._end);\n            return LocalDateRange.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the range that is the union of this range and the specified range.\n     * \n     * This finds the union of two ranges.\n     * This throws an exception if the two ranges are not {@linkplain #isConnected(LocalDateRange) connected}.\n     * \n     * @param {LocalDateRange} other - the other range to check for, not null\n     * @return {LocalDateRange} the range that is the union of the two ranges\n     * @throws {DateTimeException} if the ranges do not connect\n     */\n    union(other) {\n        requireNonNull(other, 'other');\n        if (this.isConnected(other) === false) {\n            throw new DateTimeException(`Ranges do not connect: ${this} and ${other}`);\n        }\n        const cmpStart = this._start.compareTo(other._start);\n        const cmpEnd = this._end.compareTo(other._end);\n        if (cmpStart >= 0 && cmpEnd <= 0) {\n            return other;\n        } else if (cmpStart <= 0 && cmpEnd >= 0) {\n            return this;\n        } else {\n            const newStart = (cmpStart >= 0 ? other._start : this._start);\n            const newEnd = (cmpEnd <= 0 ? other._end : this._end);\n            return LocalDateRange.of(newStart, newEnd);\n        }\n    }\n\n    /**\n     * Calculates the smallest range that encloses this range and the specified range.\n     * \n     * The result of this method will {@linkplain #encloses(LocalDateRange) enclose}\n     * this range and the specified range.\n     * \n     * @param {LocalDateRange} other - the other range to check for, not null\n     * @return {LocalDateRange} the range that spans the two ranges\n     */\n    span(other) {\n        requireNonNull(other, 'other');\n        const cmpStart = this._start.compareTo(other._start);\n        const cmpEnd = this._end.compareTo(other._end);\n        const newStart = (cmpStart >= 0 ? other._start : this._start);\n        const newEnd = (cmpEnd <= 0 ? other._end : this._end);\n        return LocalDateRange.of(newStart, newEnd);\n    }\n\n    /**\n     * Function overloading for {@link LocalDateRange.isAfter}\n     * - if called with `LocalDate`, {@link LocalDateRange._isAfterLocalDate} is executed,\n     * - if called with `LocalDateRange`, {@link LocalDateRange._isAfterLocalDateRange} is executed,\n     * - otherwise throws IllegalArgumentException.\n     *\n     * @param {LocalDate|LocalDateRange} localDateOrLocalDateRange\n     * @return {boolean}\n     */\n    isAfter(localDateOrLocalDateRange) {\n        if (localDateOrLocalDateRange instanceof LocalDate) {\n            return this._isAfterLocalDate(localDateOrLocalDateRange);\n        }\n        if (localDateOrLocalDateRange instanceof LocalDateRange) {\n            return this._isAfterLocalDateRange(localDateOrLocalDateRange);\n        }\n        throw new IllegalArgumentException(`localDateOrLocalDateRange must be an instance of LocalDate or LocalDateRange but is ${localDateOrLocalDateRange.constructor.name}`);\n    }\n\n    /**\n     * Function overloading for {@link LocalDateRange.isBefore}\n     * - if called with `LocalDate`, {@link LocalDateRange._isBeforeLocalDate} is executed,\n     * - if called with `LocalDateRange`, {@link LocalDateRange._isBeforeLocalDateRange} is executed,\n     * - otherwise throws IllegalArgumentException.\n     *\n     * @param {LocalDate|LocalDateRange} localDateOrLocalDateRange\n     * @return {boolean}\n     */\n    isBefore(localDateOrLocalDateRange) {\n        if (localDateOrLocalDateRange instanceof LocalDate) {\n            return this._isBeforeLocalDate(localDateOrLocalDateRange);\n        }\n        if (localDateOrLocalDateRange instanceof LocalDateRange) {\n            return this._isBeforeLocalDateRange(localDateOrLocalDateRange);\n        }\n        throw new IllegalArgumentException(`localDateOrLocalDateRange must be an instance of LocalDate or LocalDateRange but is ${localDateOrLocalDateRange.constructor.name}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this range is after the specified date.\n     * \n     * The result is true if every date in this range is after the specified date.\n     * An empty range behaves as though it is a date for comparison purposes.\n     *\n     * @param {LocalDate} date - the other date to compare to, not null\n     * @return {boolean} true if the start of this range is after the specified date\n     * @protected\n     */\n    _isAfterLocalDate(date) {\n        return this._start.compareTo(date) > 0;\n    }\n\n    /**\n     * Checks if this range is before the specified date.\n     * \n     * The result is true if every date in this range is before the specified date.\n     * An empty range behaves as though it is a date for comparison purposes.\n     *\n     * @param {LocalDate} date - the other date to compare to, not null\n     * @return {boolean} true if the start of this range is before the specified date\n     * @protected\n     */\n    _isBeforeLocalDate(date) {\n        return this._end.compareTo(date) <= 0 && this._start.compareTo(date) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this range is after the specified range.\n     * \n     * The result is true if every date in this range is after every date in the specified range.\n     * An empty range behaves as though it is a date for comparison purposes.\n     *\n     * @param {LocalDateRange} other - the other range to compare to, not null\n     * @return {boolean} true if every date in this range is after every date in the other range\n     * @protected\n     */\n    _isAfterLocalDateRange(other) {\n        return this._start.compareTo(other._end) >= 0 && !other.equals(this);\n    }\n\n    /**\n     * Checks if this range is before the specified range.\n     * \n     * The result is true if every date in this range is before every date in the specified range.\n     * An empty range behaves as though it is a date for comparison purposes.\n     *\n     * @param {LocalDateRange} range - the other range to compare to, not null\n     * @return {boolean} true if every date in this range is before every date in the other range\n     * @protected\n     */\n    _isBeforeLocalDateRange(range) {\n        return this._end.compareTo(range._start) <= 0 && !range.equals(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the length of this range in days.\n     * \n     * This returns the number of days between the start and end dates.\n     * Unbounded ranges return `Number.POSITIVE_INFINITY`.\n     *\n     * @return {number} the length in days, `Number.POSITIVE_INFINITY` if unbounded\n     */\n    lengthInDays() {\n        if (this.isUnboundedStart() || this.isUnboundedEnd()) {\n            return Number.POSITIVE_INFINITY;\n        }\n        return this._end.toEpochDay() - this._start.toEpochDay();\n    }\n\n    /**\n     * Obtains the length of this range as a period.\n     * \n     * This returns the {@link Period} between the start and end dates.\n     * Unbounded ranges throw {@link ArithmeticException}.\n     *\n     * @return {Period} the period of the range\n     * @throws {ArithmeticException} if the calculation exceeds the capacity of `Period`,\n     *   or the range is unbounded\n     */\n    toPeriod() {\n        if (this.isUnboundedStart() || this.isUnboundedEnd()) {\n            throw new ArithmeticException('Unbounded range cannot be converted to a Period');\n        }\n        return Period.between(this._start, this._end);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this range is equal to another range.\n     * \n     * Compares this `LocalDateRange` with another ensuring that the two dates are the same.\n     * Only objects of type `LocalDateRange` are compared, other types return false.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other range\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof LocalDateRange) {\n            const other = obj;\n            return this._start.equals(other._start) && this._end.equals(other._end);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this range.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._start.hashCode() ^ this._end.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this range as a `String`, such as `2007-12-03/2007-12-04`.\n     * \n     * The output will be the ISO-8601 format formed by combining the\n     * `toString()` methods of the two dates, separated by a forward slash.\n     *\n     * @return {string} a string representation of this date, not null\n     */\n    toString() {\n        return `${this._start.toString()}/${this._end.toString()}`;\n    }\n}\n\nexport function _init() {\n    /**\n     * A range over the whole time-line.\n     */\n    LocalDateRange.ALL = new LocalDateRange(LocalDate.MIN, LocalDate.MAX);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/LocalDateRange.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1807,
    "kind": "variable",
    "name": "MINP1",
    "memberof": "packages/extra/src/LocalDateRange.js",
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~MINP1",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/LocalDateRange.js",
    "importStyle": null,
    "description": "The day after the MIN date.",
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1808,
    "kind": "variable",
    "name": "MAXM1",
    "memberof": "packages/extra/src/LocalDateRange.js",
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~MAXM1",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/LocalDateRange.js",
    "importStyle": null,
    "description": "The day before the MAX date.",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1809,
    "kind": "class",
    "name": "LocalDateRange",
    "memberof": "packages/extra/src/LocalDateRange.js",
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/LocalDateRange.js",
    "importStyle": "{LocalDateRange}",
    "description": "A range of local dates.\n\nA `LocalDateRange` represents a range of dates, from a start date to an end date.\nInstances can be constructed from either a half-open or a closed range of dates.\nInternally, the class stores the start and end dates, with the start inclusive and the end exclusive.\nThe end date is always greater than or equal to the start date.\n\nThe constants `LocalDate.MIN` and `LocalDate.MAX` can be used\nto indicate an unbounded far-past or far-future. Note that there is no difference\nbetween a half-open and a closed range when the end is `LocalDate.MAX`.\nEmpty ranges are allowed.\n\nNo range can end at `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\nNo range can start at `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\nNo empty range can exist at `LocalDate.MIN` or `LocalDate.MAX`.\n\nDate ranges are not comparable. To compare the length of two ranges, it is\ngenerally recommended to compare the number of days they contain.",
    "lineNumber": 42,
    "interface": false
  },
  {
    "__docId__": 1810,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.of",
    "access": "public",
    "description": "function overloading for {@link LocalDateRange.of}\n- if called with `LocalDate` and `LocalDate`, {@link LocalDateRange._ofLocalDateLocalDate} is executed,\n- if called with `LocalDate` and `Period`, {@link LocalDateRange._ofLocalDatePeriod} is executed,\n- otherwise throws IllegalArgumentException.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "LocalDate",
          "Period"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusiveOrPeriod",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1811,
    "kind": "method",
    "name": "_ofLocalDateLocalDate",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange._ofLocalDateLocalDate",
    "access": "protected",
    "description": "Obtains a half-open range of dates, including the start and excluding the end.\n\nThe range includes the start date and excludes the end date, unless the end is `LocalDate.MAX`.\nThe end date must be equal to or after the start date.\nThis definition permits an empty range located at a specific date.\n\nThe constants `LocalDate.MIN` and `LocalDate.MAX` can be used\nto indicate an unbounded far-past or far-future.\n\nThe start inclusive date must not be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\nThe end inclusive date must not be `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.\nNo empty range can exist at `LocalDate.MIN` or `LocalDate.MAX`.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the inclusive start date, not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the exclusive end date, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the half-open range, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end is before the start,\n  or the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`,\n  or the end date is `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`"
      }
    ]
  },
  {
    "__docId__": 1812,
    "kind": "method",
    "name": "_ofLocalDatePeriod",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange._ofLocalDatePeriod",
    "access": "protected",
    "description": "Obtains an instance of `LocalDateRange` from the start and a period.\n\nThe end date is calculated as the start plus the duration.\nThe period must not be negative.\n\nThe constant `LocalDate.MIN` can be used to indicate an unbounded far-past.\n\nThe period must not be zero or one day when the start date is `LocalDate.MIN`.",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the inclusive start date, not null"
      },
      {
        "nullable": null,
        "types": [
          "Period"
        ],
        "spread": false,
        "optional": false,
        "name": "period",
        "description": "the period from the start to the end, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end is before the start,\n or if the period addition cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs when adding the period"
      }
    ]
  },
  {
    "__docId__": 1813,
    "kind": "method",
    "name": "ofClosed",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.ofClosed",
    "access": "public",
    "description": "Obtains a closed range of dates, including the start and end.\n\nThe range includes the start date and the end date.\nThe end date must be equal to or after the start date.\n\nThe constants `LocalDate.MIN` and `LocalDate.MAX` can be used\nto indicate an unbounded far-past or far-future. In addition, an end date of\n`LocalDate.MAX.minusDays(1)` will also create an unbounded far-future range.\n\nThe start inclusive date must not be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.\nThe end inclusive date must not be `LocalDate.MIN`.",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the inclusive start date, not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "endInclusive",
        "description": "the inclusive end date, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the closed range"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end is before the start,\n  or the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`,\n  or the end date is `LocalDate.MIN`"
      }
    ]
  },
  {
    "__docId__": 1814,
    "kind": "method",
    "name": "ofEmpty",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.ofEmpty",
    "access": "public",
    "description": "Obtains an empty date range located at the specified date.\n\nThe empty range has zero length and contains no other dates or ranges.\nAn empty range cannot be located at `LocalDate.MIN`, `LocalDate.MIN.plusDays(1)`,\n`LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date where the empty range is located, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the empty range, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the date is `LocalDate.MIN`, `LocalDate.MIN.plusDays(1)`,\n  `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`"
      }
    ]
  },
  {
    "__docId__": 1815,
    "kind": "method",
    "name": "ofUnbounded",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.ofUnbounded",
    "access": "public",
    "description": "Obtains a range that is unbounded at the start and end.",
    "lineNumber": 185,
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range, with an unbounded start and unbounded end"
    },
    "params": []
  },
  {
    "__docId__": 1816,
    "kind": "method",
    "name": "ofUnboundedStart",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.ofUnboundedStart",
    "access": "public",
    "description": "Obtains a range up to, but not including, the specified end date.\n\nThe range includes all dates from the unbounded start, denoted by `LocalDate.MIN`, to the end date.\nThe end date is exclusive and cannot be `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the exclusive end date, `LocalDate.MAX` treated as unbounded, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range, with an unbounded start"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the end date is `LocalDate.MIN` or  `LocalDate.MIN.plusDays(1)`"
      }
    ]
  },
  {
    "__docId__": 1817,
    "kind": "method",
    "name": "ofUnboundedEnd",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.ofUnboundedEnd",
    "access": "public",
    "description": "Obtains a range from and including the specified start date.\n\nThe range includes all dates from the start date to the unbounded end, denoted by `LocalDate.MAX`.\nThe start date is inclusive and cannot be `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the inclusive start date, `LocalDate.MIN` treated as unbounded, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range, with an unbounded end"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the start date is `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`"
      }
    ]
  },
  {
    "__docId__": 1818,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange.parse",
    "access": "public",
    "description": "Obtains an instance of `LocalDateRange` from a text string such as\n`2007-12-03/2007-12-04`, where the end date is exclusive.\n\nThe string must consist of one of the following three formats:\n<ul>\n<li>a representations of an {@link LocalDate}, followed by a forward slash,\n followed by a representation of a {@link LocalDate}\n<li>a representation of an {@link LocalDate}, followed by a forward slash,\n followed by a representation of a {@link Period}\n<li>a representation of a {@link Period}, followed by a forward slash,\n followed by a representation of an {@link LocalDate}\n</ul>",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the parsed range, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 1819,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 274,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "startInclusive",
        "description": "the start date, inclusive, validated not null"
      },
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date, exclusive, validated not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1820,
    "kind": "member",
    "name": "_start",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_start",
    "access": "private",
    "description": null,
    "lineNumber": 291,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1821,
    "kind": "member",
    "name": "_end",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_end",
    "access": "private",
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1822,
    "kind": "method",
    "name": "start",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#start",
    "access": "public",
    "description": "Gets the start date of this range, inclusive.\n\nThis will return `LocalDate#MIN` if the range is unbounded at the start.\nIn this case, the range includes all dates into the far-past.\n\nThis never returns `LocalDate.MAX` or `LocalDate.MAX.minusDays(1)`.",
    "lineNumber": 306,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the start date"
    },
    "params": []
  },
  {
    "__docId__": 1823,
    "kind": "method",
    "name": "end",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#end",
    "access": "public",
    "description": "Gets the end date of this range, exclusive.\n\nThis will return `LocalDate.MAX` if the range is unbounded at the end.\nIn this case, the range includes all dates into the far-future.\n\nThis never returns `LocalDate.MIN` or `LocalDate.MIN.plusDays(1)`.",
    "lineNumber": 320,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the end date, exclusive"
    },
    "params": []
  },
  {
    "__docId__": 1824,
    "kind": "method",
    "name": "endInclusive",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#endInclusive",
    "access": "public",
    "description": "Gets the end date of this range, inclusive.\n\nThis will return `LocalDate.MAX` if the range is unbounded at the end.\nIn this case, the range includes all dates into the far-future.\n\nThis returns the date before the end date.\n\nThis never returns `LocalDate.MIN`.",
    "lineNumber": 336,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the end date, inclusive"
    },
    "params": []
  },
  {
    "__docId__": 1825,
    "kind": "method",
    "name": "isEmpty",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isEmpty",
    "access": "public",
    "description": "Checks if the range is empty.\n\nAn empty range occurs when the start date equals the end date.\n\nAn empty range is never unbounded.",
    "lineNumber": 353,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the range is empty"
    },
    "params": []
  },
  {
    "__docId__": 1826,
    "kind": "method",
    "name": "isUnboundedStart",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isUnboundedStart",
    "access": "public",
    "description": "Checks if the start of the range is unbounded.\n\nAn unbounded range is never empty.",
    "lineNumber": 364,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if start is unbounded"
    },
    "params": []
  },
  {
    "__docId__": 1827,
    "kind": "method",
    "name": "isUnboundedEnd",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isUnboundedEnd",
    "access": "public",
    "description": "Checks if the end of the range is unbounded.\n\nAn unbounded range is never empty.",
    "lineNumber": 375,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if end is unbounded"
    },
    "params": []
  },
  {
    "__docId__": 1828,
    "kind": "method",
    "name": "withStart",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#withStart",
    "access": "public",
    "description": "Returns a copy of this range with the start date adjusted.\n\nThis returns a new instance with the start date altered.\nSince `LocalDate` implements `TemporalAdjuster` any\nlocal date can simply be passed in.\n\nFor example, to adjust the start to one week earlier:\n<pre>\n range = range.withStart(date -&gt; date.minus(1, ChronoUnit.WEEKS));\n</pre>",
    "lineNumber": 396,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "a copy of this range with the start date adjusted"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the new start date is after the current end date"
      }
    ]
  },
  {
    "__docId__": 1829,
    "kind": "method",
    "name": "withEnd",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#withEnd",
    "access": "public",
    "description": "Returns a copy of this range with the end date adjusted.\n\nThis returns a new instance with the exclusive end date altered.\nSince `LocalDate` implements `TemporalAdjuster` any\nlocal date can simply be passed in.\n\nFor example, to adjust the end to one week later:\n<pre>\n range = range.withEnd(date -&gt; date.plus(1, ChronoUnit.WEEKS));\n</pre>",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "a copy of this range with the end date adjusted"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the new end date is before the current start date"
      }
    ]
  },
  {
    "__docId__": 1830,
    "kind": "method",
    "name": "contains",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#contains",
    "access": "public",
    "description": "Checks if this range contains the specified date.\n\nThis checks if the specified date is within the bounds of this range.\nIf this range is empty then this method always returns false.\nElse if this range has an unbounded start then `contains(LocalDate#MIN)` returns true.\nElse if this range has an unbounded end then `contains(LocalDate#MAX)` returns true.",
    "lineNumber": 432,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this range contains the date"
    }
  },
  {
    "__docId__": 1831,
    "kind": "method",
    "name": "encloses",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#encloses",
    "access": "public",
    "description": "Checks if this range encloses the specified range.\n\nThis checks if the bounds of the specified range are within the bounds of this range.\nAn empty range encloses itself.",
    "lineNumber": 446,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this range contains all dates in the other range"
    }
  },
  {
    "__docId__": 1832,
    "kind": "method",
    "name": "abuts",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#abuts",
    "access": "public",
    "description": "Checks if this range abuts the specified range.\n\nThe result is true if the end of this range is the start of the other, or vice versa.\nAn empty range does not abut itself.",
    "lineNumber": 460,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this range abuts the other range"
    }
  },
  {
    "__docId__": 1833,
    "kind": "method",
    "name": "isConnected",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isConnected",
    "access": "public",
    "description": "Checks if this range is connected to the specified range.\n\nThe result is true if the two ranges have an enclosed range in common, even if that range is empty.\nAn empty range is connected to itself.\n\nThis is equivalent to `(overlaps(other) || abuts(other))`.",
    "lineNumber": 476,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this range is connected to the other range"
    }
  },
  {
    "__docId__": 1834,
    "kind": "method",
    "name": "overlaps",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#overlaps",
    "access": "public",
    "description": "Checks if this range overlaps the specified range.\n\nThe result is true if the two ranges share some part of the time-line.\nAn empty range overlaps itself.\n\nThis is equivalent to `(isConnected(other) && !abuts(other))`.",
    "lineNumber": 492,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the time range to compare to, null means a zero length range now"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the time ranges overlap"
    }
  },
  {
    "__docId__": 1835,
    "kind": "method",
    "name": "intersection",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#intersection",
    "access": "public",
    "description": "Calculates the range that is the intersection of this range and the specified range.\n\nThis finds the intersection of two ranges.\nThis throws an exception if the two ranges are not {@linkplain #isConnected(LocalDateRange) connected}.",
    "lineNumber": 508,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range that is the intersection of the two ranges"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the ranges do not connect"
      }
    ]
  },
  {
    "__docId__": 1836,
    "kind": "method",
    "name": "union",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#union",
    "access": "public",
    "description": "Calculates the range that is the union of this range and the specified range.\n\nThis finds the union of two ranges.\nThis throws an exception if the two ranges are not {@linkplain #isConnected(LocalDateRange) connected}.",
    "lineNumber": 536,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range that is the union of the two ranges"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the ranges do not connect"
      }
    ]
  },
  {
    "__docId__": 1837,
    "kind": "method",
    "name": "span",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#span",
    "access": "public",
    "description": "Calculates the smallest range that encloses this range and the specified range.\n\nThe result of this method will {@linkplain #encloses(LocalDateRange) enclose}\nthis range and the specified range.",
    "lineNumber": 563,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range to check for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDateRange"
      ],
      "spread": false,
      "description": "the range that spans the two ranges"
    }
  },
  {
    "__docId__": 1838,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isAfter",
    "access": "public",
    "description": "Function overloading for {@link LocalDateRange.isAfter}\n- if called with `LocalDate`, {@link LocalDateRange._isAfterLocalDate} is executed,\n- if called with `LocalDateRange`, {@link LocalDateRange._isAfterLocalDateRange} is executed,\n- otherwise throws IllegalArgumentException.",
    "lineNumber": 581,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate",
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateOrLocalDateRange",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1839,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#isBefore",
    "access": "public",
    "description": "Function overloading for {@link LocalDateRange.isBefore}\n- if called with `LocalDate`, {@link LocalDateRange._isBeforeLocalDate} is executed,\n- if called with `LocalDateRange`, {@link LocalDateRange._isBeforeLocalDateRange} is executed,\n- otherwise throws IllegalArgumentException.",
    "lineNumber": 600,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate",
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateOrLocalDateRange",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1840,
    "kind": "method",
    "name": "_isAfterLocalDate",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_isAfterLocalDate",
    "access": "protected",
    "description": "Checks if this range is after the specified date.\n\nThe result is true if every date in this range is after the specified date.\nAn empty range behaves as though it is a date for comparison purposes.",
    "lineNumber": 621,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the start of this range is after the specified date"
    }
  },
  {
    "__docId__": 1841,
    "kind": "method",
    "name": "_isBeforeLocalDate",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_isBeforeLocalDate",
    "access": "protected",
    "description": "Checks if this range is before the specified date.\n\nThe result is true if every date in this range is before the specified date.\nAn empty range behaves as though it is a date for comparison purposes.",
    "lineNumber": 635,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the start of this range is before the specified date"
    }
  },
  {
    "__docId__": 1842,
    "kind": "method",
    "name": "_isAfterLocalDateRange",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_isAfterLocalDateRange",
    "access": "protected",
    "description": "Checks if this range is after the specified range.\n\nThe result is true if every date in this range is after every date in the specified range.\nAn empty range behaves as though it is a date for comparison purposes.",
    "lineNumber": 650,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other range to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if every date in this range is after every date in the other range"
    }
  },
  {
    "__docId__": 1843,
    "kind": "method",
    "name": "_isBeforeLocalDateRange",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#_isBeforeLocalDateRange",
    "access": "protected",
    "description": "Checks if this range is before the specified range.\n\nThe result is true if every date in this range is before every date in the specified range.\nAn empty range behaves as though it is a date for comparison purposes.",
    "lineNumber": 664,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateRange"
        ],
        "spread": false,
        "optional": false,
        "name": "range",
        "description": "the other range to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if every date in this range is before every date in the other range"
    }
  },
  {
    "__docId__": 1844,
    "kind": "method",
    "name": "lengthInDays",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#lengthInDays",
    "access": "public",
    "description": "Obtains the length of this range in days.\n\nThis returns the number of days between the start and end dates.\nUnbounded ranges return `Number.POSITIVE_INFINITY`.",
    "lineNumber": 677,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length in days, `Number.POSITIVE_INFINITY` if unbounded"
    },
    "params": []
  },
  {
    "__docId__": 1845,
    "kind": "method",
    "name": "toPeriod",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#toPeriod",
    "access": "public",
    "description": "Obtains the length of this range as a period.\n\nThis returns the {@link Period} between the start and end dates.\nUnbounded ranges throw {@link ArithmeticException}.",
    "lineNumber": 694,
    "return": {
      "nullable": null,
      "types": [
        "Period"
      ],
      "spread": false,
      "description": "the period of the range"
    },
    "throws": [
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if the calculation exceeds the capacity of `Period`,\n  or the range is unbounded"
      }
    ],
    "params": []
  },
  {
    "__docId__": 1846,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#equals",
    "access": "public",
    "description": "Checks if this range is equal to another range.\n\nCompares this `LocalDateRange` with another ensuring that the two dates are the same.\nOnly objects of type `LocalDateRange` are compared, other types return false.",
    "lineNumber": 711,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other range"
    }
  },
  {
    "__docId__": 1847,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#hashCode",
    "access": "public",
    "description": "A hash code for this range.",
    "lineNumber": 727,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1848,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/LocalDateRange.js~LocalDateRange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/LocalDateRange.js~LocalDateRange#toString",
    "access": "public",
    "description": "Outputs this range as a `String`, such as `2007-12-03/2007-12-04`.\n\nThe output will be the ISO-8601 format formed by combining the\n`toString()` methods of the two dates, separated by a forward slash.",
    "lineNumber": 740,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this date, not null"
    },
    "params": []
  },
  {
    "__docId__": 1849,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/LocalDateRange.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/LocalDateRange.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/LocalDateRange.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 745,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1850,
    "kind": "file",
    "name": "packages/extra/src/OffsetDate.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField, ChronoUnit, Clock, DateTimeException, DateTimeFormatter, IllegalArgumentException, IsoChronology, LocalDate, OffsetDateTime, Temporal, TemporalField, TemporalQueries, TemporalQuery, TemporalUnit, ZoneId, ZoneOffset } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireInstance, requireNonNull } from './assert';\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * The number of seconds per day.\n */\nconst SECONDS_PER_DAY = 86400;\n\n/**\n * A date with an offset from UTC/Greenwich in the ISO-8601 calendar system,\n * such as `2007-12-03+01:00`.\n * \n * `OffsetDate` is an immutable date-time object that represents a date, often viewed\n * as year-month-day-offset. This object can also access other date fields such as\n * day-of-year, day-of-week and week-of-year.\n * \n * This class does not store or represent a time.\n * For example, the value '2nd October 2007 +02:00' can be stored\n * in an `OffsetDate`.\n *\n */\nexport class OffsetDate extends Temporal {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link OffsetDate.now}\n     * - if called with 0 argument {@link OffsetDate._now0} is executed,\n     * - if called with 1 argument and first argument is an instance of ZoneId, then {@link OffsetDate._nowZoneId} is executed,\n     * - otherwise {@link OffsetDate._nowClock} is executed\n     *\n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @return {YearQuarter}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return OffsetDate._now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return OffsetDate._nowZoneId(zoneIdOrClock);\n        } else {\n            return OffsetDate._nowClock(zoneIdOrClock);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current date from the system clock in the default time-zone.\n     * \n     * This will query the {@link Clock.systemDefaultZone} system clock in the default\n     * time-zone to obtain the current date.\n     * The offset will be calculated from the time-zone in the clock.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {OffsetDate} the current date using the system clock, not null\n     * @protected\n     */\n    static _now0() {\n        return OffsetDate.now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current date from the system clock in the specified time-zone.\n     * \n     * This will query the {@link Clock.system} system clock to obtain the current date.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * The offset will be calculated from the specified time-zone.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone - the zone ID to use, not null\n     * @return {OffsetDate} the current date using the system clock, not null\n     * @protected\n     */\n    static _nowZoneId(zone) {\n        return OffsetDate.now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current date from the specified clock.\n     * \n     * This will query the specified clock to obtain the current date - today.\n     * The offset will be calculated from the time-zone in the clock.\n     * \n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock} dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, not null\n     * @return {OffsetDate} the current date, not null\n     * @protected\n     */\n    static _nowClock(clock) {\n        requireNonNull(clock, 'clock');\n        const now = clock.instant();  // called once\n        return OffsetDate.ofInstant(now, clock.zone().rules().offset(now));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link OffsetDate.of}\n     * - if called with 2 arguments {@link OffsetDate._ofLocalDateZoneOffset} is executed,\n     * - if called with 4 agruments {@link OffsetDate._ofIntIntIntZoneOffset} is executed,\n     * - otherwise throws IllegalArgumentException.\n     *\n     * @return {YearQuarter}\n     */\n    static of() {\n        switch (arguments.length) {\n            case 2: return OffsetDate._ofLocalDateZoneOffset(...arguments);\n            case 4: return OffsetDate._ofIntIntIntZoneOffset(...arguments);\n            default: throw new IllegalArgumentException('Illegal number of arguments');\n        }\n    }\n\n    /**\n     * Obtains an instance of `OffsetDate` from a local date and an offset.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @return {OffsetDate} the offset date, not null\n     * @protected\n     */\n    static _ofLocalDateZoneOffset(date, offset) {\n        return new OffsetDate(date, offset);\n    }\n\n    /**\n     * Obtains an instance of `OffsetDate` from a year, month, day\n     * and offset.\n     * \n     * This creates an offset date with the four specified fields.\n     * \n     * This method exists primarily for writing test cases.\n     * Non test-code will typically use other methods to create an offset time.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} month - the month-of-year to represent, from 1 (January) to 12 (December)\n     * @param {number} dayOfMonth - the day-of-month to represent, from 1 to 31\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @return {OffsetDate} the offset date, not null\n     * @throws {DateTimeException} if the value of any field is out of range, or\n     *  if the day-of-month is invalid for the month-year\n     * @protected\n     */\n    static _ofIntIntIntZoneOffset(year, month, dayOfMonth, offset) {\n        const d = LocalDate.of(year, month, dayOfMonth);\n        return new OffsetDate(d, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `OffsetDate` from an `Instant` and zone ID.\n     * \n     * This creates an offset date with the same instant as midnight at the\n     * start of day of the instant specified.\n     * Finding the offset from UTC/Greenwich is simple as there is only one valid\n     * offset for each instant.\n     *\n     * @param {Instant} instant - the instant to create the time from, not null\n     * @param {ZoneId} zone - the time-zone, which may be an offset, not null\n     * @return {OffsetDate} the offset time, not null\n     */\n    static ofInstant(instant, zone) {\n        requireNonNull(instant, 'instant');\n        requireNonNull(zone, 'zone');\n        const rules = zone.rules();\n        const offset = rules.offset(instant);\n        const epochSec = instant.epochSecond() + offset.totalSeconds();  // overflow caught later\n        const epochDay = MathUtil.floorDiv(epochSec, SECONDS_PER_DAY);\n        const date = LocalDate.ofEpochDay(epochDay);\n        return new OffsetDate(date, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `OffsetDate` from a temporal object.\n     * \n     * A `TemporalAccessor` represents some form of date and time information.\n     * This factory converts the arbitrary temporal object to an instance of `OffsetDate`.\n     * \n     * The conversion extracts and combines `LocalDate` and `ZoneOffset`.\n     * \n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, `OffsetDate.FROM`.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {OffsetDate} the offset date, not null\n     * @throws {DateTimeException} if unable to convert to an `OffsetDate`\n     */\n    static from(temporal) {\n        if (temporal instanceof OffsetDate) {\n            return temporal;\n        }\n        requireNonNull(temporal, 'temporal');\n        try {\n            const date = LocalDate.from(temporal);\n            const offset = ZoneOffset.from(temporal);\n            return new OffsetDate(date, offset);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain OffsetDate from TemporalAccessor: ${temporal.constructor.name}`, ex);\n        }\n    }\n\n    /**\n     * Obtains an instance of `OffsetDate` from a text string using a specific formatter.\n     * \n     * The text is parsed using the formatter, returning a date.\n     *\n     * @param {CharSequence} text - the text to parse, not null\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {OffsetDate} the parsed offset date, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = DateTimeFormatter.ISO_OFFSET_DATE) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.parse(text, OffsetDate.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {LocalDate} date - the local date, not null\n     * @param {ZoneOffset} offset - the zone offset, not null\n     * @private\n     */\n    constructor(date, offset) {\n        super();\n        this._date = requireNonNull(date, 'date');\n        this._offset = requireNonNull(offset, 'offset');\n    }\n\n    /**\n     * Returns a new date based on this one, returning `this` where possible.\n     *\n     * @param {LocalDate} date - the date to create with, not null\n     * @param {ZoneOffset} offset - the zone offset to create with, not null\n     * @private\n     */\n    _with(date, offset) {\n        if (this._date === date && this._offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDate(date, offset);\n    }\n\n    /**\n     * function overloading for {@link OffsetDate.isSupported}\n     * - if called with an instance of {@link TemporalField}, then {@link OffsetDate._isSupportedField} is executed,\n     * - if called with an instance of {@link TemporalUnit}, then {@link OffsetDate._isSupportedUnit} is executed,\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit\n     * @return {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof TemporalField) {\n            return this._isSupportedField(fieldOrUnit);\n        }\n        if (fieldOrUnit instanceof TemporalUnit) {\n            return this._isSupportedUnit(fieldOrUnit);\n        }\n        if (fieldOrUnit == null) {\n            return false;\n        }\n        throw new IllegalArgumentException(`fieldOrUnit must be an instance of TemporalField or TemporalUnit, but is ${fieldOrUnit.constructor.name}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \n     * This checks if this date can be queried for the specified field.\n     * If false, then calling the {@link OffsetDate.range},\n     * {@link OffsetDate.get} and {@link OffsetDate.with}\n     * methods will throw an exception.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     * \n     * - `DAY_OF_WEEK`\n     * - `ALIGNED_DAY_OF_WEEK_IN_MONTH`\n     * - `ALIGNED_DAY_OF_WEEK_IN_YEAR`\n     * - `DAY_OF_MONTH`\n     * - `DAY_OF_YEAR`\n     * - `EPOCH_DAY`\n     * - `ALIGNED_WEEK_OF_MONTH`\n     * - `ALIGNED_WEEK_OF_YEAR`\n     * - `MONTH_OF_YEAR`\n     * - `PROLEPTIC_MONTH`\n     * - `YEAR_OF_ERA`\n     * - `YEAR`\n     * - `ERA`\n     * - `OFFSET_SECONDS`\n     * \n     * All other `ChronoField` instances will return false.\n     * \n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this date, false if not\n     * @protected\n     */\n    _isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field.isDateBased() || field === ChronoField.OFFSET_SECONDS;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \n     * This checks if the specified unit can be added to, or subtracted from, this date.\n     * If false, then calling the {@link OffsetDate.plus(long, TemporalUnit)} and\n     * {@link OffsetDate.minus(long, TemporalUnit) minus} methods will throw an exception.\n     * \n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     * <ul>\n     * - `DAYS`\n     * - `WEEKS`\n     * - `MONTHS`\n     * - `YEARS`\n     * - `DECADES`\n     * - `CENTURIES`\n     * - `MILLENNIA`\n     * - `ERAS`\n     * </ul>\n     * All other `ChronoUnit` instances will return false.\n     * \n     * If the unit is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`\n     * passing `this` as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param {TemporalUnit} unit - the unit to check, null returns false\n     * @return {boolean} true if the unit can be added/subtracted, false if not\n     * @protected\n     */\n    _isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit.isDateBased();\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \n     * The range object expresses the minimum and maximum valid values for a field.\n     * This date is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link OffsetDate.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     * \n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._date.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as an `int`.\n     * \n     * This queries this date for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link OffsetDate.isSupported} supported fields will return valid\n     * values based on this date, except `EPOCH_DAY` and `PROLEPTIC_MONTH`\n     * which are too large to fit in an `int` and throw a `DateTimeException`.\n     * All other `ChronoField` instances will throw a `DateTimeException`.\n     * \n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *  the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *  the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this date as a `long`.\n     * \n     * This queries this date for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link OffsetDate.isSupported} supported fields will return valid\n     * values based on this date.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     * \n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return this.offset().totalSeconds();\n            }\n            return this._date.getLong(field);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the zone offset, such as '+01:00'.\n     * \n     * This is the offset of the local date from UTC/Greenwich.\n     *\n     * @return {ZoneOffset} the zone offset, not null\n     */\n    offset() {\n        return this._offset;\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified offset ensuring\n     * that the result has the same local date.\n     * \n     * This method returns an object with the same `LocalDate` and the specified `ZoneOffset`.\n     * No calculation is needed or performed.\n     * For example, if this time represents `2007-12-03+02:00` and the offset specified is\n     * `+03:00`, then this method will return `2007-12-03+03:00`.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {ZoneOffset} offset - the zone offset to change to, not null\n     * @return {OffsetDate} an `OffsetDate` based on this date with the requested offset, not null\n     */\n    withOffsetSameLocal(offset) {\n        requireNonNull(offset, 'offset');\n        return this._with(this._date, offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the `LocalDate` part of this date.\n     * \n     * This returns a `LocalDate` with the same year, month and day\n     * as this date.\n     *\n     * @return {LocalDate} the date part of this date, not null\n     */\n    toLocalDate() {\n        return this._date;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     * \n     * This method returns the primitive `int` value for the year.\n     * \n     * The year returned by this method is proleptic as per `get(YEAR)`.\n     * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._date.year();\n    }\n\n    /**\n     * Gets the month-of-year field from 1 to 12.\n     * \n     * This method returns the month as an `int` from 1 to 12.\n     * Application code is frequently clearer if the enum {@link Month}\n     * is used by calling {@link OffsetDate.month}.\n     *\n     * @return {number} the month-of-year, from 1 to 12\n     * @see OffsetDate.month()\n     */\n    monthValue() {\n        return this._date.monthValue();\n    }\n\n    /**\n     * Gets the month-of-year field using the `Month` enum.\n     * \n     * This method returns the enum {@link Month} for the month.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link Month.value} int value.\n     *\n     * @return {Month} the month-of-year, not null\n     * @see OffsetDate.monthValue()\n     */\n    month() {\n        return this._date.month();\n    }\n\n    /**\n     * Gets the day-of-month field.\n     * \n     * This method returns the primitive `int` value for the day-of-month.\n     *\n     * @return {number} the day-of-month, from 1 to 31\n     */\n    dayOfMonth() {\n        return this._date.dayOfMonth();\n    }\n\n    /**\n     * Gets the day-of-year field.\n     * \n     * This method returns the primitive `int` value for the day-of-year.\n     *\n     * @return {number} the day-of-year, from 1 to 365, or 366 in a leap year\n     */\n    dayOfYear() {\n        return this._date.dayOfYear();\n    }\n\n    /**\n     * Gets the day-of-week field, which is an enum `DayOfWeek`.\n     * \n     * This method returns the enum {@link DayOfWeek} for the day-of-week.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link DayOfWeek.value} int value.\n     * \n     * Additional information can be obtained from the `DayOfWeek`.\n     * This includes textual names of the values.\n     *\n     * @return {DayOfWeek} the day-of-week, not null\n     */\n    dayOfWeek() {\n        return this._date.dayOfWeek();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this date.\n     * \n     * This returns an `OffsetDate` based on this one, with the date adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in {@link TemporalAdjusters}.\n     * These include finding the 'last day of the month' and 'next Wednesday'.\n     * Key date-time classes also implement the `TemporalAdjuster` interface,\n     * such as {@link Month} and {@link MonthDay}.\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * \n     * For example this code returns a date on the last day of July:\n     * <pre>\n     *  import static java.time.Month.*;\n     *  import static java.time.temporal.TemporalAdjusters.*;\n     *\n     *  result = offsetDate.with(JULY).with(lastDayOfMonth());\n     * </pre>\n     * \n     * The classes {@link LocalDate} and {@link ZoneOffset} implement `TemporalAdjuster`,\n     * thus this method can be used to change the date or offset:\n     * <pre>\n     *  result = offsetDate.with(date);\n     *  result = offsetDate.with(offset);\n     * </pre>\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster.adjustInto} method on the\n     * specified adjuster passing `this` as the argument.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {OffsetDate} an `OffsetDate` based on `this` with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof LocalDate) {\n            return this._with(adjuster, this._offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._with(this._date, adjuster);\n        } else if (adjuster instanceof OffsetDate) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this date with the specified field set to a new value.\n     * \n     * This returns an `OffsetDate` based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year, month or day-of-month.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \n     * In some cases, changing the specified field can cause the resulting date to become invalid,\n     * such as changing the month from 31st January to February would make the day-of-month invalid.\n     * In cases like this, the field is responsible for resolving the date. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     * \n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * \n     * The `OFFSET_SECONDS` field will return a date with the specified offset.\n     * The local date is unaltered. If the new offset value is outside the valid range\n     * then a `DateTimeException` will be thrown.\n     * \n     * The other {@link OffsetDate.isSupported} supported fields will behave as per\n     * the matching method on {@link LocalDate.with} LocalDate.\n     * In this case, the offset is not part of the calculation and will be unchanged.\n     * \n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     * \n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {OffsetDate} an `OffsetDate` based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                const f = field;\n                return this._with(this._date, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n            }\n            return this._with(this._date.with(field, newValue), this._offset);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this `OffsetDate` with the year altered.\n     * \n     * The offset does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {OffsetDate} year - the year to set in the result, from MIN_YEAR to MAX_YEAR\n     * @return {number} an `OffsetDate` based on this date with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        return this._with(this._date.withYear(year), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the month-of-year altered.\n     * \n     * The offset does not affect the calculation and will be the same in the result.\n     * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} month - the month-of-year to set in the result, from 1 (January) to 12 (December)\n     * @return {OffsetDate} an `OffsetDate` based on this date with the requested month, not null\n     * @throws {DateTimeException} if the month-of-year value is invalid\n     */\n    withMonth(month) {\n        return this._with(this._date.withMonth(month), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the day-of-month altered.\n     * \n     * If the resulting date is invalid, an exception is thrown.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfMonth - the day-of-month to set in the result, from 1 to 28-31\n     * @return {OffsetDate} an `OffsetDate` based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-month value is invalid,\n     *  or if the day-of-month is invalid for the month-year\n     */\n    withDayOfMonth(dayOfMonth) {\n        return this._with(this._date.withDayOfMonth(dayOfMonth), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the day-of-year altered.\n     * \n     * If the resulting date is invalid, an exception is thrown.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} dayOfYear - the day-of-year to set in the result, from 1 to 365-366\n     * @return {OffsetDate} an `OffsetDate` based on this date with the requested day, not null\n     * @throws {DateTimeException} if the day-of-year value is invalid,\n     *  or if the day-of-year is invalid for the year\n     */\n    withDayOfYear(dayOfYear) {\n        return this._with(this._date.withDayOfYear(dayOfYear), this._offset);\n    }\n\n    /**\n     * Returns a copy of this date with the specified amount added.\n     * \n     * This returns an `OffsetDate` based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoUnit} then the addition is implemented by\n     * {@link LocalDate.plus}.\n     * The offset is not part of the calculation and will be unchanged in the result.\n     * \n     * If the field is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`\n     * passing `this` as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the amount to add, not null\n     * @return {OffsetDate} an `OffsetDate` based on this date with the specified amount added, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            return this._with(this._date.plus(amountToAdd, unit), this._offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of years added.\n     * \n     * This uses {@link LocalDate.plusYears} to add the years.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to add, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusYears(years) {\n        return this._with(this._date.plusYears(years), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of months added.\n     * \n     * This uses {@link LocalDate.plusMonths} to add the months.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to add, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the months added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusMonths(months) {\n        return this._with(this._date.plusMonths(months), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of weeks added.\n     * \n     * This uses {@link LocalDate.plusWeeks} to add the weeks.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to add, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the weeks added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusWeeks(weeks) {\n        return this._with(this._date.plusWeeks(weeks), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of days added.\n     * \n     * This uses {@link LocalDate.plusDays)} to add the days.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to add, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the days added, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    plusDays(days) {\n        return this._with(this._date.plusDays(days), this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of years subtracted.\n     * \n     * This uses {@link LocalDate.minusYears} to subtract the years.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} years - the years to subtract, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusYears(years) {\n        return this._with(this._date.minusYears(years), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of months subtracted.\n     * \n     * This uses {@link LocalDate.minusMonths} to subtract the months.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} months - the months to subtract, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the months subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusMonths(months) {\n        return this._with(this._date.minusMonths(months), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of weeks subtracted.\n     * \n     * This uses {@link LocalDate.minusWeeks} to subtract the weeks.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weeks - the weeks to subtract, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the weeks subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusWeeks(weeks) {\n        return this._with(this._date.minusWeeks(weeks), this._offset);\n    }\n\n    /**\n     * Returns a copy of this `OffsetDate` with the specified number of days subtracted.\n     * \n     * This uses {@link LocalDate.minusDays} to subtract the days.\n     * The offset does not affect the calculation and will be the same in the result.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} days - the days to subtract, may be negative\n     * @return {OffsetDate} an `OffsetDate` based on this date with the days subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported date range\n     */\n    minusDays(days) {\n        return this._with(this._date.minusDays(days), this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this date using the specified query.\n     * \n     * This queries this date using the specified query strategy object.\n     * The `TemporalQuery` object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (query === TemporalQueries.offset() || query === TemporalQueries.zone()) {\n            return this.offset();\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have the same offset and date\n     * as this object.\n     * \n     * This returns a temporal object of the same observable type as the input\n     * with the offset and date changed to be the same as this.\n     * \n     * The adjustment is equivalent to using {@link Temporal.with}\n     * twice, passing {@link ChronoField.OFFSET_SECONDS} and\n     * {@link ChronoField.EPOCH_DAY} as the fields.\n     * \n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisOffsetDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisOffsetDate);\n     * </pre>\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal\n            .with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds())\n            .with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay());\n    }\n\n    /**\n     * Calculates the period between this date and another date in\n     * terms of the specified unit.\n     * \n     * This calculates the period between two dates in terms of a single unit.\n     * The start and end points are `this` and the specified date.\n     * The result will be negative if the end is before the start.\n     * For example, the period in days between two dates can be calculated\n     * using `startDate.until(endDate, DAYS)`.\n     * \n     * The `Temporal` passed to this method is converted to a\n     * `OffsetDate` using {@link OffsetDate.from}.\n     * If the offset differs between the two times, then the specified\n     * end time is normalized to have the same offset as this time.\n     * \n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the period in months between 2012-06-15Z and 2012-08-14Z\n     * will only be one month as it is one day short of two months.\n     * \n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit.between}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   amount = start.until(end, DAYS);\n     *   amount = DAYS.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     * \n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,\n     * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`\n     * are supported. Other `ChronoUnit` values will throw an exception.\n     * \n     * If the unit is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`\n     * passing `this` as the first argument and the converted input temporal\n     * as the second argument.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end time, exclusive, which is converted to an `OffsetDate`, not null\n     * @param {TemporalUnit} unit - the unit to measure the amount in, not null\n     * @return {number} the amount of time between this date and the end date\n     * @throws {DateTimeException} if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an `OffsetDate`\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        const end = OffsetDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            const offsetDiff = end._offset.totalSeconds() - this._offset.totalSeconds();\n            const endLocal = end._date.plusDays(MathUtil.intDiv(-offsetDiff, SECONDS_PER_DAY));\n            return this._date.until(endLocal, unit);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this date using the specified formatter.\n     * \n     * This date will be passed to the formatter to produce a string.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted date string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an offset date-time formed from this date at the specified time.\n     * \n     * This combines this date with the specified time to form an `OffsetDateTime`.\n     * All possible combinations of date and time are valid.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {LocalTime} time - the time to combine with, not null\n     * @return {OffsetDateTime} the offset date-time formed from this date and the specified time, not null\n     */\n    atTime(time) {\n        return OffsetDateTime.of(this._date, time, this._offset);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date to midnight at the start of day in epoch seconds.\n     *\n     * @return {number} the epoch seconds value\n     * @private\n     */\n    _toEpochSecond() {\n        const epochDay = this._date.toEpochDay();\n        const secs = epochDay * SECONDS_PER_DAY;\n        return secs - this._offset.totalSeconds();\n    }\n\n    /**\n     * Converts this `OffsetDate` to the number of seconds since the epoch\n     * of 1970-01-01T00:00:00Z.\n     * \n     * This combines this offset date with the specified time\n     * to calculate the epoch-second value, which is the\n     * number of elapsed seconds from 1970-01-01T00:00:00Z.\n     * Instants on the time-line after the epoch are positive, earlier\n     * are negative.\n     *\n     * @param {LocalTime} time - the local time, not null\n     * @return {number} the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative\n     */\n    toEpochSecond(time) {\n        requireNonNull(time, 'time');\n        return this._toEpochSecond() + time.toSecondOfDay();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this `OffsetDate` to another date.\n     * \n     * The comparison is based first on the UTC equivalent instant, then on the local date.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     * \n     * For example, the following is the comparator order:\n     * 1. 2008-06-29-11:00</li>\n     * 2. 2008-06-29-12:00</li>\n     * 3. 2008-06-30+12:00</li>\n     * 4. 2008-06-29-13:00</li>\n     * \n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with `equals()`.\n     * \n     * To compare the underlying local date of two `TemporalAccessor` instances,\n     * use {@link ChronoField.EPOCH_DAY} as a comparator.\n     *\n     * @param {OffsetDate} other - the other date to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetDate, 'other');\n        if (this._offset.equals(other._offset)) {\n            return this._date.compareTo(other._date);\n        }\n        let compare = this._toEpochSecond() - other._toEpochSecond();\n        if (compare === 0) {\n            compare = this._date.compareTo(other._date);\n        }\n        return compare;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the instant of midnight at the start of this `OffsetDate`\n     * is after midnight at the start of the specified date.\n     * \n     * This method differs from the comparison in {@link OffsetDate.compareTo} in that it\n     * only compares the instant of the date. This is equivalent to using\n     * `date1.toEpochSecond().isAfter(date2.toEpochSecond())`.\n     *\n     * @param {OffsetDate} other - the other date to compare to, not null\n     * @return {boolean} true if this is after the instant of the specified date\n     */\n    isAfter(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetDate, 'other');\n        return this._toEpochSecond() > other._toEpochSecond();\n    }\n\n    /**\n     * Checks if the instant of midnight at the start of this `OffsetDate`\n     * is before midnight at the start of the specified date.\n     * \n     * This method differs from the comparison in {@link OffsetDate.compareTo} in that it\n     * only compares the instant of the date. This is equivalent to using\n     * `date1.toEpochSecond().isBefore(date2.toEpochSecond())`.\n     *\n     * @param {OffsetDate} other - the other date to compare to, not null\n     * @return {boolean} true if this is before the instant of the specified date\n     */\n    isBefore(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetDate, 'other');\n        return this._toEpochSecond() < other._toEpochSecond();\n    }\n\n    /**\n     * Checks if the instant of midnight at the start of this `OffsetDate`\n     * equals midnight at the start of the specified date.\n     * \n     * This method differs from the comparison in {@link OffsetDate.compareTo} and {@link OffsetDate.equals}\n     * in that it only compares the instant of the date. This is equivalent to using\n     * `date1.toEpochSecond().equals(date2.toEpochSecond())`.\n     *\n     * @param {OffsetDate} other - the other date to compare to, not null\n     * @return {boolean} true if the instant equals the instant of the specified date\n     */\n    isEqual(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, OffsetDate, 'other');\n        return this._toEpochSecond() === other._toEpochSecond();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this date is equal to another date.\n     * \n     * The comparison is based on the local-date and the offset.\n     * To compare for the same instant on the time-line, use {@link OffsetDate.isEqual}.\n     * \n     * Only objects of type `OffsetDate` are compared, other types return false.\n     * To compare the underlying local date of two `TemporalAccessor` instances,\n     * use {@link ChronoField.EPOCH_DAY} as a comparator.\n     *\n     * @param {Object} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other date\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof OffsetDate) {\n            const other = obj;\n            return this._date.equals(other._date) && this._offset.equals(other._offset);\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this date.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._date.hashCode() ^ this._offset.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this date as a `String`, such as `2007-12-03+01:00`.\n     * \n     * The output will be in the ISO-8601 format `yyyy-MM-ddXXXXX`.\n     *\n     * @return {String} a string representation of this date, not null\n     */\n    toString() {\n        return this._date.toString() + this._offset.toString();\n    }\n}\n\nexport function _init() {\n    /**\n     * The minimum supported `OffsetDate`, '-999999999-01-01+18:00'.\n     * This is the minimum local date in the maximum offset\n     * (larger offsets are earlier on the time-line).\n     * This combines {@link LocalDate.MIN} and {@link ZoneOffset.MAX}.\n     * This could be used by an application as a 'far past' date.\n     */\n    OffsetDate.MIN = OffsetDate.of(LocalDate.MIN, ZoneOffset.MAX);\n    /**\n     * The maximum supported `OffsetDate`, '+999999999-12-31-18:00'.\n     * This is the maximum local date in the minimum offset\n     * (larger negative offsets are later on the time-line).\n     * This combines {@link LocalDate.MAX} and {@link ZoneOffset.MIN}.\n     * This could be used by an application as a 'far future' date.\n     */\n    OffsetDate.MAX = OffsetDate.of(LocalDate.MAX, ZoneOffset.MIN);\n\n    OffsetDate.FROM = createTemporalQuery('OffsetDate.FROM', (temporal) => {\n        return OffsetDate.from(temporal);\n    });\n}\n\n// copied from packages/core/src/temporal/TemporalQuery.js\nfunction createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/OffsetDate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1851,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/OffsetDate.js",
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/OffsetDate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1852,
    "kind": "variable",
    "name": "SECONDS_PER_DAY",
    "memberof": "packages/extra/src/OffsetDate.js",
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~SECONDS_PER_DAY",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/OffsetDate.js",
    "importStyle": null,
    "description": "The number of seconds per day.",
    "lineNumber": 18,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1853,
    "kind": "class",
    "name": "OffsetDate",
    "memberof": "packages/extra/src/OffsetDate.js",
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/OffsetDate.js",
    "importStyle": "{OffsetDate}",
    "description": "A date with an offset from UTC/Greenwich in the ISO-8601 calendar system,\nsuch as `2007-12-03+01:00`.\n\n`OffsetDate` is an immutable date-time object that represents a date, often viewed\nas year-month-day-offset. This object can also access other date fields such as\nday-of-year, day-of-week and week-of-year.\n\nThis class does not store or represent a time.\nFor example, the value '2nd October 2007 +02:00' can be stored\nin an `OffsetDate`.",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "@js-joda/core~Temporal"
    ]
  },
  {
    "__docId__": 1854,
    "kind": "method",
    "name": "now",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate.now",
    "access": "public",
    "description": "function overloading for {@link OffsetDate.now}\n- if called with 0 argument {@link OffsetDate._now0} is executed,\n- if called with 1 argument and first argument is an instance of ZoneId, then {@link OffsetDate._nowZoneId} is executed,\n- otherwise {@link OffsetDate._nowClock} is executed",
    "lineNumber": 44,
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1855,
    "kind": "method",
    "name": "_now0",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate._now0",
    "access": "protected",
    "description": "Obtains the current date from the system clock in the default time-zone.\n\nThis will query the {@link Clock.systemDefaultZone} system clock in the default\ntime-zone to obtain the current date.\nThe offset will be calculated from the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 68,
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the current date using the system clock, not null"
    },
    "params": []
  },
  {
    "__docId__": 1856,
    "kind": "method",
    "name": "_nowZoneId",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate._nowZoneId",
    "access": "protected",
    "description": "Obtains the current date from the system clock in the specified time-zone.\n\nThis will query the {@link Clock.system} system clock to obtain the current date.\nSpecifying the time-zone avoids dependence on the default time-zone.\nThe offset will be calculated from the specified time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the current date using the system clock, not null"
    }
  },
  {
    "__docId__": 1857,
    "kind": "method",
    "name": "_nowClock",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate._nowClock",
    "access": "protected",
    "description": "Obtains the current date from the specified clock.\n\nThis will query the specified clock to obtain the current date - today.\nThe offset will be calculated from the time-zone in the clock.\n\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using {@link Clock} dependency injection.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the current date, not null"
    }
  },
  {
    "__docId__": 1858,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate.of",
    "access": "public",
    "description": "function overloading for {@link OffsetDate.of}\n- if called with 2 arguments {@link OffsetDate._ofLocalDateZoneOffset} is executed,\n- if called with 4 agruments {@link OffsetDate._ofIntIntIntZoneOffset} is executed,\n- otherwise throws IllegalArgumentException.",
    "lineNumber": 118,
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1859,
    "kind": "method",
    "name": "_ofLocalDateZoneOffset",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate._ofLocalDateZoneOffset",
    "access": "protected",
    "description": "Obtains an instance of `OffsetDate` from a local date and an offset.",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the local date, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the offset date, not null"
    }
  },
  {
    "__docId__": 1860,
    "kind": "method",
    "name": "_ofIntIntIntZoneOffset",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate._ofIntIntIntZoneOffset",
    "access": "protected",
    "description": "Obtains an instance of `OffsetDate` from a year, month, day\nand offset.\n\nThis creates an offset date with the four specified fields.\n\nThis method exists primarily for writing test cases.\nNon test-code will typically use other methods to create an offset time.",
    "lineNumber": 156,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to represent, from 1 (January) to 12 (December)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to represent, from 1 to 31"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the offset date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the value of any field is out of range, or\n if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 1861,
    "kind": "method",
    "name": "ofInstant",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate.ofInstant",
    "access": "public",
    "description": "Obtains an instance of `OffsetDate` from an `Instant` and zone ID.\n\nThis creates an offset date with the same instant as midnight at the\nstart of day of the instant specified.\nFinding the offset from UTC/Greenwich is simple as there is only one valid\noffset for each instant.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to create the time from, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the time-zone, which may be an offset, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the offset time, not null"
    }
  },
  {
    "__docId__": 1862,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate.from",
    "access": "public",
    "description": "Obtains an instance of `OffsetDate` from a temporal object.\n\nA `TemporalAccessor` represents some form of date and time information.\nThis factory converts the arbitrary temporal object to an instance of `OffsetDate`.\n\nThe conversion extracts and combines `LocalDate` and `ZoneOffset`.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, `OffsetDate.FROM`.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the offset date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to an `OffsetDate`"
      }
    ]
  },
  {
    "__docId__": 1863,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate.parse",
    "access": "public",
    "description": "Obtains an instance of `OffsetDate` from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a date.",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "CharSequence"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "the parsed offset date, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 1864,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the local date, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset, not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1865,
    "kind": "member",
    "name": "_date",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_date",
    "access": "private",
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1866,
    "kind": "member",
    "name": "_offset",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_offset",
    "access": "private",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1867,
    "kind": "method",
    "name": "_with",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_with",
    "access": "private",
    "description": "Returns a new date based on this one, returning `this` where possible.",
    "lineNumber": 251,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDate"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "the date to create with, not null"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset to create with, not null"
      }
    ],
    "ignore": true,
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1868,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#isSupported",
    "access": "public",
    "description": "function overloading for {@link OffsetDate.isSupported}\n- if called with an instance of {@link TemporalField}, then {@link OffsetDate._isSupportedField} is executed,\n- if called with an instance of {@link TemporalUnit}, then {@link OffsetDate._isSupportedUnit} is executed,\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 267,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1869,
    "kind": "method",
    "name": "_isSupportedField",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_isSupportedField",
    "access": "protected",
    "description": "Checks if the specified field is supported.\n\nThis checks if this date can be queried for the specified field.\nIf false, then calling the {@link OffsetDate.range},\n{@link OffsetDate.get} and {@link OffsetDate.with}\nmethods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n- `DAY_OF_WEEK`\n- `ALIGNED_DAY_OF_WEEK_IN_MONTH`\n- `ALIGNED_DAY_OF_WEEK_IN_YEAR`\n- `DAY_OF_MONTH`\n- `DAY_OF_YEAR`\n- `EPOCH_DAY`\n- `ALIGNED_WEEK_OF_MONTH`\n- `ALIGNED_WEEK_OF_YEAR`\n- `MONTH_OF_YEAR`\n- `PROLEPTIC_MONTH`\n- `YEAR_OF_ERA`\n- `YEAR`\n- `ERA`\n- `OFFSET_SECONDS`\n\nAll other `ChronoField` instances will return false.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this date, false if not"
    }
  },
  {
    "__docId__": 1870,
    "kind": "method",
    "name": "_isSupportedUnit",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_isSupportedUnit",
    "access": "protected",
    "description": "Checks if the specified unit is supported.\n\nThis checks if the specified unit can be added to, or subtracted from, this date.\nIf false, then calling the {@link OffsetDate.plus(long, TemporalUnit)} and\n{@link OffsetDate.minus(long, TemporalUnit) minus} methods will throw an exception.\n\nIf the unit is a {@link ChronoUnit} then the query is implemented here.\nThe supported units are:\n<ul>\n- `DAYS`\n- `WEEKS`\n- `MONTHS`\n- `YEARS`\n- `DECADES`\n- `CENTURIES`\n- `MILLENNIA`\n- `ERAS`\n</ul>\nAll other `ChronoUnit` instances will return false.\n\nIf the unit is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`\npassing `this` as the argument.\nWhether the unit is supported is determined by the unit.",
    "lineNumber": 355,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the unit can be added/subtracted, false if not"
    }
  },
  {
    "__docId__": 1871,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis date is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link OffsetDate.isSupported} supported fields will return\nappropriate range instances.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 386,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 1872,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#get",
    "access": "public",
    "description": "Gets the value of the specified field from this date as an `int`.\n\nThis queries this date for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link OffsetDate.isSupported} supported fields will return valid\nvalues based on this date, except `EPOCH_DAY` and `PROLEPTIC_MONTH`\nwhich are too large to fit in an `int` and throw a `DateTimeException`.\nAll other `ChronoField` instances will throw a `DateTimeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 425,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1873,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this date as a `long`.\n\nThis queries this date for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link OffsetDate.isSupported} supported fields will return valid\nvalues based on this date.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 454,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1874,
    "kind": "method",
    "name": "offset",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#offset",
    "access": "public",
    "description": "Gets the zone offset, such as '+01:00'.\n\nThis is the offset of the local date from UTC/Greenwich.",
    "lineNumber": 474,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the zone offset, not null"
    },
    "params": []
  },
  {
    "__docId__": 1875,
    "kind": "method",
    "name": "withOffsetSameLocal",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#withOffsetSameLocal",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified offset ensuring\nthat the result has the same local date.\n\nThis method returns an object with the same `LocalDate` and the specified `ZoneOffset`.\nNo calculation is needed or performed.\nFor example, if this time represents `2007-12-03+02:00` and the offset specified is\n`+03:00`, then this method will return `2007-12-03+03:00`.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 492,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the zone offset to change to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the requested offset, not null"
    }
  },
  {
    "__docId__": 1876,
    "kind": "method",
    "name": "toLocalDate",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#toLocalDate",
    "access": "public",
    "description": "Gets the `LocalDate` part of this date.\n\nThis returns a `LocalDate` with the same year, month and day\nas this date.",
    "lineNumber": 506,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date part of this date, not null"
    },
    "params": []
  },
  {
    "__docId__": 1877,
    "kind": "method",
    "name": "year",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#year",
    "access": "public",
    "description": "Gets the year field.\n\nThis method returns the primitive `int` value for the year.\n\nThe year returned by this method is proleptic as per `get(YEAR)`.\nTo obtain the year-of-era, use `get(YEAR_OF_ERA)`.",
    "lineNumber": 521,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 1878,
    "kind": "method",
    "name": "monthValue",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#monthValue",
    "access": "public",
    "description": "Gets the month-of-year field from 1 to 12.\n\nThis method returns the month as an `int` from 1 to 12.\nApplication code is frequently clearer if the enum {@link Month}\nis used by calling {@link OffsetDate.month}.",
    "see": [
      "OffsetDate.month()"
    ],
    "lineNumber": 535,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the month-of-year, from 1 to 12"
    },
    "params": []
  },
  {
    "__docId__": 1879,
    "kind": "method",
    "name": "month",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#month",
    "access": "public",
    "description": "Gets the month-of-year field using the `Month` enum.\n\nThis method returns the enum {@link Month} for the month.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value then the enum\nprovides the {@link Month.value} int value.",
    "see": [
      "OffsetDate.monthValue()"
    ],
    "lineNumber": 550,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the month-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 1880,
    "kind": "method",
    "name": "dayOfMonth",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#dayOfMonth",
    "access": "public",
    "description": "Gets the day-of-month field.\n\nThis method returns the primitive `int` value for the day-of-month.",
    "lineNumber": 561,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-month, from 1 to 31"
    },
    "params": []
  },
  {
    "__docId__": 1881,
    "kind": "method",
    "name": "dayOfYear",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#dayOfYear",
    "access": "public",
    "description": "Gets the day-of-year field.\n\nThis method returns the primitive `int` value for the day-of-year.",
    "lineNumber": 572,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the day-of-year, from 1 to 365, or 366 in a leap year"
    },
    "params": []
  },
  {
    "__docId__": 1882,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#dayOfWeek",
    "access": "public",
    "description": "Gets the day-of-week field, which is an enum `DayOfWeek`.\n\nThis method returns the enum {@link DayOfWeek} for the day-of-week.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value then the enum\nprovides the {@link DayOfWeek.value} int value.\n\nAdditional information can be obtained from the `DayOfWeek`.\nThis includes textual names of the values.",
    "lineNumber": 589,
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 1883,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this date.\n\nThis returns an `OffsetDate` based on this one, with the date adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the year field.\nA more complex adjuster might set the date to the last day of the month.\nA selection of common adjustments is provided in {@link TemporalAdjusters}.\nThese include finding the 'last day of the month' and 'next Wednesday'.\nKey date-time classes also implement the `TemporalAdjuster` interface,\nsuch as {@link Month} and {@link MonthDay}.\nThe adjuster is responsible for handling special cases, such as the varying\nlengths of month and leap years.\n\nFor example this code returns a date on the last day of July:\n<pre>\n import static java.time.Month.*;\n import static java.time.temporal.TemporalAdjusters.*;\n\n result = offsetDate.with(JULY).with(lastDayOfMonth());\n</pre>\n\nThe classes {@link LocalDate} and {@link ZoneOffset} implement `TemporalAdjuster`,\nthus this method can be used to change the date or offset:\n<pre>\n result = offsetDate.with(date);\n result = offsetDate.with(offset);\n</pre>\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster.adjustInto} method on the\nspecified adjuster passing `this` as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 636,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on `this` with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1884,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_withField",
    "access": "private",
    "description": "Returns a copy of this date with the specified field set to a new value.\n\nThis returns an `OffsetDate` based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year, month or day-of-month.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIn some cases, changing the specified field can cause the resulting date to become invalid,\nsuch as changing the month from 31st January to February would make the day-of-month invalid.\nIn cases like this, the field is responsible for resolving the date. Typically it will choose\nthe previous valid date, which would be the last valid day of February in this example.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\n\nThe `OFFSET_SECONDS` field will return a date with the specified offset.\nThe local date is unaltered. If the new offset value is outside the valid range\nthen a `DateTimeException` will be thrown.\n\nThe other {@link OffsetDate.isSupported} supported fields will behave as per\nthe matching method on {@link LocalDate.with} LocalDate.\nIn this case, the offset is not part of the calculation and will be unchanged.\n\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.adjustInto(Temporal, long)`\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 688,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1885,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#withYear",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the year altered.\n\nThe offset does not affect the calculation and will be the same in the result.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 714,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDate"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the result, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 1886,
    "kind": "method",
    "name": "withMonth",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#withMonth",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the month-of-year altered.\n\nThe offset does not affect the calculation and will be the same in the result.\nIf the day-of-month is invalid for the year, it will be changed to the last valid day of the month.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 730,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": "the month-of-year to set in the result, from 1 (January) to 12 (December)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the requested month, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the month-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 1887,
    "kind": "method",
    "name": "withDayOfMonth",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#withDayOfMonth",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the day-of-month altered.\n\nIf the resulting date is invalid, an exception is thrown.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 747,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfMonth",
        "description": "the day-of-month to set in the result, from 1 to 28-31"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-month value is invalid,\n or if the day-of-month is invalid for the month-year"
      }
    ]
  },
  {
    "__docId__": 1888,
    "kind": "method",
    "name": "withDayOfYear",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#withDayOfYear",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the day-of-year altered.\n\nIf the resulting date is invalid, an exception is thrown.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 763,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfYear",
        "description": "the day-of-year to set in the result, from 1 to 365-366"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the requested day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day-of-year value is invalid,\n or if the day-of-year is invalid for the year"
      }
    ]
  },
  {
    "__docId__": 1889,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this date with the specified amount added.\n\nThis returns an `OffsetDate` based on this one, with the amount\nin terms of the unit added. If it is not possible to add the amount, because the\nunit is not supported or for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoUnit} then the addition is implemented by\n{@link LocalDate.plus}.\nThe offset is not part of the calculation and will be unchanged in the result.\n\nIf the field is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.addTo(Temporal, long)`\npassing `this` as the argument. In this case, the unit determines\nwhether and how to perform the addition.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 792,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the amount to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the specified amount added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the addition cannot be made"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1890,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#plusYears",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of years added.\n\nThis uses {@link LocalDate.plusYears} to add the years.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 812,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1891,
    "kind": "method",
    "name": "plusMonths",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#plusMonths",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of months added.\n\nThis uses {@link LocalDate.plusMonths} to add the months.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 828,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the months added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1892,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#plusWeeks",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of weeks added.\n\nThis uses {@link LocalDate.plusWeeks} to add the weeks.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 844,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the weeks added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1893,
    "kind": "method",
    "name": "plusDays",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#plusDays",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of days added.\n\nThis uses {@link LocalDate.plusDays)} to add the days.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 860,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the days added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1894,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#minusYears",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of years subtracted.\n\nThis uses {@link LocalDate.minusYears} to subtract the years.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 877,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "years",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1895,
    "kind": "method",
    "name": "minusMonths",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#minusMonths",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of months subtracted.\n\nThis uses {@link LocalDate.minusMonths} to subtract the months.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 893,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "months",
        "description": "the months to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the months subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1896,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#minusWeeks",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of weeks subtracted.\n\nThis uses {@link LocalDate.minusWeeks} to subtract the weeks.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 909,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeks",
        "description": "the weeks to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the weeks subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1897,
    "kind": "method",
    "name": "minusDays",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#minusDays",
    "access": "public",
    "description": "Returns a copy of this `OffsetDate` with the specified number of days subtracted.\n\nThis uses {@link LocalDate.minusDays} to subtract the days.\nThe offset does not affect the calculation and will be the same in the result.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 925,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "days",
        "description": "the days to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDate"
      ],
      "spread": false,
      "description": "an `OffsetDate` based on this date with the days subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported date range"
      }
    ]
  },
  {
    "__docId__": 1898,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#query",
    "access": "public",
    "description": "Queries this date using the specified query.\n\nThis queries this date using the specified query strategy object.\nThe `TemporalQuery` object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 947,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 1899,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have the same offset and date\nas this object.\n\nThis returns a temporal object of the same observable type as the input\nwith the offset and date changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\ntwice, passing {@link ChronoField.OFFSET_SECONDS} and\n{@link ChronoField.EPOCH_DAY} as the fields.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with(TemporalAdjuster)}:\n<pre>\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisOffsetDate.adjustInto(temporal);\n  temporal = temporal.with(thisOffsetDate);\n</pre>\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 986,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1900,
    "kind": "method",
    "name": "until",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#until",
    "access": "public",
    "description": "Calculates the period between this date and another date in\nterms of the specified unit.\n\nThis calculates the period between two dates in terms of a single unit.\nThe start and end points are `this` and the specified date.\nThe result will be negative if the end is before the start.\nFor example, the period in days between two dates can be calculated\nusing `startDate.until(endDate, DAYS)`.\n\nThe `Temporal` passed to this method is converted to a\n`OffsetDate` using {@link OffsetDate.from}.\nIf the offset differs between the two times, then the specified\nend time is normalized to have the same offset as this time.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two dates.\nFor example, the period in months between 2012-06-15Z and 2012-08-14Z\nwill only be one month as it is one day short of two months.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method.\nThe second is to use {@link TemporalUnit.between}:\n<pre>\n  // these two lines are equivalent\n  amount = start.until(end, DAYS);\n  amount = DAYS.between(start, end);\n</pre>\nThe choice should be made based on which makes the code more readable.\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,\n`DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`\nare supported. Other `ChronoUnit` values will throw an exception.\n\nIf the unit is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.between(Temporal, Temporal)`\npassing `this` as the first argument and the converted input temporal\nas the second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1042,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end time, exclusive, which is converted to an `OffsetDate`, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the amount in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of time between this date and the end date"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the amount cannot be calculated, or the end\n temporal cannot be converted to an `OffsetDate`"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1901,
    "kind": "method",
    "name": "format",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#format",
    "access": "public",
    "description": "Formats this date using the specified formatter.\n\nThis date will be passed to the formatter to produce a string.",
    "lineNumber": 1061,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted date string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 1902,
    "kind": "method",
    "name": "atTime",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#atTime",
    "access": "public",
    "description": "Returns an offset date-time formed from this date at the specified time.\n\nThis combines this date with the specified time to form an `OffsetDateTime`.\nAll possible combinations of date and time are valid.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 1078,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the time to combine with, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "OffsetDateTime"
      ],
      "spread": false,
      "description": "the offset date-time formed from this date and the specified time, not null"
    }
  },
  {
    "__docId__": 1903,
    "kind": "method",
    "name": "_toEpochSecond",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#_toEpochSecond",
    "access": "private",
    "description": "Converts this date to midnight at the start of day in epoch seconds.",
    "lineNumber": 1089,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the epoch seconds value"
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 1904,
    "kind": "method",
    "name": "toEpochSecond",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#toEpochSecond",
    "access": "public",
    "description": "Converts this `OffsetDate` to the number of seconds since the epoch\nof 1970-01-01T00:00:00Z.\n\nThis combines this offset date with the specified time\nto calculate the epoch-second value, which is the\nnumber of elapsed seconds from 1970-01-01T00:00:00Z.\nInstants on the time-line after the epoch are positive, earlier\nare negative.",
    "lineNumber": 1108,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalTime"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "the local time, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative"
    }
  },
  {
    "__docId__": 1905,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#compareTo",
    "access": "public",
    "description": "Compares this `OffsetDate` to another date.\n\nThe comparison is based first on the UTC equivalent instant, then on the local date.\nIt is 'consistent with equals', as defined by {@link Comparable}.\n\nFor example, the following is the comparator order:\n1. 2008-06-29-11:00</li>\n2. 2008-06-29-12:00</li>\n3. 2008-06-30+12:00</li>\n4. 2008-06-29-13:00</li>\n\nValues #2 and #3 represent the same instant on the time-line.\nWhen two values represent the same instant, the local date is compared\nto distinguish them. This step is needed to make the ordering\nconsistent with `equals()`.\n\nTo compare the underlying local date of two `TemporalAccessor` instances,\nuse {@link ChronoField.EPOCH_DAY} as a comparator.",
    "lineNumber": 1137,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 1906,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#isAfter",
    "access": "public",
    "description": "Checks if the instant of midnight at the start of this `OffsetDate`\nis after midnight at the start of the specified date.\n\nThis method differs from the comparison in {@link OffsetDate.compareTo} in that it\nonly compares the instant of the date. This is equivalent to using\n`date1.toEpochSecond().isAfter(date2.toEpochSecond())`.",
    "lineNumber": 1162,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the instant of the specified date"
    }
  },
  {
    "__docId__": 1907,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#isBefore",
    "access": "public",
    "description": "Checks if the instant of midnight at the start of this `OffsetDate`\nis before midnight at the start of the specified date.\n\nThis method differs from the comparison in {@link OffsetDate.compareTo} in that it\nonly compares the instant of the date. This is equivalent to using\n`date1.toEpochSecond().isBefore(date2.toEpochSecond())`.",
    "lineNumber": 1179,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is before the instant of the specified date"
    }
  },
  {
    "__docId__": 1908,
    "kind": "method",
    "name": "isEqual",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#isEqual",
    "access": "public",
    "description": "Checks if the instant of midnight at the start of this `OffsetDate`\nequals midnight at the start of the specified date.\n\nThis method differs from the comparison in {@link OffsetDate.compareTo} and {@link OffsetDate.equals}\nin that it only compares the instant of the date. This is equivalent to using\n`date1.toEpochSecond().equals(date2.toEpochSecond())`.",
    "lineNumber": 1196,
    "params": [
      {
        "nullable": null,
        "types": [
          "OffsetDate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other date to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the instant equals the instant of the specified date"
    }
  },
  {
    "__docId__": 1909,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#equals",
    "access": "public",
    "description": "Checks if this date is equal to another date.\n\nThe comparison is based on the local-date and the offset.\nTo compare for the same instant on the time-line, use {@link OffsetDate.isEqual}.\n\nOnly objects of type `OffsetDate` are compared, other types return false.\nTo compare the underlying local date of two `TemporalAccessor` instances,\nuse {@link ChronoField.EPOCH_DAY} as a comparator.",
    "lineNumber": 1216,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other date"
    }
  },
  {
    "__docId__": 1910,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#hashCode",
    "access": "public",
    "description": "A hash code for this date.",
    "lineNumber": 1232,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1911,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/OffsetDate.js~OffsetDate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/OffsetDate.js~OffsetDate#toString",
    "access": "public",
    "description": "Outputs this date as a `String`, such as `2007-12-03+01:00`.\n\nThe output will be in the ISO-8601 format `yyyy-MM-ddXXXXX`.",
    "lineNumber": 1244,
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "a string representation of this date, not null"
    },
    "params": []
  },
  {
    "__docId__": 1912,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/OffsetDate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/OffsetDate.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1249,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1913,
    "kind": "function",
    "name": "createTemporalQuery",
    "memberof": "packages/extra/src/OffsetDate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/OffsetDate.js~createTemporalQuery",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/OffsetDate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1273,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "queryFromFunction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1914,
    "kind": "file",
    "name": "packages/extra/src/Quarter.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireNonNull, requireInstance } from './assert';\nimport { ChronoField, DateTimeException, IllegalArgumentException, IllegalStateException, IsoChronology, IsoFields, Month, TemporalAccessor, TemporalField, TemporalQueries, TemporalQuery, UnsupportedTemporalTypeException, _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * A quarter-of-year, such as 'Q2'.\n *\n * `Quarter` is an enum representing the 4 quarters of the year -\n * Q1, Q2, Q3 and Q4. These are defined as January to March, April to June,\n * July to September and October to December.\n *\n * The `int` value follows the quarter, from 1 (Q1) to 4 (Q4).\n * It is recommended that applications use the enum rather than the `int` value\n * to ensure code clarity.\n *\n * **Do not use `ordinal()` to obtain the numeric representation of `Quarter`.\n * Use `getValue()` instead.**\n *\n * This enum represents a common concept that is found in many calendar systems.\n * As such, this enum may be used by any calendar system that has the quarter-of-year\n * concept defined exactly equivalent to the ISO calendar system.\n *\n */\nexport class Quarter extends TemporalAccessor {\n    /**\n     * replacement for enum `valueOf(name)`\n     *\n     * @param {string} name\n     * @return {Quarter}\n     */\n    static valueOf(name) {\n        requireNonNull(name, 'name');\n        switch (name) {\n            case 'Q1':\n                return Quarter.Q1;\n            case 'Q2':\n                return Quarter.Q2;\n            case 'Q3':\n                return Quarter.Q3;\n            case 'Q4':\n                return Quarter.Q4;\n        }\n        throw new IllegalArgumentException(`No enum constant Quarter.${name}`);\n    }\n\n    /**\n     * replacement for enum `values()`\n     * @return {Quarter[]}\n     */\n    static values() {\n        return QUARTERS.slice();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `Quarter` from an `int` value.\n     *\n     * `Quarter` is an enum representing the 4 quarters of the year.\n     * This factory allows the enum to be obtained from the `int` value.\n     * The `int` value follows the quarter, from 1 (Q1) to 4 (Q4).\n     *\n     * @param {number} quarterOfYear - the quarter-of-year to represent, from 1 (Q1) to 4 (Q4)\n     * @return {Quarter} the quarter-of-year, not null\n     * @throws {DateTimeException} if the quarter-of-year is invalid\n     */\n    static of(quarterOfYear) {\n        requireNonNull(quarterOfYear, 'quarterOfYear');\n        switch (quarterOfYear) {\n            case 1:\n                return Quarter.Q1;\n            case 2:\n                return Quarter.Q2;\n            case 3:\n                return Quarter.Q3;\n            case 4:\n                return Quarter.Q4;\n            default:\n                throw new DateTimeException(`Invalid value for Quarter: ${quarterOfYear}`);\n        }\n    }\n\n    /**\n     * Obtains an instance of `Quarter` from a month-of-year.\n     *\n     * `Quarter` is an enum representing the 4 quarters of the year.\n     * This factory allows the enum to be obtained from the `Month` value.\n     *\n     * January to March are Q1, April to June are Q2, July to September are Q3\n     * and October to December are Q4.\n     *\n     * @param {number} monthOfYear - the month-of-year to convert from, from 1 to 12\n     * @return {Quarter} the quarter-of-year, not null\n     * @throws {DateTimeException} if the month-of-year is invalid\n     */\n    static ofMonth(monthOfYear) {\n        requireNonNull(monthOfYear, 'monthOfYear');\n        ChronoField.MONTH_OF_YEAR.range().checkValidValue(monthOfYear, ChronoField.MONTH_OF_YEAR);\n        return Quarter.of(MathUtil.intDiv(monthOfYear - 1, 3) + 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `Quarter` from a temporal object.\n     *\n     * This obtains a quarter based on the specified temporal.\n     * A `TemporalAccessor` represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of `Quarter`.\n     *\n     * The conversion extracts the {@link IsoFields.QUARTER_OF_YEAR} field.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a `LocalDate`.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, `Quarter.from`.\n     *\n     * @param {Temporal} temporal - the temporal-time object to convert, not null\n     * @return {Quarter} the quarter-of-year, not null\n     * @throws {DateTimeException} if unable to convert to a `Quarter`\n     */\n    static from(temporal) {\n        if (temporal instanceof Quarter) {\n            return temporal;\n        } else if (temporal instanceof Month) {\n            const month = temporal;\n            return Quarter.of(MathUtil.intDiv(month.ordinal(), 3) + 1);\n        }\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }\n            */\n            const qoy = MathUtil.safeToInt(temporal.getLong(IsoFields.QUARTER_OF_YEAR));\n            return Quarter.of(qoy);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain Quarter from TemporalAccessor: '${temporal}' of type '${temporal && temporal.constructor.name}'`, ex);\n        }\n    }\n\n    /**\n     *\n     * @param {number} value\n     * @param {string} name\n     * @private\n     */\n    constructor(value, name) {\n        super();\n        this._value = MathUtil.safeToInt(value);\n        this._name = name;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the quarter-of-year `int` value.\n     *\n     * The values are numbered following the ISO-8601 standard,\n     * from 1 (Q1) to 4 (Q4).\n     *\n     * @return {number} the quarter-of-year, from 1 (Q1) to 4 (Q4)\n     */\n    value() {\n        return this._value;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the textual representation, such as 'Q1' or '4th quarter'.\n     *\n     * This returns the textual name used to identify the quarter-of-year,\n     * suitable for presentation to the user.\n     * The parameters control the style of the returned text and the locale.\n     *\n     * If no textual mapping is found then the {@link #getValue() numeric value} is returned.\n     *\n     * @param {TextStyle} style - the length of the text required, not null\n     * @param {Locale} locale - the locale to use, not null\n     * @return {string} the text value of the day-of-week, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    displayName(style, locale) {\n        throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this quarter-of-year can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     *\n     * If the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then\n     * this method returns true.\n     * All `ChronoField` instances will return false.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this quarter-of-year, false if not\n     */\n    isSupported(field) {\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return true;\n        } else if (field instanceof ChronoField) {\n            return false;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This quarter is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then the\n     * range of the quarter-of-year, from 1 to 4, will be returned.\n     * All `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this quarter-of-year as an `int`.\n     *\n     * This queries this quarter for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link IsoFields.QUARTER_OF_YEAR} then the\n     * value of the quarter-of-year, from 1 to 4, will be returned.\n     * All `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field, within the valid range of values\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *         the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this quarter-of-year as a `long`.\n     *\n     * This queries this quarter for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then the\n     * value of the quarter-of-year, from 1 to 4, will be returned.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the quarter that is the specified number of quarters after this one.\n     *\n     * The calculation rolls around the end of the year from Q4 to Q1.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} quarters - the quarters to add, positive or negative\n     * @return {Quarter} the resulting quarter, not null\n     */\n    plus(quarters) {\n        const amount = MathUtil.intMod(quarters, 4);\n        return QUARTERS[(this.ordinal() + amount + 4) % 4];\n    }\n\n    /**\n     * Returns the quarter that is the specified number of quarters before this one.\n     *\n     * The calculation rolls around the start of the year from Q1 to Q4.\n     * The specified period may be negative.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} quarters - the quarters to subtract, positive or negative\n     * @return {Quarter} the resulting quarter, not null\n     */\n    minus(quarters) {\n        return this.plus(-(MathUtil.intMod(quarters, 4)));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of this quarter in days.\n     *\n     * This takes a flag to determine whether to return the length for a leap year or not.\n     *\n     * Q1 has 90 in a standard year and 91 days in a leap year.\n     * Q2 has 91 days.\n     * Q3 and Q4 have 92 days.\n     *\n     * @param {boolean} leapYear - true if the length is required for a leap year\n     * @return {number} the length of this month in days, from 90 to 92\n     */\n    length(leapYear) {\n        switch (this) {\n            case Quarter.Q1:\n                return (leapYear ? 91 : 90);\n            case Quarter.Q2:\n                return 91;\n            default:\n                return 92;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the first of the three months that this quarter refers to.\n     *\n     * Q1 will return January.\n     * Q2 will return April.\n     * Q3 will return July.\n     * Q4 will return October.\n     *\n     * To obtain the other two months of the quarter, simply use {@link Month#plus(long)}\n     * on the returned month.\n     *\n     * @return {Month} the first month in the quarter, not null\n     */\n    firstMonth() {\n        switch (this) {\n            case Quarter.Q1:\n                return Month.JANUARY;\n            case Quarter.Q2:\n                return Month.APRIL;\n            case Quarter.Q3:\n                return Month.JULY;\n            case Quarter.Q4:\n                return Month.OCTOBER;\n            default:\n                throw new IllegalStateException('Unreachable');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this quarter-of-year using the specified query.\n     *\n     * This queries this quarter-of-year using the specified query strategy object.\n     * The `TemporalQuery` object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom(TemporalAccessor)} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return IsoFields.QUARTER_YEARS;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this quarter-of-year.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the quarter-of-year changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal.with}\n     * passing {@link IsoFields.QUARTER_OF_YEAR} as the field.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a `DateTimeException` is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * ```\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisQuarter.adjustInto(temporal);\n     *   temporal = temporal.with(thisQuarter);\n     * ```\n     *\n     * For example, given a date in May, the following are output:\n     * ```\n     *   dateInMay.with(Q1);    // three months earlier\n     *   dateInMay.with(Q2);    // no change\n     *   dateInMay.with(Q3);    // three months later\n     *   dateInMay.with(Q4);    // six months later\n     * ```\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        requireNonNull(temporal, 'temporal');\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException('Adjustment only supported on ISO date-time');\n        }\n        */\n        return temporal.with(IsoFields.QUARTER_OF_YEAR, this.value());\n    }\n\n    //-----------------------------------------------------------------------\n    // Enum\n    //-----------------------------------------------------------------------\n\n    /**\n     *\n     * @return {number}\n     */\n    ordinal() {\n        return this._value - 1;\n    }\n\n    /**\n     *\n     * @return {string}\n     */\n    name() {\n        return this._name;\n    }\n\n    //-----------------------------------------------------------------------\n    // Comparable\n    //-----------------------------------------------------------------------\n\n    /**\n     * Compares this Quarter to another Quarter.\n     *\n     * The comparison is based on the value of the Quarter.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {Quarter} other - the other quarter to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, Quarter, 'other');\n        return this._value - other._value;\n    }\n\n    //-----------------------------------------------------------------------\n    // Object\n    //-----------------------------------------------------------------------\n\n    /**\n     * Outputs this quarter as a String, such as Q1\n     *\n     * @return {string} a string representation of this quarter, not null\n     */\n    toString() {\n        return this.name();\n    }\n\n    /**\n     *\n     * @return {boolean}\n     */\n    equals(other){\n        return this === other;\n    }\n\n    /**\n     * A hash code for this quarter.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._value;\n    }\n}\n\nlet QUARTERS;\n\nexport function _init() {\n    /**\n     * The singleton instance for the first quarter-of-year, from January to March.\n     * This has the numeric value of `1`.\n     */\n    Quarter.Q1 = new Quarter(1, 'Q1');\n    /**\n      * The singleton instance for the second quarter-of-year, from April to June.\n      * This has the numeric value of `2`.\n      */\n    Quarter.Q2 = new Quarter(2, 'Q2');\n    /**\n      * The singleton instance for the third quarter-of-year, from July to September.\n      * This has the numeric value of `3`.\n      */\n    Quarter.Q3 = new Quarter(3, 'Q3');\n    /**\n      * The singleton instance for the fourth quarter-of-year, from October to December.\n      * This has the numeric value of `4`.\n      */\n    Quarter.Q4 = new Quarter(4, 'Q4');\n\n    Quarter.FROM = createTemporalQuery('Quarter.FROM', (temporal) => {\n        return Quarter.from(temporal);\n    });\n\n    QUARTERS = [\n        Quarter.Q1,\n        Quarter.Q2,\n        Quarter.Q3,\n        Quarter.Q4\n    ];\n}\n\n// copied from packages/core/src/temporal/TemporalQuery.js\nfunction createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/Quarter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1915,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/Quarter.js",
    "static": true,
    "longname": "packages/extra/src/Quarter.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/Quarter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1916,
    "kind": "class",
    "name": "Quarter",
    "memberof": "packages/extra/src/Quarter.js",
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Quarter.js",
    "importStyle": "{Quarter}",
    "description": "A quarter-of-year, such as 'Q2'.\n\n`Quarter` is an enum representing the 4 quarters of the year -\nQ1, Q2, Q3 and Q4. These are defined as January to March, April to June,\nJuly to September and October to December.\n\nThe `int` value follows the quarter, from 1 (Q1) to 4 (Q4).\nIt is recommended that applications use the enum rather than the `int` value\nto ensure code clarity.\n\n**Do not use `ordinal()` to obtain the numeric representation of `Quarter`.\nUse `getValue()` instead.**\n\nThis enum represents a common concept that is found in many calendar systems.\nAs such, this enum may be used by any calendar system that has the quarter-of-year\nconcept defined exactly equivalent to the ISO calendar system.",
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "@js-joda/core~TemporalAccessor"
    ]
  },
  {
    "__docId__": 1917,
    "kind": "method",
    "name": "valueOf",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter.valueOf",
    "access": "public",
    "description": "replacement for enum `valueOf(name)`",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1918,
    "kind": "method",
    "name": "values",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter.values",
    "access": "public",
    "description": "replacement for enum `values()`",
    "lineNumber": 58,
    "return": {
      "nullable": null,
      "types": [
        "Quarter[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1919,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter.of",
    "access": "public",
    "description": "Obtains an instance of `Quarter` from an `int` value.\n\n`Quarter` is an enum representing the 4 quarters of the year.\nThis factory allows the enum to be obtained from the `int` value.\nThe `int` value follows the quarter, from 1 (Q1) to 4 (Q4).",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarterOfYear",
        "description": "the quarter-of-year to represent, from 1 (Q1) to 4 (Q4)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the quarter-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the quarter-of-year is invalid"
      }
    ]
  },
  {
    "__docId__": 1920,
    "kind": "method",
    "name": "ofMonth",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter.ofMonth",
    "access": "public",
    "description": "Obtains an instance of `Quarter` from a month-of-year.\n\n`Quarter` is an enum representing the 4 quarters of the year.\nThis factory allows the enum to be obtained from the `Month` value.\n\nJanuary to March are Q1, April to June are Q2, July to September are Q3\nand October to December are Q4.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "monthOfYear",
        "description": "the month-of-year to convert from, from 1 to 12"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the quarter-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the month-of-year is invalid"
      }
    ]
  },
  {
    "__docId__": 1921,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~Quarter.from",
    "access": "public",
    "description": "Obtains an instance of `Quarter` from a temporal object.\n\nThis obtains a quarter based on the specified temporal.\nA `TemporalAccessor` represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of `Quarter`.\n\nThe conversion extracts the {@link IsoFields.QUARTER_OF_YEAR} field.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a `LocalDate`.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, `Quarter.from`.",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal-time object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the quarter-of-year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a `Quarter`"
      }
    ]
  },
  {
    "__docId__": 1922,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1923,
    "kind": "member",
    "name": "_value",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#_value",
    "access": "private",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1924,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#_name",
    "access": "private",
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1925,
    "kind": "method",
    "name": "value",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#value",
    "access": "public",
    "description": "Gets the quarter-of-year `int` value.\n\nThe values are numbered following the ISO-8601 standard,\nfrom 1 (Q1) to 4 (Q4).",
    "lineNumber": 169,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the quarter-of-year, from 1 (Q1) to 4 (Q4)"
    },
    "params": []
  },
  {
    "__docId__": 1926,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#displayName",
    "access": "public",
    "description": "Gets the textual representation, such as 'Q1' or '4th quarter'.\n\nThis returns the textual name used to identify the quarter-of-year,\nsuitable for presentation to the user.\nThe parameters control the style of the returned text and the locale.\n\nIf no textual mapping is found then the {@link #getValue() numeric value} is returned.",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "the length of the text required, not null"
      },
      {
        "nullable": null,
        "types": [
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the locale to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the text value of the day-of-week, not null"
    }
  },
  {
    "__docId__": 1927,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#isSupported",
    "access": "public",
    "description": "Checks if the specified field is supported.\n\nThis checks if this quarter-of-year can be queried for the specified field.\nIf false, then calling the {@link #range(TemporalField) range} and\n{@link #get(TemporalField) get} methods will throw an exception.\n\nIf the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then\nthis method returns true.\nAll `ChronoField` instances will return false.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this quarter-of-year, false if not"
    }
  },
  {
    "__docId__": 1928,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis quarter is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then the\nrange of the quarter-of-year, from 1 to 4, will be returned.\nAll `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 1929,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#get",
    "access": "public",
    "description": "Gets the value of the specified field from this quarter-of-year as an `int`.\n\nThis queries this quarter for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link IsoFields.QUARTER_OF_YEAR} then the\nvalue of the quarter-of-year, from 1 to 4, will be returned.\nAll `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field, within the valid range of values"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n        the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n        the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1930,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this quarter-of-year as a `long`.\n\nThis queries this quarter for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR} then the\nvalue of the quarter-of-year, from 1 to 4, will be returned.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1931,
    "kind": "method",
    "name": "plus",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#plus",
    "access": "public",
    "description": "Returns the quarter that is the specified number of quarters after this one.\n\nThe calculation rolls around the end of the year from Q4 to Q1.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 328,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarters",
        "description": "the quarters to add, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the resulting quarter, not null"
    }
  },
  {
    "__docId__": 1932,
    "kind": "method",
    "name": "minus",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#minus",
    "access": "public",
    "description": "Returns the quarter that is the specified number of quarters before this one.\n\nThe calculation rolls around the start of the year from Q1 to Q4.\nThe specified period may be negative.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 344,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarters",
        "description": "the quarters to subtract, positive or negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the resulting quarter, not null"
    }
  },
  {
    "__docId__": 1933,
    "kind": "method",
    "name": "length",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#length",
    "access": "public",
    "description": "Gets the length of this quarter in days.\n\nThis takes a flag to determine whether to return the length for a leap year or not.\n\nQ1 has 90 in a standard year and 91 days in a leap year.\nQ2 has 91 days.\nQ3 and Q4 have 92 days.",
    "lineNumber": 361,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "leapYear",
        "description": "true if the length is required for a leap year"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of this month in days, from 90 to 92"
    }
  },
  {
    "__docId__": 1934,
    "kind": "method",
    "name": "firstMonth",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#firstMonth",
    "access": "public",
    "description": "Gets the first of the three months that this quarter refers to.\n\nQ1 will return January.\nQ2 will return April.\nQ3 will return July.\nQ4 will return October.\n\nTo obtain the other two months of the quarter, simply use {@link Month#plus(long)}\non the returned month.",
    "lineNumber": 386,
    "return": {
      "nullable": null,
      "types": [
        "Month"
      ],
      "spread": false,
      "description": "the first month in the quarter, not null"
    },
    "params": []
  },
  {
    "__docId__": 1935,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#query",
    "access": "public",
    "description": "Queries this quarter-of-year using the specified query.\n\nThis queries this quarter-of-year using the specified query strategy object.\nThe `TemporalQuery` object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom(TemporalAccessor)} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 419,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 1936,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this quarter-of-year.\n\nThis returns a temporal object of the same observable type as the input\nwith the quarter-of-year changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\npassing {@link IsoFields.QUARTER_OF_YEAR} as the field.\nIf the specified temporal object does not use the ISO calendar system then\na `DateTimeException` is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n```\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisQuarter.adjustInto(temporal);\n  temporal = temporal.with(thisQuarter);\n```\n\nFor example, given a date in May, the following are output:\n```\n  dateInMay.with(Q1);    // three months earlier\n  dateInMay.with(Q2);    // no change\n  dateInMay.with(Q3);    // three months later\n  dateInMay.with(Q4);    // six months later\n```\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 464,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1937,
    "kind": "method",
    "name": "ordinal",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#ordinal",
    "access": "public",
    "description": "",
    "lineNumber": 482,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1938,
    "kind": "method",
    "name": "name",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#name",
    "access": "public",
    "description": "",
    "lineNumber": 490,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1939,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#compareTo",
    "access": "public",
    "description": "Compares this Quarter to another Quarter.\n\nThe comparison is based on the value of the Quarter.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 507,
    "params": [
      {
        "nullable": null,
        "types": [
          "Quarter"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other quarter to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 1940,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#toString",
    "access": "public",
    "description": "Outputs this quarter as a String, such as Q1",
    "lineNumber": 522,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this quarter, not null"
    },
    "params": []
  },
  {
    "__docId__": 1941,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#equals",
    "access": "public",
    "description": "",
    "lineNumber": 530,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 1942,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/Quarter.js~Quarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Quarter.js~Quarter#hashCode",
    "access": "public",
    "description": "A hash code for this quarter.",
    "lineNumber": 539,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 1943,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/Quarter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Quarter.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 546,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1944,
    "kind": "function",
    "name": "createTemporalQuery",
    "memberof": "packages/extra/src/Quarter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Quarter.js~createTemporalQuery",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/Quarter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 581,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "queryFromFunction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1945,
    "kind": "file",
    "name": "packages/extra/src/Temporals.js",
    "content": "/**\n * @copyright (c) 2015-present, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { requireNonNull } from './assert';\nimport { ChronoField, ChronoUnit, DateTimeException, DateTimeParseException, IsoFields, ParsePosition, TemporalAdjuster, UnsupportedTemporalTypeException } from '@js-joda/core';\n\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * Additional utilities for working with temporal classes.\n * \n * This includes:\n * - adjusters that ignore Saturday/Sunday weekends\n * - conversion between `TimeUnit` and `ChronoUnit`\n * - converting an amount to another unit\n *\n */\nexport class Temporals {\n    //-------------------------------------------------------------------------\n    /**\n     * Returns an adjuster that returns the next working day, ignoring Saturday and Sunday.\n     * \n     * Some territories have weekends that do not consist of Saturday and Sunday.\n     * No implementation is supplied to support this, however an adjuster\n     * can be easily written to do so.\n     *\n     * @return {TemporalAdjuster} the next working day adjuster, not null\n     */\n    static nextWorkingDay() {\n        return Adjuster.NEXT_WORKING;\n    }\n\n    /**\n     * Returns an adjuster that returns the next working day or same day if already working day, ignoring Saturday and Sunday.\n     * \n     * Some territories have weekends that do not consist of Saturday and Sunday.\n     * No implementation is supplied to support this, however an adjuster\n     * can be easily written to do so.\n     * \n     * @return {TemporalAdjuster} the next working day or same adjuster, not null\n     */\n    static nextWorkingDayOrSame() {\n        return Adjuster.NEXT_WORKING_OR_SAME;\n    }\n\n    /**\n     * Returns an adjuster that returns the previous working day, ignoring Saturday and Sunday.\n     * \n     * Some territories have weekends that do not consist of Saturday and Sunday.\n     * No implementation is supplied to support this, however an adjuster\n     * can be easily written to do so.\n     *\n     * @return {TemporalAdjuster} the previous working day adjuster, not null\n     */\n    static previousWorkingDay() {\n        return Adjuster.PREVIOUS_WORKING;\n    }\n\n    /**\n     * Returns an adjuster that returns the previous working day or same day if already working day, ignoring Saturday and Sunday.\n     * \n     * Some territories have weekends that do not consist of Saturday and Sunday.\n     * No implementation is supplied to support this, however an adjuster\n     * can be easily written to do so.\n     * \n     * @return {TemporalAdjuster} the previous working day or same adjuster, not null\n     */\n    static previousWorkingDayOrSame() {\n        return Adjuster.PREVIOUS_WORKING_OR_SAME;\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Parses the text using one of the formatters.\n     * \n     * This will try each formatter in turn, attempting to fully parse the specified text.\n     * The temporal query is typically a method reference to a `from(TemporalAccessor)` method.\n     * For example:\n     * ```\n     *  LocalDateTime dt = Temporals.parseFirstMatching(str, LocalDateTime.FROM, fm1, fm2, fm3);\n     * ```\n     * If the parse completes without reading the entire length of the text,\n     * or a problem occurs during parsing or merging, then an exception is thrown.\n     *\n     * @param {string} text  the text to parse, not null\n     * @param {TemporalQuery} query  the query defining the type to parse to, not null\n     * @param {DateTimeFormatter[]} formatters  the formatters to try, not null\n     * @return {*} the parsed date-time, not null\n     * @throws {DateTimeParseException} if unable to parse the requested result\n     */\n    static parseFirstMatching(text, query, ...formatters) {\n        requireNonNull(text, 'text');\n        requireNonNull(query, 'query');\n        requireNonNull(formatters, 'formatters');\n        if (formatters.length === 0) {\n            throw new DateTimeParseException('No formatters specified', text, 0);\n        }\n        if (formatters.length === 1) {\n            return formatters[0].parse(text, query);\n        }\n        for (const formatter of formatters) {\n            try {\n                const pp = new ParsePosition(0);\n                formatter.parseUnresolved(text, pp);\n                const len = text.length;\n                if (pp.getErrorIndex() === -1 && pp.getIndex() === len) {\n                    return formatter.parse(text, query);\n                }\n            } catch (ignored) {\n                // should not happen, but ignore if it does\n            }\n        }\n        throw new DateTimeParseException(`Text '${text}' could not be parsed`, text, 0);\n    }\n\n    //-------------------------------------------------------------------------\n    /**\n     * Converts an amount from one unit to another.\n     * \n     * This works on the units in `ChronoUnit` and `IsoFields`.\n     * The `DAYS` and `WEEKS` units are handled as exact multiple of 24 hours.\n     * The `ERAS` and `FOREVER` units are not supported.\n     *\n     * @param {long} amount  the input amount in terms of the `fromUnit`\n     * @param {TemporalUnit} fromUnit  the unit to convert from, not null\n     * @param {TemporalUnit} toUnit  the unit to convert to, not null\n     * @return {long[]} the conversion array,\n     *  element 0 is the signed whole number,\n     *  element 1 is the signed remainder in terms of the input unit,\n     *  not null\n     * @throws DateTimeException if the units cannot be converted\n     * @throws UnsupportedTemporalTypeException if the units are not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    static convertAmount(amount, fromUnit, toUnit) {\n        requireNonNull(fromUnit, 'fromUnit');\n        requireNonNull(toUnit, 'toUnit');\n        Temporals._validateUnit(fromUnit);\n        Temporals._validateUnit(toUnit);\n        if (fromUnit === toUnit) {\n            return [amount, 0];\n        }\n        // precise-based\n        if (Temporals._isPrecise(fromUnit) && Temporals._isPrecise(toUnit)) {\n            const fromNanos = fromUnit.duration().toNanos();\n            const toNanos = toUnit.duration().toNanos();\n            if (fromNanos > toNanos) {\n                const multiple = MathUtil.intDiv(fromNanos, toNanos);\n                return [MathUtil.safeMultiply(amount, multiple), 0];\n            } else {\n                const multiple = MathUtil.intDiv(toNanos, fromNanos);\n                return [MathUtil.intDiv(amount, multiple), MathUtil.intMod(amount, multiple)];\n            }\n        }\n        // month-based\n        const fromMonthFactor = Temporals._monthMonthFactor(fromUnit, fromUnit, toUnit);\n        const toMonthFactor = Temporals._monthMonthFactor(toUnit, fromUnit, toUnit);\n        if (fromMonthFactor > toMonthFactor) {\n            const multiple = MathUtil.intDiv(fromMonthFactor, toMonthFactor);\n            return [MathUtil.safeMultiply(amount, multiple), 0];\n        } else {\n            const multiple = MathUtil.intDiv(toMonthFactor, fromMonthFactor);\n            return [MathUtil.intDiv(amount, multiple), MathUtil.intMod(amount, multiple)];\n        }\n    }\n\n    /**\n     * \n     * @param {TemporalUnit} unit\n     * @private\n     */\n    static _validateUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit === ChronoUnit.ERAS || unit === ChronoUnit.FOREVER) {\n                throw new UnsupportedTemporalTypeException(`Unsupported TemporalUnit: ${unit}`);\n            }\n        } else if (unit !== IsoFields.QUARTER_YEARS) {\n            throw new UnsupportedTemporalTypeException(`Unsupported TemporalUnit: ${unit}`);\n        }\n    }\n\n    /**\n     * \n     * @param {TemporalUnit} unit\n     * @return {boolean}\n     * @private\n     */\n    static _isPrecise(unit) {\n        return unit instanceof ChronoUnit && unit.compareTo(ChronoUnit.WEEKS) <= 0;\n    }\n\n    /**\n     * \n     * @param {TemporalUnit} unit\n     * @param {TemporalUnit} fromUnit\n     * @param {TemporalUnit} toUnit\n     * @return {int}\n     * @private\n     */\n    static _monthMonthFactor(unit, fromUnit, toUnit) {\n        if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.MONTHS:\n                    return 1;\n                case ChronoUnit.YEARS:\n                    return 12;\n                case ChronoUnit.DECADES:\n                    return 120;\n                case ChronoUnit.CENTURIES:\n                    return 1200;\n                case ChronoUnit.MILLENNIA:\n                    return 12000;\n                default:\n                    throw new DateTimeException(`Unable to convert between units: ${fromUnit} to ${toUnit}`);\n            }\n        }\n        return 3; // quarters\n    }\n\n    /**\n     * Restricted constructor.\n     * \n     * @private\n     */\n    constructor() {\n    }\n}\n\nconst Adjuster = {};\n\nexport function _init() {\n    /** Next working day adjuster. */\n    Adjuster.NEXT_WORKING = new class extends TemporalAdjuster {\n        adjustInto(temporal) {\n            const dow = temporal.get(ChronoField.DAY_OF_WEEK);\n            switch (dow) {\n                case 6:  // Saturday\n                    return temporal.plus(2, ChronoUnit.DAYS);\n                case 5:  // Friday\n                    return temporal.plus(3, ChronoUnit.DAYS);\n                default:\n                    return temporal.plus(1, ChronoUnit.DAYS);\n            }\n        }\n    };\n\n    /** Previous working day adjuster. */\n    Adjuster.PREVIOUS_WORKING = new class extends TemporalAdjuster {\n        adjustInto(temporal) {\n            const dow = temporal.get(ChronoField.DAY_OF_WEEK);\n            switch (dow) {\n                case 1:  // Monday\n                    return temporal.minus(3, ChronoUnit.DAYS);\n                case 7:  // Sunday\n                    return temporal.minus(2, ChronoUnit.DAYS);\n                default:\n                    return temporal.minus(1, ChronoUnit.DAYS);\n            }\n        }\n    };\n\n    /** Next working day or same adjuster. */\n    Adjuster.NEXT_WORKING_OR_SAME = new class extends TemporalAdjuster {\n        adjustInto(temporal) {\n            const dow = temporal.get(ChronoField.DAY_OF_WEEK);\n            switch (dow) {\n                case 6: // Saturday\n                    return temporal.plus(2, ChronoUnit.DAYS);\n                case 7: // Sunday\n                    return temporal.plus(1, ChronoUnit.DAYS);\n                default:\n                    return temporal;\n            }\n        }\n    };\n\n    /** Previous working day or same adjuster. */\n    Adjuster.PREVIOUS_WORKING_OR_SAME = new class extends TemporalAdjuster {\n        adjustInto(temporal) {\n            const dow = temporal.get(ChronoField.DAY_OF_WEEK);\n            switch (dow) {\n                case 6: //Saturday\n                    return temporal.minus(1, ChronoUnit.DAYS);\n                case 7:  // Sunday\n                    return temporal.minus(2, ChronoUnit.DAYS);\n                default:\n                    return temporal;\n            }\n        }\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/Temporals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1946,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/Temporals.js",
    "static": true,
    "longname": "packages/extra/src/Temporals.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/Temporals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1947,
    "kind": "class",
    "name": "Temporals",
    "memberof": "packages/extra/src/Temporals.js",
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Temporals.js",
    "importStyle": "{Temporals}",
    "description": "Additional utilities for working with temporal classes.\n\nThis includes:\n- adjusters that ignore Saturday/Sunday weekends\n- conversion between `TimeUnit` and `ChronoUnit`\n- converting an amount to another unit",
    "lineNumber": 23,
    "interface": false
  },
  {
    "__docId__": 1948,
    "kind": "method",
    "name": "nextWorkingDay",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.nextWorkingDay",
    "access": "public",
    "description": "Returns an adjuster that returns the next working day, ignoring Saturday and Sunday.\n\nSome territories have weekends that do not consist of Saturday and Sunday.\nNo implementation is supplied to support this, however an adjuster\ncan be easily written to do so.",
    "lineNumber": 34,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the next working day adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1949,
    "kind": "method",
    "name": "nextWorkingDayOrSame",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.nextWorkingDayOrSame",
    "access": "public",
    "description": "Returns an adjuster that returns the next working day or same day if already working day, ignoring Saturday and Sunday.\n\nSome territories have weekends that do not consist of Saturday and Sunday.\nNo implementation is supplied to support this, however an adjuster\ncan be easily written to do so.",
    "lineNumber": 47,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the next working day or same adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1950,
    "kind": "method",
    "name": "previousWorkingDay",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.previousWorkingDay",
    "access": "public",
    "description": "Returns an adjuster that returns the previous working day, ignoring Saturday and Sunday.\n\nSome territories have weekends that do not consist of Saturday and Sunday.\nNo implementation is supplied to support this, however an adjuster\ncan be easily written to do so.",
    "lineNumber": 60,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the previous working day adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1951,
    "kind": "method",
    "name": "previousWorkingDayOrSame",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.previousWorkingDayOrSame",
    "access": "public",
    "description": "Returns an adjuster that returns the previous working day or same day if already working day, ignoring Saturday and Sunday.\n\nSome territories have weekends that do not consist of Saturday and Sunday.\nNo implementation is supplied to support this, however an adjuster\ncan be easily written to do so.",
    "lineNumber": 73,
    "return": {
      "nullable": null,
      "types": [
        "TemporalAdjuster"
      ],
      "spread": false,
      "description": "the previous working day or same adjuster, not null"
    },
    "params": []
  },
  {
    "__docId__": 1952,
    "kind": "method",
    "name": "parseFirstMatching",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.parseFirstMatching",
    "access": "public",
    "description": "Parses the text using one of the formatters.\n\nThis will try each formatter in turn, attempting to fully parse the specified text.\nThe temporal query is typically a method reference to a `from(TemporalAccessor)` method.\nFor example:\n```\n LocalDateTime dt = Temporals.parseFirstMatching(str, LocalDateTime.FROM, fm1, fm2, fm3);\n```\nIf the parse completes without reading the entire length of the text,\nor a problem occurs during parsing or merging, then an exception is thrown.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query defining the type to parse to, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter[]"
        ],
        "spread": false,
        "optional": false,
        "name": "formatters",
        "description": "the formatters to try, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the parsed date-time, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if unable to parse the requested result"
      }
    ]
  },
  {
    "__docId__": 1953,
    "kind": "method",
    "name": "convertAmount",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals.convertAmount",
    "access": "public",
    "description": "Converts an amount from one unit to another.\n\nThis works on the units in `ChronoUnit` and `IsoFields`.\nThe `DAYS` and `WEEKS` units are handled as exact multiple of 24 hours.\nThe `ERAS` and `FOREVER` units are not supported.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "long"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "the input amount in terms of the `fromUnit`"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fromUnit",
        "description": "the unit to convert from, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "toUnit",
        "description": "the unit to convert to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "long[]"
      ],
      "spread": false,
      "description": "the conversion array,\n element 0 is the signed whole number,\n element 1 is the signed remainder in terms of the input unit,\n not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "DateTimeException if the units cannot be converted"
      },
      {
        "types": [
          "*"
        ],
        "description": "UnsupportedTemporalTypeException if the units are not supported"
      },
      {
        "types": [
          "*"
        ],
        "description": "ArithmeticException if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1954,
    "kind": "method",
    "name": "_validateUnit",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals._validateUnit",
    "access": "private",
    "description": "",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 1955,
    "kind": "method",
    "name": "_isPrecise",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals._isPrecise",
    "access": "private",
    "description": "",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1956,
    "kind": "method",
    "name": "_monthMonthFactor",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Temporals._monthMonthFactor",
    "access": "private",
    "description": "",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fromUnit",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "toUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "int"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1957,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/Temporals.js~Temporals",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/Temporals.js~Temporals#constructor",
    "access": "private",
    "description": "Restricted constructor.",
    "lineNumber": 230,
    "ignore": true
  },
  {
    "__docId__": 1958,
    "kind": "variable",
    "name": "Adjuster",
    "memberof": "packages/extra/src/Temporals.js",
    "static": true,
    "longname": "packages/extra/src/Temporals.js~Adjuster",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/Temporals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1959,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/Temporals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/Temporals.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/Temporals.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1960,
    "kind": "file",
    "name": "packages/extra/src/YearQuarter.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField, ChronoUnit, Clock, DateTimeException, DateTimeFormatter, DateTimeFormatterBuilder, IllegalArgumentException, IsoChronology, IsoFields, LocalDate, SignStyle, Temporal, TemporalField, TemporalQueries, TemporalQuery, TemporalUnit, UnsupportedTemporalTypeException, ValueRange, Year, ZoneId } from '@js-joda/core';\nimport { Quarter } from './Quarter';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { requireInstance, requireNonNull } from './assert';\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * A year-quarter in the ISO-8601 calendar system, such as `2007-Q2`.\n *\n * `YearQuarter` is an immutable date-time object that represents the combination\n * of a year and quarter. Any field that can be derived from a year and quarter can be obtained.\n * A quarter is defined by {@link Quarter} and {@link Month.firstMonthOfQuarter} - Q1, Q2, Q3 and Q4.\n * Q1 is January to March, Q2 is April to June, Q3 is July to September and Q4 is October to December.\n *\n * This class does not store or represent a day, time or time-zone.\n * For example, the value '2nd quarter 2007' can be stored in a `YearQuarter`.\n *\n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n * Note that the ISO-8601 standard does not define or refer to quarters.\n *\n */\nexport class YearQuarter extends Temporal {\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearQuarter.now}\n     * - if called with 0 argument {@link YearQuarter._now0} is executed,\n     * - if called with 1 argument and first argument is an instance of ZoneId, then {@link YearQuarter._nowZoneId} is executed,\n     * - otherwise {@link YearQuarter._nowClock} is executed\n     *\n     * @param {ZoneId|Clock} [zoneIdOrClock=Clock.systemDefaultZone()]\n     * @return {YearQuarter}\n     */\n    static now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return YearQuarter._now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return YearQuarter._nowZoneId(zoneIdOrClock);\n        } else {\n            return YearQuarter._nowClock(zoneIdOrClock);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current year-quarter from the system clock in the default time-zone.\n     *\n     * This will query the {@link Clock.systemDefaultZone} system clock in the default\n     * time-zone to obtain the current year-quarter.\n     * The zone and offset will be set based on the time-zone in the clock.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {YearQuarter} the current year-quarter using the system clock and default time-zone, not null\n     * @protected\n     */\n    static _now0() {\n        return YearQuarter.now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year-quarter from the system clock in the specified time-zone.\n     *\n     * This will query the {@link Clock.system} to obtain the current year-quarter.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     *\n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone - the zone ID to use, not null\n     * @return {YearQuarter} the current year-quarter using the system clock, not null\n     * @protected\n     */\n    static _nowZoneId(zone) {\n        return YearQuarter.now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year-quarter from the specified clock.\n     *\n     * This will query the specified clock to obtain the current year-quarter.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock} dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, not null\n     * @return {YearQuarter} the current year-quarter, not null\n     */\n    static _nowClock(clock) {\n        const now = LocalDate.now(clock);  // called once\n        return YearQuarter.of(now.year(), Quarter.from(now.month()));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * function overloading for {@link YearQuarter.of}\n     * - if called with {Year} and {Quarter} {@link YearQuarter._ofYearQuarter} is executed,\n     * - if called with {Year} and {number} {@link YearQuarter._ofYearInt} is executed,\n     * - if called with {number} and {Quarter} {@link YearQuarter._ofIntQuarter} is executed,\n     * - if called with {number} and {number} {@link YearQuarter._ofIntInt} is executed,\n     * otherwise throws IllegalArgumentException.\n     *\n     * @param {Year|number} year\n     * @param {Quarter|number} quarter\n     * @return {YearQuarter}\n     */\n    static of(year, quarter) {\n        if (year instanceof Year && quarter instanceof Quarter) {\n            return YearQuarter._ofYearQuarter(year, quarter);\n        }\n        if (year instanceof Year && typeof quarter === 'number') {\n            return YearQuarter._ofYearInt(year, quarter);\n        }\n        if (typeof year === 'number' && quarter instanceof Quarter) {\n            return YearQuarter._ofIntQuarter(year, quarter);\n        }\n        if (typeof year === 'number' && typeof quarter === 'number') {\n            return YearQuarter._ofIntInt(year, quarter);\n        }\n        // FIXME\n        const yearMessage = `year must be an instance of Year or number but is ${year.constructor.name}`;\n        const quarterMessage = `quarter must be an instance of Quarter or number but is ${quarter.constructor.name}`;\n        throw new IllegalArgumentException(`${yearMessage} and ${quarterMessage}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `YearQuarter` from a year and quarter.\n     *\n     * @param {Year} year - the year to represent, not null\n     * @param {Quarter} quarter - the quarter-of-year to represent, not null\n     * @return {YearQuarter} the year-quarter, not null\n     * @protected\n     */\n    // FIXME ambiguous name?\n    static _ofYearQuarter(year, quarter) {\n        return YearQuarter.of(year.value(), quarter);\n    }\n\n    /**\n     * Obtains an instance of `YearQuarter` from a year and quarter.\n     *\n     * @param {Year} year - the year to represent, not null\n     * @param {number} quarter - the quarter-of-year to represent, from 1 to 4\n     * @return {YearQuarter} the year-quarter, not null\n     * @throws {DateTimeException} if the quarter value is invalid\n     * @protected\n     */\n    static _ofYearInt(year, quarter) {\n        return YearQuarter.of(year.value(), Quarter.of(quarter));\n    }\n\n    /**\n     * Obtains an instance of `YearQuarter` from a year and quarter.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {Quarter} quarter - the quarter-of-year to represent, not null\n     * @return {YearQuarter} the year-quarter, not null\n     * @throws {DateTimeException} if the year value is invalid\n     * @protected\n     */\n    static _ofIntQuarter(year, quarter) {\n        ChronoField.YEAR.checkValidValue(year);\n        requireNonNull(quarter, 'quarter');\n        return new YearQuarter(year, quarter);\n    }\n\n    /**\n     * Obtains an instance of `YearQuarter` from a year and quarter.\n     *\n     * @param {number} year - the year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} quarter - the quarter-of-year to represent, from 1 to 4\n     * @return {YearQuarter} the year-quarter, not null\n     * @throws {DateTimeException} if either field value is invalid\n     * @protected\n     */\n    static _ofIntInt(year, quarter) {\n        ChronoField.YEAR.checkValidValue(year);\n        return new YearQuarter(year, Quarter.of(quarter));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `YearQuarter` from a temporal object.\n     *\n     * This obtains a year-quarter based on the specified temporal.\n     * A `TemporalAccessor` represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of `YearQuarter`.\n     *\n     * The conversion extracts the {@link ChronoField.YEAR} and\n     * {@link IsoFields.QUARTER_OF_YEAR} fields.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a `LocalDate`.\n     *\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, `YearQuarter.FROM`.\n     *\n     * @param {TemporalAccessor} temporal - the temporal object to convert, not null\n     * @return {YearQuarter} the year-quarter, not null\n     * @throws {DateTimeException} if unable to convert to a `YearQuarter`\n     */\n    static from(temporal) {\n        if (temporal instanceof YearQuarter) {\n            return temporal;\n        }\n        requireNonNull(temporal, 'temporal');\n        try {\n            /* TODO: only IsoChronology for now\n            if (IsoChronology.INSTANCE.equals(Chronology.from(temporal)) == false) {\n                temporal = LocalDate.from(temporal);\n            }\n            */\n            // need to use getLong() as JDK Parsed class get() doesn't work properly\n            const year = MathUtil.safeToInt(temporal.getLong(ChronoField.YEAR));\n            const qoy = MathUtil.safeToInt(temporal.getLong(IsoFields.QUARTER_OF_YEAR));\n            return YearQuarter.of(year, qoy);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain YearQuarter from TemporalAccessor: ${temporal} of type ${temporal.constructor.name}`, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of `YearQuarter` from a text string using a specific formatter.\n     *\n     * The text is parsed using the formatter, returning a year-quarter.\n     *\n     * @param {string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=YearQuarter.PARSER] - the formatter to use, default is {@link YearQuarter.PARSER}\n     * @return {YearQuarter} the parsed year-quarter, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = YearQuarter.PARSER) {\n        requireNonNull(formatter, 'formatter');\n        requireInstance(formatter, DateTimeFormatter, 'formatter');\n        return formatter.parse(text, YearQuarter.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {number} year - the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {Quarter} quarter - the quarter-of-year to represent, validated not null\n     * @private\n     */\n    constructor(year, quarter) {\n        super();\n        this._year = MathUtil.safeToInt(year);\n        this._quarter = requireInstance(quarter, Quarter, 'Quarter');\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the new year and quarter, checking\n     * to see if a new object is in fact required.\n     *\n     * @param {number} newYear - the year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {Quarter} newQuarter - the quarter-of-year to represent, validated not null\n     * @return {YearQuarter} the year-quarter, not null\n     * @private\n     */\n    _with(newYear, newQuarter) {\n        if (this._year === newYear && this._quarter === newQuarter) {\n            return this;\n        }\n        return new YearQuarter(newYear, newQuarter);\n    }\n\n    /**\n     * function overloading for {@link YearWeek.isSupported}\n     * - if called with an instance of {@link TemporalField}, then {@link YearWeek.isSupportedField} is executed,\n     * - if called with an instance of {@link TemporalUnit}, then {@link YearWeek.isSupportedUnit} is executed,\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit\n     * @return {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof TemporalField) {\n            return this._isSupportedField(fieldOrUnit);\n        }\n        if (fieldOrUnit instanceof TemporalUnit) {\n            return this._isSupportedUnit(fieldOrUnit);\n        }\n        if (fieldOrUnit == null) {\n            return false;\n        }\n        throw new IllegalArgumentException(`fieldOrUnit must be an instance of TemporalField or TemporalUnit, but is ${fieldOrUnit.constructor.name}`);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     *\n     * This checks if this year-quarter can be queried for the specified field.\n     * If false, then calling the {@link YearQuarter.range},\n     * {@link YearQuarter.get} and {@link YearQuarter.with}\n     * methods will throw an exception.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The supported fields are:\n     *\n     * - `QUARTER_OF_YEAR`\n     * - `YEAR_OF_ERA`\n     * - `YEAR`\n     * - `ERA`\n     *\n     * All other `ChronoField` instances will return false.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year-quarter, false if not\n     * @protected\n     */\n    _isSupportedField(field) {\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return true;\n        } else if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     *\n     * This checks if the specified unit can be added to, or subtracted from, this year-quarter.\n     * If false, then calling the {@link YearQuarter.plus} and\n     * {@link YearQuarter.minus} methods will throw an exception.\n     *\n     * If the unit is a {@link ChronoUnit} then the query is implemented here.\n     * The supported units are:\n     *\n     * - `QUARTER_YEARS`\n     * - `YEARS`\n     * - `DECADES`\n     * - `CENTURIES`\n     * - `MILLENNIA`\n     * - `ERAS`\n     *\n     * All other `ChronoUnit` instances will return false.\n     *\n     * If the unit is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`\n     * passing `this` as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param {TemporalUnit} unit - the unit to check, null returns false\n     * @return {boolean} true if the unit can be added/subtracted, false if not\n     * @protected\n     */\n    _isSupportedUnit(unit) {\n        if (unit === IsoFields.QUARTER_YEARS) {\n            return true;\n        } else if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     *\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year-quarter is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link YearQuarter.isSupported} supported fields will return\n     * appropriate range instances.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\n     * passing `this` as the argument.\n     * Whether the range can be obtained is determined by the field.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return IsoFields.QUARTER_OF_YEAR.range();\n        }\n        if (field === ChronoField.YEAR_OF_ERA) {\n            return (this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE));\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-quarter as an `int`.\n     *\n     * This queries this year-quarter for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link YearQuarter.isSupported} supported fields will return valid\n     * values based on this year-quarter,.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *  the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *  the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-quarter as a `long`.\n     *\n     * This queries this year-quarter for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@link YearQuarter.isSupported} supported fields will return valid\n     * values based on this year-quarter.\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\n     * passing `this` as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return this._quarter.value();\n        } else if (field instanceof ChronoField) {\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA:\n                    return (this._year < 1 ? 1 - this._year : this._year);\n                case ChronoField.YEAR:\n                    return this._year;\n                case ChronoField.ERA:\n                    return (this._year < 1 ? 0 : 1);\n                default:\n                    throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n            }\n        }\n        return super.get(field);\n    }\n\n    /**\n     * @private\n     */\n    _prolepticQuarter() {\n        return this._year * 4 + (this._quarter.value() - 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the year field.\n     *\n     * This method returns the primitive `int` value for the year.\n     *\n     * The year returned by this method is proleptic as per `get(YEAR)`.\n     *\n     * @return {number} the year, from MIN_YEAR to MAX_YEAR\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     * Gets the quarter-of-year field from 1 to 4.\n     *\n     * This method returns the quarter as an `int` from 1 to 4.\n     * Application code is frequently clearer if the enum {@link Quarter}\n     * is used by calling {@link YearQuarter.getQuarter}.\n     *\n     * @return {number} the quarter-of-year, from 1 to 4\n     * @see {@link YearQuarter.quarter}\n     */\n    quarterValue() {\n        return this._quarter.value();\n    }\n\n    /**\n     * Gets the quarter-of-year field using the `Quarter` enum.\n     *\n     * This method returns the enum {@link Quarter} for the quarter.\n     * This avoids confusion as to what `int` values mean.\n     * If you need access to the primitive `int` value then the enum\n     * provides the {@link Quarter.value}.\n     *\n     * @return {Quarter} the quarter-of-year, not null\n     * @see {@link YearQuarter.quarterValue}\n     */\n    quarter() {\n        return this._quarter;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the year is a leap year, according to the ISO proleptic\n     * calendar system rules.\n     *\n     * This method applies the current rules for leap years across the whole time-line.\n     * In general, a year is a leap year if it is divisible by four without\n     * remainder. However, years divisible by 100, are not leap years, with\n     * the exception of years divisible by 400 which are.\n     *\n     * For example, 1904 is a leap year it is divisible by 4.\n     * 1900 was not a leap year as it is divisible by 100, however 2000 was a\n     * leap year as it is divisible by 400.\n     *\n     * The calculation is proleptic - applying the same rules into the far future and far past.\n     * This is historically inaccurate, but is correct for the ISO-8601 standard.\n     *\n     * @return {boolean} true if the year is leap, false otherwise\n     */\n    isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    }\n\n    /**\n     * Checks if the day-of-quarter is valid for this year-quarter.\n     *\n     * This method checks whether this year and quarter and the input day form\n     * a valid date.\n     *\n     * @param {number} dayOfQuarter - the day-of-quarter to validate, from 1 to 92, invalid value returns false\n     * @return {boolean} true if the day is valid for this year-quarter\n     */\n    isValidDay(dayOfQuarter) {\n        return dayOfQuarter >= 1 && dayOfQuarter <= this.lengthOfQuarter();\n    }\n\n    /**\n     * Returns the length of the quarter, taking account of the year.\n     *\n     * This returns the length of the quarter in days.\n     *\n     * @return {number} the length of the quarter in days, from 90 to 92\n     */\n    lengthOfQuarter() {\n        return this._quarter.length(this.isLeapYear());\n    }\n\n    /**\n     * Returns the length of the year.\n     *\n     * This returns the length of the year in days, either 365 or 366.\n     *\n     * @return {number} 366 if the year is leap, 365 otherwise\n     */\n    lengthOfYear() {\n        return (this.isLeapYear() ? 366 : 365);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this year-quarter.\n     *\n     * This returns a {@code YearQuarter} based on this one, with the year-quarter adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     *\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the year-quarter to the next quarter that\n     * Halley's comet will pass the Earth.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjuster#adjustInto(Temporal)} method on the\n     * specified adjuster passing {@code this} as the argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - the adjuster to use, not null\n     * @return {YearQuarter} based on {@code this} with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof YearQuarter) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified field set to a new value.\n     *\n     * This returns a `YearQuarter` based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year or quarter.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * - `QUARTER_OF_YEAR` -\n     *  Returns a `YearQuarter` with the specified quarter-of-year.\n     *  The year will be unchanged.\n     * - `YEAR_OF_ERA` -\n     *  Returns a `YearQuarter` with the specified year-of-era\n     *  The quarter and era will be unchanged.\n     * - `YEAR` -\n     *  Returns a `YearQuarter` with the specified year.\n     *  The quarter will be unchanged.\n     * - `ERA` -\n     *  Returns a `YearQuarter` with the specified era.\n     *  The quarter and year-of-era will be unchanged.\n     *\n     * In all cases, if the new value is outside the valid range of values for the field\n     * then a `DateTimeException` will be thrown.\n     *\n     * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoField`, then the result of this method\n     * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`\n     * passing `this` as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {YearQuarter} a `YearQuarter` based on `this` with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        requireNonNull(field, 'field');\n        requireInstance(field, TemporalField, 'field');\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            return this.withQuarter(IsoFields.QUARTER_OF_YEAR.range().checkValidIntValue(newValue, IsoFields.QUARTER_OF_YEAR));\n        } else if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch (field) {\n                case ChronoField.YEAR_OF_ERA:\n                    return this.withYear(this._year < 1 ? 1 - newValue : newValue);\n                case ChronoField.YEAR:\n                    return this.withYear(newValue);\n                case ChronoField.ERA:\n                    return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n                default:\n                    throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a copy of this `YearQuarter` with the year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} year - the year to set in the returned year-quarter, from MIN_YEAR to MAX_YEAR\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the requested year, not null\n     * @throws {DateTimeException} if the year value is invalid\n     */\n    withYear(year) {\n        ChronoField.YEAR.checkValidValue(year);\n        return this._with(year, this._quarter);\n    }\n\n    /**\n     * Returns a copy of this `YearQuarter` with the quarter-of-year altered.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} quarter - the quarter-of-year to set in the returned year-quarter, from 1 to 4\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the requested quarter, not null\n     * @throws {DateTimeException} if the quarter-of-year value is invalid\n     */\n    withQuarter(quarter) {\n        IsoFields.QUARTER_OF_YEAR.range().checkValidValue(quarter, IsoFields.QUARTER_OF_YEAR);\n        return this._with(this._year, Quarter.of(quarter));\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified amount added.\n     *\n     * This returns a `YearQuarter` based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     *\n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     *\n     * - `QUARTER_YEARS` -\n     *  Returns a `YearQuarter` with the specified number of quarters added.\n     *  This is equivalent to {@link YearQuarter.plusQuarters}.\n     * - `YEARS` -\n     *  Returns a `YearQuarter` with the specified number of years added.\n     *  This is equivalent to {@link YearQuarter.plusYears}.\n     * - `DECADES` -\n     *  Returns a `YearQuarter` with the specified number of decades added.\n     *  This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n     *  multiplied by 10.\n     * - `CENTURIES` -\n     *  Returns a `YearQuarter` with the specified number of centuries added.\n     *  This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n     *  multiplied by 100.\n     * - `MILLENNIA` -\n     *  Returns a `YearQuarter` with the specified number of millennia added.\n     *  This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n     *  multiplied by 1,000.\n     * - `ERAS` -\n     *  Returns a `YearQuarter` with the specified number of eras added.\n     *  Only two eras are supported so the amount must be one, zero or minus one.\n     *  If the amount is non-zero then the year is changed such that the year-of-era\n     *  is unchanged.\n     *\n     * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.\n     *\n     * If the field is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`\n     * passing `this` as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the amount to add, not null\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the specified amount added, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _plusUnit(amountToAdd, unit) {\n        if (unit === IsoFields.QUARTER_YEARS) {\n            return this.plusQuarters(amountToAdd);\n        } else if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.YEARS:\n                    return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS:\n                    return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n                default:\n                    throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n            }\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified period in years added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToAdd - the years to add, may be negative\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the years added, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);  // safe overflow\n        return this._with(newYear, this._quarter);\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified period in quarters added.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} quartersToAdd - the quarters to add, may be negative\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the quarters added, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    plusQuarters(quartersToAdd) {\n        if (quartersToAdd === 0) {\n            return this;\n        }\n        const quarterCount = this._year * 4 + (this._quarter.value() - 1);\n        const calcQuarters = quarterCount + quartersToAdd;  // safe overflow\n        const newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.intDiv(calcQuarters, 4));\n        const newQuarter = MathUtil.floorMod(calcQuarters, 4) + 1;\n        return this._with(newYear, Quarter.of(newQuarter));\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified period in years subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} yearsToSubtract - the years to subtract, may be negative\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the years subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    minusYears(yearsToSubtract) {\n        return (yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract));\n    }\n\n    /**\n     * Returns a copy of this year-quarter with the specified period in quarters subtracted.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} quartersToSubtract - the quarters to subtract, may be negative\n     * @return {YearQuarter} a `YearQuarter` based on this year-quarter with the quarters subtracted, not null\n     * @throws {DateTimeException} if the result exceeds the supported range\n     */\n    minusQuarters(quartersToSubtract) {\n        return (quartersToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusQuarters(MathUtil.MIN_SAFE_INTEGER).plusQuarters(1) : this.plusQuarters(-quartersToSubtract));\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year-quarter using the specified query.\n     *\n     * This queries this year-quarter using the specified query strategy object.\n     * The `TemporalQuery` object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     *\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom} method on the\n     * specified query passing `this` as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (query === TemporalQueries.precision()) {\n            return IsoFields.QUARTER_YEARS;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year-quarter.\n     *\n     * This returns a temporal object of the same observable type as the input\n     * with the year and quarter changed to be the same as this.\n     *\n     * The adjustment is equivalent to using {@link Temporal.plus}\n     * passing the number of quarters to adjust by.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a `DateTimeException` is thrown.\n     *\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * ```\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYearQuarter.adjustInto(temporal);\n     *   temporal = temporal.with(thisYearQuarter);\n     * ```\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        /* TODO: only IsoChronology for now\n        if (Chronology.from(temporal).equals(IsoChronology.INSTANCE) == false) {\n            throw new DateTimeException('Adjustment only supported on ISO date-time');\n        }*/\n        const newProlepticQuarter = this._prolepticQuarter();\n        const oldProlepticQuarter = temporal.get(ChronoField.YEAR) * 4 + (temporal.get(IsoFields.QUARTER_OF_YEAR) - 1);\n        return temporal.plus(newProlepticQuarter - oldProlepticQuarter, IsoFields.QUARTER_YEARS);\n    }\n\n    /**\n     * Calculates the amount of time until another year-quarter in terms of the specified unit.\n     *\n     * This calculates the amount of time between two `YearQuarter`\n     * objects in terms of a single `TemporalUnit`.\n     * The start and end points are `this` and the specified year-quarter.\n     * The result will be negative if the end is before the start.\n     * The `Temporal` passed to this method is converted to a\n     * `YearQuarter` using {@link YearQuarter.from}.\n     * For example, the period in years between two year-quarters can be calculated\n     * using `startYearQuarter.until(endYearQuarter, YEARS)`.\n     *\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two year-quarters.\n     * For example, the period in decades between 2012-Q3 and 2032-Q2\n     * will only be one decade as it is one quarter short of two decades.\n     *\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit.between}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   amount = start.until(end, QUARTER_YEARS);\n     *   amount = QUARTER_YEARS.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     *\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units `QUARTER_YEARS`, `YEARS`, `DECADES`,\n     * `CENTURIES`, `MILLENNIA` and `ERAS` are supported.\n     * Other `ChronoUnit` values will throw an exception.\n     *\n     * If the unit is not a `ChronoUnit`, then the result of this method\n     * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`\n     * passing `this` as the first argument and the converted input temporal\n     * as the second argument.\n     *\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, exclusive, which is converted to a `YearQuarter`, not null\n     * @param {TemporalUnit} unit - the unit to measure the amount in, not null\n     * @return {number} the amount of time between this year-quarter and the end year-quarter\n     * @throws {DateTimeException} if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a `YearQuarter`\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        requireNonNull(endExclusive, 'endExclusive');\n        requireNonNull(unit, 'unit');\n        requireInstance(endExclusive, Temporal, 'endExclusive');\n        requireInstance(unit, TemporalUnit, 'unit');\n\n        const end = YearQuarter.from(endExclusive);\n        const quartersUntil = end._prolepticQuarter() - this._prolepticQuarter();  // no overflow\n        if (unit === IsoFields.QUARTER_YEARS) {\n            return quartersUntil;\n        } else if (unit instanceof ChronoUnit) {\n            switch (unit) {\n                case ChronoUnit.YEARS:\n                    return MathUtil.intDiv(quartersUntil, 4);\n                case ChronoUnit.DECADES:\n                    return MathUtil.intDiv(quartersUntil, 40);\n                case ChronoUnit.CENTURIES:\n                    return MathUtil.intDiv(quartersUntil, 400);\n                case ChronoUnit.MILLENNIA:\n                    return MathUtil.intDiv(quartersUntil, 4000);\n                case ChronoUnit.ERAS:\n                    return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n                default:\n                    throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n            }\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * Formats this year-quarter using the specified formatter.\n     *\n     * This year-quarter will be passed to the formatter to produce a string.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted year-quarter string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year-quarter with a day-of-quarter to create a `LocalDate`.\n     *\n     * This returns a `LocalDate` formed from this year-quarter and the specified day-of-quarter.\n     *\n     * The day-of-quarter value must be valid for the year-quarter.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * ```\n     *  LocalDate date = yearQuarter.atDay(day);\n     * ```\n     *\n     * @param {number} dayOfQuarter the day-of-quarter to use, from 1 to 92\n     * @return {LocalDate} the date formed from this year-quarter and the specified day, not null\n     * @throws {DateTimeException} if the day is invalid for the year-quarter\n     * @see {@link YearQuarter.isValidDay}\n     */\n    atDay(dayOfQuarter) {\n        ValueRange.of(1, this.lengthOfQuarter()).checkValidValue(dayOfQuarter, IsoFields.DAY_OF_QUARTER);\n        const leap = Year.isLeap(this._year);\n        let month = this._quarter.firstMonth();\n        while (dayOfQuarter > month.length(leap)) {\n            dayOfQuarter -= month.length(leap);\n            month = month.plus(1);\n        }\n        return LocalDate.of(this._year, month, dayOfQuarter);\n    }\n\n    /**\n     * Returns a `LocalDate` at the end of the quarter.\n     *\n     * This returns a `LocalDate` based on this year-quarter.\n     * The day-of-quarter is set to the last valid day of the quarter, taking\n     * into account leap years.\n     *\n     * This method can be used as part of a chain to produce a date:\n     * ```\n     *  LocalDate date = year.atQuarter(quarter).atEndOfQuarter();\n     * ```\n     *\n     * @return {LocalDate} the last valid date of this year-quarter, not null\n     */\n    atEndOfQuarter() {\n        const month = this._quarter.firstMonth().plus(2);\n        return LocalDate.of(this._year, month, month.maxLength());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year-quarter to another\n     *\n     * The comparison is based first on the value of the year, then on the value of the quarter.\n     * It is 'consistent with equals', as defined by {@link Comparable}.\n     *\n     * @param {YearQuarter} other - the other year-quarter to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, YearQuarter, 'other');\n        let cmp = (this._year - other._year);\n        if (cmp === 0) {\n            cmp = this._quarter.compareTo(other._quarter);\n        }\n        return cmp;\n    }\n\n    /**\n     * Is this year-quarter after the specified year-quarter.\n     *\n     * @param {YearQuarter} other - the other year-quarter to compare to, not null\n     * @return {boolean} true if this is after the specified year-quarter\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this year-quarter before the specified year-quarter.\n     *\n     * @param {YearQuarter} other - the other year-quarter to compare to, not null\n     * @return {boolean} true if this point is before the specified year-quarter\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this year-quarter is equal to another year-quarter.\n     *\n     * The comparison is based on the time-line position of the year-quarters.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other year-quarter\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearQuarter) {\n            const other = obj;\n            return this._year === other._year && this._quarter === other._quarter;\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this year-quarter.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._year ^ (this._quarter.value() << 27);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this year-quarter as a `String`, such as `2007-Q2`.\n     *\n     * The output will be in the format `uuuu-'Q'Q`:\n     *\n     * @return {string} a string representation of this year-quarter, not null\n     */\n    toString() {\n        let yearString;\n        const yearValue = this._year;\n        const absYear = Math.abs(yearValue);\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = `-${(`${yearValue - 10000}`).slice(-4)}`;\n            } else {\n                yearString = (`${yearValue + 10000}`).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = `+${yearValue}`;\n            } else {\n                yearString = `${yearValue}`;\n            }\n        }\n        return yearString.concat('-').concat(this._quarter);\n    }\n}\n\nexport function _init() {\n    YearQuarter.PARSER = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-')\n        .appendLiteral('Q')\n        .appendValue(IsoFields.QUARTER_OF_YEAR, 1)\n        .toFormatter();\n\n    YearQuarter.FROM = createTemporalQuery('YearQuarter.FROM', (temporal) => {\n        return YearQuarter.from(temporal);\n    });\n}\n\n// copied from packages/core/src/temporal/TemporalQuery.js\nfunction createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/YearQuarter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1961,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/YearQuarter.js",
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/YearQuarter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1962,
    "kind": "class",
    "name": "YearQuarter",
    "memberof": "packages/extra/src/YearQuarter.js",
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/YearQuarter.js",
    "importStyle": "{YearQuarter}",
    "description": "A year-quarter in the ISO-8601 calendar system, such as `2007-Q2`.\n\n`YearQuarter` is an immutable date-time object that represents the combination\nof a year and quarter. Any field that can be derived from a year and quarter can be obtained.\nA quarter is defined by {@link Quarter} and {@link Month.firstMonthOfQuarter} - Q1, Q2, Q3 and Q4.\nQ1 is January to March, Q2 is April to June, Q3 is July to September and Q4 is October to December.\n\nThis class does not store or represent a day, time or time-zone.\nFor example, the value '2nd quarter 2007' can be stored in a `YearQuarter`.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\nNote that the ISO-8601 standard does not define or refer to quarters.",
    "lineNumber": 36,
    "interface": false,
    "extends": [
      "@js-joda/core~Temporal"
    ]
  },
  {
    "__docId__": 1963,
    "kind": "method",
    "name": "now",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter.now",
    "access": "public",
    "description": "function overloading for {@link YearQuarter.now}\n- if called with 0 argument {@link YearQuarter._now0} is executed,\n- if called with 1 argument and first argument is an instance of ZoneId, then {@link YearQuarter._nowZoneId} is executed,\n- otherwise {@link YearQuarter._nowClock} is executed",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Clock.systemDefaultZone()",
        "defaultRaw": "Clock.systemDefaultZone()",
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1964,
    "kind": "method",
    "name": "_now0",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._now0",
    "access": "protected",
    "description": "Obtains the current year-quarter from the system clock in the default time-zone.\n\nThis will query the {@link Clock.systemDefaultZone} system clock in the default\ntime-zone to obtain the current year-quarter.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 71,
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the current year-quarter using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 1965,
    "kind": "method",
    "name": "_nowZoneId",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._nowZoneId",
    "access": "protected",
    "description": "Obtains the current year-quarter from the system clock in the specified time-zone.\n\nThis will query the {@link Clock.system} to obtain the current year-quarter.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the current year-quarter using the system clock, not null"
    }
  },
  {
    "__docId__": 1966,
    "kind": "method",
    "name": "_nowClock",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._nowClock",
    "access": "private",
    "description": "Obtains the current year-quarter from the specified clock.\n\nThis will query the specified clock to obtain the current year-quarter.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using {@link Clock} dependency injection.",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the current year-quarter, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 1967,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter.of",
    "access": "public",
    "description": "function overloading for {@link YearQuarter.of}\n- if called with {Year} and {Quarter} {@link YearQuarter._ofYearQuarter} is executed,\n- if called with {Year} and {number} {@link YearQuarter._ofYearInt} is executed,\n- if called with {number} and {Quarter} {@link YearQuarter._ofIntQuarter} is executed,\n- if called with {number} and {number} {@link YearQuarter._ofIntInt} is executed,\notherwise throws IllegalArgumentException.",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Quarter",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1968,
    "kind": "method",
    "name": "_ofYearQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._ofYearQuarter",
    "access": "protected",
    "description": "Obtains an instance of `YearQuarter` from a year and quarter.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, not null"
      },
      {
        "nullable": null,
        "types": [
          "Quarter"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to represent, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    }
  },
  {
    "__docId__": 1969,
    "kind": "method",
    "name": "_ofYearInt",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._ofYearInt",
    "access": "protected",
    "description": "Obtains an instance of `YearQuarter` from a year and quarter.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to represent, from 1 to 4"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the quarter value is invalid"
      }
    ]
  },
  {
    "__docId__": 1970,
    "kind": "method",
    "name": "_ofIntQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._ofIntQuarter",
    "access": "protected",
    "description": "Obtains an instance of `YearQuarter` from a year and quarter.",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "Quarter"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to represent, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 1971,
    "kind": "method",
    "name": "_ofIntInt",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter._ofIntInt",
    "access": "protected",
    "description": "Obtains an instance of `YearQuarter` from a year and quarter.",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to represent, from 1 to 4"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if either field value is invalid"
      }
    ]
  },
  {
    "__docId__": 1972,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter.from",
    "access": "public",
    "description": "Obtains an instance of `YearQuarter` from a temporal object.\n\nThis obtains a year-quarter based on the specified temporal.\nA `TemporalAccessor` represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of `YearQuarter`.\n\nThe conversion extracts the {@link ChronoField.YEAR} and\n{@link IsoFields.QUARTER_OF_YEAR} fields.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a `LocalDate`.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, `YearQuarter.FROM`.",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAccessor"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a `YearQuarter`"
      }
    ]
  },
  {
    "__docId__": 1973,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter.parse",
    "access": "public",
    "description": "Obtains an instance of `YearQuarter` from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a year-quarter.",
    "lineNumber": 246,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "YearQuarter.PARSER",
        "defaultRaw": "YearQuarter.PARSER",
        "name": "formatter",
        "description": "the formatter to use, default is {@link YearQuarter.PARSER}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the parsed year-quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 1974,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 260,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, validated from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "Quarter"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to represent, validated not null"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1975,
    "kind": "member",
    "name": "_year",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_year",
    "access": "private",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1976,
    "kind": "member",
    "name": "_quarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_quarter",
    "access": "private",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1977,
    "kind": "method",
    "name": "_with",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_with",
    "access": "private",
    "description": "Returns a copy of this year-quarter with the new year and quarter, checking\nto see if a new object is in fact required.",
    "lineNumber": 275,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newYear",
        "description": "the year to represent, validated from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "Quarter"
        ],
        "spread": false,
        "optional": false,
        "name": "newQuarter",
        "description": "the quarter-of-year to represent, validated not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "the year-quarter, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 1978,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#isSupported",
    "access": "public",
    "description": "function overloading for {@link YearWeek.isSupported}\n- if called with an instance of {@link TemporalField}, then {@link YearWeek.isSupportedField} is executed,\n- if called with an instance of {@link TemporalUnit}, then {@link YearWeek.isSupportedUnit} is executed,\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 291,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1979,
    "kind": "method",
    "name": "_isSupportedField",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_isSupportedField",
    "access": "protected",
    "description": "Checks if the specified field is supported.\n\nThis checks if this year-quarter can be queried for the specified field.\nIf false, then calling the {@link YearQuarter.range},\n{@link YearQuarter.get} and {@link YearQuarter.with}\nmethods will throw an exception.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe supported fields are:\n\n- `QUARTER_OF_YEAR`\n- `YEAR_OF_ERA`\n- `YEAR`\n- `ERA`\n\nAll other `ChronoField` instances will return false.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this year-quarter, false if not"
    }
  },
  {
    "__docId__": 1980,
    "kind": "method",
    "name": "_isSupportedUnit",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_isSupportedUnit",
    "access": "protected",
    "description": "Checks if the specified unit is supported.\n\nThis checks if the specified unit can be added to, or subtracted from, this year-quarter.\nIf false, then calling the {@link YearQuarter.plus} and\n{@link YearQuarter.minus} methods will throw an exception.\n\nIf the unit is a {@link ChronoUnit} then the query is implemented here.\nThe supported units are:\n\n- `QUARTER_YEARS`\n- `YEARS`\n- `DECADES`\n- `CENTURIES`\n- `MILLENNIA`\n- `ERAS`\n\nAll other `ChronoUnit` instances will return false.\n\nIf the unit is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`\npassing `this` as the argument.\nWhether the unit is supported is determined by the unit.",
    "lineNumber": 369,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the unit can be added/subtracted, false if not"
    }
  },
  {
    "__docId__": 1981,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis year-quarter is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link YearQuarter.isSupported} supported fields will return\nappropriate range instances.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`\npassing `this` as the argument.\nWhether the range can be obtained is determined by the field.",
    "lineNumber": 402,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 1982,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#get",
    "access": "public",
    "description": "Gets the value of the specified field from this year-quarter as an `int`.\n\nThis queries this year-quarter for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link YearQuarter.isSupported} supported fields will return valid\nvalues based on this year-quarter,.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 440,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1983,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this year-quarter as a `long`.\n\nThis queries this year-quarter for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the query is implemented here.\nThe {@link YearQuarter.isSupported} supported fields will return valid\nvalues based on this year-quarter.\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.getFrom(TemporalAccessor)`\npassing `this` as the argument. Whether the value can be obtained,\nand what the value represents, is determined by the field.",
    "lineNumber": 469,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 1984,
    "kind": "method",
    "name": "_prolepticQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_prolepticQuarter",
    "access": "private",
    "description": "",
    "lineNumber": 492,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1985,
    "kind": "method",
    "name": "year",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#year",
    "access": "public",
    "description": "Gets the year field.\n\nThis method returns the primitive `int` value for the year.\n\nThe year returned by this method is proleptic as per `get(YEAR)`.",
    "lineNumber": 506,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the year, from MIN_YEAR to MAX_YEAR"
    },
    "params": []
  },
  {
    "__docId__": 1986,
    "kind": "method",
    "name": "quarterValue",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#quarterValue",
    "access": "public",
    "description": "Gets the quarter-of-year field from 1 to 4.\n\nThis method returns the quarter as an `int` from 1 to 4.\nApplication code is frequently clearer if the enum {@link Quarter}\nis used by calling {@link YearQuarter.getQuarter}.",
    "see": [
      "{@link YearQuarter.quarter}"
    ],
    "lineNumber": 520,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the quarter-of-year, from 1 to 4"
    },
    "params": []
  },
  {
    "__docId__": 1987,
    "kind": "method",
    "name": "quarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#quarter",
    "access": "public",
    "description": "Gets the quarter-of-year field using the `Quarter` enum.\n\nThis method returns the enum {@link Quarter} for the quarter.\nThis avoids confusion as to what `int` values mean.\nIf you need access to the primitive `int` value then the enum\nprovides the {@link Quarter.value}.",
    "see": [
      "{@link YearQuarter.quarterValue}"
    ],
    "lineNumber": 535,
    "return": {
      "nullable": null,
      "types": [
        "Quarter"
      ],
      "spread": false,
      "description": "the quarter-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 1988,
    "kind": "method",
    "name": "isLeapYear",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#isLeapYear",
    "access": "public",
    "description": "Checks if the year is a leap year, according to the ISO proleptic\ncalendar system rules.\n\nThis method applies the current rules for leap years across the whole time-line.\nIn general, a year is a leap year if it is divisible by four without\nremainder. However, years divisible by 100, are not leap years, with\nthe exception of years divisible by 400 which are.\n\nFor example, 1904 is a leap year it is divisible by 4.\n1900 was not a leap year as it is divisible by 100, however 2000 was a\nleap year as it is divisible by 400.\n\nThe calculation is proleptic - applying the same rules into the far future and far past.\nThis is historically inaccurate, but is correct for the ISO-8601 standard.",
    "lineNumber": 558,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year is leap, false otherwise"
    },
    "params": []
  },
  {
    "__docId__": 1989,
    "kind": "method",
    "name": "isValidDay",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#isValidDay",
    "access": "public",
    "description": "Checks if the day-of-quarter is valid for this year-quarter.\n\nThis method checks whether this year and quarter and the input day form\na valid date.",
    "lineNumber": 571,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfQuarter",
        "description": "the day-of-quarter to validate, from 1 to 92, invalid value returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the day is valid for this year-quarter"
    }
  },
  {
    "__docId__": 1990,
    "kind": "method",
    "name": "lengthOfQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#lengthOfQuarter",
    "access": "public",
    "description": "Returns the length of the quarter, taking account of the year.\n\nThis returns the length of the quarter in days.",
    "lineNumber": 582,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the length of the quarter in days, from 90 to 92"
    },
    "params": []
  },
  {
    "__docId__": 1991,
    "kind": "method",
    "name": "lengthOfYear",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#lengthOfYear",
    "access": "public",
    "description": "Returns the length of the year.\n\nThis returns the length of the year in days, either 365 or 366.",
    "lineNumber": 593,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "366 if the year is leap, 365 otherwise"
    },
    "params": []
  },
  {
    "__docId__": 1992,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this year-quarter.\n\nThis returns a {@code YearQuarter} based on this one, with the year-quarter adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nA simple adjuster might simply set the one of the fields, such as the year field.\nA more complex adjuster might set the year-quarter to the next quarter that\nHalley's comet will pass the Earth.\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjuster#adjustInto(Temporal)} method on the\nspecified adjuster passing {@code this} as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 620,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "based on {@code this} with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1993,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_withField",
    "access": "private",
    "description": "Returns a copy of this year-quarter with the specified field set to a new value.\n\nThis returns a `YearQuarter` based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year or quarter.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n- `QUARTER_OF_YEAR` -\n Returns a `YearQuarter` with the specified quarter-of-year.\n The year will be unchanged.\n- `YEAR_OF_ERA` -\n Returns a `YearQuarter` with the specified year-of-era\n The quarter and era will be unchanged.\n- `YEAR` -\n Returns a `YearQuarter` with the specified year.\n The quarter will be unchanged.\n- `ERA` -\n Returns a `YearQuarter` with the specified era.\n The quarter and year-of-era will be unchanged.\n\nIn all cases, if the new value is outside the valid range of values for the field\nthen a `DateTimeException` will be thrown.\n\nAll other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoField`, then the result of this method\nis obtained by invoking `TemporalField.adjustInto(Temporal, long)`\npassing `this` as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 671,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on `this` with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1994,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#withYear",
    "access": "public",
    "description": "Returns a copy of this `YearQuarter` with the year altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 702,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to set in the returned year-quarter, from MIN_YEAR to MAX_YEAR"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the year value is invalid"
      }
    ]
  },
  {
    "__docId__": 1995,
    "kind": "method",
    "name": "withQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#withQuarter",
    "access": "public",
    "description": "Returns a copy of this `YearQuarter` with the quarter-of-year altered.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 716,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quarter",
        "description": "the quarter-of-year to set in the returned year-quarter, from 1 to 4"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the requested quarter, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the quarter-of-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 1996,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this year-quarter with the specified amount added.\n\nThis returns a `YearQuarter` based on this one, with the amount\nin terms of the unit added. If it is not possible to add the amount, because the\nunit is not supported or for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoUnit} then the addition is implemented here.\nThe supported fields behave as follows:\n\n- `QUARTER_YEARS` -\n Returns a `YearQuarter` with the specified number of quarters added.\n This is equivalent to {@link YearQuarter.plusQuarters}.\n- `YEARS` -\n Returns a `YearQuarter` with the specified number of years added.\n This is equivalent to {@link YearQuarter.plusYears}.\n- `DECADES` -\n Returns a `YearQuarter` with the specified number of decades added.\n This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n multiplied by 10.\n- `CENTURIES` -\n Returns a `YearQuarter` with the specified number of centuries added.\n This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n multiplied by 100.\n- `MILLENNIA` -\n Returns a `YearQuarter` with the specified number of millennia added.\n This is equivalent to calling {@link YearQuarter.plusYears} with the amount\n multiplied by 1,000.\n- `ERAS` -\n Returns a `YearQuarter` with the specified number of eras added.\n Only two eras are supported so the amount must be one, zero or minus one.\n If the amount is non-zero then the year is changed such that the year-of-era\n is unchanged.\n\nAll other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.\n\nIf the field is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.addTo(Temporal, long)`\npassing `this` as the argument. In this case, the unit determines\nwhether and how to perform the addition.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 771,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the amount to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the specified amount added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the addition cannot be made"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 1997,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#plusYears",
    "access": "public",
    "description": "Returns a copy of this year-quarter with the specified period in years added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 802,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the years added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 1998,
    "kind": "method",
    "name": "plusQuarters",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#plusQuarters",
    "access": "public",
    "description": "Returns a copy of this year-quarter with the specified period in quarters added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 819,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quartersToAdd",
        "description": "the quarters to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the quarters added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 1999,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#minusYears",
    "access": "public",
    "description": "Returns a copy of this year-quarter with the specified period in years subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 839,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the years subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 2000,
    "kind": "method",
    "name": "minusQuarters",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#minusQuarters",
    "access": "public",
    "description": "Returns a copy of this year-quarter with the specified period in quarters subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 852,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "quartersToSubtract",
        "description": "the quarters to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearQuarter"
      ],
      "spread": false,
      "description": "a `YearQuarter` based on this year-quarter with the quarters subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the result exceeds the supported range"
      }
    ]
  },
  {
    "__docId__": 2001,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#query",
    "access": "public",
    "description": "Queries this year-quarter using the specified query.\n\nThis queries this year-quarter using the specified query strategy object.\nThe `TemporalQuery` object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom} method on the\nspecified query passing `this` as the argument.",
    "lineNumber": 875,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 2002,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this year-quarter.\n\nThis returns a temporal object of the same observable type as the input\nwith the year and quarter changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.plus}\npassing the number of quarters to adjust by.\nIf the specified temporal object does not use the ISO calendar system then\na `DateTimeException` is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n```\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisYearQuarter.adjustInto(temporal);\n  temporal = temporal.with(thisYearQuarter);\n```\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 910,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2003,
    "kind": "method",
    "name": "until",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#until",
    "access": "public",
    "description": "Calculates the amount of time until another year-quarter in terms of the specified unit.\n\nThis calculates the amount of time between two `YearQuarter`\nobjects in terms of a single `TemporalUnit`.\nThe start and end points are `this` and the specified year-quarter.\nThe result will be negative if the end is before the start.\nThe `Temporal` passed to this method is converted to a\n`YearQuarter` using {@link YearQuarter.from}.\nFor example, the period in years between two year-quarters can be calculated\nusing `startYearQuarter.until(endYearQuarter, YEARS)`.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two year-quarters.\nFor example, the period in decades between 2012-Q3 and 2032-Q2\nwill only be one decade as it is one quarter short of two decades.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method.\nThe second is to use {@link TemporalUnit.between}:\n<pre>\n  // these two lines are equivalent\n  amount = start.until(end, QUARTER_YEARS);\n  amount = QUARTER_YEARS.between(start, end);\n</pre>\nThe choice should be made based on which makes the code more readable.\n\nThe calculation is implemented in this method for {@link ChronoUnit}.\nThe units `QUARTER_YEARS`, `YEARS`, `DECADES`,\n`CENTURIES`, `MILLENNIA` and `ERAS` are supported.\nOther `ChronoUnit` values will throw an exception.\n\nIf the unit is not a `ChronoUnit`, then the result of this method\nis obtained by invoking `TemporalUnit.between(Temporal, Temporal)`\npassing `this` as the first argument and the converted input temporal\nas the second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 967,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date, exclusive, which is converted to a `YearQuarter`, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the amount in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of time between this year-quarter and the end year-quarter"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the amount cannot be calculated, or the end\n temporal cannot be converted to a `YearQuarter`"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2004,
    "kind": "method",
    "name": "format",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#format",
    "access": "public",
    "description": "Formats this year-quarter using the specified formatter.\n\nThis year-quarter will be passed to the formatter to produce a string.",
    "lineNumber": 1005,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted year-quarter string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 2005,
    "kind": "method",
    "name": "atDay",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#atDay",
    "access": "public",
    "description": "Combines this year-quarter with a day-of-quarter to create a `LocalDate`.\n\nThis returns a `LocalDate` formed from this year-quarter and the specified day-of-quarter.\n\nThe day-of-quarter value must be valid for the year-quarter.\n\nThis method can be used as part of a chain to produce a date:\n```\n LocalDate date = yearQuarter.atDay(day);\n```",
    "see": [
      "{@link YearQuarter.isValidDay}"
    ],
    "lineNumber": 1028,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfQuarter",
        "description": "the day-of-quarter to use, from 1 to 92"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date formed from this year-quarter and the specified day, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the day is invalid for the year-quarter"
      }
    ]
  },
  {
    "__docId__": 2006,
    "kind": "method",
    "name": "atEndOfQuarter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#atEndOfQuarter",
    "access": "public",
    "description": "Returns a `LocalDate` at the end of the quarter.\n\nThis returns a `LocalDate` based on this year-quarter.\nThe day-of-quarter is set to the last valid day of the quarter, taking\ninto account leap years.\n\nThis method can be used as part of a chain to produce a date:\n```\n LocalDate date = year.atQuarter(quarter).atEndOfQuarter();\n```",
    "lineNumber": 1053,
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the last valid date of this year-quarter, not null"
    },
    "params": []
  },
  {
    "__docId__": 2007,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#compareTo",
    "access": "public",
    "description": "Compares this year-quarter to another\n\nThe comparison is based first on the value of the year, then on the value of the quarter.\nIt is 'consistent with equals', as defined by {@link Comparable}.",
    "lineNumber": 1068,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearQuarter"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-quarter to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 2008,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#isAfter",
    "access": "public",
    "description": "Is this year-quarter after the specified year-quarter.",
    "lineNumber": 1084,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearQuarter"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-quarter to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified year-quarter"
    }
  },
  {
    "__docId__": 2009,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#isBefore",
    "access": "public",
    "description": "Is this year-quarter before the specified year-quarter.",
    "lineNumber": 1094,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearQuarter"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-quarter to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified year-quarter"
    }
  },
  {
    "__docId__": 2010,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#equals",
    "access": "public",
    "description": "Checks if this year-quarter is equal to another year-quarter.\n\nThe comparison is based on the time-line position of the year-quarters.",
    "lineNumber": 1107,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other year-quarter"
    }
  },
  {
    "__docId__": 2011,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#hashCode",
    "access": "public",
    "description": "A hash code for this year-quarter.",
    "lineNumber": 1123,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 2012,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/YearQuarter.js~YearQuarter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearQuarter.js~YearQuarter#toString",
    "access": "public",
    "description": "Outputs this year-quarter as a `String`, such as `2007-Q2`.\n\nThe output will be in the format `uuuu-'Q'Q`:",
    "lineNumber": 1135,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this year-quarter, not null"
    },
    "params": []
  },
  {
    "__docId__": 2013,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/YearQuarter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/YearQuarter.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1156,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2014,
    "kind": "function",
    "name": "createTemporalQuery",
    "memberof": "packages/extra/src/YearQuarter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearQuarter.js~createTemporalQuery",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/YearQuarter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1171,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "queryFromFunction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2015,
    "kind": "file",
    "name": "packages/extra/src/YearWeek.js",
    "content": "/*\n * @copyright (c) 2022, Philipp Thürwächter & Pattrick Hüper & Michał Sobkiewicz\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { ChronoField, ChronoUnit, Clock, DateTimeException, DateTimeFormatterBuilder, DayOfWeek, IllegalArgumentException, IsoChronology, IsoFields, LocalDate, NullPointerException, SignStyle, Temporal, TemporalField, TemporalQueries, TemporalQuery, TemporalUnit, UnsupportedTemporalTypeException, ValueRange, Year, ZoneId } from '@js-joda/core';\n\n// TODO: hm... is this a good idea?? copied from joda currently, could we add a js-joda-utils module??\nimport { assert, requireInstance, requireNonNull } from './assert';\nimport { _ as jodaInternal } from '@js-joda/core';\n\nconst MathUtil = jodaInternal.MathUtil;\n\n/**\n * A year-week in the ISO week date system such as `2015-W13`\n * \n * {@link YearWeek} is an immutable date-time object that represents the combination\n * of a week-based-year and week-of-week-based-year.\n * Any field that can be derived from those two fields can be obtained.\n * \n * This class does not store or represent a day, time or time-zone.\n * For example, the value '13th week of 2007' can be stored in a {@link YearWeek}.\n * \n * The ISO-8601 calendar system is the modern civil calendar system used today\n * in most of the world. It is equivalent to the proleptic Gregorian calendar\n * system, in which today's rules for leap years are applied for all time.\n * For most applications written today, the ISO-8601 rules are entirely suitable.\n * However, any application that makes use of historical dates, and requires them\n * to be accurate will find the ISO-8601 approach unsuitable.\n * \n * ISO-8601 defines the week as always starting with Monday.\n * The first week is the week which contains the first Thursday of the calendar year.\n * As such, the week-based-year used in this class does not align with the calendar year.\n */\nexport class YearWeek extends Temporal {\n    /**\n     * Function overloading for {@link YearWeek.now}:\n     * - if called with no arguments, {@link YearWeek._now0} is executed;\n     * - if called with an instance of {@link ZoneId}, then {@link YearWeek._nowZoneId} is executed;\n     * - if called with an instance of {@link Clock}, then {@link YearWeek._nowClock} is executed;\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     * \n     * @param {?(ZoneId|Clock)} zoneIdOrClock\n     * @return {YearWeek}\n     */\n    static now(zoneIdOrClock) {\n        switch (arguments.length) {\n            case 0:\n                return YearWeek._now0();\n            case 1:\n                requireNonNull(zoneIdOrClock, 'clockOrZone');\n                if (zoneIdOrClock instanceof ZoneId) {\n                    return YearWeek._nowZoneId(zoneIdOrClock);\n                }\n                if (zoneIdOrClock instanceof Clock) {\n                    return YearWeek._nowClock(zoneIdOrClock);\n                }\n                throw new IllegalArgumentException(`zoneIdOrClock must be an instance of ZoneId or Clock, but is ${zoneIdOrClock.constructor.name}`);\n            default:\n                throw new IllegalArgumentException(`Invalid number of arguments: ${arguments.length}`);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains the current year-week from the system clock in the default time-zone.\n     * \n     * This will query the {@link Clock.systemDefaultZone} system clock in the default\n     * time-zone to obtain the current year-week.\n     * The zone and offset will be set based on the time-zone in the clock.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @return {YearWeek} the current year-week using the system clock and default time-zone, not null\n     * @protected\n     */\n    static _now0() {\n        return YearWeek.now(Clock.systemDefaultZone());\n    }\n\n    /**\n     * Obtains the current year-week from the system clock in the specified time-zone.\n     * \n     * This will query the {@link Clock.system} system clock to obtain the current year-week.\n     * Specifying the time-zone avoids dependence on the default time-zone.\n     * \n     * Using this method will prevent the ability to use an alternate clock for testing\n     * because the clock is hard-coded.\n     *\n     * @param {ZoneId} zone - the zone ID to use, not null\n     * @return {YearWeek} the current year-week using the system clock, not null\n     * @protected\n     */\n    static _nowZoneId(zone) {\n        return YearWeek.now(Clock.system(zone));\n    }\n\n    /**\n     * Obtains the current year-week from the specified clock.\n     * \n     * This will query the specified clock to obtain the current year-week.\n     * Using this method allows the use of an alternate clock for testing.\n     * The alternate clock may be introduced using {@link Clock} dependency injection.\n     *\n     * @param {Clock} clock - the clock to use, not null\n     * @return {YearWeek} the current year-week, not null\n     * @protected\n     */\n    static _nowClock(clock) {\n        const now = LocalDate.now(clock);  // called once\n        return YearWeek.of(now.get(IsoFields.WEEK_BASED_YEAR), now.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Function overloading for {@link YearWeek.of}:\n     * - if called with an instances of {@link Year} and `int`, then {@link YearWeek._ofYearWeek} is executed;\n     * - if called with an instances of number and `int`, then {@link YearWeek._ofWeekBasedYear} is executed;\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     * \n     * @param {Year|number} year - the year to represent, not null\n     * @param {number} week - the week-of-week-based-year to represent, from 1 to 53\n     * @return {YearWeek} the year-week, not null\n     */\n    static of(year, week) {\n        MathUtil.verifyInt(week);\n        if (year instanceof Year) {\n            return this._ofYearWeek(year, week);\n        } else {\n            MathUtil.verifyInt(year);\n            return this._ofWeekBasedYear(year, week);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@link YearWeek} from a year and week.\n     * \n     * If the week is 53 and the year does not have 53 weeks, week one of the following\n     * year is selected.\n     * \n     * Note that this class is based on the week-based-year which aligns to Monday to Sunday weeks,\n     * whereas {@link Year} is intended to represent standard years aligned from January to December.\n     * This difference may be seen at the start and/or end of the year.\n     * This method treats the standard year as though it is the week-based-year.\n     * Thus, `YearWeek.of(Year.of(2020), 1)` creates an object where Monday and Tuesday of the week\n     * are actually the last two days of 2019.\n     *\n     * @param {Year} year - the year to represent, not null\n     * @param {number} week - the week-of-week-based-year to represent, from 1 to 53\n     * @return {YearWeek} the year-week, not null\n     * @throws {DateTimeException} if the week value is invalid\n     * @protected\n     */\n    static _ofYearWeek(year, week) {\n        const weekBasedYear = year.value();\n        return this._ofWeekBasedYear(weekBasedYear, week);\n    }\n\n    /**\n     * Obtains an instance of {@link YearWeek} from a week-based-year and week.\n     * \n     * If the week is 53 and the year does not have 53 weeks, week one of the following\n     * year is selected.\n     *\n     * @param {number} weekBasedYear - the week-based-year to represent, from MIN_YEAR to MAX_YEAR\n     * @param {number} week - the week-of-week-based-year to represent, from 1 to 53\n     * @return {YearWeek} the year-week, not null\n     * @throws {DateTimeException} if either field is invalid\n     * @protected\n     */\n    static _ofWeekBasedYear(weekBasedYear, week) {\n        IsoFields.WEEK_BASED_YEAR.range().checkValidValue(weekBasedYear, IsoFields.WEEK_BASED_YEAR);\n        IsoFields.WEEK_OF_WEEK_BASED_YEAR.range().checkValidValue(week, IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n        if (week === 53 && YearWeek._weekRange(weekBasedYear) < 53) {\n            week = 1;\n            weekBasedYear++;\n            IsoFields.WEEK_BASED_YEAR.range().checkValidValue(weekBasedYear, IsoFields.WEEK_BASED_YEAR);\n        }\n        return new YearWeek(weekBasedYear, week);\n    }\n\n    /**\n     * from IsoFields in ThreeTen-Backport\n     * @private\n     */\n    static _weekRange(weekBasedYear) {\n        const date = LocalDate.of(weekBasedYear, 1, 1);\n        // 53 weeks if year starts on Thursday, or Wed in a leap year\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || (date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear())) {\n            return 53;\n        }\n        return 52;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link YearWeek} from a temporal object.\n     * \n     * This obtains a year-week based on the specified temporal.\n     * A {@link TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@link YearWeek}.\n     * \n     * The conversion extracts the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n     * {@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields.\n     * The extraction is only permitted if the temporal object has an ISO\n     * chronology, or can be converted to a {@link LocalDate}.\n     * \n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used in queries via method reference, {@link YearWeek.FROM}.\n     *\n     * @param {Temporal} temporal - the temporal object to convert, not null\n     * @return {YearWeek} the year-week, not null\n     * @throws {DateTimeException} if unable to convert to a {@link YearWeek}\n     */\n    static from(temporal) {\n        if (temporal instanceof YearWeek) {\n            return temporal;\n        }\n        requireNonNull(temporal, 'temporal');\n        try {\n            /* TODO: only IsoChronology for now\n            if (!IsoChronology.INSTANCE.equals(Chronology.from(temporal))) {\n                temporal = LocalDate.from(temporal);\n            }*/\n            // need to use getLong() as JDK Parsed class get() doesn't work properly\n            const year = MathUtil.safeToInt(temporal.getLong(IsoFields.WEEK_BASED_YEAR));\n            const week = MathUtil.safeToInt(temporal.getLong(IsoFields.WEEK_OF_WEEK_BASED_YEAR));\n            return YearWeek.of(year, week);\n        } catch (ex) {\n            throw new DateTimeException(`Unable to obtain YearWeek from TemporalAccessor: ${temporal.constructor.name}`, ex);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Obtains an instance of {@link YearWeek} from a text string using a specific formatter.\n     * \n     * The text is parsed using the formatter, returning a year-week.\n     *\n     * @param {string} text - the text to parse, not null\n     * @param {DateTimeFormatter} [formatter=YearWeek.PARSER] - the formatter to use, default is\n     * {@link YearWeek.PARSER}\n     * \n     * @return {YearWeek} the parsed year-week, not null\n     * @throws {DateTimeParseException} if the text cannot be parsed\n     */\n    static parse(text, formatter = YearWeek.PARSER) {\n        assert(formatter != null, 'formatter', NullPointerException);\n        return formatter.parse(text, YearWeek.FROM);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {number} weekBasedYear - the week-based-year to represent, validated from MIN_YEAR to MAX_YEAR\n     * @param {number} week - the week to represent, validated\n     * @private\n     */\n    constructor(weekBasedYear, week) {\n        super();\n        this._year = weekBasedYear;\n        this._week = week;\n    }\n\n    /**\n     * function overloading for {@link YearWeek.isSupported}\n     * - if called with an instance of {@link TemporalField}, then {@link YearWeek._isSupportedField} is executed,\n     * - if called with an instance of {@link TemporalUnit}, then {@link YearWeek._isSupportedUnit} is executed,\n     * - otherwise {@link IllegalArgumentException} is thrown.\n     *\n     * @param {TemporalField|TemporalUnit} fieldOrUnit\n     * @return {boolean}\n     */\n    isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof TemporalField) {\n            return this._isSupportedField(fieldOrUnit);\n        }\n        if (fieldOrUnit instanceof TemporalUnit) {\n            return this._isSupportedUnit(fieldOrUnit);\n        }\n        if (fieldOrUnit == null) {\n            return false;\n        }\n        throw new IllegalArgumentException(`fieldOrUnit must be an instance of TemporalField or TemporalUnit, but is ${fieldOrUnit.constructor.name}`);\n    }\n\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the specified field is supported.\n     * \n     * This checks if this year-week can be queried for the specified field.\n     * If false, then calling the {@link YearWeek.range} range and\n     * {@link YearWeek.get} get methods will throw an exception.\n     * \n     * The supported fields are:\n     * <ul>\n     * <li>{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR}\n     * <li>{@link IsoFields.WEEK_BASED_YEAR}\n     * </ul>\n     * All other {@link ChronoField} instances will return false.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.isSupportedBy}\n     * passing this as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param {TemporalField} field - the field to check, null returns false\n     * @return {boolean} true if the field is supported on this year-week, false if not\n     * @protected\n     */\n    _isSupportedField(field) {\n        if (field === IsoFields.WEEK_OF_WEEK_BASED_YEAR || field === IsoFields.WEEK_BASED_YEAR) {\n            return true;\n        } else if (field instanceof ChronoField) {\n            return false;\n        }\n        return field != null && field.isSupportedBy(this);\n    }\n\n    /**\n     * Checks if the specified unit is supported.\n     * \n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link YearWeek.plus} and\n     * {@link YearWeek.minus} minus methods will throw an exception.\n     * \n     * The supported units are:\n     * - {@link ChronoUnit.WEEKS}\n     * - {@link IsoFields.WEEK_BASED_YEARS}\n     * \n     * All other {@link ChronoUnit} instances will return false.\n     * \n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.isSupportedBy}\n     * passing this as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param {TemporalUnit} unit - the unit to check, null returns false\n     * @return {boolean} true if the unit can be added/subtracted, false if not\n     * @protected\n     */\n    _isSupportedUnit(unit) {\n        if (unit === ChronoUnit.WEEKS || unit === IsoFields.WEEK_BASED_YEARS) {\n            return true;\n        } else if (unit instanceof ChronoUnit) {\n            return false;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the range of valid values for the specified field.\n     * \n     * The range object expresses the minimum and maximum valid values for a field.\n     * This year-week is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * The range for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n     * {@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\n     * All {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * @param {TemporalField} field - the field to query the range for, not null\n     * @return {ValueRange} the range of valid values for the field, not null\n     * @throws {DateTimeException} if the range for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     */\n    range(field) {\n        requireNonNull(field, 'field');\n        if (field === IsoFields.WEEK_BASED_YEAR) {\n            return IsoFields.WEEK_BASED_YEAR.range();\n        }\n        if (field === IsoFields.WEEK_OF_WEEK_BASED_YEAR) {\n            return ValueRange.of(1, YearWeek._weekRange(this._year));\n        }\n        return super.range(field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-week as an `int`.\n     * \n     * This queries this year-week for the value for the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * The value for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n     * {@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\n     * All {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained or\n     *  the value is outside the range of valid values for the field\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported or\n     *  the range of values exceeds an `int`\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    }\n\n    /**\n     * Gets the value of the specified field from this year-week as a `long`.\n     * \n     * This queries this year-week for the value for the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * \n     * The value for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n     * {@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\n     * All {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     *\n     * @param {TemporalField} field - the field to get, not null\n     * @return {number} the value for the field\n     * @throws {DateTimeException} if a value for the field cannot be obtained\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    getLong(field) {\n        requireNonNull(field, 'field');\n        if (field === IsoFields.WEEK_BASED_YEAR) {\n            return this._year;\n        }\n        if (field === IsoFields.WEEK_OF_WEEK_BASED_YEAR) {\n            return this._week;\n        }\n        if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.getFrom(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the week-based-year field.\n     * \n     * This method returns the primitive `int` value for the week-based-year.\n     * \n     * Note that the ISO week-based-year does not align with the standard Gregorian/ISO calendar year.\n     *\n     * @return {number} the week-based-year\n     */\n    year() {\n        return this._year;\n    }\n\n    /**\n     * Gets the week-of-week-based-year field.\n     * \n     * This method returns the primitive `int` value for the week of the week-based-year.\n     *\n     * @return {number} the week-of-week-based-year\n     */\n    week() {\n        return this._week;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the week-based-year has 53 weeks.\n     * \n     * This determines if the year has 53 weeks, returning true.\n     * If false, the year has 52 weeks.\n     *\n     * @return {boolean} true if the year has 53 weeks, false otherwise\n     */\n    is53WeekYear() {\n        return YearWeek._weekRange(this._year) === 53;\n    }\n\n    /**\n     * Returns the length of the week-based-year.\n     * \n     * This returns the length of the year in days, either 364 or 371.\n     *\n     * @return {number} 364 if the year has 52 weeks, 371 if it has 53 weeks\n     */\n    lengthOfYear() {\n        return (this.is53WeekYear() ? 371 : 364);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns an adjusted copy of this year-week.\n     * \n     * This returns a {@link YearWeek}, based on this one, with the year-week adjusted.\n     * The adjustment takes place using the specified adjuster strategy object.\n     * Read the documentation of the adjuster to understand what adjustment will be made.\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalAdjusteradjustInto} method on the\n     * specified adjuster passing this as the argument.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalAdjuster} adjuster - adjuster the adjuster to use, not null\n     * @return {YearWeek} a year-week based on this with the adjustment made, not null\n     * @throws {DateTimeException} if the adjustment cannot be made\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withAdjuster(adjuster) {\n        // optimizations\n        if (adjuster instanceof YearWeek) {\n            return adjuster;\n        }\n        return super._withAdjuster(adjuster);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified field set to a new value.\n     * \n     * This returns a {@link YearWeek}, based on this one, with the value\n     * for the specified field changed.\n     * This can be used to change any supported field, such as the year or week.\n     * If it is not possible to set the value, because the field is not supported or for\n     * some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoField} then the adjustment is implemented here.\n     * The supported fields behave as follows:\n     * - {@link WEEK_OF_WEEK_BASED_YEAR} - Returns a {@link YearWeek} with the specified week-of-year set as per {@link YearWeek.withWeek}.\n     * - {@link WEEK_BASED_YEAR} - Returns a {@link YearWeek} with the specified year set as per {@link YearWeek.withYear}.\n     * \n     * All {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoField}, then the result of this method\n     * is obtained by invoking {@link TemporalField.adjustInto}\n     * passing this as the argument. In this case, the field determines\n     * whether and how to adjust the instant.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {TemporalField} field - the field to set in the result, not null\n     * @param {number} newValue - the new value of the field in the result\n     * @return {YearWeek} a year-week based on this with the specified field set, not null\n     * @throws {DateTimeException} if the field cannot be set\n     * @throws {UnsupportedTemporalTypeException} if the field is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _withField(field, newValue) {\n        if (field === IsoFields.WEEK_OF_WEEK_BASED_YEAR) {\n            return this.withWeek(IsoFields.WEEK_OF_WEEK_BASED_YEAR.range().checkValidIntValue(newValue, IsoFields.WEEK_OF_WEEK_BASED_YEAR));\n        } else if (field === IsoFields.WEEK_BASED_YEAR) {\n            return this.withYear(IsoFields.WEEK_BASED_YEAR.range().checkValidIntValue(newValue, IsoFields.WEEK_BASED_YEAR));\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(`Unsupported field: ${field}`);\n        }\n        return field.adjustInto(this, newValue);\n    }\n\n    /**\n     * Returns a copy of this {@link YearWeek} with the week-based-year altered.\n     * \n     * This returns a year-week with the specified week-based-year.\n     * If the week of this instance is 53 and the new year does not have 53 weeks,\n     * the week will be adjusted to be 52.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} weekBasedYear - the week-based-year to set in the returned year-week\n     * @return {YearWeek} a year-week based on this year-week with the requested year, not null\n     * @throws {DateTimeException} if the week-based-year value is invalid\n     */\n    withYear(weekBasedYear) {\n        if (this._week === 53 && YearWeek._weekRange(weekBasedYear) < 53) {\n            return YearWeek.of(weekBasedYear, 52);\n        }\n        return YearWeek.of(weekBasedYear, this._week);\n    }\n\n    /**\n     * Returns a copy of this {@link YearWeek} with the week altered.\n     * \n     * This returns a year-week with the specified week-of-week-based-year.\n     * If the new week is 53 and the year does not have 53 weeks, week one of the\n     * following year is selected.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} week - the week-of-week-based-year to set in the returned year-week\n     * @return {YearWeek} a year-week based on this year-week with the requested week, not null\n     * @throws {DateTimeException} if the week-of-week-based-year value is invalid\n     */\n    withWeek(week) {\n        return YearWeek.of(this._year, week);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified amount added.\n     * \n     * This returns a {@link YearWeek}, based on this one, with the amount\n     * in terms of the unit added. If it is not possible to add the amount, because the\n     * unit is not supported or for some other reason, an exception is thrown.\n     * \n     * If the field is a {@link ChronoUnit} then the addition is implemented here.\n     * The supported fields behave as follows:\n     * - {@link WEEKS} - Returns a {@link YearWeek} with the weeks added as per {@link YearWeek.plusWeeks}.\n     * - {@link WEEK_BASED_YEARS} - Returns a {@link YearWeek} with the years added as per {@link YearWeek.plusYears}.\n     * \n     * All {@link ChronoUnit} instances will throw an {@link UnsupportedTemporalTypeException}.\n     * \n     * If the field is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.addTo}\n     * passing this as the argument. In this case, the unit determines\n     * whether and how to perform the addition.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToAdd - the amount of the unit to add to the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the amount to add, not null\n     * @return {YearWeek} a year-week based on this year-week with the specified amount added, not null\n     * @throws {DateTimeException} if the addition cannot be made\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _plusUnit(amountToAdd, unit) {\n        if (unit === ChronoUnit.WEEKS) {\n            return this.plusWeeks(amountToAdd);\n        } else if (unit === IsoFields.WEEK_BASED_YEARS) {\n            return this.plusYears(amountToAdd);\n        } else if (unit instanceof ChronoUnit) {\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.addTo(this, amountToAdd);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified number of years added.\n     * \n     * If the week of this instance is 53 and the new year does not have 53 weeks,\n     * the week will be adjusted to be 52.\n     * \n     * This instance is immutable and unaffected by this method call.\n     * \n     * @param {number} yearsToAdd - the years to add, may be negative\n     * @return {YearWeek} the year-week with the years added, not null\n     */\n    plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        const newYear = MathUtil.safeToInt(MathUtil.safeAdd(this._year, yearsToAdd));\n        return this.withYear(newYear);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified number of weeks added.\n     * \n     * This instance is immutable and unaffected by this method call.\n     * \n     * @param {number} weeksToAdd - the weeks to add, may be negative\n     * @return {YearWeek} the year-week with the weeks added, not null\n     */\n    plusWeeks(weeksToAdd) {\n        if (weeksToAdd === 0) {\n            return this;\n        }\n        const mondayOfWeek = this.atDay(DayOfWeek.MONDAY).plusWeeks(weeksToAdd);\n        return YearWeek.from(mondayOfWeek);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified amount subtracted.\n     * \n     * This returns a {@link YearWeek}, based on this one, with the amount\n     * in terms of the unit subtracted. If it is not possible to subtract the amount,\n     * because the unit is not supported or for some other reason, an exception is thrown.\n     * \n     * This method is equivalent to {@link YearWeek.plus} with the amount negated.\n     * See that method for a full description of how addition, and thus subtraction, works.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {number} amountToSubtract - the amount of the unit to subtract from the result, may be negative\n     * @param {TemporalUnit} unit - the unit of the amount to subtract, not null\n     * @return {YearWeek} a year-week based on this year-week with the specified amount subtracted, not null\n     * @throws {DateTimeException} if the subtraction cannot be made\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    _minusUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, 'amountToSubtract');\n        requireNonNull(unit, 'unit');\n        return this._plusUnit(-amountToSubtract, unit);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified number of years subtracted.\n     * \n     * If the week of this instance is 53 and the new year does not have 53 weeks,\n     * the week will be adjusted to be 52.\n     * \n     * This instance is immutable and unaffected by this method call.\n     * \n     * @param {number} yearsToSubtract - the years to subtract, may be negative\n     * @return {YearWeek} the year-week with the years subtracted, not null\n     */\n    minusYears(yearsToSubtract) {\n        if (yearsToSubtract === 0) {\n            return this;\n        }\n        const newYear = MathUtil.safeToInt(MathUtil.safeSubtract(this._year, yearsToSubtract));\n        return this.withYear(newYear);\n    }\n\n    /**\n     * Returns a copy of this year-week with the specified number of weeks subtracted.\n     * \n     * This instance is immutable and unaffected by this method call.\n     * \n     * @param {number} weeksToSubtract - the weeks to subtract, may be negative\n     * @return {YearWeek} the year-week with the weeks subtracted, not null\n     */\n    minusWeeks(weeksToSubtract) {\n        if (weeksToSubtract === 0) {\n            return this;\n        }\n        const mondayOfWeek = this.atDay(DayOfWeek.MONDAY).minusWeeks(weeksToSubtract);\n        return YearWeek.from(mondayOfWeek);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Queries this year-week using the specified query.\n     * \n     * This queries this year-week using the specified query strategy object.\n     * The {@link TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * \n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery.queryFrom} method on the\n     * specified query passing this as the argument.\n     *\n     * @param {TemporalQuery} query - the query to invoke, not null\n     * @return {*} the query result, null may be returned (defined by the query)\n     * @throws {DateTimeException} if unable to query (defined by the query)\n     * @throws {ArithmeticException} if numeric overflow occurs (defined by the query)\n     */\n    query(query) {\n        requireNonNull(query, 'query');\n        requireInstance(query, TemporalQuery, 'query');\n        if (query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return super.query(query);\n    }\n\n    /**\n     * Adjusts the specified temporal object to have this year-week.\n     * \n     * This returns a temporal object of the same observable type as the input\n     * with the week-based-year and week changed to be the same as this.\n     * \n     * The adjustment is equivalent to using {@link Temporal.with}\n     * twice, passing {@link IsoFields.WEEK_BASED_YEAR} and\n     * {@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} as the fields.\n     * If the specified temporal object does not use the ISO calendar system then\n     * a {@link DateTimeException} is thrown.\n     * \n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal.with}:\n     * ```\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisYearWeek.adjustInto(temporal);\n     *   temporal = temporal.with(thisYearWeek);\n     * ```\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} temporal - the target object to be adjusted, not null\n     * @return {Temporal} the adjusted object, not null\n     * @throws {DateTimeException} if unable to make the adjustment\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    adjustInto(temporal) {\n        return temporal.with(IsoFields.WEEK_BASED_YEAR, this._year).with(IsoFields.WEEK_OF_WEEK_BASED_YEAR, this._week);\n    }\n\n    /**\n     * Calculates the amount of time until another year-week in terms of the specified unit.\n     * \n     * This calculates the amount of time between two {@link YearWeek}\n     * objects in terms of a single {@link TemporalUnit}.\n     * The start and end points are this and the specified year-week.\n     * The result will be negative if the end is before the start.\n     * The {@link Temporal} passed to this method is converted to a\n     * {@link YearWeek} using {@link YearWeek.from}.\n     * For example, the period in years between two year-weeks can be calculated\n     * using `startYearWeek.until(endYearWeek, YEARS)`.\n     * \n     * The calculation returns a whole number, representing the number of\n     * complete units between the two year-weeks.\n     * For example, the period in years between 2012-W23 and 2032-W22\n     * will only be 9 years as it is one week short of 10 years.\n     * \n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit.between}:\n     * ```\n     *   // these two lines are equivalent\n     *   amount = start.until(end, WEEKS);\n     *   amount = WEEKS.between(start, end);\n     * ```\n     * The choice should be made based on which makes the code more readable.\n     * \n     * The calculation is implemented in this method for units {@link WEEKS}\n     * and {@link WEEK_BASED_YEARS}.\n     * Other {@link ChronoUnit} values will throw an exception.\n     * \n     * If the unit is not a {@link ChronoUnit}, then the result of this method\n     * is obtained by invoking {@link TemporalUnit.between}\n     * passing this as the first argument and the converted input temporal\n     * as the second argument.\n     * \n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {Temporal} endExclusive - the end date, exclusive, which is converted to a {@link YearWeek}, not null\n     * @param {TemporalUnit} unit - the unit to measure the amount in, not null\n     * @return {number} the amount of time between this year-week and the end year-week\n     * @throws {DateTimeException} if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@link YearWeek}\n     * @throws {UnsupportedTemporalTypeException} if the unit is not supported\n     * @throws {ArithmeticException} if numeric overflow occurs\n     */\n    until(endExclusive, unit) {\n        const end = YearWeek.from(endExclusive);\n        if (unit === ChronoUnit.WEEKS) {\n            return this._daysUntil(end);\n        } else if (unit === IsoFields.WEEK_BASED_YEARS) {\n            return this._yearsUntil(end);\n        } else if (unit instanceof ChronoUnit) {\n            throw new UnsupportedTemporalTypeException(`Unsupported unit: ${unit}`);\n        }\n        return unit.between(this, end);\n    }\n\n    /**\n     * @private\n     */\n    _daysUntil(end) {\n        const startDate = this.atDay(DayOfWeek.MONDAY);\n        const endDate = end.atDay(DayOfWeek.MONDAY);\n        const days = endDate.toEpochDay() - startDate.toEpochDay();\n        return MathUtil.intDiv(days, 7);\n    }\n\n    /**\n     * @private\n     */\n    _yearsUntil(end) {\n        const yearsDiff = end._year - this._year;\n        if (yearsDiff > 0 && end._week < this._week) {\n            return yearsDiff - 1;\n        }\n        if (yearsDiff < 0 && end._week > this._week) {\n            return yearsDiff + 1;\n        }\n        return yearsDiff;\n    }\n\n    /**\n     * Formats this year-week using the specified formatter.\n     * \n     * This year-week will be passed to the formatter to produce a string.\n     *\n     * @param {DateTimeFormatter} formatter - the formatter to use, not null\n     * @return {string} the formatted year-week string, not null\n     * @throws {DateTimeException} if an error occurs during printing\n     */\n    format(formatter) {\n        requireNonNull(formatter, 'formatter');\n        return formatter.format(this);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this year-week with a day-of-week to create a {@link LocalDate}.\n     * \n     * This returns a {@link LocalDate} formed from this year-week and the specified day-of-Week.\n     * \n     * This method can be used as part of a chain to produce a date:\n     * ```\n     *  LocalDate date = yearWeek.atDay(MONDAY);\n     * ```\n     *\n     * @param {DayOfWeek} dayOfWeek - the day-of-week to use, not null\n     * @return {LocalDate} the date formed from this year-week and the specified day, not null\n     */\n    atDay(dayOfWeek) {\n        requireNonNull(dayOfWeek, 'dayOfWeek');\n        const correction = LocalDate.of(this._year, 1, 4).dayOfWeek().value() + 3;\n        const dayOfYear = this._week * 7 + dayOfWeek.value() - correction;\n        const maxDaysOfYear = Year.isLeap(this._year) ? 366 : 365;\n        if (dayOfYear > maxDaysOfYear) {\n            return LocalDate.ofYearDay(this._year + 1, dayOfYear - maxDaysOfYear);\n        }\n        if (dayOfYear > 0) {\n            return LocalDate.ofYearDay(this._year, dayOfYear);\n        } else {\n            const daysOfPreviousYear = Year.isLeap(this._year - 1) ? 366 : 365;\n            return LocalDate.ofYearDay(this._year - 1, daysOfPreviousYear + dayOfYear);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this year-week to another\n     * \n     * The comparison is based first on the value of the year, then on the value of the week.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     *\n     * @param {YearWeek} other - the other year-week to compare to, not null\n     * @return {number} the comparator value, negative if less, positive if greater\n     */\n    compareTo(other) {\n        requireNonNull(other, 'other');\n        requireInstance(other, YearWeek, 'other');\n        let cmp = (this._year - other._year);\n        if (cmp === 0) {\n            cmp = (this._week - other._week);\n        }\n        return cmp;\n    }\n \n    /**\n     * Is this year-week after the specified year-week.\n     *\n     * @param {YearWeek} other - the other year-week to compare to, not null\n     * @return {boolean} true if this is after the specified year-week\n     */\n    isAfter(other) {\n        return this.compareTo(other) > 0;\n    }\n\n    /**\n     * Is this year-week before the specified year-week.\n     *\n     * @param {YearWeek} other - the other year-week to compare to, not null\n     * @return {boolean} true if this point is before the specified year-week\n     */\n    isBefore(other) {\n        return this.compareTo(other) < 0;\n    }\n \n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this year-week is equal to another year-week.\n     *\n     * @param {*} obj - the object to check, null returns false\n     * @return {boolean} true if this is equal to the other year-week\n     */\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearWeek) {\n            return this._year === obj._year && this._week === obj._week;\n        }\n        return false;\n    }\n \n    /**\n     * A hash code for this year-week.\n     *\n     * @return {number} a suitable hash code\n     */\n    hashCode() {\n        return this._year ^ (this._week << 25);\n    }\n \n    //-----------------------------------------------------------------------\n    /**\n     * Outputs this year-week as a {@link String}, such as `2015-W13`.\n     * \n     * The output will be in the format `YYYY-'W'ww`:\n     *\n     * @return {string} a string representation of this year-week, not null\n     */\n    toString() {\n        let yearString;\n        const yearValue = this._year;\n        const absYear = Math.abs(yearValue);\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = `-${(`${yearValue - 10000}`).slice(-4)}`;\n            } else {\n                yearString = (`${yearValue + 10000}`).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = `+${yearValue}`;\n            } else {\n                yearString = `${yearValue}`;\n            }\n        }\n        return yearString.concat(this._week < 10 ? '-W0' : '-W').concat(this._week);\n    }\n}\n\nexport function _init() {\n    YearWeek.PARSER = new DateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)\n        .appendLiteral('-W')\n        .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)\n        .toFormatter();\n\n    YearWeek.FROM = createTemporalQuery('YearWeek.FROM', (temporal) => {\n        return YearWeek.from(temporal);\n    });\n}\n\n// copied from packages/core/src/temporal/TemporalQuery.js\nfunction createTemporalQuery(name, queryFromFunction) {\n    class ExtendedTemporalQuery extends TemporalQuery {\n    }\n\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/YearWeek.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2016,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/extra/src/YearWeek.js",
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/YearWeek.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2017,
    "kind": "class",
    "name": "YearWeek",
    "memberof": "packages/extra/src/YearWeek.js",
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/YearWeek.js",
    "importStyle": "{YearWeek}",
    "description": "A year-week in the ISO week date system such as `2015-W13`\n\n{@link YearWeek} is an immutable date-time object that represents the combination\nof a week-based-year and week-of-week-based-year.\nAny field that can be derived from those two fields can be obtained.\n\nThis class does not store or represent a day, time or time-zone.\nFor example, the value '13th week of 2007' can be stored in a {@link YearWeek}.\n\nThe ISO-8601 calendar system is the modern civil calendar system used today\nin most of the world. It is equivalent to the proleptic Gregorian calendar\nsystem, in which today's rules for leap years are applied for all time.\nFor most applications written today, the ISO-8601 rules are entirely suitable.\nHowever, any application that makes use of historical dates, and requires them\nto be accurate will find the ISO-8601 approach unsuitable.\n\nISO-8601 defines the week as always starting with Monday.\nThe first week is the week which contains the first Thursday of the calendar year.\nAs such, the week-based-year used in this class does not align with the calendar year.",
    "lineNumber": 36,
    "interface": false,
    "extends": [
      "@js-joda/core~Temporal"
    ]
  },
  {
    "__docId__": 2018,
    "kind": "method",
    "name": "now",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek.now",
    "access": "public",
    "description": "Function overloading for {@link YearWeek.now}:\n- if called with no arguments, {@link YearWeek._now0} is executed;\n- if called with an instance of {@link ZoneId}, then {@link YearWeek._nowZoneId} is executed;\n- if called with an instance of {@link Clock}, then {@link YearWeek._nowClock} is executed;\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": true,
        "types": [
          "ZoneId",
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneIdOrClock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2019,
    "kind": "method",
    "name": "_now0",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._now0",
    "access": "protected",
    "description": "Obtains the current year-week from the system clock in the default time-zone.\n\nThis will query the {@link Clock.systemDefaultZone} system clock in the default\ntime-zone to obtain the current year-week.\nThe zone and offset will be set based on the time-zone in the clock.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 79,
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the current year-week using the system clock and default time-zone, not null"
    },
    "params": []
  },
  {
    "__docId__": 2020,
    "kind": "method",
    "name": "_nowZoneId",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._nowZoneId",
    "access": "protected",
    "description": "Obtains the current year-week from the system clock in the specified time-zone.\n\nThis will query the {@link Clock.system} system clock to obtain the current year-week.\nSpecifying the time-zone avoids dependence on the default time-zone.\n\nUsing this method will prevent the ability to use an alternate clock for testing\nbecause the clock is hard-coded.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "ZoneId"
        ],
        "spread": false,
        "optional": false,
        "name": "zone",
        "description": "the zone ID to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the current year-week using the system clock, not null"
    }
  },
  {
    "__docId__": 2021,
    "kind": "method",
    "name": "_nowClock",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._nowClock",
    "access": "protected",
    "description": "Obtains the current year-week from the specified clock.\n\nThis will query the specified clock to obtain the current year-week.\nUsing this method allows the use of an alternate clock for testing.\nThe alternate clock may be introduced using {@link Clock} dependency injection.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "Clock"
        ],
        "spread": false,
        "optional": false,
        "name": "clock",
        "description": "the clock to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the current year-week, not null"
    }
  },
  {
    "__docId__": 2022,
    "kind": "method",
    "name": "of",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek.of",
    "access": "public",
    "description": "Function overloading for {@link YearWeek.of}:\n- if called with an instances of {@link Year} and `int`, then {@link YearWeek._ofYearWeek} is executed;\n- if called with an instances of number and `int`, then {@link YearWeek._ofWeekBasedYear} is executed;\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "week",
        "description": "the week-of-week-based-year to represent, from 1 to 53"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week, not null"
    }
  },
  {
    "__docId__": 2023,
    "kind": "method",
    "name": "_ofYearWeek",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._ofYearWeek",
    "access": "protected",
    "description": "Obtains an instance of {@link YearWeek} from a year and week.\n\nIf the week is 53 and the year does not have 53 weeks, week one of the following\nyear is selected.\n\nNote that this class is based on the week-based-year which aligns to Monday to Sunday weeks,\nwhereas {@link Year} is intended to represent standard years aligned from January to December.\nThis difference may be seen at the start and/or end of the year.\nThis method treats the standard year as though it is the week-based-year.\nThus, `YearWeek.of(Year.of(2020), 1)` creates an object where Monday and Tuesday of the week\nare actually the last two days of 2019.",
    "lineNumber": 156,
    "params": [
      {
        "nullable": null,
        "types": [
          "Year"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": "the year to represent, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "week",
        "description": "the week-of-week-based-year to represent, from 1 to 53"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the week value is invalid"
      }
    ]
  },
  {
    "__docId__": 2024,
    "kind": "method",
    "name": "_ofWeekBasedYear",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._ofWeekBasedYear",
    "access": "protected",
    "description": "Obtains an instance of {@link YearWeek} from a week-based-year and week.\n\nIf the week is 53 and the year does not have 53 weeks, week one of the following\nyear is selected.",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weekBasedYear",
        "description": "the week-based-year to represent, from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "week",
        "description": "the week-of-week-based-year to represent, from 1 to 53"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if either field is invalid"
      }
    ]
  },
  {
    "__docId__": 2025,
    "kind": "method",
    "name": "_weekRange",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek._weekRange",
    "access": "private",
    "description": "from IsoFields in ThreeTen-Backport",
    "lineNumber": 188,
    "ignore": true,
    "params": [
      {
        "name": "weekBasedYear",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 2026,
    "kind": "method",
    "name": "from",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek.from",
    "access": "public",
    "description": "Obtains an instance of {@link YearWeek} from a temporal object.\n\nThis obtains a year-week based on the specified temporal.\nA {@link TemporalAccessor} represents an arbitrary set of date and time information,\nwhich this factory converts to an instance of {@link YearWeek}.\n\nThe conversion extracts the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields.\nThe extraction is only permitted if the temporal object has an ISO\nchronology, or can be converted to a {@link LocalDate}.\n\nThis method matches the signature of the functional interface {@link TemporalQuery}\nallowing it to be used in queries via method reference, {@link YearWeek.FROM}.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the temporal object to convert, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to convert to a {@link YearWeek}"
      }
    ]
  },
  {
    "__docId__": 2027,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~YearWeek.parse",
    "access": "public",
    "description": "Obtains an instance of {@link YearWeek} from a text string using a specific formatter.\n\nThe text is parsed using the formatter, returning a year-week.",
    "lineNumber": 249,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text to parse, not null"
      },
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "YearWeek.PARSER",
        "defaultRaw": "YearWeek.PARSER",
        "name": "formatter",
        "description": "the formatter to use, default is\n{@link YearWeek.PARSER}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the parsed year-week, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeParseException"
        ],
        "description": "if the text cannot be parsed"
      }
    ]
  },
  {
    "__docId__": 2028,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#constructor",
    "access": "private",
    "description": "Constructor.",
    "lineNumber": 262,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weekBasedYear",
        "description": "the week-based-year to represent, validated from MIN_YEAR to MAX_YEAR"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "week",
        "description": "the week to represent, validated"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2029,
    "kind": "member",
    "name": "_year",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_year",
    "access": "private",
    "description": null,
    "lineNumber": 264,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2030,
    "kind": "member",
    "name": "_week",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_week",
    "access": "private",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2031,
    "kind": "method",
    "name": "isSupported",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#isSupported",
    "access": "public",
    "description": "function overloading for {@link YearWeek.isSupported}\n- if called with an instance of {@link TemporalField}, then {@link YearWeek._isSupportedField} is executed,\n- if called with an instance of {@link TemporalUnit}, then {@link YearWeek._isSupportedUnit} is executed,\n- otherwise {@link IllegalArgumentException} is thrown.",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField",
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "fieldOrUnit",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2032,
    "kind": "method",
    "name": "_isSupportedField",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_isSupportedField",
    "access": "protected",
    "description": "Checks if the specified field is supported.\n\nThis checks if this year-week can be queried for the specified field.\nIf false, then calling the {@link YearWeek.range} range and\n{@link YearWeek.get} get methods will throw an exception.\n\nThe supported fields are:\n<ul>\n<li>{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR}\n<li>{@link IsoFields.WEEK_BASED_YEAR}\n</ul>\nAll other {@link ChronoField} instances will return false.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.isSupportedBy}\npassing this as the argument.\nWhether the field is supported is determined by the field.",
    "lineNumber": 315,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the field is supported on this year-week, false if not"
    }
  },
  {
    "__docId__": 2033,
    "kind": "method",
    "name": "_isSupportedUnit",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_isSupportedUnit",
    "access": "protected",
    "description": "Checks if the specified unit is supported.\n\nThis checks if the specified unit can be added to, or subtracted from, this date-time.\nIf false, then calling the {@link YearWeek.plus} and\n{@link YearWeek.minus} minus methods will throw an exception.\n\nThe supported units are:\n- {@link ChronoUnit.WEEKS}\n- {@link IsoFields.WEEK_BASED_YEARS}\n\nAll other {@link ChronoUnit} instances will return false.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.isSupportedBy}\npassing this as the argument.\nWhether the unit is supported is determined by the unit.",
    "lineNumber": 346,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the unit can be added/subtracted, false if not"
    }
  },
  {
    "__docId__": 2034,
    "kind": "method",
    "name": "range",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#range",
    "access": "public",
    "description": "Gets the range of valid values for the specified field.\n\nThe range object expresses the minimum and maximum valid values for a field.\nThis year-week is used to enhance the accuracy of the returned range.\nIf it is not possible to return the range, because the field is not supported\nor for some other reason, an exception is thrown.\n\nThe range for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\nAll {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to query the range for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ValueRange"
      ],
      "spread": false,
      "description": "the range of valid values for the field, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the range for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      }
    ]
  },
  {
    "__docId__": 2035,
    "kind": "method",
    "name": "get",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#get",
    "access": "public",
    "description": "Gets the value of the specified field from this year-week as an `int`.\n\nThis queries this year-week for the value for the specified field.\nThe returned value will always be within the valid range of values for the field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nThe value for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\nAll {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.",
    "lineNumber": 404,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained or\n the value is outside the range of valid values for the field"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported or\n the range of values exceeds an `int`"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2036,
    "kind": "method",
    "name": "getLong",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#getLong",
    "access": "public",
    "description": "Gets the value of the specified field from this year-week as a `long`.\n\nThis queries this year-week for the value for the specified field.\nIf it is not possible to return the value, because the field is not supported\nor for some other reason, an exception is thrown.\n\nThe value for the {@link IsoFields.WEEK_BASED_YEAR} WEEK_BASED_YEAR and\n{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} WEEK_OF_WEEK_BASED_YEAR fields is returned.\nAll {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.",
    "lineNumber": 425,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to get, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the value for the field"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if a value for the field cannot be obtained"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2037,
    "kind": "method",
    "name": "year",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#year",
    "access": "public",
    "description": "Gets the week-based-year field.\n\nThis method returns the primitive `int` value for the week-based-year.\n\nNote that the ISO week-based-year does not align with the standard Gregorian/ISO calendar year.",
    "lineNumber": 449,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the week-based-year"
    },
    "params": []
  },
  {
    "__docId__": 2038,
    "kind": "method",
    "name": "week",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#week",
    "access": "public",
    "description": "Gets the week-of-week-based-year field.\n\nThis method returns the primitive `int` value for the week of the week-based-year.",
    "lineNumber": 460,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the week-of-week-based-year"
    },
    "params": []
  },
  {
    "__docId__": 2039,
    "kind": "method",
    "name": "is53WeekYear",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#is53WeekYear",
    "access": "public",
    "description": "Checks if the week-based-year has 53 weeks.\n\nThis determines if the year has 53 weeks, returning true.\nIf false, the year has 52 weeks.",
    "lineNumber": 473,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the year has 53 weeks, false otherwise"
    },
    "params": []
  },
  {
    "__docId__": 2040,
    "kind": "method",
    "name": "lengthOfYear",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#lengthOfYear",
    "access": "public",
    "description": "Returns the length of the week-based-year.\n\nThis returns the length of the year in days, either 364 or 371.",
    "lineNumber": 484,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "364 if the year has 52 weeks, 371 if it has 53 weeks"
    },
    "params": []
  },
  {
    "__docId__": 2041,
    "kind": "method",
    "name": "_withAdjuster",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_withAdjuster",
    "access": "private",
    "description": "Returns an adjusted copy of this year-week.\n\nThis returns a {@link YearWeek}, based on this one, with the year-week adjusted.\nThe adjustment takes place using the specified adjuster strategy object.\nRead the documentation of the adjuster to understand what adjustment will be made.\n\nThe result of this method is obtained by invoking the\n{@link TemporalAdjusteradjustInto} method on the\nspecified adjuster passing this as the argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 507,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalAdjuster"
        ],
        "spread": false,
        "optional": false,
        "name": "adjuster",
        "description": "adjuster the adjuster to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this with the adjustment made, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the adjustment cannot be made"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2042,
    "kind": "method",
    "name": "_withField",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_withField",
    "access": "private",
    "description": "Returns a copy of this year-week with the specified field set to a new value.\n\nThis returns a {@link YearWeek}, based on this one, with the value\nfor the specified field changed.\nThis can be used to change any supported field, such as the year or week.\nIf it is not possible to set the value, because the field is not supported or for\nsome other reason, an exception is thrown.\n\nIf the field is a {@link ChronoField} then the adjustment is implemented here.\nThe supported fields behave as follows:\n- {@link WEEK_OF_WEEK_BASED_YEAR} - Returns a {@link YearWeek} with the specified week-of-year set as per {@link YearWeek.withWeek}.\n- {@link WEEK_BASED_YEAR} - Returns a {@link YearWeek} with the specified year set as per {@link YearWeek.withYear}.\n\nAll {@link ChronoField} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoField}, then the result of this method\nis obtained by invoking {@link TemporalField.adjustInto}\npassing this as the argument. In this case, the field determines\nwhether and how to adjust the instant.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 545,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to set in the result, not null"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newValue",
        "description": "the new value of the field in the result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this with the specified field set, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the field cannot be set"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the field is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2043,
    "kind": "method",
    "name": "withYear",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#withYear",
    "access": "public",
    "description": "Returns a copy of this {@link YearWeek} with the week-based-year altered.\n\nThis returns a year-week with the specified week-based-year.\nIf the week of this instance is 53 and the new year does not have 53 weeks,\nthe week will be adjusted to be 52.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 569,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weekBasedYear",
        "description": "the week-based-year to set in the returned year-week"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this year-week with the requested year, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the week-based-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 2044,
    "kind": "method",
    "name": "withWeek",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#withWeek",
    "access": "public",
    "description": "Returns a copy of this {@link YearWeek} with the week altered.\n\nThis returns a year-week with the specified week-of-week-based-year.\nIf the new week is 53 and the year does not have 53 weeks, week one of the\nfollowing year is selected.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 589,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "week",
        "description": "the week-of-week-based-year to set in the returned year-week"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this year-week with the requested week, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the week-of-week-based-year value is invalid"
      }
    ]
  },
  {
    "__docId__": 2045,
    "kind": "method",
    "name": "_plusUnit",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_plusUnit",
    "access": "private",
    "description": "Returns a copy of this year-week with the specified amount added.\n\nThis returns a {@link YearWeek}, based on this one, with the amount\nin terms of the unit added. If it is not possible to add the amount, because the\nunit is not supported or for some other reason, an exception is thrown.\n\nIf the field is a {@link ChronoUnit} then the addition is implemented here.\nThe supported fields behave as follows:\n- {@link WEEKS} - Returns a {@link YearWeek} with the weeks added as per {@link YearWeek.plusWeeks}.\n- {@link WEEK_BASED_YEARS} - Returns a {@link YearWeek} with the years added as per {@link YearWeek.plusYears}.\n\nAll {@link ChronoUnit} instances will throw an {@link UnsupportedTemporalTypeException}.\n\nIf the field is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.addTo}\npassing this as the argument. In this case, the unit determines\nwhether and how to perform the addition.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 621,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToAdd",
        "description": "the amount of the unit to add to the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the amount to add, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this year-week with the specified amount added, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the addition cannot be made"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2046,
    "kind": "method",
    "name": "plusYears",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#plusYears",
    "access": "public",
    "description": "Returns a copy of this year-week with the specified number of years added.\n\nIf the week of this instance is 53 and the new year does not have 53 weeks,\nthe week will be adjusted to be 52.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 643,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToAdd",
        "description": "the years to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week with the years added, not null"
    }
  },
  {
    "__docId__": 2047,
    "kind": "method",
    "name": "plusWeeks",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#plusWeeks",
    "access": "public",
    "description": "Returns a copy of this year-week with the specified number of weeks added.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 659,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeksToAdd",
        "description": "the weeks to add, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week with the weeks added, not null"
    }
  },
  {
    "__docId__": 2048,
    "kind": "method",
    "name": "_minusUnit",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_minusUnit",
    "access": "private",
    "description": "Returns a copy of this year-week with the specified amount subtracted.\n\nThis returns a {@link YearWeek}, based on this one, with the amount\nin terms of the unit subtracted. If it is not possible to subtract the amount,\nbecause the unit is not supported or for some other reason, an exception is thrown.\n\nThis method is equivalent to {@link YearWeek.plus} with the amount negated.\nSee that method for a full description of how addition, and thus subtraction, works.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 686,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amountToSubtract",
        "description": "the amount of the unit to subtract from the result, may be negative"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit of the amount to subtract, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "a year-week based on this year-week with the specified amount subtracted, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the subtraction cannot be made"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2049,
    "kind": "method",
    "name": "minusYears",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#minusYears",
    "access": "public",
    "description": "Returns a copy of this year-week with the specified number of years subtracted.\n\nIf the week of this instance is 53 and the new year does not have 53 weeks,\nthe week will be adjusted to be 52.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 703,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearsToSubtract",
        "description": "the years to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week with the years subtracted, not null"
    }
  },
  {
    "__docId__": 2050,
    "kind": "method",
    "name": "minusWeeks",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#minusWeeks",
    "access": "public",
    "description": "Returns a copy of this year-week with the specified number of weeks subtracted.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 719,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "weeksToSubtract",
        "description": "the weeks to subtract, may be negative"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "YearWeek"
      ],
      "spread": false,
      "description": "the year-week with the weeks subtracted, not null"
    }
  },
  {
    "__docId__": 2051,
    "kind": "method",
    "name": "query",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#query",
    "access": "public",
    "description": "Queries this year-week using the specified query.\n\nThis queries this year-week using the specified query strategy object.\nThe {@link TemporalQuery} object defines the logic to be used to\nobtain the result. Read the documentation of the query to understand\nwhat the result of this method will be.\n\nThe result of this method is obtained by invoking the\n{@link TemporalQuery.queryFrom} method on the\nspecified query passing this as the argument.",
    "lineNumber": 745,
    "params": [
      {
        "nullable": null,
        "types": [
          "TemporalQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to invoke, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the query result, null may be returned (defined by the query)"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to query (defined by the query)"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs (defined by the query)"
      }
    ]
  },
  {
    "__docId__": 2052,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#adjustInto",
    "access": "public",
    "description": "Adjusts the specified temporal object to have this year-week.\n\nThis returns a temporal object of the same observable type as the input\nwith the week-based-year and week changed to be the same as this.\n\nThe adjustment is equivalent to using {@link Temporal.with}\ntwice, passing {@link IsoFields.WEEK_BASED_YEAR} and\n{@link IsoFields.WEEK_OF_WEEK_BASED_YEAR} as the fields.\nIf the specified temporal object does not use the ISO calendar system then\na {@link DateTimeException} is thrown.\n\nIn most cases, it is clearer to reverse the calling pattern by using\n{@link Temporal.with}:\n```\n  // these two lines are equivalent, but the second approach is recommended\n  temporal = thisYearWeek.adjustInto(temporal);\n  temporal = temporal.with(thisYearWeek);\n```\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 781,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "temporal",
        "description": "the target object to be adjusted, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Temporal"
      ],
      "spread": false,
      "description": "the adjusted object, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if unable to make the adjustment"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2053,
    "kind": "method",
    "name": "until",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#until",
    "access": "public",
    "description": "Calculates the amount of time until another year-week in terms of the specified unit.\n\nThis calculates the amount of time between two {@link YearWeek}\nobjects in terms of a single {@link TemporalUnit}.\nThe start and end points are this and the specified year-week.\nThe result will be negative if the end is before the start.\nThe {@link Temporal} passed to this method is converted to a\n{@link YearWeek} using {@link YearWeek.from}.\nFor example, the period in years between two year-weeks can be calculated\nusing `startYearWeek.until(endYearWeek, YEARS)`.\n\nThe calculation returns a whole number, representing the number of\ncomplete units between the two year-weeks.\nFor example, the period in years between 2012-W23 and 2032-W22\nwill only be 9 years as it is one week short of 10 years.\n\nThere are two equivalent ways of using this method.\nThe first is to invoke this method.\nThe second is to use {@link TemporalUnit.between}:\n```\n  // these two lines are equivalent\n  amount = start.until(end, WEEKS);\n  amount = WEEKS.between(start, end);\n```\nThe choice should be made based on which makes the code more readable.\n\nThe calculation is implemented in this method for units {@link WEEKS}\nand {@link WEEK_BASED_YEARS}.\nOther {@link ChronoUnit} values will throw an exception.\n\nIf the unit is not a {@link ChronoUnit}, then the result of this method\nis obtained by invoking {@link TemporalUnit.between}\npassing this as the first argument and the converted input temporal\nas the second argument.\n\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 831,
    "params": [
      {
        "nullable": null,
        "types": [
          "Temporal"
        ],
        "spread": false,
        "optional": false,
        "name": "endExclusive",
        "description": "the end date, exclusive, which is converted to a {@link YearWeek}, not null"
      },
      {
        "nullable": null,
        "types": [
          "TemporalUnit"
        ],
        "spread": false,
        "optional": false,
        "name": "unit",
        "description": "the unit to measure the amount in, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of time between this year-week and the end year-week"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if the amount cannot be calculated, or the end\n temporal cannot be converted to a {@link YearWeek}"
      },
      {
        "types": [
          "UnsupportedTemporalTypeException"
        ],
        "description": "if the unit is not supported"
      },
      {
        "types": [
          "ArithmeticException"
        ],
        "description": "if numeric overflow occurs"
      }
    ]
  },
  {
    "__docId__": 2054,
    "kind": "method",
    "name": "_daysUntil",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_daysUntil",
    "access": "private",
    "description": "",
    "lineNumber": 846,
    "ignore": true,
    "params": [
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2055,
    "kind": "method",
    "name": "_yearsUntil",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#_yearsUntil",
    "access": "private",
    "description": "",
    "lineNumber": 856,
    "ignore": true,
    "params": [
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2056,
    "kind": "method",
    "name": "format",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#format",
    "access": "public",
    "description": "Formats this year-week using the specified formatter.\n\nThis year-week will be passed to the formatter to produce a string.",
    "lineNumber": 876,
    "params": [
      {
        "nullable": null,
        "types": [
          "DateTimeFormatter"
        ],
        "spread": false,
        "optional": false,
        "name": "formatter",
        "description": "the formatter to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the formatted year-week string, not null"
    },
    "throws": [
      {
        "types": [
          "DateTimeException"
        ],
        "description": "if an error occurs during printing"
      }
    ]
  },
  {
    "__docId__": 2057,
    "kind": "method",
    "name": "atDay",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#atDay",
    "access": "public",
    "description": "Combines this year-week with a day-of-week to create a {@link LocalDate}.\n\nThis returns a {@link LocalDate} formed from this year-week and the specified day-of-Week.\n\nThis method can be used as part of a chain to produce a date:\n```\n LocalDate date = yearWeek.atDay(MONDAY);\n```",
    "lineNumber": 895,
    "params": [
      {
        "nullable": null,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "dayOfWeek",
        "description": "the day-of-week to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LocalDate"
      ],
      "spread": false,
      "description": "the date formed from this year-week and the specified day, not null"
    }
  },
  {
    "__docId__": 2058,
    "kind": "method",
    "name": "compareTo",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#compareTo",
    "access": "public",
    "description": "Compares this year-week to another\n\nThe comparison is based first on the value of the year, then on the value of the week.\nIt is \"consistent with equals\", as defined by {@link Comparable}.",
    "lineNumber": 921,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-week to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the comparator value, negative if less, positive if greater"
    }
  },
  {
    "__docId__": 2059,
    "kind": "method",
    "name": "isAfter",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#isAfter",
    "access": "public",
    "description": "Is this year-week after the specified year-week.",
    "lineNumber": 937,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-week to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is after the specified year-week"
    }
  },
  {
    "__docId__": 2060,
    "kind": "method",
    "name": "isBefore",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#isBefore",
    "access": "public",
    "description": "Is this year-week before the specified year-week.",
    "lineNumber": 947,
    "params": [
      {
        "nullable": null,
        "types": [
          "YearWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other year-week to compare to, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this point is before the specified year-week"
    }
  },
  {
    "__docId__": 2061,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#equals",
    "access": "public",
    "description": "Checks if this year-week is equal to another year-week.",
    "lineNumber": 958,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "the object to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if this is equal to the other year-week"
    }
  },
  {
    "__docId__": 2062,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#hashCode",
    "access": "public",
    "description": "A hash code for this year-week.",
    "lineNumber": 973,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 2063,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/extra/src/YearWeek.js~YearWeek",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/extra/src/YearWeek.js~YearWeek#toString",
    "access": "public",
    "description": "Outputs this year-week as a {@link String}, such as `2015-W13`.\n\nThe output will be in the format `YYYY-'W'ww`:",
    "lineNumber": 985,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "a string representation of this year-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 2064,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/extra/src/YearWeek.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/YearWeek.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 1006,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2065,
    "kind": "function",
    "name": "createTemporalQuery",
    "memberof": "packages/extra/src/YearWeek.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/YearWeek.js~createTemporalQuery",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/YearWeek.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1020,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "queryFromFunction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2066,
    "kind": "file",
    "name": "packages/extra/src/_init.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { _init as dayOfMonthInit } from './DayOfMonth';\nimport { _init as dayOfYearInit } from './DayOfYear';\nimport { _init as intervalInit } from './Interval';\nimport { _init as localDateRangeInit } from './LocalDateRange';\nimport { _init as offsetDateInit } from './OffsetDate';\nimport { _init as quarterInit } from './Quarter';\nimport { _init as temporalsInit } from './Temporals';\nimport { _init as yearQuarterInit } from './YearQuarter';\nimport { _init as yearWeekInit } from './YearWeek';\n\nlet isInit = false;\n\nfunction init() {\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    dayOfMonthInit();\n    dayOfYearInit();\n    intervalInit();\n    localDateRangeInit();\n    offsetDateInit();\n    quarterInit();\n    temporalsInit();\n    yearQuarterInit();\n    yearWeekInit();\n}\n\ninit();\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/_init.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2067,
    "kind": "variable",
    "name": "isInit",
    "memberof": "packages/extra/src/_init.js",
    "static": true,
    "longname": "packages/extra/src/_init.js~isInit",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2068,
    "kind": "function",
    "name": "init",
    "memberof": "packages/extra/src/_init.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/_init.js~init",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/extra/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2069,
    "kind": "file",
    "name": "packages/extra/src/assert.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nimport { NullPointerException, IllegalArgumentException } from '@js-joda/core';\n\n/**\n * @private\n *\n * @param assertion\n * @param msg\n * @param error\n */\nexport function assert(assertion, msg, error) {\n    if (!assertion) {\n        if (error) {\n            // eslint-disable-next-line new-cap\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\n\n/**\n * @private\n *\n * @param value\n * @param parameterName\n * @return {*}\n */\nexport function requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(`${parameterName} must not be null`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param value\n * @param _class\n * @param parameterName\n * @return {_class}\n */\nexport function requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(`${parameterName} must be an instance of ${_class.name ? _class.name : _class}${value && value.constructor && value.constructor.name ? `, but is ${value.constructor.name}` : ''}`);\n    }\n    return value;\n}\n\n/**\n * @private\n *\n * @param methodName\n */\nexport function abstractMethodFail(methodName) {\n    throw new TypeError(`abstract method \"${methodName}\" is not implemented`);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/assert.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2070,
    "kind": "function",
    "name": "assert",
    "memberof": "packages/extra/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/assert.js~assert",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/assert.js",
    "importStyle": "{assert}",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "assertion",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 2071,
    "kind": "function",
    "name": "requireNonNull",
    "memberof": "packages/extra/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/assert.js~requireNonNull",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/assert.js",
    "importStyle": "{requireNonNull}",
    "description": "",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parameterName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2072,
    "kind": "function",
    "name": "requireInstance",
    "memberof": "packages/extra/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/assert.js~requireInstance",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/assert.js",
    "importStyle": "{requireInstance}",
    "description": "",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "_class",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parameterName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "_class"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2073,
    "kind": "function",
    "name": "abstractMethodFail",
    "memberof": "packages/extra/src/assert.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/assert.js~abstractMethodFail",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/assert.js",
    "importStyle": "{abstractMethodFail}",
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "methodName",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 2074,
    "kind": "file",
    "name": "packages/extra/src/js-joda-extra.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { use } from '@js-joda/core';\n\nimport { DayOfMonth } from './DayOfMonth';\nimport { DayOfYear } from './DayOfYear';\nimport { Interval } from './Interval';\nimport { LocalDateRange } from './LocalDateRange';\nimport { OffsetDate } from './OffsetDate';\nimport { Quarter } from './Quarter';\nimport { Temporals } from './Temporals';\nimport { YearQuarter } from './YearQuarter';\nimport { YearWeek } from './YearWeek';\nimport plug from './plug';\n\nuse(plug);\n\nexport {\n    DayOfMonth,\n    DayOfYear,\n    Interval,\n    LocalDateRange,\n    OffsetDate,\n    Quarter,\n    Temporals,\n    YearQuarter,\n    YearWeek,\n};\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/js-joda-extra.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2075,
    "kind": "file",
    "name": "packages/extra/src/plug.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n// import { DayOfMonth } from './DayOfMonth';\n// import { DayOfYear } from './DayOfYear';\n// import { Interval } from './Interval';\n// import { LocalDateRange } from './LocalDateRange';\n// import { OffsetDate } from './OffsetDate';\n// import { Quarter } from './Quarter';\n// import { Temporals } from './Temporals';\n// import { YearQuarter } from './YearQuarter';\n// import { YearWeek } from './YearWeek';\n\nimport './_init';\n\n/**\n * @private\n *\n * plugin Function, call using js-jodas use()\n */\nexport default function (/* jsJoda */) {\n    // assign new prop to jsJoda context is useless, because it lives only in the local context\n    // jsJoda.DayOfMonth = DayOfMonth;\n    // jsJoda.DayOfYear = DayOfYear;\n    // jsJoda.Interval = Interval;\n    // jsJoda.LocalDateRange = LocalDateRange;\n    // jsJoda.OffsetDate = OffsetDate;\n    // jsJoda.Quarter = Quarter;\n    // jsJoda.Temporals = Temporals;\n    // jsJoda.YearQuarter = YearQuarter;\n    // jsJoda.YearWeek = YearWeek;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/extra/src/plug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2076,
    "kind": "function",
    "name": "plug",
    "memberof": "packages/extra/src/plug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/extra/src/plug.js~plug",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/extra/src/plug.js",
    "importStyle": "plug",
    "description": "",
    "lineNumber": 23,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2077,
    "kind": "file",
    "name": "packages/locale/src/Locale.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport CldrDateTimeTextProvider from './format/cldr/CldrDateTimeTextProvider';\n\nexport default class Locale {\n    static getAvailableLocales() {\n        return new CldrDateTimeTextProvider().getAvailableLocales();\n    }\n\n    // TODO: maybe use new Cldr(<'en'>) constructor instead?\n    // see https://github.com/rxaviers/cldrjs#instantiate-a-locale-and-get-it-normalized\n    constructor(language, country = '', localeString = '') {\n        this._language = language;\n        this._country = country;\n        this._localeString = localeString;\n    }\n\n    language() {\n        return this._language;\n    }\n\n    country() {\n        return this._country;\n    }\n\n    localeString() {\n        if (this._localeString.length > 0) {\n            return this._localeString;\n        }\n        if (this._country.length > 0) {\n            return `${this._language}-${this._country}`;\n        } else {\n            return this._language;\n        }\n    }\n\n    toString() {\n        return `Locale[${this.localeString()}]`;\n    }\n\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (!(other instanceof Locale)) {\n            return false;\n        }\n        return this.localeString() === other.localeString();\n    }\n}\n\nexport function _init() {\n    //some samples/consts\n    Locale.ENGLISH = new Locale('en');\n    Locale.US = new Locale('en', 'US', 'en'); // default in cldr-data, no en-US\n    Locale.UK = new Locale('en', 'GB');\n    Locale.CANADA = new Locale('en', 'CA');\n    Locale.FRENCH = new Locale('fr');\n    Locale.FRANCE = new Locale('fr', 'FR', 'fr'); // default in cldr-data, no fr-FR\n    Locale.GERMAN = new Locale('de');\n    Locale.GERMANY = new Locale('de', 'DE', 'de'); // default in cldr-data, no de-DE\n    Locale.KOREAN = new Locale('ko');\n    Locale.JAPANESE = new Locale('ja', 'JP');\n    Locale.JAPAN = new Locale('ja', 'JP', 'ja');\n    Locale.ITALIAN = new Locale('it');\n    Locale.ITALY = new Locale('it', 'IT', 'it');\n    Locale.CHINESE = new Locale('zh');\n    Locale.ROMANIAN = new Locale('ro');\n    Locale.SWEDISH = new Locale('sv');\n    Locale.SWEDEN = new Locale('sv', 'SE', 'sv');\n    Locale.HINDI = new Locale('hi');\n    Locale.RUSSIAN = new Locale('ru');\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/Locale.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2078,
    "kind": "class",
    "name": "Locale",
    "memberof": "packages/locale/src/Locale.js",
    "static": true,
    "longname": "packages/locale/src/Locale.js~Locale",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/Locale.js",
    "importStyle": "Locale",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 2079,
    "kind": "method",
    "name": "getAvailableLocales",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/Locale.js~Locale.getAvailableLocales",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2080,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true
  },
  {
    "__docId__": 2081,
    "kind": "member",
    "name": "_language",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#_language",
    "access": "private",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2082,
    "kind": "member",
    "name": "_country",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#_country",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2083,
    "kind": "member",
    "name": "_localeString",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#_localeString",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2084,
    "kind": "method",
    "name": "language",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#language",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2085,
    "kind": "method",
    "name": "country",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#country",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2086,
    "kind": "method",
    "name": "localeString",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#localeString",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2087,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#toString",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 2088,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/locale/src/Locale.js~Locale",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/Locale.js~Locale#equals",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2089,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/locale/src/Locale.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/Locale.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/Locale.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2090,
    "kind": "file",
    "name": "packages/locale/src/_init.js",
    "content": "/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { _init as localeInit } from './Locale';\nimport { _init as weekFieldsInit } from './temporal/WeekFields';\nimport { _init as dateTimeFormatterInit } from './format/LocaleDateTimeFormatter';\n\nlet isInit = false;\n\nfunction init() {\n    /* istanbul ignore if */\n    if (isInit) {\n        return;\n    }\n\n    isInit = true;\n\n    localeInit();\n    weekFieldsInit();\n    dateTimeFormatterInit();\n}\n\ninit();\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/_init.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2091,
    "kind": "variable",
    "name": "isInit",
    "memberof": "packages/locale/src/_init.js",
    "static": true,
    "longname": "packages/locale/src/_init.js~isInit",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2092,
    "kind": "function",
    "name": "init",
    "memberof": "packages/locale/src/_init.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/_init.js~init",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/_init.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2093,
    "kind": "file",
    "name": "packages/locale/src/format/LocaleDateTimeFormatter.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {\n    _ as jodaInternal,\n    DateTimeFormatter,\n    ChronoField,\n    ResolverStyle,\n    IsoChronology,\n} from '@js-joda/core';\n// eslint-disable-next-line no-unused-vars\nimport Locale from '../Locale';\nimport CldrDateTimeFormatterBuilder from './cldr/CldrDateTimeFormatterBuilder';\n\nconst { assert: { requireNonNull } } = jodaInternal;\n\nexport default class LocaleDateTimeFormatter extends DateTimeFormatter {\n\n    /**\n     * Returns a copy of this formatter with a new locale.\n     * <p>\n     * This is used to lookup any part of the formatter needing specific\n     * localization, such as the text or localized pattern.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param {!Locale} locale  the new locale, not null\n     * @return a formatter based on this formatter with the requested locale, not null\n     */\n    withLocale(locale) {\n        requireNonNull(locale, 'locale');\n        if (locale.equals(this._locale)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, locale, this._decimalStyle, this._resolverStyle, this._resolverFields, this._chrono, this._zone);\n    }\n}\n\nexport function _init() {\n    const dow = {\n        1: 'Mon',\n        2: 'Tue',\n        3: 'Wed',\n        4: 'Thu',\n        5: 'Fri',\n        6: 'Sat',\n        7: 'Sun',\n    };\n\n    const moy = {\n        1: 'Jan',\n        2: 'Feb',\n        3: 'Mar',\n        4: 'Apr',\n        5: 'May',\n        6: 'Jun',\n        7: 'Jul',\n        8: 'Aug',\n        9: 'Sep',\n        10: 'Oct',\n        11: 'Nov',\n        12: 'Dec',\n    };\n\n    LocaleDateTimeFormatter.RFC_1123_DATE_TIME = new CldrDateTimeFormatterBuilder()\n        .parseCaseInsensitive()\n        .parseLenient()\n        .optionalStart()\n        .appendText(ChronoField.DAY_OF_WEEK, dow)\n        .appendLiteral(', ')\n        .optionalEnd()\n        .appendValue(ChronoField.DAY_OF_MONTH, 2)\n        .appendLiteral(' ')\n        .appendText(ChronoField.MONTH_OF_YEAR, moy)\n        .appendLiteral(' ')\n        .appendValue(ChronoField.YEAR, 4)  // 2 digit year not handled\n        .appendLiteral(' ')\n        .appendValue(ChronoField.HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)\n        .optionalStart()\n        .appendLiteral(':')\n        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)\n        .optionalEnd()\n        .appendLiteral(' ')\n        .appendZoneId()\n        .toFormatter(ResolverStyle.SMART).withChronology(IsoChronology.INSTANCE);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/LocaleDateTimeFormatter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2094,
    "kind": "variable",
    "name": "assert",
    "memberof": "packages/locale/src/format/LocaleDateTimeFormatter.js",
    "static": true,
    "longname": "packages/locale/src/format/LocaleDateTimeFormatter.js~assert",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleDateTimeFormatter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2095,
    "kind": "class",
    "name": "LocaleDateTimeFormatter",
    "memberof": "packages/locale/src/format/LocaleDateTimeFormatter.js",
    "static": true,
    "longname": "packages/locale/src/format/LocaleDateTimeFormatter.js~LocaleDateTimeFormatter",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleDateTimeFormatter.js",
    "importStyle": "LocaleDateTimeFormatter",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "interface": false,
    "extends": [
      "@js-joda/core~DateTimeFormatter"
    ]
  },
  {
    "__docId__": 2096,
    "kind": "method",
    "name": "withLocale",
    "memberof": "packages/locale/src/format/LocaleDateTimeFormatter.js~LocaleDateTimeFormatter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/LocaleDateTimeFormatter.js~LocaleDateTimeFormatter#withLocale",
    "access": "public",
    "description": "Returns a copy of this formatter with a new locale.\n<p>\nThis is used to lookup any part of the formatter needing specific\nlocalization, such as the text or localized pattern.\n<p>\nThis instance is immutable and unaffected by this method call.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": false,
        "types": [
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the new locale, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a formatter based on this formatter with the requested locale, not null"
    }
  },
  {
    "__docId__": 2097,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/locale/src/format/LocaleDateTimeFormatter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/LocaleDateTimeFormatter.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleDateTimeFormatter.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2098,
    "kind": "file",
    "name": "packages/locale/src/format/LocaleStore.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n\n/**\n * @private\n *\n * Helper method to create an immutable entry.\n *\n * @param text  the text, not null\n * @param field  the field, not null\n * @return the entry, not null\n */\nexport const createEntry = (text, field) => {\n    return {\n        key: text,\n        value: field,\n        toString: function () {\n            return `${text}->${field}`;\n        }\n    };\n};\n\nconst _comparator = (obj1, obj2) => {\n    return obj2.key.length - obj1.key.length;  // longest to shortest\n};\n\n/**\n * Stores the text for a single locale.\n * <p>\n * Some fields have a textual representation, such as day-of-week or month-of-year.\n * These textual representations can be captured in this class for printing\n * and parsing.\n */\nexport class LocaleStore {\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor.\n     *\n     * @param {Object} valueTextMap  the map of values to text to store, assigned and not altered, not null\n     */\n    constructor(valueTextMap) {\n        this._valueTextMap = valueTextMap;\n        const map = {};\n        let allList = [];\n        Object.keys(valueTextMap).forEach((style) => {\n            const reverse = {};\n            const list = [];\n            Object.keys(valueTextMap[style]).forEach((key) => {\n                const value = valueTextMap[style][key];\n                if (reverse[value] === undefined) {\n                    reverse[value] = createEntry(value, parseInt(key));\n                    list.push(reverse[value]);\n                }\n            });\n            list.sort(_comparator);\n            map[style] = list;\n            allList = allList.concat(list);\n            map[null] = allList;\n        });\n        allList.sort(_comparator);\n        this._parsable = map;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text for the specified field value, locale and style\n     * for the purpose of printing.\n     *\n     * @param {Number} value  the value to get text for, not null\n     * @param {TextStyle} style  the style to get text for, not null\n     * @return the text for the field value, null if no text found\n     */\n    getText(value, style) {\n        const map = this._valueTextMap[style];\n        return map != null ? map[value] : null;\n    }\n\n    /**\n     * Gets an iterator of text to field for the specified style for the purpose of parsing.\n     * <p>\n     * The iterator must be returned in order from the longest text to the shortest.\n     *\n     * @param style  the style to get text for, null for all parsable text\n     * @return the iterator of text to field pairs, in order from longest text to shortest text,\n     *  null if the style is not parsable\n     */\n    getTextIterator(style) {\n        const list = this._parsable[style];\n        return list != null ? list[Symbol.iterator]() : null;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/LocaleStore.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2099,
    "kind": "function",
    "name": "createEntry",
    "memberof": "packages/locale/src/format/LocaleStore.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/LocaleStore.js~createEntry",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleStore.js",
    "importStyle": "{createEntry}",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": "the text, not null"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the entry, not null"
    },
    "ignore": true
  },
  {
    "__docId__": 2100,
    "kind": "function",
    "name": "_comparator",
    "memberof": "packages/locale/src/format/LocaleStore.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/LocaleStore.js~_comparator",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleStore.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "obj1",
        "types": [
          "*"
        ]
      },
      {
        "name": "obj2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2101,
    "kind": "class",
    "name": "LocaleStore",
    "memberof": "packages/locale/src/format/LocaleStore.js",
    "static": true,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/LocaleStore.js",
    "importStyle": "{LocaleStore}",
    "description": "Stores the text for a single locale.\n<p>\nSome fields have a textual representation, such as day-of-week or month-of-year.\nThese textual representations can be captured in this class for printing\nand parsing.",
    "lineNumber": 37,
    "interface": false
  },
  {
    "__docId__": 2102,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "valueTextMap",
        "description": "the map of values to text to store, assigned and not altered, not null"
      }
    ]
  },
  {
    "__docId__": 2103,
    "kind": "member",
    "name": "_valueTextMap",
    "memberof": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "static": false,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore#_valueTextMap",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2104,
    "kind": "member",
    "name": "_parsable",
    "memberof": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "static": false,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore#_parsable",
    "access": "private",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2105,
    "kind": "method",
    "name": "getText",
    "memberof": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore#getText",
    "access": "public",
    "description": "Gets the text for the specified field value, locale and style\nfor the purpose of printing.",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to get text for, not null"
      },
      {
        "nullable": null,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "the style to get text for, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the text for the field value, null if no text found"
    }
  },
  {
    "__docId__": 2106,
    "kind": "method",
    "name": "getTextIterator",
    "memberof": "packages/locale/src/format/LocaleStore.js~LocaleStore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/LocaleStore.js~LocaleStore#getTextIterator",
    "access": "public",
    "description": "Gets an iterator of text to field for the specified style for the purpose of parsing.\n<p>\nThe iterator must be returned in order from the longest text to the shortest.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "style",
        "description": "the style to get text for, null for all parsable text"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the iterator of text to field pairs, in order from longest text to shortest text,\n null if the style is not parsable"
    }
  },
  {
    "__docId__": 2107,
    "kind": "file",
    "name": "packages/locale/src/format/cldr/CldrCache.js",
    "content": "/*\n* @copyright (c) 2020, Philipp Thuerwaechter & Pattrick Hueper\n* @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n*/\n\nimport cldrData from 'cldr-data';\nimport Cldr from 'cldrjs';\n\nconst cldrDataLoaded = new Set();\n/**\n * @private\n *\n* Loads the Cldr data for the given path if it hasn't been loaded before.\n*/\nexport const loadCldrData = (path) => {\n    if (!cldrDataLoaded.has(path)) {\n        Cldr.load(cldrData(path));\n        cldrDataLoaded.add(path);\n    }\n};\n\nconst localeToCldrInstanceCache = {};\n/**\n * @private\n *\n* Returns a Cldr instance for the given locale.\n* Memoized, so a given locale will always return the exact same cldr instance.\n*/\nexport const getOrCreateCldrInstance = (locale) => {\n    if (localeToCldrInstanceCache[locale] == null) {\n        localeToCldrInstanceCache[locale] = new Cldr(locale);\n    }\n\n    return localeToCldrInstanceCache[locale];\n};\n\nconst localeToMapZonesCache = {};\n/**\n * @private\n *\n* Returns a map zones object for a Cldr instance.\n* Memoized, so for any given Cldr instance locale, the same object will be returned.\n*/\nexport const getOrCreateMapZones = (cldr) => {\n    if (localeToMapZonesCache[cldr.locale] == null) {\n        const mapZones = {};\n\n        cldr.get('supplemental/metaZones/metazones').forEach((metaZone) => {\n            if (metaZone.mapZone) {\n                if (!mapZones[metaZone.mapZone._other]) {\n                    mapZones[metaZone.mapZone._other] = {};\n                }\n                mapZones[metaZone.mapZone._other][metaZone.mapZone._territory] = metaZone.mapZone._type;\n            }\n        });\n\n        localeToMapZonesCache[cldr.locale] = mapZones;\n    }\n\n    return localeToMapZonesCache[cldr.locale];\n};\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/cldr/CldrCache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2108,
    "kind": "variable",
    "name": "cldrDataLoaded",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~cldrDataLoaded",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2109,
    "kind": "function",
    "name": "loadCldrData",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~loadCldrData",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": "{loadCldrData}",
    "description": "",
    "lineNumber": 15,
    "ignore": true,
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 2110,
    "kind": "variable",
    "name": "localeToCldrInstanceCache",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~localeToCldrInstanceCache",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2111,
    "kind": "function",
    "name": "getOrCreateCldrInstance",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~getOrCreateCldrInstance",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": "{getOrCreateCldrInstance}",
    "description": "",
    "lineNumber": 29,
    "ignore": true,
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2112,
    "kind": "variable",
    "name": "localeToMapZonesCache",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~localeToMapZonesCache",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2113,
    "kind": "function",
    "name": "getOrCreateMapZones",
    "memberof": "packages/locale/src/format/cldr/CldrCache.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrCache.js~getOrCreateMapZones",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrCache.js",
    "importStyle": "{getOrCreateMapZones}",
    "description": "",
    "lineNumber": 44,
    "ignore": true,
    "params": [
      {
        "name": "cldr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2114,
    "kind": "file",
    "name": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { ChronoField, IsoFields, TextStyle } from '@js-joda/core';\n\nimport cldrData from 'cldr-data';\n\nimport { LocaleStore, createEntry } from '../LocaleStore';\nimport { getOrCreateCldrInstance, loadCldrData } from './CldrCache';\n\n/**\n * The Service Provider Implementation to obtain date-time text for a field.\n * <p>\n * This implementation is based on data from cldr.\n *\n * @private\n */\nexport default class CldrDateTimeTextProvider {\n\n    constructor() {\n        this._cache = {};\n        loadCldrData('supplemental/likelySubtags.json');\n    }\n\n    //-----------------------------------------------------------------------\n    getAvailableLocales() {\n        return cldrData('availableLocales.json').availableLocales;\n    }\n\n    //-----------------------------------------------------------------------\n    getText(field, value, style, locale) {\n        const store = this._findStore(field, locale);\n        if (store instanceof LocaleStore) {\n            return store.getText(value, style);\n        }\n        return null;\n    }\n\n    getTextIterator(field, style, locale) {\n        const store = this._findStore(field, locale);\n        if (store instanceof LocaleStore) {\n            return store.getTextIterator(style);\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    _findStore(field, locale) {\n        const key = createEntry(field, locale);\n        let store = this._cache[key];\n        if (store === undefined) {\n            store = this._createStore(field, locale);\n            this._cache[key] = store;\n        }\n        return store;\n    }\n\n    _createStore(field, locale) {\n        loadCldrData(`main/${locale.localeString()}/ca-gregorian.json`);\n        const cldr = getOrCreateCldrInstance(locale.localeString());\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            const monthsData = cldr.main('dates/calendars/gregorian/months/format');\n            const styleMap = {};\n            let data = {};\n            data[1] = monthsData.wide[1];\n            data[2] = monthsData.wide[2];\n            data[3] = monthsData.wide[3];\n            data[4] = monthsData.wide[4];\n            data[5] = monthsData.wide[5];\n            data[6] = monthsData.wide[6];\n            data[7] = monthsData.wide[7];\n            data[8] = monthsData.wide[8];\n            data[9] = monthsData.wide[9];\n            data[10] = monthsData.wide[10];\n            data[11] = monthsData.wide[11];\n            data[12] = monthsData.wide[12];\n            styleMap[TextStyle.FULL] = data;\n\n            data = {};\n            data[1] = monthsData.narrow[1];\n            data[2] = monthsData.narrow[2];\n            data[3] = monthsData.narrow[3];\n            data[4] = monthsData.narrow[4];\n            data[5] = monthsData.narrow[5];\n            data[6] = monthsData.narrow[6];\n            data[7] = monthsData.narrow[7];\n            data[8] = monthsData.narrow[8];\n            data[9] = monthsData.narrow[9];\n            data[10] = monthsData.narrow[10];\n            data[11] = monthsData.narrow[11];\n            data[12] = monthsData.narrow[12];\n            styleMap[TextStyle.NARROW] = data;\n\n            data = {};\n            data[1] = monthsData.abbreviated[1];\n            data[2] = monthsData.abbreviated[2];\n            data[3] = monthsData.abbreviated[3];\n            data[4] = monthsData.abbreviated[4];\n            data[5] = monthsData.abbreviated[5];\n            data[6] = monthsData.abbreviated[6];\n            data[7] = monthsData.abbreviated[7];\n            data[8] = monthsData.abbreviated[8];\n            data[9] = monthsData.abbreviated[9];\n            data[10] = monthsData.abbreviated[10];\n            data[11] = monthsData.abbreviated[11];\n            data[12] = monthsData.abbreviated[12];\n            styleMap[TextStyle.SHORT] = data;\n            return this._createLocaleStore(styleMap);\n        }\n        if (field === ChronoField.DAY_OF_WEEK) {\n            const daysData = cldr.main('dates/calendars/gregorian/days/format');\n            const styleMap = {};\n            let data = {};\n            data[1] = daysData.wide.mon;\n            data[2] = daysData.wide.tue;\n            data[3] = daysData.wide.wed;\n            data[4] = daysData.wide.thu;\n            data[5] = daysData.wide.fri;\n            data[6] = daysData.wide.sat;\n            data[7] = daysData.wide.sun;\n            styleMap[TextStyle.FULL] = data;\n\n            data = {};\n            data[1] = daysData.narrow.mon;\n            data[2] = daysData.narrow.tue;\n            data[3] = daysData.narrow.wed;\n            data[4] = daysData.narrow.thu;\n            data[5] = daysData.narrow.fri;\n            data[6] = daysData.narrow.sat;\n            data[7] = daysData.narrow.sun;\n            styleMap[TextStyle.NARROW] = data;\n\n            data = {};\n            data[1] = daysData.abbreviated.mon;\n            data[2] = daysData.abbreviated.tue;\n            data[3] = daysData.abbreviated.wed;\n            data[4] = daysData.abbreviated.thu;\n            data[5] = daysData.abbreviated.fri;\n            data[6] = daysData.abbreviated.sat;\n            data[7] = daysData.abbreviated.sun;\n            styleMap[TextStyle.SHORT] = data;\n            return this._createLocaleStore(styleMap);\n        }\n        if (field === ChronoField.AMPM_OF_DAY) {\n            const dayPeriodsData = cldr.main('dates/calendars/gregorian/dayPeriods/format');\n            const styleMap = {};\n            let data = {};\n            data[0] = dayPeriodsData.wide.am;\n            data[1] = dayPeriodsData.wide.pm;\n            styleMap[TextStyle.FULL] = data;\n\n            data = {};\n            data[0] = dayPeriodsData.narrow.am;\n            data[1] = dayPeriodsData.narrow.pm;\n            styleMap[TextStyle.NARROW] = data;\n\n            data = {};\n            data[0] = dayPeriodsData.abbreviated.am;\n            data[1] = dayPeriodsData.abbreviated.pm;\n            styleMap[TextStyle.SHORT] = data;\n\n            return this._createLocaleStore(styleMap);\n        }\n        if (field === ChronoField.ERA) {\n            const erasData = cldr.main('dates/calendars/gregorian/eras');\n            const styleMap = {};\n            let data = {};\n            data[0] = erasData.eraNames['0'];\n            data[1] = erasData.eraNames['1'];\n            styleMap[TextStyle.FULL] = data;\n\n            data = {};\n            data[0] = erasData.eraNarrow['0'];\n            data[1] = erasData.eraNarrow['1'];\n            styleMap[TextStyle.NARROW] = data;\n\n            data = {};\n            data[0] = erasData.eraAbbr['0'];\n            data[1] = erasData.eraAbbr['1'];\n            styleMap[TextStyle.SHORT] = data;\n\n            return this._createLocaleStore(styleMap);\n        }\n        if (field === IsoFields.QUARTER_OF_YEAR) {\n            const quartersData = cldr.main('dates/calendars/gregorian/quarters/format');\n            const styleMap = {};\n            let data = {};\n            data[1] = quartersData.wide['1'];\n            data[2] = quartersData.wide['2'];\n            data[3] = quartersData.wide['3'];\n            data[4] = quartersData.wide['4'];\n            styleMap[TextStyle.FULL] = data;\n\n            data = {};\n            data[1] = quartersData.narrow['1'];\n            data[2] = quartersData.narrow['2'];\n            data[3] = quartersData.narrow['3'];\n            data[4] = quartersData.narrow['4'];\n            styleMap[TextStyle.NARROW] = data;\n\n            data = {};\n            data[1] = quartersData.abbreviated['1'];\n            data[2] = quartersData.abbreviated['2'];\n            data[3] = quartersData.abbreviated['3'];\n            data[4] = quartersData.abbreviated['4'];\n            styleMap[TextStyle.SHORT] = data;\n\n            return this._createLocaleStore(styleMap);\n        }\n        return null;  // null marker for map\n    }\n\n    //-----------------------------------------------------------------------\n    _createLocaleStore(valueTextMap) {\n        valueTextMap[TextStyle.FULL_STANDALONE] = valueTextMap[TextStyle.FULL];\n        valueTextMap[TextStyle.SHORT_STANDALONE] = valueTextMap[TextStyle.SHORT];\n        /* istanbul ignore if */ // this doesn't seem to happen?\n        if (Object.keys(valueTextMap).indexOf(TextStyle.NARROW) > -1\n                && Object.keys(valueTextMap).indexOf(TextStyle.NARROW_STANDALONE) === -1) {\n            valueTextMap[TextStyle.NARROW_STANDALONE] = valueTextMap[TextStyle.NARROW];\n        }\n        return new LocaleStore(valueTextMap);\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/cldr/CldrDateTimeTextProvider.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2115,
    "kind": "class",
    "name": "CldrDateTimeTextProvider",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrDateTimeTextProvider.js",
    "importStyle": "CldrDateTimeTextProvider",
    "description": "The Service Provider Implementation to obtain date-time text for a field.\n<p>\nThis implementation is based on data from cldr.",
    "lineNumber": 20,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2116,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true
  },
  {
    "__docId__": 2117,
    "kind": "member",
    "name": "_cache",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#_cache",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 2118,
    "kind": "method",
    "name": "getAvailableLocales",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#getAvailableLocales",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2119,
    "kind": "method",
    "name": "getText",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#getText",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "style",
        "types": [
          "*"
        ]
      },
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2120,
    "kind": "method",
    "name": "getTextIterator",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#getTextIterator",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "style",
        "types": [
          "*"
        ]
      },
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2121,
    "kind": "method",
    "name": "_findStore",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#_findStore",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2122,
    "kind": "method",
    "name": "_createStore",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#_createStore",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2123,
    "kind": "method",
    "name": "_createLocaleStore",
    "memberof": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrDateTimeTextProvider.js~CldrDateTimeTextProvider#_createLocaleStore",
    "access": "private",
    "description": null,
    "lineNumber": 216,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "valueTextMap",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2124,
    "kind": "file",
    "name": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {\n    _ as jodaInternal,\n    TextStyle,\n    TemporalQueries,\n    ZoneId,\n    ZoneOffset,\n    ZoneRulesProvider,\n} from '@js-joda/core';\n\nimport { getOrCreateCldrInstance, getOrCreateMapZones, loadCldrData } from './CldrCache';\n\nconst { assert: { requireNonNull, requireInstance } } = jodaInternal;\n\n//-----------------------------------------------------------------------\nconst LENGTH_COMPARATOR = (str1, str2) => {\n    let cmp = str2.length - str1.length;\n    if (cmp === 0) {\n        cmp = str1.localeCompare(str2);\n    }\n    return cmp;\n};\n\n/**\n * Cache for `_cachedResolveZoneIdText`.\n *\n * Its basic structure is:\n * Obj { locale: zoneId }\n * Obj { zoneId: style}\n * Obj { style: type}\n * Obj { type: resolvedZoneIdText}\n */\nconst resolveZoneIdTextCache = {};\n\n/**\n * Prints or parses a zone ID.\n */\nexport default class CldrZoneTextPrinterParser {\n    /** The text style to output. */\n\n    constructor(textStyle) {\n        requireNonNull(textStyle, 'textStyle');\n        requireInstance(textStyle, TextStyle, 'textStyle');\n        this._textStyle = textStyle;\n        this._zoneIdsLocales = {};\n        loadCldrData('supplemental/likelySubtags.json');\n        loadCldrData('supplemental/metaZones.json');\n    }\n\n    _cachedResolveZoneIdText(cldr, zoneId, style, type) {\n        if (resolveZoneIdTextCache[cldr.locale] == null) {\n            resolveZoneIdTextCache[cldr.locale] = {};\n        }\n\n        const zoneIdToStyle = resolveZoneIdTextCache[cldr.locale];\n        if (zoneIdToStyle[zoneId] == null) {\n            zoneIdToStyle[zoneId] = {};\n        }\n\n        const styleToType = zoneIdToStyle[zoneId];\n        if (styleToType[style] == null) {\n            styleToType[style] = {};\n        }\n\n        const typeToResolvedZoneIdText = styleToType[style];\n        if (typeToResolvedZoneIdText[type] == null) {\n            typeToResolvedZoneIdText[type] = this._resolveZoneIdText(cldr, zoneId, style, type);\n        }\n\n        return typeToResolvedZoneIdText[type];\n    }\n\n    _resolveZoneIdText(cldr, zoneId, style, type) {\n        const zoneData = cldr.main(`dates/timeZoneNames/zone/${zoneId}/${style}/${type}`);\n        if (zoneData) {\n            return zoneData;\n        } else {\n            const metazoneInfo = cldr.get(`supplemental/metaZones/metazoneInfo/timezone/${zoneId}`);\n            if (metazoneInfo) {\n                // const zoneData = cldr.main(`dates/timeZoneNames/metazone/Acre`);\n                // TODO: determine metaZone for current temporal, for now, we use the last one :/\n                const metazone = metazoneInfo[metazoneInfo.length - 1]['usesMetazone']['_mzone'];\n                let metaZoneData = cldr.main(`dates/timeZoneNames/metazone/${metazone}/${style}/${type}`);\n                if (metaZoneData) {\n                    return metaZoneData;\n                } else {\n                    // type fallback, first generic, then standard\n                    metaZoneData = cldr.main(`dates/timeZoneNames/metazone/${metazone}/${style}/generic`);\n                    if (!metaZoneData) {\n                        metaZoneData = cldr.main(`dates/timeZoneNames/metazone/${metazone}/${style}/standard`);\n                    }\n                    if (metaZoneData) {\n                        return metaZoneData;\n                    } else {\n                        const mapZones = getOrCreateMapZones(cldr);\n                        // find preferred Zone and resolve again\n                        const preferredZone = mapZones[metazone][cldr.attributes.territory];\n                        if (preferredZone) {\n                            if (preferredZone !== zoneId) {\n                                return this._cachedResolveZoneIdText(cldr, preferredZone, style, type);\n                            }\n                        } else {\n                            // find golden Zone and resolve again\n                            const goldenZone = mapZones[metazone]['001'];\n                            if (goldenZone !== zoneId) {\n                                return this._cachedResolveZoneIdText(cldr, goldenZone, style, type);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    print(context, buf) {\n\n        //see http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Zone_Names\n\n        const zone = context.getValueQuery(TemporalQueries.zoneId());\n        /* istanbul ignore if */ // shouldn't happen... getValueQuery throws before returning null\n        if (zone == null) {\n            return false;\n        }\n        if (zone.normalized() instanceof ZoneOffset) {\n            buf.append(zone.id());\n            return true;\n        }\n        const daylight = false;\n        const hasDaylightSupport = false;\n        /* TODO: currently js-joda-timezone does not support ZoneRules.isDaylightSavings() ... uncomment if it does\n         const temporal = context.temporal();\n         if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            hasDaylightSupport = true;\n            const instant = Instant.ofEpochSecond(temporal.getLong(ChronoField.INSTANT_SECONDS));\n            daylight = zone.rules().isDaylightSavings(instant);\n        }*/\n        const tzType = hasDaylightSupport ? (daylight ? 'daylight' : 'standard') : 'generic';\n        const tzstyle = (this._textStyle.asNormal() === TextStyle.FULL ? 'long' : 'short');\n        loadCldrData(`main/${context.locale().localeString()}/timeZoneNames.json`);\n        const cldr = getOrCreateCldrInstance(context.locale().localeString());\n\n        const text = this._cachedResolveZoneIdText(cldr, zone.id(), tzstyle, tzType);\n        if (text) {\n            buf.append(text);\n        } else {\n            // fallback, print zoneId\n            buf.append(zone.id());\n        }\n        return true;\n    }\n\n    _resolveZoneIds(localString) {\n        if(this._zoneIdsLocales[localString] != null) {\n            return this._zoneIdsLocales[localString];\n        }\n        const ids = {};\n        loadCldrData(`main/${localString}/timeZoneNames.json`);\n        const cldr = getOrCreateCldrInstance(localString);\n\n        for (const id of ZoneRulesProvider.getAvailableZoneIds()) {\n            ids[id] = id;\n            const tzstyle = (this._textStyle.asNormal() === TextStyle.FULL ? 'long' : 'short');\n\n            const genericText = this._cachedResolveZoneIdText(cldr, id, tzstyle, 'generic');\n            if (genericText) {\n                ids[genericText] = id;\n            }\n            const standardText = this._cachedResolveZoneIdText(cldr, id, tzstyle, 'standard');\n            if (standardText) {\n                ids[standardText] = id;\n            }\n            const daylightText = this._cachedResolveZoneIdText(cldr, id, tzstyle, 'daylight');\n            if (daylightText) {\n                ids[daylightText] = id;\n            }\n        }\n        // threeten is using a (sorted) TreeMap... so we need to sort the keys\n        const sortedKeys = Object.keys(ids).sort(LENGTH_COMPARATOR);\n\n        this._zoneIdsLocales[localString] = { ids, sortedKeys };\n        return this._zoneIdsLocales[localString];\n    }\n\n    // That's a very poor implementation, there are missing bug fixes and functionality from threeten and jdk\n    parse(context, text, position) {\n        for (const name of ['UTC', 'GMT']) {\n            if (context.subSequenceEquals(text, position, name, 0, name.length)) {\n                context.setParsedZone(ZoneId.of(name));\n                return position + name.length;\n            }\n        }\n        const { ids, sortedKeys } = this._resolveZoneIds(context.locale().localeString());\n        for (const name of sortedKeys) {\n            if (context.subSequenceEquals(text, position, name, 0, name.length)) {\n                context.setParsedZone(ZoneId.of(ids[name]));\n                return position + name.length;\n            }\n        }\n        return ~position;\n    }\n\n    toString() {\n        return `ZoneText(${this._textStyle})`;\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2125,
    "kind": "variable",
    "name": "assert",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~assert",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2126,
    "kind": "function",
    "name": "LENGTH_COMPARATOR",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~LENGTH_COMPARATOR",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "str1",
        "types": [
          "*"
        ]
      },
      {
        "name": "str2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2127,
    "kind": "variable",
    "name": "resolveZoneIdTextCache",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~resolveZoneIdTextCache",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "importStyle": null,
    "description": "Cache for `_cachedResolveZoneIdText`.\n\nIts basic structure is:\nObj { locale: zoneId }\nObj { zoneId: style}\nObj { style: type}\nObj { type: resolvedZoneIdText}",
    "lineNumber": 37,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2128,
    "kind": "class",
    "name": "CldrZoneTextPrinterParser",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js",
    "importStyle": "CldrZoneTextPrinterParser",
    "description": "Prints or parses a zone ID.",
    "lineNumber": 42,
    "interface": false
  },
  {
    "__docId__": 2129,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#constructor",
    "access": "public",
    "description": "The text style to output.",
    "lineNumber": 45
  },
  {
    "__docId__": 2130,
    "kind": "member",
    "name": "_textStyle",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#_textStyle",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2131,
    "kind": "member",
    "name": "_zoneIdsLocales",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#_zoneIdsLocales",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 2132,
    "kind": "method",
    "name": "_cachedResolveZoneIdText",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#_cachedResolveZoneIdText",
    "access": "private",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "cldr",
        "types": [
          "*"
        ]
      },
      {
        "name": "zoneId",
        "types": [
          "*"
        ]
      },
      {
        "name": "style",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2133,
    "kind": "method",
    "name": "_resolveZoneIdText",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#_resolveZoneIdText",
    "access": "private",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "cldr",
        "types": [
          "*"
        ]
      },
      {
        "name": "zoneId",
        "types": [
          "*"
        ]
      },
      {
        "name": "style",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2134,
    "kind": "method",
    "name": "print",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2135,
    "kind": "method",
    "name": "_resolveZoneIds",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#_resolveZoneIds",
    "access": "private",
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "localString",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2136,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2137,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/cldr/CldrZoneTextPrinterParser.js~CldrZoneTextPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 2138,
    "kind": "file",
    "name": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    _ as jodaInternal,\n    DateTimeFormatterBuilder,\n    ChronoField,\n    TextStyle\n} from '@js-joda/core';\n\nconst { MathUtil } = jodaInternal;\n//-----------------------------------------------------------------------\n/**\n * Prints or parses field text.\n * @private\n */\nexport default class LocalizedOffsetPrinterParser {\n    /**\n     * Constructor.\n     *\n     * @param {!TextStyle} textStyle  the text style, not null\n     */\n    constructor(textStyle) {\n        this._textStyle = textStyle;\n    }\n\n    textStyle() {\n        return this._textStyle;\n    }\n\n    print(context, buf) {\n        const offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        /* istanbul ignore if */ // shouldn't happen... getValue throws for unsupported fields?\n        if (offsetSecs == null) {\n            return false;\n        }\n        buf.append('GMT');\n        if (this._textStyle === TextStyle.FULL) {\n            return new DateTimeFormatterBuilder.OffsetIdPrinterParser('', '+HH:MM:ss').print(context, buf);\n        }\n        const totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs !== 0) {\n            const absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));  // anything larger than 99 silently dropped\n            const absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs,60), 60));\n            const absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            buf.append(totalSecs < 0 ? '-' : '+').append(absHours);\n            if (absMinutes > 0 || absSeconds > 0) {\n                buf.append(':')\n                    .append(MathUtil.intDiv(absMinutes, 10)).append(MathUtil.intMod(absMinutes,10));\n                if (absSeconds > 0) {\n                    buf.append(':')\n                        .append(MathUtil.intDiv(absSeconds, 10)).append(MathUtil.intMod(absSeconds, 10));\n                }\n            }\n        }\n        return true;\n    }\n\n    parse(context, text, position) {\n        if (context.subSequenceEquals(text, position, 'GMT', 0, 3) === false) {\n            return ~position;\n        }\n        position += 3;\n        if (this._textStyle === TextStyle.FULL) {\n            return new DateTimeFormatterBuilder.OffsetIdPrinterParser('', '+HH:MM:ss').parse(context, text, position);\n        }\n        const end = text.length;\n        if (position === end) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n        }\n        const sign = text.charAt(position);\n        if (sign !== '+' && sign !== '-') {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n        }\n        const negative = (sign === '-' ? -1 : 1);\n        /* istanbul ignore if */ // cannot happen, already checked before\n        if (position === end) {\n            return ~position;\n        }\n        position++;\n        // hour\n        let ch = text.charAt(position);\n        if (ch < '0' || ch > '9') {\n            return ~position;\n        }\n        position++;\n        let hour = MathUtil.parseInt(ch);\n        if (position !== end) {\n            ch = text.charAt(position);\n            if (ch >= '0' && ch <= '9') {\n                hour = hour * 10 + MathUtil.parseInt(ch);\n                if (hour > 23) {\n                    return ~position;\n                }\n                position++;\n            }\n        }\n        if (position === end || text.charAt(position) !== ':') {\n            const offset = negative * 3600 * hour;\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, offset, position, position);\n        }\n        position++;\n        // minute\n        if (position > end - 2) {\n            return ~position;\n        }\n        ch = text.charAt(position);\n        if (ch < '0' || ch > '9') {\n            return ~position;\n        }\n        position++;\n        let min = MathUtil.parseInt(ch);\n        ch = text.charAt(position);\n        if (ch < '0' || ch > '9') {\n            return ~position;\n        }\n        position++;\n        min = min * 10 + MathUtil.parseInt(ch);\n        if (min > 59) {\n            return ~position;\n        }\n        if (position === end || text.charAt(position) !== ':') {\n            const offset = negative * (3600 * hour + 60 * min);\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, offset, position, position);\n        }\n        position++;\n        // second\n        if (position > end - 2) {\n            return ~position;\n        }\n        ch = text.charAt(position);\n        if (ch < '0' || ch > '9') {\n            return ~position;\n        }\n        position++;\n        let sec = MathUtil.parseInt(ch);\n        ch = text.charAt(position);\n        if (ch < '0' || ch > '9') {\n            return ~position;\n        }\n        position++;\n        sec = sec * 10 + MathUtil.parseInt(ch);\n        if (sec > 59) {\n            return ~position;\n        }\n        const offset = negative * (3600 * hour + 60 * min + sec);\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, offset, position, position);\n    }\n\n    toString() {\n        return `LocalizedOffset(${this._textStyle})`;\n    }\n\n}\n\n//-----------------------------------------------------------------------\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2139,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2140,
    "kind": "class",
    "name": "LocalizedOffsetPrinterParser",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js",
    "importStyle": "LocalizedOffsetPrinterParser",
    "description": "Prints or parses field text.",
    "lineNumber": 20,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2141,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": false,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "textStyle",
        "description": "the text style, not null"
      }
    ]
  },
  {
    "__docId__": 2142,
    "kind": "member",
    "name": "_textStyle",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#_textStyle",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2143,
    "kind": "method",
    "name": "textStyle",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#textStyle",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2144,
    "kind": "method",
    "name": "print",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2145,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2146,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/LocalizedOffsetPrinterParser.js~LocalizedOffsetPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 2147,
    "kind": "file",
    "name": "packages/locale/src/format/parser/TextPrinterParser.js",
    "content": "/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { DateTimeFormatterBuilder, IllegalArgumentException, SignStyle, TextStyle } from '@js-joda/core';\n\n//-----------------------------------------------------------------------\n/**\n * Prints or parses field text.\n * @private\n */\nexport default class TextPrinterParser {\n    /**\n     * Constructor.\n     *\n     * @param {!TemporalField} field  the field to output, not null\n     * @param {!TextStyle} textStyle  the text style, not null\n     * @param {!DateTimeProvider} provider  the text provider, not null\n     */\n    constructor(field, textStyle, provider) {\n        // validated by caller\n        this._field = field;\n        this._textStyle = textStyle;\n        this._provider = provider;\n    }\n\n    field() {\n        return this._field;\n    }\n\n    textStyle() {\n        return this._textStyle;\n    }\n\n    provider() {\n        return this._provider;\n    }\n\n    print(context, buf) {\n        const value = context.getValue(this._field);\n        if (value === null) {\n            return false;\n        }\n        const text = this._provider.getText(this._field, value, this._textStyle, context.locale());\n        if (text === null) {\n            return this._numberPrinterParser().print(context, buf);\n        }\n        buf.append(text);\n        return true;\n    }\n\n    parse(context, parseText, position) {\n        const length = parseText.length;\n        if (position < 0 || position > length) {\n            throw new IllegalArgumentException(`The position is invalid: ${position}`);\n        }\n        const style = (context.isStrict() ? this._textStyle : null);\n        const it = this._provider.getTextIterator(this._field, style, context.locale());\n        if (it != null) {\n            for (const entry of it) {\n                const itText = entry.key;\n                if (context.subSequenceEquals(itText, 0, parseText, position, itText.length)) {\n                    return context.setParsedField(this._field, entry.value, position, position + itText.length);\n                }\n            }\n            if (context.isStrict()) {\n                return ~position;\n            }\n        }\n        return this._numberPrinterParser().parse(context, parseText, position);\n    }\n\n    /**\n     * Create and cache a number printer parser.\n     * @return the number printer parser for this field, not null\n     */\n    _numberPrinterParser() {\n        if (this._currentNumberPrinterParser == null) {\n            this._currentNumberPrinterParser = new DateTimeFormatterBuilder.NumberPrinterParser(this._field, 1, 19, SignStyle.NORMAL);\n        }\n        return this._currentNumberPrinterParser;\n    }\n\n    toString() {\n        if (this._textStyle === TextStyle.FULL) {\n            return `Text(${this._field})`;\n        }\n        return `Text(${this._field},${this._textStyle})`;\n    }\n}\n\n//-----------------------------------------------------------------------\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/parser/TextPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2148,
    "kind": "class",
    "name": "TextPrinterParser",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/parser/TextPrinterParser.js",
    "importStyle": "TextPrinterParser",
    "description": "Prints or parses field text.",
    "lineNumber": 14,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2149,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#constructor",
    "access": "public",
    "description": "Constructor.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": false,
        "types": [
          "TemporalField"
        ],
        "spread": false,
        "optional": false,
        "name": "field",
        "description": "the field to output, not null"
      },
      {
        "nullable": false,
        "types": [
          "TextStyle"
        ],
        "spread": false,
        "optional": false,
        "name": "textStyle",
        "description": "the text style, not null"
      },
      {
        "nullable": false,
        "types": [
          "DateTimeProvider"
        ],
        "spread": false,
        "optional": false,
        "name": "provider",
        "description": "the text provider, not null"
      }
    ]
  },
  {
    "__docId__": 2150,
    "kind": "member",
    "name": "_field",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#_field",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2151,
    "kind": "member",
    "name": "_textStyle",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#_textStyle",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2152,
    "kind": "member",
    "name": "_provider",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#_provider",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2153,
    "kind": "method",
    "name": "field",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#field",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2154,
    "kind": "method",
    "name": "textStyle",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#textStyle",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2155,
    "kind": "method",
    "name": "provider",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#provider",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2156,
    "kind": "method",
    "name": "print",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2157,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "parseText",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2158,
    "kind": "method",
    "name": "_numberPrinterParser",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#_numberPrinterParser",
    "access": "private",
    "description": "Create and cache a number printer parser.",
    "lineNumber": 79,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the number printer parser for this field, not null"
    },
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 2159,
    "kind": "member",
    "name": "_currentNumberPrinterParser",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#_currentNumberPrinterParser",
    "access": "private",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2160,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/TextPrinterParser.js~TextPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 2161,
    "kind": "file",
    "name": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport { _ as jodaInternal, DateTimeFormatterBuilder, SignStyle } from '@js-joda/core';\n\nimport { WeekFields } from '../../temporal/WeekFields';\n\nconst { StringBuilder } = jodaInternal;\n\nexport default class WeekFieldsPrinterParser {\n    constructor(letter, count) {\n        this._letter = letter;\n        this._count = count;\n    }\n\n    print(context, buf) {\n        const weekFields = WeekFields.of(context.locale());\n        const pp = this._evaluate(weekFields);\n        return pp.print(context, buf);\n    }\n\n    parse(context, text, position) {\n        const weekFields = WeekFields.of(context.locale());\n        const pp = this._evaluate(weekFields);\n        return pp.parse(context, text, position);\n    }\n\n    _evaluate(weekFields) {\n        let pp = null;\n        switch (this._letter) {\n            case 'e':  // day-of-week\n                pp = new DateTimeFormatterBuilder.NumberPrinterParser(weekFields.dayOfWeek(), this._count, 2, SignStyle.NOT_NEGATIVE);\n                break;\n            case 'c':  // day-of-week\n                pp = new DateTimeFormatterBuilder.NumberPrinterParser(weekFields.dayOfWeek(), this._count, 2, SignStyle.NOT_NEGATIVE);\n                break;\n            case 'w':  // week-of-year\n                pp = new DateTimeFormatterBuilder.NumberPrinterParser(weekFields.weekOfWeekBasedYear(), this._count, 2, SignStyle.NOT_NEGATIVE);\n                break;\n            case 'W':  // week-of-month\n                pp = new DateTimeFormatterBuilder.NumberPrinterParser(weekFields.weekOfMonth(), 1, 2, SignStyle.NOT_NEGATIVE);\n                break;\n            case 'Y':  // weekyear\n                if (this._count === 2) {\n                    pp = new DateTimeFormatterBuilder.ReducedPrinterParser(weekFields.weekBasedYear(), 2, 2, 0, DateTimeFormatterBuilder.ReducedPrinterParser.BASE_DATE);\n                } else {\n                    pp = new DateTimeFormatterBuilder.NumberPrinterParser(weekFields.weekBasedYear(), this._count, 19,\n                        (this._count < 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD, -1);\n                }\n                break;\n        }\n        return pp;\n    }\n\n    toString() {\n        const sb = new StringBuilder(30);\n        sb.append('Localized(');\n        if (this._letter === 'Y') {\n            if (this._count === 1) {\n                sb.append('WeekBasedYear');\n            } else if (this._count === 2) {\n                sb.append('ReducedValue(WeekBasedYear,2,2,2000-01-01)');\n            } else {\n                sb.append('WeekBasedYear,').append(this._count).append(',')\n                    .append(19).append(',')\n                    .append((this._count < 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD);\n            }\n        } else {\n            if (this._letter === 'c' || this._letter === 'e') {\n                sb.append('DayOfWeek');\n            } else if (this._letter === 'w') {\n                sb.append('WeekOfWeekBasedYear');\n            } else if (this._letter === 'W') {\n                sb.append('WeekOfMonth');\n            }\n            sb.append(',');\n            sb.append(this._count);\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2162,
    "kind": "variable",
    "name": "StringBuilder",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~StringBuilder",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2163,
    "kind": "class",
    "name": "WeekFieldsPrinterParser",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "static": true,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/format/parser/WeekFieldsPrinterParser.js",
    "importStyle": "WeekFieldsPrinterParser",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 2164,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true
  },
  {
    "__docId__": 2165,
    "kind": "member",
    "name": "_letter",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#_letter",
    "access": "private",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2166,
    "kind": "member",
    "name": "_count",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#_count",
    "access": "private",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2167,
    "kind": "method",
    "name": "print",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#print",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "buf",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2168,
    "kind": "method",
    "name": "parse",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#parse",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "text",
        "types": [
          "*"
        ]
      },
      {
        "name": "position",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2169,
    "kind": "method",
    "name": "_evaluate",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#_evaluate",
    "access": "private",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "weekFields",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2170,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/format/parser/WeekFieldsPrinterParser.js~WeekFieldsPrinterParser#toString",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2171,
    "kind": "file",
    "name": "packages/locale/src/js-joda-locale.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\nimport { use } from '@js-joda/core';\nimport plug from './plug';\nimport Locale from './Locale';\nimport { WeekFields } from './temporal/WeekFields';\n\nuse(plug);\n\nexport {\n    Locale,\n    WeekFields\n};\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/js-joda-locale.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2172,
    "kind": "file",
    "name": "packages/locale/src/license-preamble.js",
    "content": "//! @copyright (c) 2015-2016, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/license-preamble.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2173,
    "kind": "file",
    "name": "packages/locale/src/plug.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\n/* eslint-disable no-param-reassign */\n\nimport CldrDateTimeFormatterBuilder from './format/cldr/CldrDateTimeFormatterBuilder';\nimport LocaleDateTimeFormatter from './format/LocaleDateTimeFormatter';\n\nimport './_init';\n\n/**\n * @private\n *\n * plugin Function, call using js-jodas use()\n *\n * @param jsJoda\n */\nexport default function (jsJoda) {\n    // inject all prototype properties (except constructor) from CldrDateTimeFormatterBuilder into DateTimeFormatterBuilder\n    Object.getOwnPropertyNames(CldrDateTimeFormatterBuilder.prototype).forEach((prop) => {\n        if (prop !== 'constructor') {\n            jsJoda.DateTimeFormatterBuilder.prototype[prop] = CldrDateTimeFormatterBuilder.prototype[prop];\n        }\n    });\n    // inject all prototype properties (except constructor) from LocaleDateTimeFormatter into DateTimeFormatter\n    Object.getOwnPropertyNames(LocaleDateTimeFormatter.prototype).forEach((prop) => {\n        if (prop !== 'constructor') {\n            jsJoda.DateTimeFormatter.prototype[prop] = LocaleDateTimeFormatter.prototype[prop];\n        }\n    });\n    // copy statics manually\n    jsJoda.DateTimeFormatter.RFC_1123_DATE_TIME = LocaleDateTimeFormatter.RFC_1123_DATE_TIME;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/plug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2174,
    "kind": "function",
    "name": "plug",
    "memberof": "packages/locale/src/plug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/plug.js~plug",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/plug.js",
    "importStyle": "plug",
    "description": "",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "jsJoda",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 2175,
    "kind": "file",
    "name": "packages/locale/src/temporal/WeekFields.js",
    "content": "/*\n * @copyright (c) 2017, Philipp Thuerwaechter & Pattrick Hueper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nimport {\n    _ as jodaInternal,\n    DateTimeException,\n    DayOfWeek,\n    ChronoField,\n    ChronoUnit,\n    IllegalArgumentException,\n    IllegalStateException,\n    IsoChronology,\n    IsoFields,\n    LocalDate,\n    ResolverStyle,\n    ValueRange,\n    Year\n} from '@js-joda/core';\nimport cldrData from 'cldr-data';\nimport Cldr from 'cldrjs';\n\nconst { MathUtil, assert: { requireNonNull, requireInstance } } = jodaInternal;\n\n//-----------------------------------------------------------------------\nconst DAY_OF_WEEK_RANGE = ValueRange.of(1, 7);\nconst WEEK_OF_MONTH_RANGE = ValueRange.of(0, 1, 4, 6);\nconst WEEK_OF_YEAR_RANGE = ValueRange.of(0, 1, 52, 54);\nconst WEEK_OF_WEEK_BASED_YEAR_RANGE = ValueRange.of(1, 52, 53);\nconst WEEK_BASED_YEAR_RANGE = ChronoField.YEAR.range();\n\n/* map from the string from cldr `firstDay()` to DayOfWeek */\nconst _weekDayMap = {\n    'mon': DayOfWeek.MONDAY,\n    'tue': DayOfWeek.TUESDAY,\n    'wed': DayOfWeek.WEDNESDAY,\n    'thu': DayOfWeek.THURSDAY,\n    'fri': DayOfWeek.FRIDAY,\n    'sat': DayOfWeek.SATURDAY,\n    'sun': DayOfWeek.SUNDAY,\n};\n\n/**\n * Field type that computes DayOfWeek, WeekOfMonth, and WeekOfYear\n * based on a WeekFields.\n * A separate Field instance is required for each different WeekFields;\n * combination of start of week and minimum number of days.\n * Constructors are provided to create fields for DayOfWeek, WeekOfMonth,\n * and WeekOfYear.\n */\nexport class ComputedDayOfField {\n\n    /**\n     * Returns a field to access the day of week,\n     * computed based on a WeekFields.\n     * <p>\n     * The WeekDefintion of the first day of the week is used with\n     * the ISO DAY_OF_WEEK field to compute week boundaries.\n     */\n    static ofDayOfWeekField(weekDef) {\n        return new ComputedDayOfField('DayOfWeek', weekDef,\n            ChronoUnit.DAYS, ChronoUnit.WEEKS, DAY_OF_WEEK_RANGE);\n    }\n\n    /**\n     * Returns a field to access the week of month,\n     * computed based on a WeekFields.\n     * @see WeekFields#weekOfMonth()\n     */\n    static ofWeekOfMonthField(weekDef) {\n        return new ComputedDayOfField('WeekOfMonth', weekDef,\n            ChronoUnit.WEEKS, ChronoUnit.MONTHS, WEEK_OF_MONTH_RANGE);\n    }\n\n    /**\n     * Returns a field to access the week of year,\n     * computed based on a WeekFields.\n     * @see WeekFields#weekOfYear()\n     */\n    static ofWeekOfYearField(weekDef) {\n        return new ComputedDayOfField('WeekOfYear', weekDef,\n            ChronoUnit.WEEKS, ChronoUnit.YEARS, WEEK_OF_YEAR_RANGE);\n    }\n\n    /**\n     * Returns a field to access the week of week-based-year,\n     * computed based on a WeekFields.\n     * @see WeekFields#weekOfWeekBasedYear()\n     */\n    static ofWeekOfWeekBasedYearField(weekDef) {\n        return new ComputedDayOfField('WeekOfWeekBasedYear', weekDef,\n            ChronoUnit.WEEKS, IsoFields.WEEK_BASED_YEARS, WEEK_OF_WEEK_BASED_YEAR_RANGE);\n    }\n\n    /**\n     * Returns a field to access the week-based-year,\n     * computed based on a WeekFields.\n     * @see WeekFields#weekBasedYear()\n     */\n    static ofWeekBasedYearField(weekDef) {\n        return new ComputedDayOfField('WeekBasedYear', weekDef,\n            IsoFields.WEEK_BASED_YEARS, ChronoUnit.FOREVER, WEEK_BASED_YEAR_RANGE);\n    }\n\n    /**\n     *@private\n     */\n    constructor(name, weekDef, baseUnit, rangeUnit, range) {\n        this._name = name;\n        this._weekDef = weekDef;\n        this._baseUnit = baseUnit;\n        this._rangeUnit = rangeUnit;\n        this._range = range;\n    }\n\n    getFrom(temporal) {\n        // Offset the ISO DOW by the start of this week\n        const sow = this._weekDef.firstDayOfWeek().value();\n        const dow = this._localizedDayOfWeek(temporal, sow);\n\n        if (this._rangeUnit === ChronoUnit.WEEKS) {\n            return dow;\n        } else if (this._rangeUnit === ChronoUnit.MONTHS) {\n            return this._localizedWeekOfMonth(temporal, dow);\n        } else if (this._rangeUnit === ChronoUnit.YEARS) {\n            return this._localizedWeekOfYear(temporal, dow);\n        } else if (this._rangeUnit === IsoFields.WEEK_BASED_YEARS) {\n            return this._localizedWOWBY(temporal);\n        } else if (this._rangeUnit === ChronoUnit.FOREVER) {\n            return this._localizedWBY(temporal);\n        } else {\n            throw new IllegalStateException('unreachable');\n        }\n    }\n\n    _localizedDayOfWeek(temporal, sow) {\n        const isoDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        return MathUtil.floorMod(isoDow - sow, 7) + 1;\n    }\n\n    _localizedWeekOfMonth(temporal, dow) {\n        const dom = temporal.get(ChronoField.DAY_OF_MONTH);\n        const offset = this._startOfWeekOffset(dom, dow);\n        return ComputedDayOfField._computeWeek(offset, dom);\n    }\n\n    _localizedWeekOfYear(temporal, dow) {\n        const doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        const offset = this._startOfWeekOffset(doy, dow);\n        return ComputedDayOfField._computeWeek(offset, doy);\n    }\n\n    _localizedWOWBY(temporal) {\n        const sow = this._weekDef.firstDayOfWeek().value();\n        const isoDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n        const woy = this._localizedWeekOfYear(temporal, dow);\n        if (woy === 0) {\n            const previous = LocalDate.from(temporal).minus(1, ChronoUnit.WEEKS);\n            return this._localizedWeekOfYear(previous, dow) + 1;\n        } else if (woy >= 53) {\n            const offset = this._startOfWeekOffset(temporal.get(ChronoField.DAY_OF_YEAR), dow);\n            const year = temporal.get(ChronoField.YEAR);\n            const yearLen = Year.isLeap(year) ? 366 : 365;\n            const weekIndexOfFirstWeekNextYear = ComputedDayOfField._computeWeek(offset, yearLen + this._weekDef.minimalDaysInFirstWeek());\n            if (woy >= weekIndexOfFirstWeekNextYear) {\n                return (woy - (weekIndexOfFirstWeekNextYear - 1));\n            }\n        }\n        return woy;\n    }\n\n    _localizedWBY(temporal) {\n        const sow = this._weekDef.firstDayOfWeek().value();\n        const isoDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n        const year = temporal.get(ChronoField.YEAR);\n        const woy = this._localizedWeekOfYear(temporal, dow);\n        if (woy === 0) {\n            return year - 1;\n        } else if (woy < 53) {\n            return year;\n        }\n        const offset = this._startOfWeekOffset(temporal.get(ChronoField.DAY_OF_YEAR), dow);\n        const yearLen = Year.isLeap(year) ? 366 : 365;\n        const weekIndexOfFirstWeekNextYear = ComputedDayOfField._computeWeek(offset, yearLen + this._weekDef.minimalDaysInFirstWeek());\n        if (woy >= weekIndexOfFirstWeekNextYear) {\n            return year + 1;\n        }\n        return year;\n    }\n\n    /**\n     * Returns an offset to align week start with a day of month or day of year.\n     *\n     * @param day the day; 1 through infinity\n     * @param dow the day of the week of that day; 1 through 7\n     * @return an offset in days to align a day with the start of the first 'full' week\n     */\n    _startOfWeekOffset(day, dow) {\n        // offset of first day corresponding to the day of week in first 7 days (zero origin)\n        const weekStart = MathUtil.floorMod(day - dow, 7);\n        let offset = -weekStart;\n        if (weekStart + 1 > this._weekDef.minimalDaysInFirstWeek()) {\n            // The previous week has the minimum days in the current month to be a 'week'\n            offset = 7 - weekStart;\n        }\n        return offset;\n    }\n\n    /**\n     * Returns the week number computed from the reference day and reference dayOfWeek.\n     *\n     * @param offset the offset to align a date with the start of week\n     *     from {@link #startOfWeekOffset}.\n     * @param day  the day for which to compute the week number\n     * @return the week number where zero is used for a partial week and 1 for the first full week\n     */\n    static _computeWeek(offset, day) {\n        return MathUtil.intDiv((7 + offset + (day - 1)), 7);\n    }\n\n    adjustInto(temporal, newValue) {\n        // Check the new value and get the old value of the field\n        const newVal = this._range.checkValidIntValue(newValue, this);\n        const currentVal = temporal.get(this);\n        if (newVal === currentVal) {\n            return temporal;\n        }\n        if (this._rangeUnit === ChronoUnit.FOREVER) {\n            // adjust in whole weeks so dow never changes\n            const baseWowby = temporal.get(this._weekDef.weekOfWeekBasedYear());\n            const diffWeeks = MathUtil.roundDown((newValue - currentVal) * 52.1775);\n            let result = temporal.plus(diffWeeks, ChronoUnit.WEEKS);\n            if (result.get(this) > newVal) {\n                // ended up in later week-based-year\n                // move to last week of previous year\n                const newWowby = result.get(this._weekDef.weekOfWeekBasedYear());\n                result = result.minus(newWowby, ChronoUnit.WEEKS);\n            } else {\n                if (result.get(this) < newVal) {\n                    // ended up in earlier week-based-year\n                    result = result.plus(2, ChronoUnit.WEEKS);\n                }\n                // reset the week-of-week-based-year\n                const newWowby = result.get(this._weekDef.weekOfWeekBasedYear());\n                result = result.plus(baseWowby - newWowby, ChronoUnit.WEEKS);\n                if (result.get(this) > newVal) {\n                    result = result.minus(1, ChronoUnit.WEEKS);\n                }\n            }\n            return result;\n        }\n        // Compute the difference and add that using the base using of the field\n        const delta = newVal - currentVal;\n        return temporal.plus(delta, this._baseUnit);\n    }\n\n    resolve(fieldValues, partialTemporal, resolverStyle) {\n        const sow = this._weekDef.firstDayOfWeek().value();\n        if (this._rangeUnit === ChronoUnit.WEEKS) {  // day-of-week\n            const value = fieldValues.remove(this);\n            const localDow = this._range.checkValidIntValue(value, this);\n            const isoDow = MathUtil.floorMod((sow - 1) + (localDow - 1), 7) + 1;\n            fieldValues.put(ChronoField.DAY_OF_WEEK, isoDow);\n            return null;\n        }\n        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK) === false) {\n            return null;\n        }\n\n        // week-based-year\n        if (this._rangeUnit === ChronoUnit.FOREVER) {\n            if (fieldValues.containsKey(this._weekDef.weekOfWeekBasedYear()) === false) {\n                return null;\n            }\n            // const chrono = IsoChronology.INSTANCE; //TODO: Chronology.from(partialTemporal);  // defaults to ISO\n            const isoDow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.get(ChronoField.DAY_OF_WEEK));\n            const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n            const wby = this.range().checkValidIntValue(fieldValues.get(this), this);\n            let date;\n            let days;\n            if (resolverStyle === ResolverStyle.LENIENT) {\n                date = LocalDate.of(wby, 1, this._weekDef.minimalDaysInFirstWeek()); //TODO: chrono.date(wby, 1, this._weekDef.minimalDaysInFirstWeek());\n                const wowby = fieldValues.get(this._weekDef.weekOfWeekBasedYear());\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const weeks = wowby - this._localizedWeekOfYear(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            } else {\n                date = LocalDate.of(wby, 1, this._weekDef.minimalDaysInFirstWeek()); //TODO: chrono.date(wby, 1, this._weekDef.minimalDaysInFirstWeek());\n                const wowby = this._weekDef.weekOfWeekBasedYear().range().checkValidIntValue(\n                    fieldValues.get(this._weekDef.weekOfWeekBasedYear()), this._weekDef.weekOfWeekBasedYear);\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const weeks = wowby - this._localizedWeekOfYear(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            }\n            date = date.plus(days, ChronoUnit.DAYS);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                if (date.getLong(this) !== fieldValues.get(this)) {\n                    throw new DateTimeException('Strict mode rejected date parsed to a different year');\n                }\n            }\n            fieldValues.remove(this);\n            fieldValues.remove(this._weekDef.weekOfWeekBasedYear());\n            fieldValues.remove(ChronoField.DAY_OF_WEEK);\n            return date;\n        }\n\n        if (fieldValues.containsKey(ChronoField.YEAR) === false) {\n            return null;\n        }\n        const isoDow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.get(ChronoField.DAY_OF_WEEK));\n        const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n        const year = ChronoField.YEAR.checkValidIntValue(fieldValues.get(ChronoField.YEAR));\n        // const chrono = IsoChronology.INSTANCE; //TODO: Chronology.from(partialTemporal);  // defaults to ISO\n        if (this._rangeUnit === ChronoUnit.MONTHS) {  // week-of-month\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR) === false) {\n                return null;\n            }\n            const value = fieldValues.remove(this);\n            let date;\n            let days;\n            if (resolverStyle === ResolverStyle.LENIENT) {\n                const month = fieldValues.get(ChronoField.MONTH_OF_YEAR);\n                date = LocalDate.of(year, 1, 1); // TODO: chrono.date(year, 1, 1);\n                date = date.plus(month - 1, ChronoUnit.MONTHS);\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const weeks = value - this._localizedWeekOfMonth(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            } else {\n                const month = ChronoField.MONTH_OF_YEAR.checkValidIntValue(fieldValues.get(ChronoField.MONTH_OF_YEAR));\n                date = LocalDate.of(year, month, 8); // TODO: chrono.date(year, month, 8);\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const wom = this._range.checkValidIntValue(value, this);\n                const weeks = wom - this._localizedWeekOfMonth(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            }\n            date = date.plus(days, ChronoUnit.DAYS);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                if (date.getLong(ChronoField.MONTH_OF_YEAR) !== fieldValues.get(ChronoField.MONTH_OF_YEAR)) {\n                    throw new DateTimeException('Strict mode rejected date parsed to a different month');\n                }\n            }\n            fieldValues.remove(this);\n            fieldValues.remove(ChronoField.YEAR);\n            fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n            fieldValues.remove(ChronoField.DAY_OF_WEEK);\n            return date;\n        } else if (this._rangeUnit === ChronoUnit.YEARS) {  // week-of-year\n            const value = fieldValues.remove(this);\n            let date = LocalDate.of(year, 1, 1); // TODO: chrono.date(year, 1, 1);\n            let days;\n            if (resolverStyle === ResolverStyle.LENIENT) {\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const weeks = value - this._localizedWeekOfYear(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            } else {\n                const dateDow = this._localizedDayOfWeek(date, sow);\n                const woy = this._range.checkValidIntValue(value, this);\n                const weeks = woy - this._localizedWeekOfYear(date, dateDow);\n                days = weeks * 7 + (dow - dateDow);\n            }\n            date = date.plus(days, ChronoUnit.DAYS);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                if (date.getLong(ChronoField.YEAR) !== fieldValues.get(ChronoField.YEAR)) {\n                    throw new DateTimeException('Strict mode rejected date parsed to a different year');\n                }\n            }\n            fieldValues.remove(this);\n            fieldValues.remove(ChronoField.YEAR);\n            fieldValues.remove(ChronoField.DAY_OF_WEEK);\n            return date;\n        } else {\n            throw new IllegalStateException('unreachable');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    name() {\n        return this._name;\n    }\n\n    baseUnit() {\n        return this._baseUnit;\n    }\n\n    rangeUnit() {\n        return this._rangeUnit;\n    }\n\n    range() {\n        return this._range;\n    }\n\n    //-----------------------------------------------------------------------\n    isDateBased() {\n        return true;\n    }\n\n    isTimeBased() {\n        return false;\n    }\n\n    isSupportedBy(temporal) {\n        if (temporal.isSupported(ChronoField.DAY_OF_WEEK)) {\n            if (this._rangeUnit === ChronoUnit.WEEKS) {\n                return true;\n            } else if (this._rangeUnit === ChronoUnit.MONTHS) {\n                return temporal.isSupported(ChronoField.DAY_OF_MONTH);\n            } else if (this._rangeUnit === ChronoUnit.YEARS) {\n                return temporal.isSupported(ChronoField.DAY_OF_YEAR);\n            } else if (this._rangeUnit === IsoFields.WEEK_BASED_YEARS) {\n                return temporal.isSupported(ChronoField.EPOCH_DAY);\n            } else if (this._rangeUnit === ChronoUnit.FOREVER) {\n                return temporal.isSupported(ChronoField.EPOCH_DAY);\n            }\n        }\n        return false;\n    }\n\n    rangeRefinedBy(temporal) {\n        if (this._rangeUnit === ChronoUnit.WEEKS) {\n            return this._range;\n        }\n\n        let field = null;\n        if (this._rangeUnit === ChronoUnit.MONTHS) {\n            field = ChronoField.DAY_OF_MONTH;\n        } else if (this._rangeUnit === ChronoUnit.YEARS) {\n            field = ChronoField.DAY_OF_YEAR;\n        } else if (this._rangeUnit === IsoFields.WEEK_BASED_YEARS) {\n            return this._rangeWOWBY(temporal);\n        } else if (this._rangeUnit === ChronoUnit.FOREVER) {\n            return temporal.range(ChronoField.YEAR);\n        } else {\n            throw new IllegalStateException('unreachable');\n        }\n\n        // Offset the ISO DOW by the start of this week\n        const sow = this._weekDef.firstDayOfWeek().value();\n        const isoDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n\n        const offset = this._startOfWeekOffset(temporal.get(field), dow);\n        const fieldRange = temporal.range(field);\n        return ValueRange.of(ComputedDayOfField._computeWeek(offset, fieldRange.minimum()),\n            ComputedDayOfField._computeWeek(offset, fieldRange.maximum()));\n    }\n\n    _rangeWOWBY(temporal) {\n        const sow = this._weekDef.firstDayOfWeek().value();\n        const isoDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        const dow = MathUtil.floorMod(isoDow - sow, 7) + 1;\n        const woy = this._localizedWeekOfYear(temporal, dow);\n        if (woy === 0) {\n            // TODO: we use IsoChronology for now\n            return this._rangeWOWBY(IsoChronology.INSTANCE.date(temporal).minus(2, ChronoUnit.WEEKS));\n            // return this._rangeWOWBY(Chronology.from(temporal).date(temporal).minus(2, ChronoUnit.WEEKS));\n        }\n        const offset = this._startOfWeekOffset(temporal.get(ChronoField.DAY_OF_YEAR), dow);\n        const year = temporal.get(ChronoField.YEAR);\n        const yearLen = Year.isLeap(year) ? 366 : 365;\n        const weekIndexOfFirstWeekNextYear = ComputedDayOfField._computeWeek(offset, yearLen + this._weekDef.minimalDaysInFirstWeek());\n        if (woy >= weekIndexOfFirstWeekNextYear) {\n            // TODO: we use IsoChronology for now\n            return this._rangeWOWBY(IsoChronology.INSTANCE.date(temporal).plus(2, ChronoUnit.WEEKS));\n            // return this._rangeWOWBY(Chronology.from(temporal).date(temporal).plus(2, ChronoUnit.WEEKS));\n        }\n        return ValueRange.of(1, weekIndexOfFirstWeekNextYear - 1);\n    }\n\n    displayName(locale) {\n        requireNonNull(locale, 'locale');\n        if (this._rangeUnit === ChronoUnit.YEARS) {  // week-of-year\n            return 'Week';\n        }\n        return this.toString();\n    }\n\n    //-----------------------------------------------------------------------\n    toString() {\n        return `${this._name}[${this._weekDef.toString()}]`;\n    }\n}\n\n/**\n * The cache of rules by firstDayOfWeek plus minimalDays.\n * Initialized first to be available for definition of ISO, etc.\n */\nconst WeekFieldsCache = new Map();\n\n\n/**\n * Localized definitions of the day-of-week, week-of-month and week-of-year fields.\n * <p>\n * A standard week is seven days long, but cultures have different definitions for some\n * other aspects of a week. This class represents the definition of the week, for the\n * purpose of providing {@link TemporalField} instances.\n * <p>\n * WeekFields provides three fields,\n * {@link #dayOfWeek()}, {@link #weekOfMonth()}, and {@link #weekOfYear()}\n * that provide access to the values from any {@link Temporal temporal object}.\n * <p>\n * The computations for day-of-week, week-of-month, and week-of-year are based\n * on the  {@link ChronoField#YEAR proleptic-year},\n * {@link ChronoField#MONTH_OF_YEAR month-of-year},\n * {@link ChronoField#DAY_OF_MONTH day-of-month}, and\n * {@link ChronoField#DAY_OF_WEEK ISO day-of-week} which are based on the\n * {@link ChronoField#EPOCH_DAY epoch-day} and the chronology.\n * The values may not be aligned with the {@link ChronoField#YEAR_OF_ERA year-of-Era}\n * depending on the Chronology.\n * <p>A week is defined by:\n * <ul>\n * <li>The first day-of-week.\n * For example, the ISO-8601 standard considers Monday to be the first day-of-week.\n * <li>The minimal number of days in the first week.\n * For example, the ISO-8601 standard counts the first week as needing at least 4 days.\n * </ul><p>\n * Together these two values allow a year or month to be divided into weeks.\n * <p>\n * <h3>Week of Month</h3>\n * One field is used: week-of-month.\n * The calculation ensures that weeks never overlap a month boundary.\n * The month is divided into periods where each period starts on the defined first day-of-week.\n * The earliest period is referred to as week 0 if it has less than the minimal number of days\n * and week 1 if it has at least the minimal number of days.\n * <p>\n * <table cellpadding=\"0\" cellspacing=\"3\" border=\"0\" style=\"text-align: left; width: 50%;\">\n * <caption>Examples of WeekFields</caption>\n * <tr><th>Date</th><td>Day-of-week</td>\n *  <td>First day: Monday<br>Minimal days: 4</td><td>First day: Monday<br>Minimal days: 5</td></tr>\n * <tr><th>2008-12-31</th><td>Wednesday</td>\n *  <td>Week 5 of December 2008</td><td>Week 5 of December 2008</td></tr>\n * <tr><th>2009-01-01</th><td>Thursday</td>\n *  <td>Week 1 of January 2009</td><td>Week 0 of January 2009</td></tr>\n * <tr><th>2009-01-04</th><td>Sunday</td>\n *  <td>Week 1 of January 2009</td><td>Week 0 of January 2009</td></tr>\n * <tr><th>2009-01-05</th><td>Monday</td>\n *  <td>Week 2 of January 2009</td><td>Week 1 of January 2009</td></tr>\n * </table>\n * <p>\n * <h3>Week of Year</h3>\n * One field is used: week-of-year.\n * The calculation ensures that weeks never overlap a year boundary.\n * The year is divided into periods where each period starts on the defined first day-of-week.\n * The earliest period is referred to as week 0 if it has less than the minimal number of days\n * and week 1 if it has at least the minimal number of days.\n * <p>\n * This class is immutable and thread-safe.\n */\nexport class WeekFields {\n    // implementation notes\n    // querying week-of-month or week-of-year should return the week value bound within the month/year\n    // however, setting the week value should be lenient (use plus/minus weeks)\n    // allow week-of-month outer range [0 to 5]\n    // allow week-of-year outer range [0 to 53]\n    // this is because callers shouldn't be expected to know the details of validity\n\n    /**\n     * function overloading for {@link WeekFields#of}\n     *\n     * if called with 1 arguments then {@link WeekFields.ofLocale} is executed.\n     *\n     * Otherwise {@link WeekFields.ofFirstDayOfWeekMinDays} is executed.\n     *\n     * @param {!DayOfWeek | Locale} firstDayOrLocale\n     * @param {Number} minDays\n     * @returns {WeekFields} this for chaining\n     */\n    static of(firstDayOrLocale, minDays) {\n        if (minDays === undefined) {\n            return WeekFields.ofLocale(firstDayOrLocale);\n        } else {\n            return WeekFields.ofFirstDayOfWeekMinDays(firstDayOrLocale, minDays);\n        }\n    }\n\n    /**\n     * Obtains an instance of {@code WeekFields} appropriate for a locale.\n     * <p>\n     * This will look up appropriate values from the provider of localization data.\n     *\n     * @param {!Locale} locale  the locale to use, not null\n     * @return the week-definition, not null\n     */\n    static ofLocale(locale) {\n        requireNonNull(locale, 'locale');\n\n        Cldr.load(cldrData('supplemental/weekData.json'));\n        const cldr = new Cldr(locale.localeString());\n        const worldRegion = '001';\n        const weekData = cldr.get('supplemental/weekData');\n        let dow = _weekDayMap[weekData.firstDay[locale.country()]];\n        if (!dow) {\n            dow = _weekDayMap[weekData.firstDay[worldRegion]];\n        }\n        let minDays = weekData.minDays[locale.country()];\n        if (!minDays) {\n            minDays = weekData.minDays[worldRegion];\n        }\n        return WeekFields.ofFirstDayOfWeekMinDays(dow, minDays);\n    }\n\n    /**\n     * Obtains an instance of {@code WeekFields} from the first day-of-week and minimal days.\n     * <p>\n     * The first day-of-week defines the ISO {@code DayOfWeek} that is day 1 of the week.\n     * The minimal number of days in the first week defines how many days must be present\n     * in a month or year, starting from the first day-of-week, before the week is counted\n     * as the first week. A value of 1 will count the first day of the month or year as part\n     * of the first week, whereas a value of 7 will require the whole seven days to be in\n     * the new month or year.\n     * <p>\n     * WeekFields instances are singletons; for each unique combination\n     * of {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} the\n     * the same instance will be returned.\n     *\n     * @param {!DayOfWeek} firstDayOfWeek  the first day of the week, not null\n     * @param {!Number} minimalDaysInFirstWeek  the minimal number of days in the first week, from\n     *     1 to 7\n     * @return {WeekFields} the week-definition, not null\n     * @throws IllegalArgumentException if the minimal days value is less than one\n     *      or greater than 7\n     */\n    static ofFirstDayOfWeekMinDays(firstDayOfWeek, minimalDaysInFirstWeek) {\n        requireNonNull(firstDayOfWeek, 'firstDayOfWeek');\n        requireInstance(firstDayOfWeek, DayOfWeek, 'firstDayOfWeek');\n        requireNonNull(minimalDaysInFirstWeek, 'minimalDaysInFirstWeek');\n        const key = firstDayOfWeek.toString() + minimalDaysInFirstWeek;\n        let rules = WeekFieldsCache.get(key);\n        if (rules == null) {\n            rules = new WeekFields(firstDayOfWeek, minimalDaysInFirstWeek);\n            WeekFieldsCache.set(key, rules);\n            rules = WeekFieldsCache.get(key);\n        }\n        return rules;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates an instance of the definition.\n     *\n     * @param {!DayOfWeek} firstDayOfWeek  the first day of the week, not null\n     * @param {!Number} minimalDaysInFirstWeek  the minimal number of days in the first week, from\n     *     1 to 7\n     * @throws IllegalArgumentException if the minimal days value is invalid\n     *\n     * @private\n     */\n    constructor(firstDayOfWeek, minimalDaysInFirstWeek) {\n        requireNonNull(firstDayOfWeek, 'firstDayOfWeek');\n        requireInstance(firstDayOfWeek, DayOfWeek, 'firstDayOfWeek');\n        requireNonNull(minimalDaysInFirstWeek, 'minimalDaysInFirstWeek');\n        if (minimalDaysInFirstWeek < 1 || minimalDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException('Minimal number of days is invalid');\n        }\n        this._firstDayOfWeek = firstDayOfWeek;\n        this._minimalDays = minimalDaysInFirstWeek;\n        this._dayOfWeek = ComputedDayOfField.ofDayOfWeekField(this);\n        this._weekOfMonth = ComputedDayOfField.ofWeekOfMonthField(this);\n        this._weekOfYear = ComputedDayOfField.ofWeekOfYearField(this);\n        this._weekOfWeekBasedYear = ComputedDayOfField.ofWeekOfWeekBasedYearField(this);\n        this._weekBasedYear = ComputedDayOfField.ofWeekBasedYearField(this);\n        Cldr.load(cldrData('supplemental/likelySubtags.json'));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the first day-of-week.\n     * <p>\n     * The first day-of-week varies by culture.\n     * For example, the US uses Sunday, while France and the ISO-8601 standard use Monday.\n     * This method returns the first day using the standard {@code DayOfWeek} enum.\n     *\n     * @return {DayOfWeek} the first day-of-week, not null\n     */\n    firstDayOfWeek() {\n        return this._firstDayOfWeek;\n    }\n\n    /**\n     * Gets the minimal number of days in the first week.\n     * <p>\n     * The number of days considered to define the first week of a month or year\n     * varies by culture.\n     * For example, the ISO-8601 requires 4 days (more than half a week) to\n     * be present before counting the first week.\n     *\n     * @return {Number} the minimal number of days in the first week of a month or year, from 1 to 7\n     */\n    minimalDaysInFirstWeek() {\n        return this._minimalDays;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns a field to access the day of week based on this {@code WeekFields}.\n     * <p>\n     * This is similar to {@link ChronoField#DAY_OF_WEEK} but uses values for\n     * the day-of-week based on this {@code WeekFields}.\n     * The days are numbered from 1 to 7 where the\n     * {@link #getFirstDayOfWeek() first day-of-week} is assigned the value 1.\n     * <p>\n     * For example, if the first day-of-week is Sunday, then that will have the\n     * value 1, with other days ranging from Monday as 2 to Saturday as 7.\n     * <p>\n     * In the resolving phase of parsing, a localized day-of-week will be converted\n     * to a standardized {@code ChronoField} day-of-week.\n     * The day-of-week must be in the valid range 1 to 7.\n     * Other fields in this class build dates using the standardized day-of-week.\n     *\n     * @return {TemporalField} a field providing access to the day-of-week with localized\n     *     numbering, not null\n     */\n    dayOfWeek() {\n        return this._dayOfWeek;\n    }\n\n    /**\n     * Returns a field to access the week of month based on this {@code WeekFields}.\n     * <p>\n     * This represents the concept of the count of weeks within the month where weeks\n     * start on a fixed day-of-week, such as Monday.\n     * This field is typically used with {@link WeekFields#dayOfWeek()}.\n     * <p>\n     * Week one (1) is the week starting on the {@link WeekFields#firstDayOfWeek}\n     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the month.\n     * Thus, week one may start up to {@code minDays} days before the start of the month.\n     * If the first week starts after the start of the month then the period before is week zero\n     * (0).\n     * <p>\n     * For example:<br>\n     * - if the 1st day of the month is a Monday, week one starts on the 1st and there is no week\n     * zero<br>\n     * - if the 2nd day of the month is a Monday, week one starts on the 2nd and the 1st is in week\n     * zero<br>\n     * - if the 4th day of the month is a Monday, week one starts on the 4th and the 1st to 3rd is\n     * in week zero<br>\n     * - if the 5th day of the month is a Monday, week two starts on the 5th and the 1st to 4th is\n     * in week one<br>\n     * <p>\n     * This field can be used with any calendar system.\n     * <p>\n     * In the resolving phase of parsing, a date can be created from a year,\n     * week-of-month, month-of-year and day-of-week.\n     * <p>\n     * In {@linkplain ResolverStyle#STRICT strict mode}, all four fields are\n     * validated against their range of valid values. The week-of-month field\n     * is validated to ensure that the resulting month is the month requested.\n     * <p>\n     * In {@linkplain ResolverStyle#SMART smart mode}, all four fields are\n     * validated against their range of valid values. The week-of-month field\n     * is validated from 0 to 6, meaning that the resulting date can be in a\n     * different month to that specified.\n     * <p>\n     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\n     * are validated against the range of valid values. The resulting date is calculated\n     * equivalent to the following four stage approach.\n     * First, create a date on the first day of the first week of January in the requested year.\n     * Then take the month-of-year, subtract one, and add the amount in months to the date.\n     * Then take the week-of-month, subtract one, and add the amount in weeks to the date.\n     * Finally, adjust to the correct day-of-week within the localized week.\n     *\n     * @return {TemporalField} a field providing access to the week-of-month, not null\n     */\n    weekOfMonth() {\n        return this._weekOfMonth;\n    }\n\n    /**\n     * Returns a field to access the week of year based on this {@code WeekFields}.\n     * <p>\n     * This represents the concept of the count of weeks within the year where weeks\n     * start on a fixed day-of-week, such as Monday.\n     * This field is typically used with {@link WeekFields#dayOfWeek()}.\n     * <p>\n     * Week one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\n     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\n     * Thus, week one may start up to {@code minDays} days before the start of the year.\n     * If the first week starts after the start of the year then the period before is week zero\n     * (0).\n     * <p>\n     * For example:<br>\n     * - if the 1st day of the year is a Monday, week one starts on the 1st and there is no week\n     * zero<br>\n     * - if the 2nd day of the year is a Monday, week one starts on the 2nd and the 1st is in week\n     * zero<br>\n     * - if the 4th day of the year is a Monday, week one starts on the 4th and the 1st to 3rd is\n     * in week zero<br>\n     * - if the 5th day of the year is a Monday, week two starts on the 5th and the 1st to 4th is\n     * in week one<br>\n     * <p>\n     * This field can be used with any calendar system.\n     * <p>\n     * In the resolving phase of parsing, a date can be created from a year,\n     * week-of-year and day-of-week.\n     * <p>\n     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\n     * validated against their range of valid values. The week-of-year field\n     * is validated to ensure that the resulting year is the year requested.\n     * <p>\n     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are\n     * validated against their range of valid values. The week-of-year field\n     * is validated from 0 to 54, meaning that the resulting date can be in a\n     * different year to that specified.\n     * <p>\n     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\n     * are validated against the range of valid values. The resulting date is calculated\n     * equivalent to the following three stage approach.\n     * First, create a date on the first day of the first week in the requested year.\n     * Then take the week-of-year, subtract one, and add the amount in weeks to the date.\n     * Finally, adjust to the correct day-of-week within the localized week.\n     *\n     * @return {TemporalField} a field providing access to the week-of-year, not null\n     */\n    weekOfYear() {\n        return this._weekOfYear;\n    }\n\n    /**\n     * Returns a field to access the week of a week-based-year based on this {@code WeekFields}.\n     * <p>\n     * This represents the concept of the count of weeks within the year where weeks\n     * start on a fixed day-of-week, such as Monday and each week belongs to exactly one year.\n     * This field is typically used with {@link WeekFields#dayOfWeek()} and\n     * {@link WeekFields#weekBasedYear()}.\n     * <p>\n     * Week one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\n     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\n     * If the first week starts after the start of the year then the period before\n     * is in the last week of the previous year.\n     * <p>\n     * For example:<br>\n     * - if the 1st day of the year is a Monday, week one starts on the 1st<br>\n     * - if the 2nd day of the year is a Monday, week one starts on the 2nd and\n     *   the 1st is in the last week of the previous year<br>\n     * - if the 4th day of the year is a Monday, week one starts on the 4th and\n     *   the 1st to 3rd is in the last week of the previous year<br>\n     * - if the 5th day of the year is a Monday, week two starts on the 5th and\n     *   the 1st to 4th is in week one<br>\n     * <p>\n     * This field can be used with any calendar system.\n     * <p>\n     * In the resolving phase of parsing, a date can be created from a week-based-year,\n     * week-of-year and day-of-week.\n     * <p>\n     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\n     * validated against their range of valid values. The week-of-year field\n     * is validated to ensure that the resulting week-based-year is the\n     * week-based-year requested.\n     * <p>\n     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are\n     * validated against their range of valid values. The week-of-week-based-year field\n     * is validated from 1 to 53, meaning that the resulting date can be in the\n     * following week-based-year to that specified.\n     * <p>\n     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\n     * are validated against the range of valid values. The resulting date is calculated\n     * equivalent to the following three stage approach.\n     * First, create a date on the first day of the first week in the requested week-based-year.\n     * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.\n     * Finally, adjust to the correct day-of-week within the localized week.\n     *\n     * @return {TemporalField} a field providing access to the week-of-week-based-year, not null\n     */\n    weekOfWeekBasedYear() {\n        return this._weekOfWeekBasedYear;\n    }\n\n    /**\n     * Returns a field to access the year of a week-based-year based on this {@code WeekFields}.\n     * <p>\n     * This represents the concept of the year where weeks start on a fixed day-of-week,\n     * such as Monday and each week belongs to exactly one year.\n     * This field is typically used with {@link WeekFields#dayOfWeek()} and\n     * {@link WeekFields#weekOfWeekBasedYear()}.\n     * <p>\n     * Week one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\n     * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\n     * Thus, week one may start before the start of the year.\n     * If the first week starts after the start of the year then the period before\n     * is in the last week of the previous year.\n     * <p>\n     * This field can be used with any calendar system.\n     * <p>\n     * In the resolving phase of parsing, a date can be created from a week-based-year,\n     * week-of-year and day-of-week.\n     * <p>\n     * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\n     * validated against their range of valid values. The week-of-year field\n     * is validated to ensure that the resulting week-based-year is the\n     * week-based-year requested.\n     * <p>\n     * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are\n     * validated against their range of valid values. The week-of-week-based-year field\n     * is validated from 1 to 53, meaning that the resulting date can be in the\n     * following week-based-year to that specified.\n     * <p>\n     * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\n     * are validated against the range of valid values. The resulting date is calculated\n     * equivalent to the following three stage approach.\n     * First, create a date on the first day of the first week in the requested week-based-year.\n     * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.\n     * Finally, adjust to the correct day-of-week within the localized week.\n     *\n     * @return {TemporalField} a field providing access to the week-based-year, not null\n     */\n    weekBasedYear() {\n        return this._weekBasedYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if this {@code WeekFields} is equal to the specified other.\n     * <p>\n     * The comparison is based on the entire state of the rules, which is\n     * the first day-of-week and minimal days.\n     *\n     * @param {*} other  the other rules to compare to, null returns false\n     * @return true if this is equal to the specified rules\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof WeekFields) {\n            return this.hashCode() === other.hashCode();\n        }\n        return false;\n    }\n\n    /**\n     * A hash code for this {@code WeekFields}.\n     *\n     * @return a suitable hash code\n     */\n    hashCode() {\n        return this._firstDayOfWeek.ordinal() * 7 + this._minimalDays;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * A string representation of this {@code WeekFields} instance.\n     *\n     * @return the string representation, not null\n     */\n    toString() {\n        return `WeekFields[${this._firstDayOfWeek},${this._minimalDays}]`;\n    }\n\n}\n\nexport function _init() {\n    /**\n     * The ISO-8601 definition, where a week starts on Monday and the first week\n     * has a minimum of 4 days.\n     * <p>\n     * The ISO-8601 standard defines a calendar system based on weeks.\n     * It uses the week-based-year and week-of-week-based-year concepts to split\n     * up the passage of days instead of the standard year/month/day.\n     * <p>\n     * Note that the first week may start in the previous calendar year.\n     * Note also that the first few days of a calendar year may be in the\n     * week-based-year corresponding to the previous calendar year.\n     */\n    WeekFields.ISO = WeekFields.of(DayOfWeek.MONDAY, 4);\n\n    /**\n     * The common definition of a week that starts on Sunday.\n     * <p>\n     * Defined as starting on Sunday and with a minimum of 1 day in the month.\n     * This week definition is in use in the US and other European countries.\n     *\n     */\n    WeekFields.SUNDAY_START = WeekFields.of(DayOfWeek.SUNDAY, 1);\n\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/locale/src/temporal/WeekFields.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2176,
    "kind": "variable",
    "name": "MathUtil",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~MathUtil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2177,
    "kind": "variable",
    "name": "DAY_OF_WEEK_RANGE",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~DAY_OF_WEEK_RANGE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2178,
    "kind": "variable",
    "name": "WEEK_OF_MONTH_RANGE",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WEEK_OF_MONTH_RANGE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2179,
    "kind": "variable",
    "name": "WEEK_OF_YEAR_RANGE",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WEEK_OF_YEAR_RANGE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2180,
    "kind": "variable",
    "name": "WEEK_OF_WEEK_BASED_YEAR_RANGE",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WEEK_OF_WEEK_BASED_YEAR_RANGE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2181,
    "kind": "variable",
    "name": "WEEK_BASED_YEAR_RANGE",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WEEK_BASED_YEAR_RANGE",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2182,
    "kind": "variable",
    "name": "_weekDayMap",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~_weekDayMap",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "{\"mon\": *, \"tue\": *, \"wed\": *, \"thu\": *, \"fri\": *, \"sat\": *, \"sun\": *}"
      ]
    }
  },
  {
    "__docId__": 2183,
    "kind": "class",
    "name": "ComputedDayOfField",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": "{ComputedDayOfField}",
    "description": "Field type that computes DayOfWeek, WeekOfMonth, and WeekOfYear\nbased on a WeekFields.\nA separate Field instance is required for each different WeekFields;\ncombination of start of week and minimum number of days.\nConstructors are provided to create fields for DayOfWeek, WeekOfMonth,\nand WeekOfYear.",
    "lineNumber": 52,
    "interface": false
  },
  {
    "__docId__": 2184,
    "kind": "method",
    "name": "ofDayOfWeekField",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.ofDayOfWeekField",
    "access": "public",
    "description": "Returns a field to access the day of week,\ncomputed based on a WeekFields.\n<p>\nThe WeekDefintion of the first day of the week is used with\nthe ISO DAY_OF_WEEK field to compute week boundaries.",
    "lineNumber": 61,
    "params": [
      {
        "name": "weekDef",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2185,
    "kind": "method",
    "name": "ofWeekOfMonthField",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.ofWeekOfMonthField",
    "access": "public",
    "description": "Returns a field to access the week of month,\ncomputed based on a WeekFields.",
    "see": [
      "WeekFields#weekOfMonth()"
    ],
    "lineNumber": 71,
    "params": [
      {
        "name": "weekDef",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2186,
    "kind": "method",
    "name": "ofWeekOfYearField",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.ofWeekOfYearField",
    "access": "public",
    "description": "Returns a field to access the week of year,\ncomputed based on a WeekFields.",
    "see": [
      "WeekFields#weekOfYear()"
    ],
    "lineNumber": 81,
    "params": [
      {
        "name": "weekDef",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2187,
    "kind": "method",
    "name": "ofWeekOfWeekBasedYearField",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.ofWeekOfWeekBasedYearField",
    "access": "public",
    "description": "Returns a field to access the week of week-based-year,\ncomputed based on a WeekFields.",
    "see": [
      "WeekFields#weekOfWeekBasedYear()"
    ],
    "lineNumber": 91,
    "params": [
      {
        "name": "weekDef",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2188,
    "kind": "method",
    "name": "ofWeekBasedYearField",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField.ofWeekBasedYearField",
    "access": "public",
    "description": "Returns a field to access the week-based-year,\ncomputed based on a WeekFields.",
    "see": [
      "WeekFields#weekBasedYear()"
    ],
    "lineNumber": 101,
    "params": [
      {
        "name": "weekDef",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2189,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 109,
    "ignore": true
  },
  {
    "__docId__": 2190,
    "kind": "member",
    "name": "_name",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_name",
    "access": "private",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2191,
    "kind": "member",
    "name": "_weekDef",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_weekDef",
    "access": "private",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2192,
    "kind": "member",
    "name": "_baseUnit",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_baseUnit",
    "access": "private",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2193,
    "kind": "member",
    "name": "_rangeUnit",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_rangeUnit",
    "access": "private",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2194,
    "kind": "member",
    "name": "_range",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_range",
    "access": "private",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2195,
    "kind": "method",
    "name": "getFrom",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#getFrom",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2196,
    "kind": "method",
    "name": "_localizedDayOfWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_localizedDayOfWeek",
    "access": "private",
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "sow",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2197,
    "kind": "method",
    "name": "_localizedWeekOfMonth",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_localizedWeekOfMonth",
    "access": "private",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "dow",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2198,
    "kind": "method",
    "name": "_localizedWeekOfYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_localizedWeekOfYear",
    "access": "private",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "dow",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2199,
    "kind": "method",
    "name": "_localizedWOWBY",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_localizedWOWBY",
    "access": "private",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2200,
    "kind": "method",
    "name": "_localizedWBY",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_localizedWBY",
    "access": "private",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2201,
    "kind": "method",
    "name": "_startOfWeekOffset",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_startOfWeekOffset",
    "access": "private",
    "description": "Returns an offset to align week start with a day of month or day of year.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "day",
        "description": "the day; 1 through infinity"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "dow",
        "description": "the day of the week of that day; 1 through 7"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "an offset in days to align a day with the start of the first 'full' week"
    },
    "ignore": true
  },
  {
    "__docId__": 2202,
    "kind": "method",
    "name": "_computeWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField._computeWeek",
    "access": "private",
    "description": "Returns the week number computed from the reference day and reference dayOfWeek.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to align a date with the start of week\n    from {@link #startOfWeekOffset}."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "day",
        "description": "the day for which to compute the week number"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the week number where zero is used for a partial week and 1 for the first full week"
    },
    "ignore": true
  },
  {
    "__docId__": 2203,
    "kind": "method",
    "name": "adjustInto",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#adjustInto",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "newValue",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2204,
    "kind": "method",
    "name": "resolve",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "fieldValues",
        "types": [
          "*"
        ]
      },
      {
        "name": "partialTemporal",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolverStyle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2205,
    "kind": "method",
    "name": "name",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#name",
    "access": "public",
    "description": null,
    "lineNumber": 380,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2206,
    "kind": "method",
    "name": "baseUnit",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#baseUnit",
    "access": "public",
    "description": null,
    "lineNumber": 384,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2207,
    "kind": "method",
    "name": "rangeUnit",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#rangeUnit",
    "access": "public",
    "description": null,
    "lineNumber": 388,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2208,
    "kind": "method",
    "name": "range",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#range",
    "access": "public",
    "description": null,
    "lineNumber": 392,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2209,
    "kind": "method",
    "name": "isDateBased",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#isDateBased",
    "access": "public",
    "description": null,
    "lineNumber": 397,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2210,
    "kind": "method",
    "name": "isTimeBased",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#isTimeBased",
    "access": "public",
    "description": null,
    "lineNumber": 401,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2211,
    "kind": "method",
    "name": "isSupportedBy",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#isSupportedBy",
    "access": "public",
    "description": null,
    "lineNumber": 405,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 2212,
    "kind": "method",
    "name": "rangeRefinedBy",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#rangeRefinedBy",
    "access": "public",
    "description": null,
    "lineNumber": 422,
    "undocument": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2213,
    "kind": "method",
    "name": "_rangeWOWBY",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#_rangeWOWBY",
    "access": "private",
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "temporal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2214,
    "kind": "method",
    "name": "displayName",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#displayName",
    "access": "public",
    "description": null,
    "lineNumber": 473,
    "undocument": true,
    "params": [
      {
        "name": "locale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2215,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~ComputedDayOfField#toString",
    "access": "public",
    "description": null,
    "lineNumber": 482,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 2216,
    "kind": "variable",
    "name": "WeekFieldsCache",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFieldsCache",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": null,
    "description": "The cache of rules by firstDayOfWeek plus minimalDays.\nInitialized first to be available for definition of ISO, etc.",
    "lineNumber": 491,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2217,
    "kind": "class",
    "name": "WeekFields",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": "{WeekFields}",
    "description": "Localized definitions of the day-of-week, week-of-month and week-of-year fields.\n<p>\nA standard week is seven days long, but cultures have different definitions for some\nother aspects of a week. This class represents the definition of the week, for the\npurpose of providing {@link TemporalField} instances.\n<p>\nWeekFields provides three fields,\n{@link #dayOfWeek()}, {@link #weekOfMonth()}, and {@link #weekOfYear()}\nthat provide access to the values from any {@link Temporal temporal object}.\n<p>\nThe computations for day-of-week, week-of-month, and week-of-year are based\non the  {@link ChronoField#YEAR proleptic-year},\n{@link ChronoField#MONTH_OF_YEAR month-of-year},\n{@link ChronoField#DAY_OF_MONTH day-of-month}, and\n{@link ChronoField#DAY_OF_WEEK ISO day-of-week} which are based on the\n{@link ChronoField#EPOCH_DAY epoch-day} and the chronology.\nThe values may not be aligned with the {@link ChronoField#YEAR_OF_ERA year-of-Era}\ndepending on the Chronology.\n<p>A week is defined by:\n<ul>\n<li>The first day-of-week.\nFor example, the ISO-8601 standard considers Monday to be the first day-of-week.\n<li>The minimal number of days in the first week.\nFor example, the ISO-8601 standard counts the first week as needing at least 4 days.\n</ul><p>\nTogether these two values allow a year or month to be divided into weeks.\n<p>\n<h3>Week of Month</h3>\nOne field is used: week-of-month.\nThe calculation ensures that weeks never overlap a month boundary.\nThe month is divided into periods where each period starts on the defined first day-of-week.\nThe earliest period is referred to as week 0 if it has less than the minimal number of days\nand week 1 if it has at least the minimal number of days.\n<p>\n<table cellpadding=\"0\" cellspacing=\"3\" border=\"0\" style=\"text-align: left; width: 50%;\">\n<caption>Examples of WeekFields</caption>\n<tr><th>Date</th><td>Day-of-week</td>\n <td>First day: Monday<br>Minimal days: 4</td><td>First day: Monday<br>Minimal days: 5</td></tr>\n<tr><th>2008-12-31</th><td>Wednesday</td>\n <td>Week 5 of December 2008</td><td>Week 5 of December 2008</td></tr>\n<tr><th>2009-01-01</th><td>Thursday</td>\n <td>Week 1 of January 2009</td><td>Week 0 of January 2009</td></tr>\n<tr><th>2009-01-04</th><td>Sunday</td>\n <td>Week 1 of January 2009</td><td>Week 0 of January 2009</td></tr>\n<tr><th>2009-01-05</th><td>Monday</td>\n <td>Week 2 of January 2009</td><td>Week 1 of January 2009</td></tr>\n</table>\n<p>\n<h3>Week of Year</h3>\nOne field is used: week-of-year.\nThe calculation ensures that weeks never overlap a year boundary.\nThe year is divided into periods where each period starts on the defined first day-of-week.\nThe earliest period is referred to as week 0 if it has less than the minimal number of days\nand week 1 if it has at least the minimal number of days.\n<p>\nThis class is immutable and thread-safe.",
    "lineNumber": 552,
    "interface": false
  },
  {
    "__docId__": 2218,
    "kind": "method",
    "name": "of",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields.of",
    "access": "public",
    "description": "function overloading for {@link WeekFields#of}\n\nif called with 1 arguments then {@link WeekFields.ofLocale} is executed.\n\nOtherwise {@link WeekFields.ofFirstDayOfWeekMinDays} is executed.",
    "lineNumber": 571,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{WeekFields} this for chaining"
      }
    ],
    "params": [
      {
        "nullable": false,
        "types": [
          "DayOfWeek ",
          " Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "firstDayOrLocale",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minDays",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WeekFields"
      ],
      "spread": false,
      "description": "this for chaining"
    }
  },
  {
    "__docId__": 2219,
    "kind": "method",
    "name": "ofLocale",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields.ofLocale",
    "access": "public",
    "description": "Obtains an instance of {@code WeekFields} appropriate for a locale.\n<p>\nThis will look up appropriate values from the provider of localization data.",
    "lineNumber": 587,
    "params": [
      {
        "nullable": false,
        "types": [
          "Locale"
        ],
        "spread": false,
        "optional": false,
        "name": "locale",
        "description": "the locale to use, not null"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the week-definition, not null"
    }
  },
  {
    "__docId__": 2220,
    "kind": "method",
    "name": "ofFirstDayOfWeekMinDays",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields.ofFirstDayOfWeekMinDays",
    "access": "public",
    "description": "Obtains an instance of {@code WeekFields} from the first day-of-week and minimal days.\n<p>\nThe first day-of-week defines the ISO {@code DayOfWeek} that is day 1 of the week.\nThe minimal number of days in the first week defines how many days must be present\nin a month or year, starting from the first day-of-week, before the week is counted\nas the first week. A value of 1 will count the first day of the month or year as part\nof the first week, whereas a value of 7 will require the whole seven days to be in\nthe new month or year.\n<p>\nWeekFields instances are singletons; for each unique combination\nof {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} the\nthe same instance will be returned.",
    "lineNumber": 626,
    "params": [
      {
        "nullable": false,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "firstDayOfWeek",
        "description": "the first day of the week, not null"
      },
      {
        "nullable": false,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minimalDaysInFirstWeek",
        "description": "the minimal number of days in the first week, from\n    1 to 7"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "WeekFields"
      ],
      "spread": false,
      "description": "the week-definition, not null"
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the minimal days value is less than one\n     or greater than 7"
      }
    ]
  },
  {
    "__docId__": 2221,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#constructor",
    "access": "private",
    "description": "Creates an instance of the definition.",
    "lineNumber": 651,
    "params": [
      {
        "nullable": false,
        "types": [
          "DayOfWeek"
        ],
        "spread": false,
        "optional": false,
        "name": "firstDayOfWeek",
        "description": "the first day of the week, not null"
      },
      {
        "nullable": false,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "minimalDaysInFirstWeek",
        "description": "the minimal number of days in the first week, from\n    1 to 7"
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "IllegalArgumentException if the minimal days value is invalid"
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 2222,
    "kind": "member",
    "name": "_firstDayOfWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_firstDayOfWeek",
    "access": "private",
    "description": null,
    "lineNumber": 658,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2223,
    "kind": "member",
    "name": "_minimalDays",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_minimalDays",
    "access": "private",
    "description": null,
    "lineNumber": 659,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2224,
    "kind": "member",
    "name": "_dayOfWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_dayOfWeek",
    "access": "private",
    "description": null,
    "lineNumber": 660,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2225,
    "kind": "member",
    "name": "_weekOfMonth",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_weekOfMonth",
    "access": "private",
    "description": null,
    "lineNumber": 661,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2226,
    "kind": "member",
    "name": "_weekOfYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_weekOfYear",
    "access": "private",
    "description": null,
    "lineNumber": 662,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2227,
    "kind": "member",
    "name": "_weekOfWeekBasedYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_weekOfWeekBasedYear",
    "access": "private",
    "description": null,
    "lineNumber": 663,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2228,
    "kind": "member",
    "name": "_weekBasedYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#_weekBasedYear",
    "access": "private",
    "description": null,
    "lineNumber": 664,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2229,
    "kind": "method",
    "name": "firstDayOfWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#firstDayOfWeek",
    "access": "public",
    "description": "Gets the first day-of-week.\n<p>\nThe first day-of-week varies by culture.\nFor example, the US uses Sunday, while France and the ISO-8601 standard use Monday.\nThis method returns the first day using the standard {@code DayOfWeek} enum.",
    "lineNumber": 678,
    "return": {
      "nullable": null,
      "types": [
        "DayOfWeek"
      ],
      "spread": false,
      "description": "the first day-of-week, not null"
    },
    "params": []
  },
  {
    "__docId__": 2230,
    "kind": "method",
    "name": "minimalDaysInFirstWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#minimalDaysInFirstWeek",
    "access": "public",
    "description": "Gets the minimal number of days in the first week.\n<p>\nThe number of days considered to define the first week of a month or year\nvaries by culture.\nFor example, the ISO-8601 requires 4 days (more than half a week) to\nbe present before counting the first week.",
    "lineNumber": 692,
    "return": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": "the minimal number of days in the first week of a month or year, from 1 to 7"
    },
    "params": []
  },
  {
    "__docId__": 2231,
    "kind": "method",
    "name": "dayOfWeek",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#dayOfWeek",
    "access": "public",
    "description": "Returns a field to access the day of week based on this {@code WeekFields}.\n<p>\nThis is similar to {@link ChronoField#DAY_OF_WEEK} but uses values for\nthe day-of-week based on this {@code WeekFields}.\nThe days are numbered from 1 to 7 where the\n{@link #getFirstDayOfWeek() first day-of-week} is assigned the value 1.\n<p>\nFor example, if the first day-of-week is Sunday, then that will have the\nvalue 1, with other days ranging from Monday as 2 to Saturday as 7.\n<p>\nIn the resolving phase of parsing, a localized day-of-week will be converted\nto a standardized {@code ChronoField} day-of-week.\nThe day-of-week must be in the valid range 1 to 7.\nOther fields in this class build dates using the standardized day-of-week.",
    "lineNumber": 716,
    "return": {
      "nullable": null,
      "types": [
        "TemporalField"
      ],
      "spread": false,
      "description": "a field providing access to the day-of-week with localized\n    numbering, not null"
    },
    "params": []
  },
  {
    "__docId__": 2232,
    "kind": "method",
    "name": "weekOfMonth",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#weekOfMonth",
    "access": "public",
    "description": "Returns a field to access the week of month based on this {@code WeekFields}.\n<p>\nThis represents the concept of the count of weeks within the month where weeks\nstart on a fixed day-of-week, such as Monday.\nThis field is typically used with {@link WeekFields#dayOfWeek()}.\n<p>\nWeek one (1) is the week starting on the {@link WeekFields#firstDayOfWeek}\nwhere there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the month.\nThus, week one may start up to {@code minDays} days before the start of the month.\nIf the first week starts after the start of the month then the period before is week zero\n(0).\n<p>\nFor example:<br>\n- if the 1st day of the month is a Monday, week one starts on the 1st and there is no week\nzero<br>\n- if the 2nd day of the month is a Monday, week one starts on the 2nd and the 1st is in week\nzero<br>\n- if the 4th day of the month is a Monday, week one starts on the 4th and the 1st to 3rd is\nin week zero<br>\n- if the 5th day of the month is a Monday, week two starts on the 5th and the 1st to 4th is\nin week one<br>\n<p>\nThis field can be used with any calendar system.\n<p>\nIn the resolving phase of parsing, a date can be created from a year,\nweek-of-month, month-of-year and day-of-week.\n<p>\nIn {@linkplain ResolverStyle#STRICT strict mode}, all four fields are\nvalidated against their range of valid values. The week-of-month field\nis validated to ensure that the resulting month is the month requested.\n<p>\nIn {@linkplain ResolverStyle#SMART smart mode}, all four fields are\nvalidated against their range of valid values. The week-of-month field\nis validated from 0 to 6, meaning that the resulting date can be in a\ndifferent month to that specified.\n<p>\nIn {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\nare validated against the range of valid values. The resulting date is calculated\nequivalent to the following four stage approach.\nFirst, create a date on the first day of the first week of January in the requested year.\nThen take the month-of-year, subtract one, and add the amount in months to the date.\nThen take the week-of-month, subtract one, and add the amount in weeks to the date.\nFinally, adjust to the correct day-of-week within the localized week.",
    "lineNumber": 767,
    "return": {
      "nullable": null,
      "types": [
        "TemporalField"
      ],
      "spread": false,
      "description": "a field providing access to the week-of-month, not null"
    },
    "params": []
  },
  {
    "__docId__": 2233,
    "kind": "method",
    "name": "weekOfYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#weekOfYear",
    "access": "public",
    "description": "Returns a field to access the week of year based on this {@code WeekFields}.\n<p>\nThis represents the concept of the count of weeks within the year where weeks\nstart on a fixed day-of-week, such as Monday.\nThis field is typically used with {@link WeekFields#dayOfWeek()}.\n<p>\nWeek one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\nwhere there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\nThus, week one may start up to {@code minDays} days before the start of the year.\nIf the first week starts after the start of the year then the period before is week zero\n(0).\n<p>\nFor example:<br>\n- if the 1st day of the year is a Monday, week one starts on the 1st and there is no week\nzero<br>\n- if the 2nd day of the year is a Monday, week one starts on the 2nd and the 1st is in week\nzero<br>\n- if the 4th day of the year is a Monday, week one starts on the 4th and the 1st to 3rd is\nin week zero<br>\n- if the 5th day of the year is a Monday, week two starts on the 5th and the 1st to 4th is\nin week one<br>\n<p>\nThis field can be used with any calendar system.\n<p>\nIn the resolving phase of parsing, a date can be created from a year,\nweek-of-year and day-of-week.\n<p>\nIn {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\nvalidated against their range of valid values. The week-of-year field\nis validated to ensure that the resulting year is the year requested.\n<p>\nIn {@linkplain ResolverStyle#SMART smart mode}, all three fields are\nvalidated against their range of valid values. The week-of-year field\nis validated from 0 to 54, meaning that the resulting date can be in a\ndifferent year to that specified.\n<p>\nIn {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\nare validated against the range of valid values. The resulting date is calculated\nequivalent to the following three stage approach.\nFirst, create a date on the first day of the first week in the requested year.\nThen take the week-of-year, subtract one, and add the amount in weeks to the date.\nFinally, adjust to the correct day-of-week within the localized week.",
    "lineNumber": 817,
    "return": {
      "nullable": null,
      "types": [
        "TemporalField"
      ],
      "spread": false,
      "description": "a field providing access to the week-of-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 2234,
    "kind": "method",
    "name": "weekOfWeekBasedYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#weekOfWeekBasedYear",
    "access": "public",
    "description": "Returns a field to access the week of a week-based-year based on this {@code WeekFields}.\n<p>\nThis represents the concept of the count of weeks within the year where weeks\nstart on a fixed day-of-week, such as Monday and each week belongs to exactly one year.\nThis field is typically used with {@link WeekFields#dayOfWeek()} and\n{@link WeekFields#weekBasedYear()}.\n<p>\nWeek one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\nwhere there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\nIf the first week starts after the start of the year then the period before\nis in the last week of the previous year.\n<p>\nFor example:<br>\n- if the 1st day of the year is a Monday, week one starts on the 1st<br>\n- if the 2nd day of the year is a Monday, week one starts on the 2nd and\n  the 1st is in the last week of the previous year<br>\n- if the 4th day of the year is a Monday, week one starts on the 4th and\n  the 1st to 3rd is in the last week of the previous year<br>\n- if the 5th day of the year is a Monday, week two starts on the 5th and\n  the 1st to 4th is in week one<br>\n<p>\nThis field can be used with any calendar system.\n<p>\nIn the resolving phase of parsing, a date can be created from a week-based-year,\nweek-of-year and day-of-week.\n<p>\nIn {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\nvalidated against their range of valid values. The week-of-year field\nis validated to ensure that the resulting week-based-year is the\nweek-based-year requested.\n<p>\nIn {@linkplain ResolverStyle#SMART smart mode}, all three fields are\nvalidated against their range of valid values. The week-of-week-based-year field\nis validated from 1 to 53, meaning that the resulting date can be in the\nfollowing week-based-year to that specified.\n<p>\nIn {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\nare validated against the range of valid values. The resulting date is calculated\nequivalent to the following three stage approach.\nFirst, create a date on the first day of the first week in the requested week-based-year.\nThen take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.\nFinally, adjust to the correct day-of-week within the localized week.",
    "lineNumber": 867,
    "return": {
      "nullable": null,
      "types": [
        "TemporalField"
      ],
      "spread": false,
      "description": "a field providing access to the week-of-week-based-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 2235,
    "kind": "method",
    "name": "weekBasedYear",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#weekBasedYear",
    "access": "public",
    "description": "Returns a field to access the year of a week-based-year based on this {@code WeekFields}.\n<p>\nThis represents the concept of the year where weeks start on a fixed day-of-week,\nsuch as Monday and each week belongs to exactly one year.\nThis field is typically used with {@link WeekFields#dayOfWeek()} and\n{@link WeekFields#weekOfWeekBasedYear()}.\n<p>\nWeek one(1) is the week starting on the {@link WeekFields#firstDayOfWeek}\nwhere there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.\nThus, week one may start before the start of the year.\nIf the first week starts after the start of the year then the period before\nis in the last week of the previous year.\n<p>\nThis field can be used with any calendar system.\n<p>\nIn the resolving phase of parsing, a date can be created from a week-based-year,\nweek-of-year and day-of-week.\n<p>\nIn {@linkplain ResolverStyle#STRICT strict mode}, all three fields are\nvalidated against their range of valid values. The week-of-year field\nis validated to ensure that the resulting week-based-year is the\nweek-based-year requested.\n<p>\nIn {@linkplain ResolverStyle#SMART smart mode}, all three fields are\nvalidated against their range of valid values. The week-of-week-based-year field\nis validated from 1 to 53, meaning that the resulting date can be in the\nfollowing week-based-year to that specified.\n<p>\nIn {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week\nare validated against the range of valid values. The resulting date is calculated\nequivalent to the following three stage approach.\nFirst, create a date on the first day of the first week in the requested week-based-year.\nThen take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.\nFinally, adjust to the correct day-of-week within the localized week.",
    "lineNumber": 909,
    "return": {
      "nullable": null,
      "types": [
        "TemporalField"
      ],
      "spread": false,
      "description": "a field providing access to the week-based-year, not null"
    },
    "params": []
  },
  {
    "__docId__": 2236,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#equals",
    "access": "public",
    "description": "Checks if this {@code WeekFields} is equal to the specified other.\n<p>\nThe comparison is based on the entire state of the rules, which is\nthe first day-of-week and minimal days.",
    "lineNumber": 923,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "the other rules to compare to, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true if this is equal to the specified rules"
    }
  },
  {
    "__docId__": 2237,
    "kind": "method",
    "name": "hashCode",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#hashCode",
    "access": "public",
    "description": "A hash code for this {@code WeekFields}.",
    "lineNumber": 938,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "a suitable hash code"
    },
    "params": []
  },
  {
    "__docId__": 2238,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/locale/src/temporal/WeekFields.js~WeekFields",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/locale/src/temporal/WeekFields.js~WeekFields#toString",
    "access": "public",
    "description": "A string representation of this {@code WeekFields} instance.",
    "lineNumber": 948,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "the string representation, not null"
    },
    "params": []
  },
  {
    "__docId__": 2239,
    "kind": "function",
    "name": "_init",
    "memberof": "packages/locale/src/temporal/WeekFields.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/locale/src/temporal/WeekFields.js~_init",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/locale/src/temporal/WeekFields.js",
    "importStyle": "{_init}",
    "description": null,
    "lineNumber": 954,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2240,
    "kind": "file",
    "name": "packages/timezone/src/MomentZoneRules.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    LocalDateTime, Instant, ZoneOffset, ZoneOffsetTransition, ZoneRules\n} from '@js-joda/core';\n\nexport class MomentZoneRules extends ZoneRules{\n    constructor(tzdbInfo){\n        super();\n        this._tzdbInfo = tzdbInfo;\n        this._ldtUntils = new LDTUntils(this._tzdbInfo.untils, this._tzdbInfo.offsets);\n    }\n    /**\n     * Checks of the zone rules are fixed, such that the offset never varies.\n     *\n     * @return {boolean} true if the time-zone is fixed and the offset never changes\n     */\n    isFixedOffset(){\n        return this._tzdbInfo.offsets.length === 1;\n    }\n\n    //-----------------------------------------------------------------------\n\n    /**\n     * Gets the offset applicable at the specified instant in these rules.\n     * <p>\n     * The mapping from an instant to an offset is simple, there is only\n     * one valid offset for each instant.\n     * This method returns that offset.\n     *\n     * @param {Instant} instant - the instant to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfInstant(instant){\n        const epochMilli = instant.toEpochMilli();\n        return this.offsetOfEpochMilli(epochMilli);\n    }\n\n    /**\n     * Gets the offset applicable at the specified epochMilli in these rules.\n     *\n     * The method is for javascript performance optimisation.\n     *\n     * @param {number} epochMilli - the epoch millisecond to find the offset for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the offset, not null\n     */\n    offsetOfEpochMilli(epochMilli){\n        const index  = binarySearch(this._tzdbInfo.untils, epochMilli);\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(index));\n    }\n\n\n    /**\n     * Gets a suitable offset for the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns the single offset in the Normal case, and in the Gap or Overlap\n     * case it returns the offset before the transition.\n     * <p>\n     * Since, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\n     * than the \"correct\" value, it should be treated with care. Applications that care\n     * about the correct offset should use a combination of this method,\n     * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the best available offset for the local date-time, not null\n     */\n    offsetOfLocalDateTime(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.offsetBefore();\n        }\n        return info;\n    }\n\n    _offsetInfo(localDateTime) {\n        const index  = ldtBinarySearch(this._ldtUntils, localDateTime);\n        const offsetIndex = index >> 1;\n\n        if (index % 2 === 1){\n            const ldtBefore = this._ldtUntils.get(Math.max(index-1, 0));\n            const ldtAfter = this._ldtUntils.get(Math.min(index, this._ldtUntils.size-1));\n            const offsetBefore = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n            const offsetAfter = ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(Math.min(offsetIndex+1, this._tzdbInfo.offsets.length-1)));\n            // console.log(offsetBefore.toString(), offsetAfter.toString());\n            if (offsetBefore.compareTo(offsetAfter) > 0) {\n                // gap\n                // console.log('gap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtBefore, offsetBefore, offsetAfter);\n            } else {\n                // overlap\n                // console.log('overlap', ldtBefore.toString(), localDateTime.toString(), ldtAfter.toString());\n                return ZoneOffsetTransition.of(ldtAfter, offsetBefore, offsetAfter);\n            }\n        }\n        return ZoneOffset.ofTotalSeconds(this._offsetByIndexInSeconds(offsetIndex));\n    }\n\n    _offsetByIndexInSeconds(index){\n        return -offsetInSeconds(this._tzdbInfo.offsets[index]);\n    }\n\n    /**\n     * Gets the offset applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * Thus, for any given local date-time there can be zero, one or two valid offsets.\n     * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.\n     * In the case where there are two offsets, the earlier offset is returned at index 0\n     * and the later offset at index 1.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n     *  if (validOffsets.size() == 1) {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = validOffsets.get(0);\n     *  } else {\n     *    // Gap or Overlap: determine what to do from transition (which will be non-null)\n     *    ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  }\n     * </pre>\n     * <p>\n     * In theory, it is possible for there to be more than two valid offsets.\n     * This would happen if clocks to be put back more than once in quick succession.\n     * This has never happened in the history of time-zones and thus has no special handling.\n     * However, if it were to happen, then the list would return more than 2 entries.\n     *\n     * @param {LocalDateTime} localDateTime - the local date-time to query for valid offsets, not null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition | ZoneOffset[]} the list of valid offsets, may be immutable, not null\n     */\n    validOffsets(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info.validOffsets();\n        }\n        return [info];\n    }\n\n    /**\n     * Gets the offset transition applicable at the specified local date-time in these rules.\n     * <p>\n     * The mapping from a local date-time to an offset is not straightforward.\n     * There are three cases:\n     * <p><ul>\n     * <li>Normal, with one valid offset. For the vast majority of the year, the normal\n     *  case applies, where there is a single valid offset for the local date-time.</li>\n     * <li>Gap, with zero valid offsets. This is when clocks jump forward typically\n     *  due to the spring daylight savings change from \"winter\" to \"summer\".\n     *  In a gap there are local date-time values with no valid offset.</li>\n     * <li>Overlap, with two valid offsets. This is when clocks are set back typically\n     *  due to the autumn daylight savings change from \"summer\" to \"winter\".\n     *  In an overlap there are local date-time values with two valid offsets.</li>\n     * </ul><p>\n     * A transition is used to model the cases of a Gap or Overlap.\n     * The Normal case will return null.\n     * <p>\n     * There are various ways to handle the conversion from a {@code LocalDateTime}.\n     * One technique, using this method, would be:\n     * <pre>\n     *  ZoneOffsetTransition trans = rules.getTransition(localDT);\n     *  if (trans != null) {\n     *    // Gap or Overlap: determine what to do from transition\n     *  } else {\n     *    // Normal case: only one valid offset\n     *    zoneOffset = rule.getOffset(localDT);\n     *  }\n     * </pre>\n     *\n     * @param {LocalDateTime} localDateTime  the local date-time to query for offset transition, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the offset transition, null if the local date-time is not in transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    transition(localDateTime){\n        const info = this._offsetInfo(localDateTime);\n        if (info instanceof ZoneOffsetTransition) {\n            return info;\n        }\n        return null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the standard offset for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the standard offset\n     * has changed over time.\n     * The standard offset is the offset before any daylight saving time is applied.\n     * This is typically the offset applicable during winter.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffset} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    standardOffset(instant){\n        notSupported('ZoneRules.standardOffset');\n    }\n\n    /**\n     * Gets the amount of daylight savings in use for the specified instant in this zone.\n     * <p>\n     * This provides access to historic information on how the amount of daylight\n     * savings has changed over time.\n     * This is the difference between the standard offset and the actual offset.\n     * Typically the amount is zero during winter and one hour during summer.\n     * Time-zones are second-based, so the nanosecond part of the duration will be zero.\n     *\n     * @param {Instant} instant - the instant to find the daylight savings for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {Duration} the difference between the standard and actual offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    daylightSavings(instant){\n        notSupported('ZoneRules.daylightSavings');\n    }\n\n    /**\n     * Checks if the specified instant is in daylight savings.\n     * <p>\n     * This checks if the standard and actual offsets are the same at the specified instant.\n     *\n     * @param {Instant} instant - the instant to find the offset information for, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {boolean} the standard offset, not null\n     */\n    // eslint-disable-next-line no-unused-vars\n    isDaylightSavings(instant) {\n        notSupported('ZoneRules.isDaylightSavings');\n    }\n\n    /**\n     * Checks if the offset date-time is valid for these rules.\n     * <p>\n     * To be valid, the local date-time must not be in a gap and the offset\n     * must match the valid offsets.\n     *\n     * @param {LocalDateTime} localDateTime - the date-time to check, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @param {ZoneOffset} offset - the offset to check, null returns false\n     * @return {boolean} true if the offset date-time is valid for these rules\n     */\n    isValidOffset(localDateTime, offset){\n        return this.validOffsets(localDateTime).some( o => o.equals(offset));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the next transition after the specified instant.\n     * <p>\n     * This returns details of the next transition after the specified instant.\n     * For example, if the instant represents a point where \"Summer\" daylight savings time\n     * applies, then the method will return the transition to the next \"Winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the next transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the next transition after the specified instant, null if this is after the last transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    nextTransition(instant){\n        notSupported('ZoneRules.nextTransition');\n    }\n\n    /**\n     * Gets the previous transition before the specified instant.\n     * <p>\n     * This returns details of the previous transition after the specified instant.\n     * For example, if the instant represents a point where \"summer\" daylight saving time\n     * applies, then the method will return the transition from the previous \"winter\" time.\n     *\n     * @param {Instant} instant - the instant to get the previous transition after, not null, but null\n     *  may be ignored if the rules have a single offset for all instants\n     * @return {ZoneOffsetTransition} the previous transition after the specified instant, null if this is before the first transition\n     */\n    // eslint-disable-next-line no-unused-vars\n    previousTransition(instant){\n        notSupported('ZoneRules.previousTransition');\n    }\n\n    /**\n     * Gets the complete list of fully defined transitions.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitionRules()}. This method returns those transitions that have\n     * been fully defined. These are typically historical, but may be in the future.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there has\n     * only ever been a single offset. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransition[]} an immutable list of fully defined transitions, not null\n     */\n    transitions(){\n        notSupported('ZoneRules.transitions');\n    }\n\n    /**\n     * Gets the list of transition rules for years beyond those defined in the transition list.\n     * <p>\n     * The complete set of transitions for this rules instance is defined by this method\n     * and {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}\n     * that define an algorithm for when transitions will occur.\n     * <p>\n     * For any given {@code ZoneRules}, this list contains the transition rules for years\n     * beyond those years that have been fully defined. These rules typically refer to future\n     * daylight saving time rule changes.\n     * <p>\n     * If the zone defines daylight savings into the future, then the list will normally\n     * be of size two and hold information about entering and exiting daylight savings.\n     * If the zone does not have daylight savings, or information about future changes\n     * is uncertain, then the list will be empty.\n     * <p>\n     * The list will be empty for fixed offset rules and for any time-zone where there is no\n     * daylight saving time. The list will also be empty if the transition rules are unknown.\n     *\n     * @return {ZoneOffsetTransitionRule[]} an immutable list of transition rules, not null\n     */\n    transitionRules(){\n        notSupported('ZoneRules.transitionRules');\n    }\n\n    /**\n     *\n     * @param other\n     * @returns {boolean}\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof MomentZoneRules) {\n            return this._tzdbInfo === other._tzdbInfo;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @returns {string}\n     */\n    toString() {\n        return this._tzdbInfo.name;\n    }\n}\n\nclass LDTUntils {\n    constructor(_tzdbUntils, tzdbOffsets) {\n        this._tzdbUntils = _tzdbUntils;\n        this._tzdbOffsets = tzdbOffsets;\n        this._ldtUntils = [];\n        this.size = this._tzdbUntils.length * 2;\n    }\n\n\n    _generateTupple(index) {\n        const epochMillis = this._tzdbUntils[index];\n        if (epochMillis === Infinity) {\n            return [LocalDateTime.MAX, LocalDateTime.MAX];\n        }\n        const instant = Instant.ofEpochMilli(epochMillis);\n\n        const offset1 = offsetInSeconds(this._tzdbOffsets[index]);\n        const zone1 = ZoneOffset.ofTotalSeconds(-offset1);\n        const ldt1 = LocalDateTime.ofInstant(instant, zone1);\n\n        const nextIndex = Math.min(index + 1, this._tzdbOffsets.length - 1);\n        const offset2 = offsetInSeconds(this._tzdbOffsets[nextIndex]);\n        const zone2 = ZoneOffset.ofTotalSeconds(-offset2);\n        const ldt2 = LocalDateTime.ofInstant(instant, zone2);\n\n        if(offset1 > offset2) {\n            return [ldt1, ldt2];\n        } else {\n            return [ldt2, ldt1];\n        }\n    }\n\n    _getTupple(index){\n        if (this._ldtUntils[index] == null) {\n            this._ldtUntils[index] = this._generateTupple(index);\n        }\n        return this._ldtUntils[index];\n    }\n\n    get(index) {\n        const ldtTupple = this._getTupple(index >> 1);\n        return ldtTupple[index % 2];\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction ldtBinarySearch(array, value) {\n    let hi = array.size - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (!value.isBefore(array.get(mid = hi + lo >> 1))) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction offsetInSeconds(tzdbOffset){\n    return roundDown(+tzdbOffset*60);\n}\n\nfunction roundDown(r){\n    if (r < 0) {\n        return Math.ceil(r);\n    } else {\n        return Math.floor(r);\n    }\n}\n\n// modified bin-search, to always find existing indices for non-empty arrays\n// value in array at index is larger than input value (or last index of array)\nfunction binarySearch(array, value) {\n    let hi = array.length - 1, lo = -1, mid;\n    while (hi - lo > 1) {\n        if (array[mid = hi + lo >> 1] <= value) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return hi;\n}\n\nfunction notSupported(msg){\n    throw new Error(`not supported: ${msg}`);\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/MomentZoneRules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2241,
    "kind": "class",
    "name": "MomentZoneRules",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": "{MomentZoneRules}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "interface": false,
    "extends": [
      "@js-joda/core~ZoneRules"
    ]
  },
  {
    "__docId__": 2242,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 2243,
    "kind": "member",
    "name": "_tzdbInfo",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#_tzdbInfo",
    "access": "private",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2244,
    "kind": "member",
    "name": "_ldtUntils",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#_ldtUntils",
    "access": "private",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2245,
    "kind": "method",
    "name": "isFixedOffset",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#isFixedOffset",
    "access": "public",
    "description": "Checks of the zone rules are fixed, such that the offset never varies.",
    "lineNumber": 22,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the time-zone is fixed and the offset never changes"
    },
    "params": []
  },
  {
    "__docId__": 2246,
    "kind": "method",
    "name": "offsetOfInstant",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#offsetOfInstant",
    "access": "public",
    "description": "Gets the offset applicable at the specified instant in these rules.\n<p>\nThe mapping from an instant to an offset is simple, there is only\none valid offset for each instant.\nThis method returns that offset.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset, not null"
    }
  },
  {
    "__docId__": 2247,
    "kind": "method",
    "name": "offsetOfEpochMilli",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#offsetOfEpochMilli",
    "access": "public",
    "description": "Gets the offset applicable at the specified epochMilli in these rules.\n\nThe method is for javascript performance optimisation.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "epochMilli",
        "description": "the epoch millisecond to find the offset for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the offset, not null"
    }
  },
  {
    "__docId__": 2248,
    "kind": "method",
    "name": "offsetOfLocalDateTime",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#offsetOfLocalDateTime",
    "access": "public",
    "description": "Gets a suitable offset for the specified local date-time in these rules.\n<p>\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n<p><ul>\n<li>Normal, with one valid offset. For the vast majority of the year, the normal\n case applies, where there is a single valid offset for the local date-time.</li>\n<li>Gap, with zero valid offsets. This is when clocks jump forward typically\n due to the spring daylight savings change from \"winter\" to \"summer\".\n In a gap there are local date-time values with no valid offset.</li>\n<li>Overlap, with two valid offsets. This is when clocks are set back typically\n due to the autumn daylight savings change from \"summer\" to \"winter\".\n In an overlap there are local date-time values with two valid offsets.</li>\n</ul><p>\nThus, for any given local date-time there can be zero, one or two valid offsets.\nThis method returns the single offset in the Normal case, and in the Gap or Overlap\ncase it returns the offset before the transition.\n<p>\nSince, in the case of Gap and Overlap, the offset returned is a \"best\" value, rather\nthan the \"correct\" value, it should be treated with care. Applications that care\nabout the correct offset should use a combination of this method,\n{@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the best available offset for the local date-time, not null"
    }
  },
  {
    "__docId__": 2249,
    "kind": "method",
    "name": "_offsetInfo",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#_offsetInfo",
    "access": "private",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "localDateTime",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2250,
    "kind": "method",
    "name": "_offsetByIndexInSeconds",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#_offsetByIndexInSeconds",
    "access": "private",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2251,
    "kind": "method",
    "name": "validOffsets",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#validOffsets",
    "access": "public",
    "description": "Gets the offset applicable at the specified local date-time in these rules.\n<p>\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n<p><ul>\n<li>Normal, with one valid offset. For the vast majority of the year, the normal\n case applies, where there is a single valid offset for the local date-time.</li>\n<li>Gap, with zero valid offsets. This is when clocks jump forward typically\n due to the spring daylight savings change from \"winter\" to \"summer\".\n In a gap there are local date-time values with no valid offset.</li>\n<li>Overlap, with two valid offsets. This is when clocks are set back typically\n due to the autumn daylight savings change from \"summer\" to \"winter\".\n In an overlap there are local date-time values with two valid offsets.</li>\n</ul><p>\nThus, for any given local date-time there can be zero, one or two valid offsets.\nThis method returns that list of valid offsets, which is a list of size 0, 1 or 2.\nIn the case where there are two offsets, the earlier offset is returned at index 0\nand the later offset at index 1.\n<p>\nThere are various ways to handle the conversion from a {@code LocalDateTime}.\nOne technique, using this method, would be:\n<pre>\n List<ZoneOffset> validOffsets = rules.getOffset(localDT);\n if (validOffsets.size() == 1) {\n   // Normal case: only one valid offset\n   zoneOffset = validOffsets.get(0);\n } else {\n   // Gap or Overlap: determine what to do from transition (which will be non-null)\n   ZoneOffsetTransition trans = rules.getTransition(localDT);\n }\n</pre>\n<p>\nIn theory, it is possible for there to be more than two valid offsets.\nThis would happen if clocks to be put back more than once in quick succession.\nThis has never happened in the history of time-zones and thus has no special handling.\nHowever, if it were to happen, then the list would return more than 2 entries.",
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query for valid offsets, not null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition ",
        " ZoneOffset[]"
      ],
      "spread": false,
      "description": "the list of valid offsets, may be immutable, not null"
    }
  },
  {
    "__docId__": 2252,
    "kind": "method",
    "name": "transition",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#transition",
    "access": "public",
    "description": "Gets the offset transition applicable at the specified local date-time in these rules.\n<p>\nThe mapping from a local date-time to an offset is not straightforward.\nThere are three cases:\n<p><ul>\n<li>Normal, with one valid offset. For the vast majority of the year, the normal\n case applies, where there is a single valid offset for the local date-time.</li>\n<li>Gap, with zero valid offsets. This is when clocks jump forward typically\n due to the spring daylight savings change from \"winter\" to \"summer\".\n In a gap there are local date-time values with no valid offset.</li>\n<li>Overlap, with two valid offsets. This is when clocks are set back typically\n due to the autumn daylight savings change from \"summer\" to \"winter\".\n In an overlap there are local date-time values with two valid offsets.</li>\n</ul><p>\nA transition is used to model the cases of a Gap or Overlap.\nThe Normal case will return null.\n<p>\nThere are various ways to handle the conversion from a {@code LocalDateTime}.\nOne technique, using this method, would be:\n<pre>\n ZoneOffsetTransition trans = rules.getTransition(localDT);\n if (trans != null) {\n   // Gap or Overlap: determine what to do from transition\n } else {\n   // Normal case: only one valid offset\n   zoneOffset = rule.getOffset(localDT);\n }\n</pre>",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the local date-time to query for offset transition, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the offset transition, null if the local date-time is not in transition"
    }
  },
  {
    "__docId__": 2253,
    "kind": "method",
    "name": "standardOffset",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#standardOffset",
    "access": "public",
    "description": "Gets the standard offset for the specified instant in this zone.\n<p>\nThis provides access to historic information on how the standard offset\nhas changed over time.\nThe standard offset is the offset before any daylight saving time is applied.\nThis is typically the offset applicable during winter.",
    "lineNumber": 229,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset information for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffset"
      ],
      "spread": false,
      "description": "the standard offset, not null"
    }
  },
  {
    "__docId__": 2254,
    "kind": "method",
    "name": "daylightSavings",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#daylightSavings",
    "access": "public",
    "description": "Gets the amount of daylight savings in use for the specified instant in this zone.\n<p>\nThis provides access to historic information on how the amount of daylight\nsavings has changed over time.\nThis is the difference between the standard offset and the actual offset.\nTypically the amount is zero during winter and one hour during summer.\nTime-zones are second-based, so the nanosecond part of the duration will be zero.",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the daylight savings for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Duration"
      ],
      "spread": false,
      "description": "the difference between the standard and actual offset, not null"
    }
  },
  {
    "__docId__": 2255,
    "kind": "method",
    "name": "isDaylightSavings",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#isDaylightSavings",
    "access": "public",
    "description": "Checks if the specified instant is in daylight savings.\n<p>\nThis checks if the standard and actual offsets are the same at the specified instant.",
    "lineNumber": 261,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to find the offset information for, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "the standard offset, not null"
    }
  },
  {
    "__docId__": 2256,
    "kind": "method",
    "name": "isValidOffset",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#isValidOffset",
    "access": "public",
    "description": "Checks if the offset date-time is valid for these rules.\n<p>\nTo be valid, the local date-time must not be in a gap and the offset\nmust match the valid offsets.",
    "lineNumber": 276,
    "params": [
      {
        "nullable": null,
        "types": [
          "LocalDateTime"
        ],
        "spread": false,
        "optional": false,
        "name": "localDateTime",
        "description": "the date-time to check, not null, but null\n may be ignored if the rules have a single offset for all instants"
      },
      {
        "nullable": null,
        "types": [
          "ZoneOffset"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "the offset to check, null returns false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the offset date-time is valid for these rules"
    }
  },
  {
    "__docId__": 2257,
    "kind": "method",
    "name": "nextTransition",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#nextTransition",
    "access": "public",
    "description": "Gets the next transition after the specified instant.\n<p>\nThis returns details of the next transition after the specified instant.\nFor example, if the instant represents a point where \"Summer\" daylight savings time\napplies, then the method will return the transition to the next \"Winter\" time.",
    "lineNumber": 293,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to get the next transition after, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the next transition after the specified instant, null if this is after the last transition"
    }
  },
  {
    "__docId__": 2258,
    "kind": "method",
    "name": "previousTransition",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#previousTransition",
    "access": "public",
    "description": "Gets the previous transition before the specified instant.\n<p>\nThis returns details of the previous transition after the specified instant.\nFor example, if the instant represents a point where \"summer\" daylight saving time\napplies, then the method will return the transition from the previous \"winter\" time.",
    "lineNumber": 309,
    "params": [
      {
        "nullable": null,
        "types": [
          "Instant"
        ],
        "spread": false,
        "optional": false,
        "name": "instant",
        "description": "the instant to get the previous transition after, not null, but null\n may be ignored if the rules have a single offset for all instants"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition"
      ],
      "spread": false,
      "description": "the previous transition after the specified instant, null if this is before the first transition"
    }
  },
  {
    "__docId__": 2259,
    "kind": "method",
    "name": "transitions",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#transitions",
    "access": "public",
    "description": "Gets the complete list of fully defined transitions.\n<p>\nThe complete set of transitions for this rules instance is defined by this method\nand {@link #getTransitionRules()}. This method returns those transitions that have\nbeen fully defined. These are typically historical, but may be in the future.\n<p>\nThe list will be empty for fixed offset rules and for any time-zone where there has\nonly ever been a single offset. The list will also be empty if the transition rules are unknown.",
    "lineNumber": 325,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransition[]"
      ],
      "spread": false,
      "description": "an immutable list of fully defined transitions, not null"
    },
    "params": []
  },
  {
    "__docId__": 2260,
    "kind": "method",
    "name": "transitionRules",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#transitionRules",
    "access": "public",
    "description": "Gets the list of transition rules for years beyond those defined in the transition list.\n<p>\nThe complete set of transitions for this rules instance is defined by this method\nand {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}\nthat define an algorithm for when transitions will occur.\n<p>\nFor any given {@code ZoneRules}, this list contains the transition rules for years\nbeyond those years that have been fully defined. These rules typically refer to future\ndaylight saving time rule changes.\n<p>\nIf the zone defines daylight savings into the future, then the list will normally\nbe of size two and hold information about entering and exiting daylight savings.\nIf the zone does not have daylight savings, or information about future changes\nis uncertain, then the list will be empty.\n<p>\nThe list will be empty for fixed offset rules and for any time-zone where there is no\ndaylight saving time. The list will also be empty if the transition rules are unknown.",
    "lineNumber": 350,
    "return": {
      "nullable": null,
      "types": [
        "ZoneOffsetTransitionRule[]"
      ],
      "spread": false,
      "description": "an immutable list of transition rules, not null"
    },
    "params": []
  },
  {
    "__docId__": 2261,
    "kind": "method",
    "name": "equals",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#equals",
    "access": "public",
    "description": "",
    "lineNumber": 359,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2262,
    "kind": "method",
    "name": "toString",
    "memberof": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~MomentZoneRules#toString",
    "access": "public",
    "description": "",
    "lineNumber": 373,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 2263,
    "kind": "class",
    "name": "LDTUntils",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 378,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2264,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 379,
    "undocument": true
  },
  {
    "__docId__": 2265,
    "kind": "member",
    "name": "_tzdbUntils",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#_tzdbUntils",
    "access": "private",
    "description": null,
    "lineNumber": 380,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2266,
    "kind": "member",
    "name": "_tzdbOffsets",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#_tzdbOffsets",
    "access": "private",
    "description": null,
    "lineNumber": 381,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2267,
    "kind": "member",
    "name": "_ldtUntils",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#_ldtUntils",
    "access": "private",
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 2268,
    "kind": "member",
    "name": "size",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#size",
    "access": "public",
    "description": null,
    "lineNumber": 383,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2269,
    "kind": "method",
    "name": "_generateTupple",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#_generateTupple",
    "access": "private",
    "description": null,
    "lineNumber": 387,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 2270,
    "kind": "method",
    "name": "_getTupple",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#_getTupple",
    "access": "private",
    "description": null,
    "lineNumber": 410,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2271,
    "kind": "method",
    "name": "get",
    "memberof": "packages/timezone/src/MomentZoneRules.js~LDTUntils",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "packages/timezone/src/MomentZoneRules.js~LDTUntils#get",
    "access": "public",
    "description": null,
    "lineNumber": 417,
    "undocument": true,
    "params": [
      {
        "name": "index",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2272,
    "kind": "function",
    "name": "ldtBinarySearch",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~ldtBinarySearch",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 425,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2273,
    "kind": "function",
    "name": "offsetInSeconds",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~offsetInSeconds",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 437,
    "undocument": true,
    "params": [
      {
        "name": "tzdbOffset",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2274,
    "kind": "function",
    "name": "roundDown",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~roundDown",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 441,
    "undocument": true,
    "params": [
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2275,
    "kind": "function",
    "name": "binarySearch",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~binarySearch",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2276,
    "kind": "function",
    "name": "notSupported",
    "memberof": "packages/timezone/src/MomentZoneRules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRules.js~notSupported",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 463,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2277,
    "kind": "file",
    "name": "packages/timezone/src/MomentZoneRulesProvider.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport {\n    DateTimeException,\n    ZoneRulesProvider,\n} from '@js-joda/core';\n\nimport { MomentZoneRules } from './MomentZoneRules';\n\nimport { unpack } from './unpack';\n\nlet TZDB_DATA;\nlet TZDB_VERSION;\nconst AVAILABLE_ZONE_IDS = [];\n\nconst zones = {};\nconst links = {};\n\nexport class MomentZoneRulesProvider extends ZoneRulesProvider {\n    /**\n     * Gets the rules for the zone ID.\n     * <p>\n     * This returns the latest available rules for the zone ID.\n     * <p>\n     * This method relies on time-zone data provider files that are configured.\n     *\n     * @param {string} zoneId\n     * @return {ZoneRules}\n     */\n    static getRules(zoneId){\n        const tzdbZoneInfo = zones[links[zoneId]];\n        if(tzdbZoneInfo == null){\n            throw new DateTimeException(`Unknown time-zone ID: ${zoneId}`);\n        }\n        return new MomentZoneRules(tzdbZoneInfo);\n    }\n\n\n    /**\n     * Gets the set of available zone IDs.\n     * <p>\n     * These zone IDs are loaded and available for use by {@code ZoneId}.\n     *\n     * @return {string[]} a modifiable copy of the set of zone IDs, not null\n     */\n    static getAvailableZoneIds(){\n        return AVAILABLE_ZONE_IDS;\n    }\n\n    /**\n     *\n     * @return {string} the tzdb version.\n     */\n    static getVersion() {\n        return TZDB_VERSION;\n    }\n\n    /**\n     * Provides the packed tzdb data,\n     * the data has the same format as provided from moment-timezone.\n     *\n     * @return {object} the packed tzdb data.\n     */\n    static getTzdbData(){\n        return TZDB_DATA;\n    }\n\n    /**\n     * Sets the packed tzdb data.\n     * Accepts tzdb data in the same format as provided from moment-timezone.\n     *\n     * @param packedJson\n     */\n    static loadTzdbData(packedJson){\n        TZDB_DATA = packedJson;\n        TZDB_VERSION = packedJson.version;\n\n        for (const packedZoneInfo of packedJson.zones) {\n            const tzdbZoneInfo = unpack(packedZoneInfo);\n            AVAILABLE_ZONE_IDS.push(tzdbZoneInfo.name);\n            zones[tzdbZoneInfo.name] = tzdbZoneInfo;\n            links[tzdbZoneInfo.name] = tzdbZoneInfo.name;\n        }\n\n        for (const packedLink of packedJson.links) {\n            const link = packedLink.split('|');\n            AVAILABLE_ZONE_IDS.push(link[1]);\n            links[link[1]] = link[0];\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/MomentZoneRulesProvider.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2278,
    "kind": "variable",
    "name": "AVAILABLE_ZONE_IDS",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~AVAILABLE_ZONE_IDS",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRulesProvider.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2279,
    "kind": "variable",
    "name": "zones",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~zones",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRulesProvider.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2280,
    "kind": "variable",
    "name": "links",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~links",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRulesProvider.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2281,
    "kind": "class",
    "name": "MomentZoneRulesProvider",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js",
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "access": "public",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/MomentZoneRulesProvider.js",
    "importStyle": "{MomentZoneRulesProvider}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "interface": false,
    "extends": [
      "@js-joda/core~ZoneRulesProvider"
    ]
  },
  {
    "__docId__": 2282,
    "kind": "method",
    "name": "getRules",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.getRules",
    "access": "public",
    "description": "Gets the rules for the zone ID.\n<p>\nThis returns the latest available rules for the zone ID.\n<p>\nThis method relies on time-zone data provider files that are configured.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "zoneId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ZoneRules"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 2283,
    "kind": "method",
    "name": "getAvailableZoneIds",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.getAvailableZoneIds",
    "access": "public",
    "description": "Gets the set of available zone IDs.\n<p>\nThese zone IDs are loaded and available for use by {@code ZoneId}.",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": "a modifiable copy of the set of zone IDs, not null"
    },
    "params": []
  },
  {
    "__docId__": 2284,
    "kind": "method",
    "name": "getVersion",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.getVersion",
    "access": "public",
    "description": "",
    "lineNumber": 58,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the tzdb version."
    },
    "params": []
  },
  {
    "__docId__": 2285,
    "kind": "method",
    "name": "getTzdbData",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.getTzdbData",
    "access": "public",
    "description": "Provides the packed tzdb data,\nthe data has the same format as provided from moment-timezone.",
    "lineNumber": 68,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "the packed tzdb data."
    },
    "params": []
  },
  {
    "__docId__": 2286,
    "kind": "method",
    "name": "loadTzdbData",
    "memberof": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/MomentZoneRulesProvider.js~MomentZoneRulesProvider.loadTzdbData",
    "access": "public",
    "description": "Sets the packed tzdb data.\nAccepts tzdb data in the same format as provided from moment-timezone.",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "packedJson",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 2287,
    "kind": "file",
    "name": "packages/timezone/src/auto-plug.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { use } from '@js-joda/core';\n\nimport plug from './plug';\n\n/**\n * @private\n */\nexport default function autoPlug() {\n    use(plug);\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/auto-plug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2288,
    "kind": "function",
    "name": "autoPlug",
    "memberof": "packages/timezone/src/auto-plug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/auto-plug.js~autoPlug",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/auto-plug.js",
    "importStyle": "autoPlug",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 2289,
    "kind": "file",
    "name": "packages/timezone/src/js-joda-timezone-empty.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport autoPlug from './auto-plug';\n\nautoPlug();",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/js-joda-timezone-empty.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2290,
    "kind": "file",
    "name": "packages/timezone/src/js-joda-timezone.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport latest from './tzdbData';\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport autoPlug from './auto-plug';\n\nMomentZoneRulesProvider.loadTzdbData(latest);\n\nautoPlug();\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/js-joda-timezone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2291,
    "kind": "file",
    "name": "packages/timezone/src/plug.js",
    "content": "/*\n * @copyright (c) 2016-present, Philipp Thürwächter, Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nimport { MomentZoneRulesProvider } from './MomentZoneRulesProvider';\nimport extendSystemDefaultZoneId from './system-default-zone';\n\n/**\n * @private\n */\nexport default function (jsJoda) {\n    jsJoda.ZoneRulesProvider.getRules = MomentZoneRulesProvider.getRules;\n    jsJoda.ZoneRulesProvider.getAvailableZoneIds = MomentZoneRulesProvider.getAvailableZoneIds;\n    jsJoda.ZoneRulesProvider.getTzdbData = MomentZoneRulesProvider.getTzdbData;\n    jsJoda.ZoneRulesProvider.loadTzdbData = MomentZoneRulesProvider.loadTzdbData;\n\n    extendSystemDefaultZoneId(jsJoda.ZoneId);\n    return jsJoda;\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/plug.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2292,
    "kind": "function",
    "name": "plug",
    "memberof": "packages/timezone/src/plug.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/plug.js~plug",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/plug.js",
    "importStyle": "plug",
    "description": "",
    "lineNumber": 12,
    "ignore": true,
    "params": [
      {
        "name": "jsJoda",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2293,
    "kind": "file",
    "name": "packages/timezone/src/system-default-zone.js",
    "content": "/**\n * @private\n *\n * @param ZoneId\n * @returns {null|*}\n */\nfunction getResolvedZoneId(ZoneId) {\n    try {\n        const resolvedTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return ZoneId.of(resolvedTimeZone);\n    } catch (err) {\n        // ignore\n    }\n    return null;\n}\n\n/**\n * @private\n *\n * @param ZoneId\n */\nexport default function extendSystemDefaultZoneId(ZoneId) {\n    const resolvedZoneId = getResolvedZoneId(ZoneId);\n\n    if (resolvedZoneId == null) {\n        return;\n    }\n\n    ZoneId.systemDefault = function () {\n        return resolvedZoneId;\n    };\n}\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/system-default-zone.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2294,
    "kind": "function",
    "name": "getResolvedZoneId",
    "memberof": "packages/timezone/src/system-default-zone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/system-default-zone.js~getResolvedZoneId",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/system-default-zone.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{null|*}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ZoneId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "null",
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2295,
    "kind": "function",
    "name": "extendSystemDefaultZoneId",
    "memberof": "packages/timezone/src/system-default-zone.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/system-default-zone.js~extendSystemDefaultZoneId",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/system-default-zone.js",
    "importStyle": "extendSystemDefaultZoneId",
    "description": "",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ZoneId",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 2296,
    "kind": "file",
    "name": "packages/timezone/src/tzdbData.js",
    "content": "import latest from '../data/packed/latest.json';\n\nexport default latest;\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/tzdbData.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2297,
    "kind": "file",
    "name": "packages/timezone/src/unpack.js",
    "content": "/* eslint-disable no-var */\n\n//! moment-timezone.js\n//! version : 0.5.2\n//! author : Tim Wood\n//! license : MIT\n//! github.com/moment/moment-timezone\n\n/************************************\n Unpacking\n ************************************/\n\n/**\n * @private\n *\n * @param charCode\n * @returns {number}\n */\nfunction charCodeToInt(charCode) {\n    if (charCode > 96) {\n        return charCode - 87;\n    } else if (charCode > 64) {\n        return charCode - 29;\n    }\n    return charCode - 48;\n}\n\nfunction unpackBase60(string) {\n    var i = 0,\n        parts = string.split('.'),\n        whole = parts[0],\n        fractional = parts[1] || '',\n        multiplier = 1,\n        num,\n        out = 0,\n        sign = 1;\n\n    // handle negative numbers\n    if (string.charCodeAt(0) === 45) {\n        i = 1;\n        sign = -1;\n    }\n\n    // handle digits before the decimal\n    for (i; i < whole.length; i++) {\n        num = charCodeToInt(whole.charCodeAt(i));\n        out = 60 * out + num;\n    }\n\n    // handle digits after the decimal\n    for (i = 0; i < fractional.length; i++) {\n        multiplier = multiplier / 60;\n        num = charCodeToInt(fractional.charCodeAt(i));\n        out += num * multiplier;\n    }\n\n    return out * sign;\n}\n\nfunction arrayToInt (array) {\n    for (var i = 0; i < array.length; i++) {\n        array[i] = unpackBase60(array[i]);\n    }\n}\n\nfunction intToUntil (array, length) {\n    for (var i = 0; i < length; i++) {\n        array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds\n    }\n\n    array[length - 1] = Infinity;\n}\n\nfunction mapIndices (source, indices) {\n    var out = [], i;\n\n    for (i = 0; i < indices.length; i++) {\n        out[i] = source[indices[i]];\n    }\n\n    return out;\n}\n\n/**\n * @private\n *\n * @param string\n * @returns {{offsets: *[], abbrs: *[], name, untils: *, population: number}}\n */\nexport function unpack (string) {\n    var data = string.split('|'),\n        offsets = data[2].split(' '),\n        indices = data[3].split(''),\n        untils  = data[4].split(' ');\n\n    arrayToInt(offsets);\n    arrayToInt(indices);\n    arrayToInt(untils);\n\n    intToUntil(untils, indices.length);\n\n    return {\n        name       : data[0],\n        abbrs      : mapIndices(data[1].split(' '), indices),\n        offsets    : mapIndices(offsets, indices),\n        untils     : untils,\n        population : data[5] | 0\n    };\n}\n\n",
    "static": true,
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/packages/timezone/src/unpack.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 2298,
    "kind": "function",
    "name": "charCodeToInt",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~charCodeToInt",
    "access": "private",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "charCode",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 2299,
    "kind": "function",
    "name": "unpackBase60",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~unpackBase60",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2300,
    "kind": "function",
    "name": "arrayToInt",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~arrayToInt",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2301,
    "kind": "function",
    "name": "intToUntil",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~intToUntil",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 2302,
    "kind": "function",
    "name": "mapIndices",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~mapIndices",
    "access": "public",
    "export": false,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 2303,
    "kind": "function",
    "name": "unpack",
    "memberof": "packages/timezone/src/unpack.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "packages/timezone/src/unpack.js~unpack",
    "access": "private",
    "export": true,
    "importPath": "@js-joda/root/packages/timezone/src/unpack.js",
    "importStyle": "{unpack}",
    "description": "",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{offsets: *[], abbrs: *[], name, untils: *, population: number}}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{offsets: *[], abbrs: *[], name, untils: *, population: number}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# Immutable date and time library for JavaScript\n\n[![npm version](https://badge.fury.io/js/%40js-joda%2Fcore.svg)](https://badge.fury.io/js/%40js-joda%2Fcore)\n[![GH Actions Build Status](https://github.com/js-joda/js-joda/actions/workflows/tests.yaml/badge.svg?branch=main)](https://github.com/js-joda/js-joda/actions)\n[![Sauce Test Status](https://saucelabs.com/buildstatus/js-joda)](https://saucelabs.com/u/js-joda)\n[![Coverage Status](https://coveralls.io/repos/js-joda/js-joda/badge.svg?branch=main&service=github)](https://coveralls.io/github/js-joda/js-joda?branch=main)\n[![Downloads/Month](https://img.shields.io/npm/dm/%40js-joda%2Fcore.svg)](https://img.shields.io/npm/dm/%40js-joda%2Fcore.svg)\n\n[![Sauce Browser Matrix](https://saucelabs.com/browser-matrix/js-joda.svg?branch=main&421)](https://saucelabs.com/u/js-joda)\n\n## Introduction\n\n**js-joda** is an **immutable date and time library** for JavaScript. It provides a **simple, domain-driven and clean API** based on the ISO calendar system, which is the de facto world calendar following the proleptic Gregorian rules.\n\n- js-joda has a lightweight footprint, only **43 kB minified and compressed**, no third party dependencies.\n\n- js-joda is **fast**. It is about 2 to 10 times faster than other JavaScript date libraries.\n\n- js-joda comes with built-in parsers/ formatters for ISO 8601 as specified in RFC 3339, that can be easily customized.\n\n- js-joda supports **ECMAScript 5** browsers down to IE11.\n\n- js-joda is a **port of the threeten** backport, which is the base for JSR-310 implementation of the Java SE 8 java.time package. Threeten is inspired by **Joda-Time**, having similar concepts and the same author.\n\n- js-joda is **robust and stable**. We ported more then 1700 test-cases with a lots of test-permutations from the threetenbp project. We run the automated karma test-suite against Firefox, Chrome, Node and phantomjs.\n\n## Why yet another JavaScript date and time library?\n\n- Popular JavaScript date libraries like [moment](https://momentjs.com/) or [date-utils](https://github.com/continuouscalendar/dateutils) are **wrappers** around the native JavaScript `Date` object, providing syntactic sugar. The native `Date` object always consist of a date, time and a timezone part. In contrast, js-joda is a **standalone** date and time implementation.\n\n- The API has a **domain-driven design** with classes for each of the different use cases, like `LocalDate`, `ZonedDateTime` or `Period`. For example, `LocalDate` allows you to handle dates without times (like birthdays or holidays) in a clean and error-safe way, especially if these dates are persisted to an external server.\n\n- js-joda is **immutable**. Immutability aligns well with pure functions and with the architecture of frameworks like React and Flux.\n\n## The ThreeTen domain models\n\n### Dates and Times\n\n- **LocalDate** represents a date without a time and timezone in the ISO-8601 calendar system, such as 2007-12-24.\n\n- **LocalTime** represents a time without timezone in the ISO-8601 calendar system such as '11:55:00'.\n\n- **LocalDateTime** is a description of the date (LocalDate), as used for birthdays, combined with the local time (LocalTime) as seen on a wall clock.\n\n- **ZonedDateTime** is a date-time with a timezone in the ISO-8601 calendar system, such as 2007-12-24T16:15:30+01:00 UTC+01:00.\n\n- **Instant** is an instantaneous point on the time-line measured from the epoch of _1970-01-01T00:00:00Z_ in epoch-seconds and nanosecond-of-second.\n\n### Duration and Period\n\n- **Duration** is a time-based amount of time, such as '34.5 seconds'.\n\n- **Period** is a date-based amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.\n\n### Additional value types\n\n- **Year** represents a year in the ISO-8601 calendar system, such as '2016'.\n\n- **YearMonth** represents a year and a month in the ISO-8601 calendar system, such as '2016-01'.\n\n- **Month** represents a month-of-year in the ISO-8601 calendar system, such as 'July'.\n\n- **MonthDay** represents a month-day in the ISO-8601 calendar system, such as '--12-03'. Could be used to represent e.g. Birthdays.\n\n- **DayOfWeek** represents a day-of-week in the ISO-8601 calendar system, such as 'Tuesday'.\n\n## Getting started\n\n### Node\n\nInstall joda using npm\n\n```\nnpm install @js-joda/core\n```\n\nThen require it to any module\n\n```js\nvar LocalDate = require('@js-joda/core').LocalDate;\n\nvar d = LocalDate.parse('2012-12-24').atStartOfDay().plusMonths(2); // 2013-02-24T00:00:00\n```\n\n### Browser\n\nTo use js-joda from a browser, download js-joda from a cdn (eg https://cdn.jsdelivr.net/npm/@js-joda/core@<version>) \neither `dist/js-joda.min.js` or `dist/js-joda.js` (with sourcemaps for development). \nThen add it as a script tag to your page\n\n```html\n<script src=\"js-joda.min.js\"></script>\n<script>\n    var LocalDate = JSJoda.LocalDate;\n    var d = LocalDate.parse('2012-12-24').atStartOfDay().plusMonths(2); // 2013-02-24T00:00:00\n</script>\n```\n\n## js-joda packages\n\njs-joda consist of four packages:\n\n|  package name | description  |  path |\n|---|---|---|\n| `@js-joda/core` | Implementation of the ThreeTen Classes and API | [/packages/core](//github.com/js-joda/js-joda/tree/main/packages/core) |\n| `@js-joda/timezone` | Implementation of timezone calculation based on the iana Time Zone Database | [/packages/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone) |\n| `@js-joda/locale` | Implementation of locale specific functionality for js-joda, especially for formatting and parsing locale specific dates | [/packages/locale](//github.com/js-joda/js-joda/tree/main/packages/locale) |\n| `@js-joda/extra` | Implementation of the ThreeTen-Extra Classes and API |[/packages/extra](//github.com/js-joda/js-joda/tree/main/packages/extra) |\n\nThe [@js-joda/examples](//github.com/js-joda/js-joda/tree/main/packages/examples) package is for testing the different build artifacts in different context, like webpack, browser node, etc.\n\n## Documentation\n\n- [js-joda Quick start guide](//js-joda.github.io/js-joda/manual/getting-started.html) Quick start guide and examples\n- [API](//js-joda.github.io/js-joda/identifiers.html) ESDoc generated API documentation\n\n## Contributing\n\nContributions are always welcome. Before contributing please read the [code of conduct](http://contributor-covenant.org/version/1/4/) &\nsearch the issue tracker. We use GitHub issues. Your issue may have already been discussed or fixed. To contribute, fork js-joda, commit your changes, & send a pull request.\n\nBy contributing to js-joda, you agree that your contributions will be licensed under its BSD license.\n\nNote that only pull requests and issues that match the threeten backport API will be considered. Additional requested features will be rejected.\n\n## License\n\n- `js-joda` is released under the [BSD 3-clause license](//github.com/js-joda/js-joda/blob/main/LICENSE).\n\n- `js-joda` uses the ThreeTen-Backport implementation (http://www.threeten.org/threetenbp/) as a reference base for implementation. This allows us to release js-joda under the BSD License while the OpenJDK java.time implementation is under GNU GPL+linking exception. The API of the ThreeTen-Backport is mostly identical to the official Java SE 8 API from the view of our JavaScript port.\n\n- Our implementation reference base ThreeTen-Backport (http://www.threeten.org/threetenbp/) is also released under the BSD 3-clause license\n\n- `OpenJDK` is under GNU GPL+linking exception.\n\n- The author of `Joda-Time` and the lead architect of the JSR-310 is Stephen Colebourne.\n\nThe API of this project (as far as possible with JavaScript), a lot of implementation details and documentation\nare just copied but never equalled.\n\n## Roadmap\n\n### Milestone 1: Core domains (reached with version v1.0.0)\n\n- Support for the domain models `LocalDate`, `LocalDateTime`, `ZonedDateTime`, `Instant`, `Duration` and `Period` converting to and from ISO8601.\n- `ZonedDateTime` (without support for loading iana timezone databases) currently supports only fixed offsets like UTC or UTC+02:00 and the system default time zone.\n\n### Milestone 2: IANA timezone support (reached with version v1.2.0)\n\n- Add IANA timezone database support to js-joda. Implement handling of daylight saving transitions, mainly in `ZonedDateTime`.\n- For access to the IANA timezone database, the plugin [@js-joda/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone) is required. It provides an implementation of the [ZoneRulesProvider](//js-joda.github.io/js-joda/class/packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider.html) and contains the iana timezone database.\n\n### Milestone 3: Locale support (reached with v2.0.0 of @js-joda/locale)\n\n- Add locale support.\n- Extend pattern parser/ formatter for text with locale support.\n\nsee the plugin [@js-joda/locale](//github.com/js-joda/js-joda/tree/main/packages/locale)\n\n### Future Milestones\n\n- Reduce library size by removing redundant code, especially by refactoring code for formatting/ parsing dates.\n- Increase test coverage (ongoing task)\n- Cleanup documentation (ongoing task)\n",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "# Immutable date and time library for JavaScript\n\n[![npm version](https://badge.fury.io/js/%40js-joda%2Fcore.svg)](https://badge.fury.io/js/%40js-joda%2Fcore)\n[![GH Actions Build Status](https://github.com/js-joda/js-joda/actions/workflows/tests.yaml/badge.svg?branch=main)](https://github.com/js-joda/js-joda/actions)\n[![Sauce Test Status](https://saucelabs.com/buildstatus/js-joda)](https://saucelabs.com/u/js-joda)\n[![Coverage Status](https://coveralls.io/repos/js-joda/js-joda/badge.svg?branch=main&service=github)](https://coveralls.io/github/js-joda/js-joda?branch=main)\n[![Downloads/Month](https://img.shields.io/npm/dm/%40js-joda%2Fcore.svg)](https://img.shields.io/npm/dm/%40js-joda%2Fcore.svg)\n\n[![Sauce Browser Matrix](https://saucelabs.com/browser-matrix/js-joda.svg?branch=main&421)](https://saucelabs.com/u/js-joda)\n\n## Introduction\n\n**js-joda** is an **immutable date and time library** for JavaScript. It provides a **simple, domain-driven and clean API** based on the ISO calendar system, which is the de facto world calendar following the proleptic Gregorian rules.\n\n- js-joda has a lightweight footprint, only **43 kB minified and compressed**, no third party dependencies.\n\n- js-joda is **fast**. It is about 2 to 10 times faster than other JavaScript date libraries.\n\n- js-joda comes with built-in parsers/ formatters for ISO 8601 as specified in RFC 3339, that can be easily customized.\n\n- js-joda supports **ECMAScript 5** browsers down to IE11.\n\n- js-joda is a **port of the threeten** backport, which is the base for JSR-310 implementation of the Java SE 8 java.time package. Threeten is inspired by **Joda-Time**, having similar concepts and the same author.\n\n- js-joda is **robust and stable**. We ported more then 1700 test-cases with a lots of test-permutations from the threetenbp project. We run the automated karma test-suite against Firefox, Chrome, Node and phantomjs.\n\n## Why yet another JavaScript date and time library?\n\n- Popular JavaScript date libraries like [moment](https://momentjs.com/) or [date-utils](https://github.com/continuouscalendar/dateutils) are **wrappers** around the native JavaScript `Date` object, providing syntactic sugar. The native `Date` object always consist of a date, time and a timezone part. In contrast, js-joda is a **standalone** date and time implementation.\n\n- The API has a **domain-driven design** with classes for each of the different use cases, like `LocalDate`, `ZonedDateTime` or `Period`. For example, `LocalDate` allows you to handle dates without times (like birthdays or holidays) in a clean and error-safe way, especially if these dates are persisted to an external server.\n\n- js-joda is **immutable**. Immutability aligns well with pure functions and with the architecture of frameworks like React and Flux.\n\n## The ThreeTen domain models\n\n### Dates and Times\n\n- **LocalDate** represents a date without a time and timezone in the ISO-8601 calendar system, such as 2007-12-24.\n\n- **LocalTime** represents a time without timezone in the ISO-8601 calendar system such as '11:55:00'.\n\n- **LocalDateTime** is a description of the date (LocalDate), as used for birthdays, combined with the local time (LocalTime) as seen on a wall clock.\n\n- **ZonedDateTime** is a date-time with a timezone in the ISO-8601 calendar system, such as 2007-12-24T16:15:30+01:00 UTC+01:00.\n\n- **Instant** is an instantaneous point on the time-line measured from the epoch of _1970-01-01T00:00:00Z_ in epoch-seconds and nanosecond-of-second.\n\n### Duration and Period\n\n- **Duration** is a time-based amount of time, such as '34.5 seconds'.\n\n- **Period** is a date-based amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.\n\n### Additional value types\n\n- **Year** represents a year in the ISO-8601 calendar system, such as '2016'.\n\n- **YearMonth** represents a year and a month in the ISO-8601 calendar system, such as '2016-01'.\n\n- **Month** represents a month-of-year in the ISO-8601 calendar system, such as 'July'.\n\n- **MonthDay** represents a month-day in the ISO-8601 calendar system, such as '--12-03'. Could be used to represent e.g. Birthdays.\n\n- **DayOfWeek** represents a day-of-week in the ISO-8601 calendar system, such as 'Tuesday'.\n\n## Getting started\n\n### Node\n\nInstall joda using npm\n\n```\nnpm install @js-joda/core\n```\n\nThen require it to any module\n\n```js\nvar LocalDate = require('@js-joda/core').LocalDate;\n\nvar d = LocalDate.parse('2012-12-24').atStartOfDay().plusMonths(2); // 2013-02-24T00:00:00\n```\n\n### Browser\n\nTo use js-joda from a browser, download js-joda from a cdn (eg https://cdn.jsdelivr.net/npm/@js-joda/core@<version>) \neither `dist/js-joda.min.js` or `dist/js-joda.js` (with sourcemaps for development). \nThen add it as a script tag to your page\n\n```html\n<script src=\"js-joda.min.js\"></script>\n<script>\n    var LocalDate = JSJoda.LocalDate;\n    var d = LocalDate.parse('2012-12-24').atStartOfDay().plusMonths(2); // 2013-02-24T00:00:00\n</script>\n```\n\n## js-joda packages\n\njs-joda consist of four packages:\n\n|  package name | description  |  path |\n|---|---|---|\n| `@js-joda/core` | Implementation of the ThreeTen Classes and API | [/packages/core](//github.com/js-joda/js-joda/tree/main/packages/core) |\n| `@js-joda/timezone` | Implementation of timezone calculation based on the iana Time Zone Database | [/packages/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone) |\n| `@js-joda/locale` | Implementation of locale specific functionality for js-joda, especially for formatting and parsing locale specific dates | [/packages/locale](//github.com/js-joda/js-joda/tree/main/packages/locale) |\n| `@js-joda/extra` | Implementation of the ThreeTen-Extra Classes and API |[/packages/extra](//github.com/js-joda/js-joda/tree/main/packages/extra) |\n\nThe [@js-joda/examples](//github.com/js-joda/js-joda/tree/main/packages/examples) package is for testing the different build artifacts in different context, like webpack, browser node, etc.\n\n## Documentation\n\n- [js-joda Quick start guide](//js-joda.github.io/js-joda/manual/getting-started.html) Quick start guide and examples\n- [API](//js-joda.github.io/js-joda/identifiers.html) ESDoc generated API documentation\n\n## Contributing\n\nContributions are always welcome. Before contributing please read the [code of conduct](http://contributor-covenant.org/version/1/4/) &\nsearch the issue tracker. We use GitHub issues. Your issue may have already been discussed or fixed. To contribute, fork js-joda, commit your changes, & send a pull request.\n\nBy contributing to js-joda, you agree that your contributions will be licensed under its BSD license.\n\nNote that only pull requests and issues that match the threeten backport API will be considered. Additional requested features will be rejected.\n\n## License\n\n- `js-joda` is released under the [BSD 3-clause license](//github.com/js-joda/js-joda/blob/main/LICENSE).\n\n- `js-joda` uses the ThreeTen-Backport implementation (http://www.threeten.org/threetenbp/) as a reference base for implementation. This allows us to release js-joda under the BSD License while the OpenJDK java.time implementation is under GNU GPL+linking exception. The API of the ThreeTen-Backport is mostly identical to the official Java SE 8 API from the view of our JavaScript port.\n\n- Our implementation reference base ThreeTen-Backport (http://www.threeten.org/threetenbp/) is also released under the BSD 3-clause license\n\n- `OpenJDK` is under GNU GPL+linking exception.\n\n- The author of `Joda-Time` and the lead architect of the JSR-310 is Stephen Colebourne.\n\nThe API of this project (as far as possible with JavaScript), a lot of implementation details and documentation\nare just copied but never equalled.\n\n## Roadmap\n\n### Milestone 1: Core domains (reached with version v1.0.0)\n\n- Support for the domain models `LocalDate`, `LocalDateTime`, `ZonedDateTime`, `Instant`, `Duration` and `Period` converting to and from ISO8601.\n- `ZonedDateTime` (without support for loading iana timezone databases) currently supports only fixed offsets like UTC or UTC+02:00 and the system default time zone.\n\n### Milestone 2: IANA timezone support (reached with version v1.2.0)\n\n- Add IANA timezone database support to js-joda. Implement handling of daylight saving transitions, mainly in `ZonedDateTime`.\n- For access to the IANA timezone database, the plugin [@js-joda/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone) is required. It provides an implementation of the [ZoneRulesProvider](//js-joda.github.io/js-joda/class/packages/core/src/zone/ZoneRulesProvider.js~ZoneRulesProvider.html) and contains the iana timezone database.\n\n### Milestone 3: Locale support (reached with v2.0.0 of @js-joda/locale)\n\n- Add locale support.\n- Extend pattern parser/ formatter for text with locale support.\n\nsee the plugin [@js-joda/locale](//github.com/js-joda/js-joda/tree/main/packages/locale)\n\n### Future Milestones\n\n- Reduce library size by removing redundant code, especially by refactoring code for formatting/ parsing dates.\n- Increase test coverage (ongoing task)\n- Cleanup documentation (ongoing task)\n",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/getting-started.md",
    "name": "./esdoc/manual/getting-started.md",
    "content": "# Getting started\n\n### Node\n\nInstall joda using npm\n\n```bash\nnpm install @js-joda/core\n```\n\nThen require it to any module\n\n```javascript\nvar LocalDate = require(\"@js-joda/core\").LocalDate;\n\nvar d = LocalDate.parse(\"2012-12-24\")\n  .atStartOfDay()\n  .plusMonths(2); // 2013-02-24T00:00:00\n```\n\n### Browser\n\nTo use js-joda from a browser, download either dist/js-joda.min.js or dist/js-joda.js (with sourcemaps for development)\n\nThen add it as a script tag to your page\n\n```html\n<script src=\"js-joda.min.js\"></script>\n<script>\n    var LocalDate = JSJoda.LocalDate;\n    var d = LocalDate.parse('2012-12-24').atStartOfDay().plusMonths(2); // 2013-02-24T00:00:00\n</script>\n```\n\n### Fiddle around\n\nFiddle around with js-joda, here on this page in the browser developer console, \nthe latest js-joda code of all packages is always injected into this documentation.\n\nOr find a simple example setup at JSFiddle [https://jsfiddle.net/shto0ze6/](https://jsfiddle.net/shto0ze6/),\nbut don't forget to update the cdnjs resources to the desired versions. \n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/usage.md",
    "name": "./esdoc/manual/usage.md",
    "content": "# Usage\n\nThe API is **immutable**. An existing instance is never changed. All manipulating methods (`plus`, `at`, etc.) return new instances.\n\n**An existing instance is always valid**. If you try to create an invalid value, you'll get an exception instead of a `null` or `undefined` value.\n\n### Method naming conventions\n\nThe API uses consistently named methods.\n\n| method name or prefix | usage                                        | examples                                                        |\n| --------------------- | -------------------------------------------- | --------------------------------------------------------------- |\n| `.of`                 | static factory method for building by parts  | `LocalDate.of(2016, 2, 23)` <br> `LocalDate.ofInstant(i)`       |\n| `.parse`              | static factory method for parsing strings    | `LocalDate.parse('2016-02-23')` <br> `LocalTime.parse('12:34')` |\n| `.is`                 | checks for certain conditions                | `t1.isAfter(t2)` <br> `d1.isLeapYear()`                         |\n| `.equals`             | checks for equivalence between two instances | `t1.equals(t2)`                                                 |\n| `.with`               | the immutable equivalent of a setter         | `d.withDayOfMonth(1)` <br> `t.withHour(9)`                      |\n| `.plus`               | adds an amount to an object                  | `t.plusMinutes(5)` <br> `d.plus(3, ChronoUnit.YEARS)`           |\n| `.minus`              | subtracts an amount from an object           | `t.minusHours(1)` <br> `d.minus(1, ChronoUnit.DAYS)`            |\n| `.to`                 | converts this object to another type         | `dt.toLocalDate()` <br> `d1.until(d2).toTotalMonths()`          |\n| `.at`                 | combines one object with another             | `date.atTime(time)` <br> `localDate.atZone(tz)`                 |\n\nNote that getter methods for instance properties omit the get keyword: `d.year()`, not ~~`d.getYear()`~~.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/LocalDate.md",
    "name": "./esdoc/manual/LocalDate.md",
    "content": "# LocalDate\n\nA `LocalDate` represents a date with **no time** and **no time zone** in the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) calendar system, such as 2007-12-24.\n\n### Create a `LocalDate`\n\n```javascript\n// obtain the current date in the system default time zone, e.g. 2016-02-23\nLocalDate.now();\n\n// obtain the current date in the UTC time zone, e.g. 2016-02-23\nLocalDate.now(ZoneOffset.UTC);\n\n// obtain an instance of LocalDate from an ISO 8601 formatted text string\nLocalDate.parse(\"2016-02-23\");\n\n// obtain an instance of LocalDate from a year, month, and dayOfMonth value\nLocalDate.of(2016, 2, 23); // 2016-02-23\n\n// obtain an instance of LocalDate from a year, month, and dayOfMonth value\nLocalDate.of(2016, Month.FEBRUARY, 23); // 2016-02-23\n\n// obtain an instance of LocalDate from an epochDay where day 0 is 1970-01-01\nLocalDate.ofEpochDay(-1); // 1969-12-31\n\n// obtain an instance of LocalDate from an epochDay where day 0 is 1970-01-01\nLocalDate.ofYearDay(2016, 42); // 2016-02-11\n```\n\n### Get values from `LocalDate`\n\n```javascript\nvar d = LocalDate.parse(\"2016-12-24\");\n\nd.toString(); // '2016-12-24' ISO 8601 format\n\nd.dayOfMonth(); // 24\nd.month(); // Month.DECEMBER\nd.monthValue(); // 12\nd.year(); // 2016\n\nd.dayOfWeek(); // DayOfWeek.SATURDAY\nd.dayOfWeek().value(); // 6\nd.dayOfYear(); // 359\n\nd.isLeapYear(); // true - 2016 is a leap year\nd.plusYears(1).isLeapYear(); // false\n\n// get the epoch day where 0 is 1970-01-01\nd.toEpochDay(); // 17159\n\n// get range of month\nd.lengthOfMonth(); // 31\nd.range(ChronoField.DAY_OF_MONTH); // ValueRange(1 - 31)\n\n// get range of year\nd.lengthOfYear(); // 366\nd.range(ChronoField.DAY_OF_YEAR); // ValueRange(1 - 366)\n\n// get other date-based field like the aligned week of year\nd.get(ChronoField.ALIGNED_WEEK_OF_YEAR); // 52\n\n// or the day of week aligned to the first day of month\nd.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH); // 3\n```\n\n### Get week of week-based year, quarter of year, day of quarter\n\n```javascript\n// get week of week-based year as defined by ISO 8601, with a Monday-based week\nd.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR); // 51\n\nd.isoWeekOfWeekyear(); // 51, equivalent to the above\nd.isoWeekyear(); // 2016\n\nLocalDate.of(2017, 1, 1).isoWeekOfWeekyear(); // 52\nLocalDate.of(2017, 1, 1).isoWeekyear(); // 2016\n\n// set the date to week 52 of week-based year with the same day of week\nd.with(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 52); // 2016-12-31\n\n// get the quarter of the year\nd.get(IsoFields.QUARTER_OF_YEAR); // 4\nd.get(IsoFields.DAY_OF_QUARTER); // 85\n\n// set the date to the 15th day of the third quarter\nd.with(IsoFields.QUARTER_OF_YEAR, 3).with(IsoFields.DAY_OF_QUARTER, 15); // 2016-07-15\n```\n\n### Adding to and subtracting from a `LocalDate`\n\nNote that each of these methods returns a new `LocalDate` instance.\n\n```javascript\nvar d = LocalDate.parse(\"2016-02-23\");\n\n// add/subtract 366 days\nd.plusDays(366); // '2017-02-23'\nd.minusDays(366); // '2015-02-22'\n\n// add/subtract 12 months\nd.plusMonths(12); // '2017-02-23'\nd.minusMonths(12); // '2015-02-23'\n\n// add/subtract 4 weeks\nd.plusWeeks(4); // '2016-03-22'\nd.minusWeeks(4); // '2016-01-26'\n\n// add/subtract 1 year\nd.plusYears(1); // '2017-02-23'\nd.minusYears(1); // '2015-02-23'\n\n// add/subtract 30 years\nd.plus(3, ChronoUnit.DECADES); // '2046-02-23'\nd.minus(3, ChronoUnit.DECADES); // '1986-02-23'\n\n// add/subtract a Period of 3 Months and 3 Days\nd.plus(Period.ofMonths(3).plusDays(3)); // '2016-05-26'\nd.minus(Period.ofMonths(3).plusDays(3)); // '2015-11-20'\n```\n\n### Alter specific fields of a LocalDate\n\n```javascript\nvar d = LocalDate.parse(\"2016-12-24\");\n\n// set the day of month to 1\nd.withDayOfMonth(1); // '2016-12-01'\n\n// set month and the day of month to 1\nd.withMonth(1).withDayOfMonth(1); // '2016-01-01'\n\n// set month to November and the day of month to 1\nd.withMonth(Month.NOVEMBER).withDayOfMonth(1); // '2016-11-01'\n\n// set the year to beginning of era\nd.withYear(1); // '0001-12-24'\n\n// get the last day of the current month\nLocalDate.now()\n  .plusMonths(1)\n  .withDayOfMonth(1)\n  .minusDays(1);\n\n// set the day of year\nd.withDayOfYear(42); // 2016-02-11\n\n// set the week of week-based year to 52\nd.with(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 52); // 2016-12-31\n```\n\n### Compare one `LocalDate` with another\n\n```javascript\nvar d1 = LocalDate.parse(\"2016-12-24\");\nvar d2 = d1.plusDays(2);\n\nd1.isAfter(d2); // false\nd1.isBefore(d2); // true\n\nd1.equals(d2); // false\nd1.equals(d1.plusDays(0)); // true\nd1.equals(d1.plusDays(1)); // false\n\nd1.compareTo(d1) === 0; // true\nd1.compareTo(d2) < 0; // true\nd2.compareTo(d1) > 0; // true\n\nd1.hashCode(); // 4129560\nd2.hashCode(); // 4129562\nd1.hashCode() !== d2.hashCode(); // true\n```\n\n### Distance on the timeline\n\n```javascript\nvar d1 = LocalDate.parse(\"2016-12-24\");\nvar d2 = d1.plusMonths(13).plusDays(42);\n\n// obtain the Period between the two dates\nd1.until(d2).toString(); // 'P1Y2M11D' (1 year, 2 months, 11 days in ISO-8601 period format)\nd1.until(d2).toTotalMonths(); // 14\n\n// obtain the distance between the two dates with a specific precision\nd1.until(d2, ChronoUnit.MONTHS); // 14, returns the distance in total months\nd1.until(d2, ChronoUnit.DAYS); // 438, returns the distance in total days\n```\n\n### Converting from and to other temporals\n\n```javascript\n// obtain a LocalDate from a LocalDateTime instance\nvar dt = LocalDateTime.now();\nLocalDate.from(dt); // LocalDate from LocalDateTime\ndt.toLocalDate(); // LocalDateTime to LocalDate (equivalent to the above)\n\nvar d1 = LocalDate.parse(\"2016-02-25\");\n\n// obtain a LocalDateTime at a certain LocalTime\nd1.atStartOfDay(); // '2016-02-25T00:00'\nd1.atTime(LocalTime.of(11, 55)); // '2016-02-25T11:55'\nd1.atTime(LocalTime.NOON); // '2016-02-25T12:00'\n\n// obtain a LocalDate from a JavaScript Date\n\n// the manual way\nvar d = LocalDate.ofInstant(Instant.ofEpochMilli(new Date().getTime()));\n// the recommended way with the JavaScript temporal\nd = LocalDate.from(nativeJs(new Date()));\n// converting from a moment works the same way\nd = LocalDate.from(nativeJs(moment()));\n```\n\n### Adjust a date to another date\n\n`TemporalAdjusters` provide compact business logic for date-based temporals such as `LocalDate`, `LocalDateTime` or `ZonedDateTime`.\n\n```javascript\nvar d = LocalDate.parse(\"2016-12-24\");\n\n// get first/ last day of month\nd.with(TemporalAdjusters.firstDayOfMonth()); // 2016-12-01\nd.with(TemporalAdjusters.lastDayOfMonth()); // 2016-12-31\n\n// get the next specified weekday\nd.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY)); // 2016-12-25\nd.with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY)); // 2016-12-24\nd.with(TemporalAdjusters.next(DayOfWeek.SATURDAY)); // 2016-12-31\n\n// get the first/last weekday of month\nd.with(TemporalAdjusters.lastInMonth(DayOfWeek.SATURDAY)); // 2016-12-31\nd.with(TemporalAdjusters.firstInMonth(DayOfWeek.SATURDAY)); // 2016-12-03\n```\n\nFind more adjusters in the TemporalAdjusters API documentation.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/LocalTime.md",
    "name": "./esdoc/manual/LocalTime.md",
    "content": "# LocalTime\n\nA `LocalTime` represents a time with **no date** and **no time zone** in the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) calendar system, such as '10:15:30'\n\n### Create a `LocalTime` instance\n\n```javascript\n// obtain the current time in the system default time zone, e.g. '10:29:05.743'\nLocalTime.now();\n\n// obtain the current time in the UTC time zone, e.g. '09:29:05.743'\nLocalTime.now(ZoneOffset.UTC);\n\n// obtain an instance of LocalTime from an ISO 8601 formatted text string\nLocalTime.parse(\"09:42\"); // '09:42'\nLocalTime.parse(\"09:42:42\"); // '09:42:42'\nLocalTime.parse(\"09:42:42.123\"); // '09:42:42.123'\nLocalTime.parse(\"09:42:42.123456789\"); // '09:42:42.123456789'\n\n// obtain an instance of LocalTime from hour, minute, second, and nanosecond values\nLocalTime.of(23, 55); // '23:55'\nLocalTime.of(23, 55, 42); // '23:55:42'\nLocalTime.of(23, 55, 42, 123000000); // '23:55:42.123'\n\n// obtain an instance of LocalTime from second of day\nLocalTime.ofSecondOfDay(3666); // '01:01:06'\n```\n\n### Get values from `LocalTime`\n\n```javascript\nvar t = LocalTime.parse(\"23:55:42.123\");\n\nt.toString(); // '23:55:42.123' ISO 8601 format\n\nt.hour(); // 23\nt.minute(); // 55\nt.second(); // 42\nt.nano(); // 123000000\n\n// get other time-based fields\nt.get(ChronoField.SECOND_OF_DAY); // 86142\nt.get(ChronoField.MILLI_OF_SECOND); // 123\nt.get(ChronoField.HOUR_OF_AMPM); // 11\n// any other time-based ChronoField is allowed as param for get\n```\n\n### Adding to/ subtracting from a `LocalTime` instance\n\n```javascript\nvar t = LocalTime.parse(\"11:55:42\");\n\n// add/subtract 12 hours\nt.plusHours(12); // '23:55:42'\nt.minusHours(12); // '23:55:42'\n\n// add/subtract 30 minutes\nt.plusMinutes(30); // '12:25:42'\nt.minusMinutes(30); // '11:25:42'\n\n// add/subtract 30 seconds\nt.plusSeconds(30); // '11:56:12'\nt.minusSeconds(30); // '11:55:12'\n\n// add/subtract 1 million nanoseconds (1 millisecond)\nt.plusNanos(1000000); // '11:56:42.001'\nt.minusNanos(1000000); // '11:55:41.999'\n\n// add/subtract a time-based unit\nt.plus(1, ChronoUnit.MILLIS); // '11:55:42.001'\nt.plus(1, ChronoUnit.HALF_DAYS); // '23:55:42'\n\n// add/subtract a duration of 15 minutes\nt.plus(Duration.ofMinutes(15)); // '12:10:42'\nt.minus(Duration.ofMinutes(15)); // '11:40:42'\n```\n\n### Alter specific fields of a `LocalTime` instance\n\n```javascript\nvar t = LocalTime.parse(\"11:55:42\");\n\n// set the hour of day to 1\nt.withHour(1); // '01:55:42'\n\n// set the minute of hour to 1\nt.withMinute(1); // '11:01:42'\n\n// set the second of minute to 1\nt.withSecond(1); // '11:55:01'\n\n// set the MILLI_OF_SECOND to 51\nt.with(ChronoField.MILLI_OF_SECOND, 51); // '11:55:42.051'\n\n// set by a custom  TemporalAdjusters\n// sample of a custom adjuster that adjust to the next even second\nnextEvenSecond = {\n  adjustInto: function(t) {\n    return t.second() % 2 === 0 ? t.plusSeconds(2) : t.plusSeconds(1);\n  }\n};\nt.with(nextEvenSecond); // '11:55:44'\nt.plusSeconds(1).with(nextEvenSecond); // '11:55:44'\n```\n\n### Truncate a `LocalTime` instance\n\n```javascript\nvar t = LocalTime.parse(\"23:55:42.123\");\n\nt.truncatedTo(ChronoUnit.SECONDS); // '23:55:42'\nt.truncatedTo(ChronoUnit.MINUTES); // '23:55:00'\nt.truncatedTo(ChronoUnit.HOURS); // '23:00'\nt.truncatedTo(ChronoUnit.HALF_DAYS); // '12:00'\nt.truncatedTo(ChronoUnit.DAYS); // '00:00'\n```\n\n### Compare `LocalTime` instances\n\n```javascript\nvar t1 = LocalTime.parse(\"11:55:42\");\nvar t2 = t1.plusHours(2);\n\nt1.isAfter(t2); // false\nt1.isBefore(t2); // true\n\nt1.equals(t1.plusHours(0)); // true\nt1.equals(t1.plusHours(1)); // false\n\nt1.compareTo(t1) === 0; // true\nt1.compareTo(t2) < 0; // true\nt2.compareTo(t1) > 0; // true\n\nt1.hashCode(); // 916974646\nt2.hashCode(); // -1743180648\nt1.hashCode() !== t2.hashCode(); // true\n```\n\n### Distance between times\n\n```javascript\nvar t1 = LocalTime.parse(\"11:00\");\nvar t2 = t1\n  .plusHours(2)\n  .plusMinutes(42)\n  .plusSeconds(12);\n\n// obtain the duration between the two dates\nt1.until(t2, ChronoUnit.HOURS); // 2\nt1.until(t2, ChronoUnit.MINUTES); // 162\nt1.until(t2, ChronoUnit.SECONDS); // 9732\n```\n\n### Convert a `LocalTime` from a `moment` or JavaScript `Date`\n\n```javascript\n// obtain a LocalTime instance from a JavaScript Date\n\n// the manual way\nvar t = LocalTime.ofInstant(Instant.ofEpochMilli(new Date().getTime()));\n// the recommended way with the JavaScript temporal\nt = LocalTime.from(nativeJs(new Date()));\n// converting from a `moment` instance works the same way\nd = LocalTime.from(nativeJs(moment()));\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/LocalDateTime.md",
    "name": "./esdoc/manual/LocalDateTime.md",
    "content": "# LocalDateTime\n\nA LocalDateTime represents a date-time with **no time zone** in the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) calendar system, such as '2007-12-03T10:15:30'.\n\n### Create a `LocalDateTime` instance\n\n```javascript\n// obtain the current date and time in the system default time zone, e.g. '2016-02-26T10:29:05.743'\nLocalDateTime.now();\n\n// obtain the current date and time in the UTC time zone\nLocalDateTime.now(ZoneOffset.UTC);\n\n// obtain an instance of LocalDateTime from an ISO 8601 formatted text string\nLocalDateTime.parse(\"2016-02-26T09:42\"); // '2016-02-26T09:42'\nLocalDateTime.parse(\"2016-02-26T09:42:42.123\"); // '2016-02-26T09:42:42.123'\n\n// obtain an instance of LocalDateTime from year, month, dayOfMonth, hour, minute, second and nanosecond values\nLocalDateTime.of(2016, 2, 29); // '2016-02-29T00:00'\nLocalDateTime.of(2016, 2, 29, 12, 55, 42); // '2016-02-29T12:55:42'\nLocalDateTime.of(2016, 2, 29, 12, 55, 42, 9); // '2016-02-29T12:55:42.000000009'\n\n// obtain an instance of LocalDateTime from epoch seconds and a ZoneOffset\nLocalDateTime.ofEpochSecond(0, ZoneOffset.UTC); // '1970-01-01T00:00'\nLocalDateTime.ofInstant(Instant.now()); // current local date-time\nLocalDateTime.ofInstant(Instant.now(), ZoneOffset.UTC); // current local UTC date-time\n```\n\n### Get values from `LocalDateTime`\n\n```javascript\nvar dt = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\n\ndt.toString(); // '2016-02-26T23:55:42.123' ISO 8601 format\n\ndt.year(); // 2016\ndt.month(); // Month.FEBRUARY\ndt.monthValue(); // 2\ndt.dayOfMonth(); // 26\ndt.hour(); // 23\ndt.minute(); // 55\ndt.second(); // 42\ndt.nano(); // 123000000\n\ndt.dayOfWeek(); // DayOfWeek.FRIDAY\ndt.dayOfWeek().value(); // 5\ndt.dayOfYear(); // 57\n\ndt.toLocalDate().isLeapYear(); // true 2016 is a leap year\n\n// obtain the date and time components of the LocalDateTime\ndt.toLocalDate();\ndt.toLocalTime();\n\n// get range of month\ndt.toLocalDate().lengthOfMonth(); // 29\ndt.range(ChronoField.DAY_OF_MONTH); // ValueRange(1 - 29)\n\n// get range of year\ndt.toLocalDate().lengthOfYear(); // 366\ndt.range(ChronoField.DAY_OF_YEAR); // ValueRange(1 - 366)\n\n// get other date-based fields like the aligned week of year\ndt.get(ChronoField.ALIGNED_WEEK_OF_YEAR); // 9\n\n// get week of week-based year\ndt.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR); // 8\ndt.toLocalDate().isoWeekOfWeekyear();\n\n// get other time-based fields\ndt.get(ChronoField.SECOND_OF_DAY); // 86142\ndt.get(ChronoField.MILLI_OF_SECOND); // 123\ndt.get(ChronoField.HOUR_OF_AMPM); // 11\n// any other date or time-based ChronoField can be passed to `get`\n```\n\n### Adding to and subtracting from a `LocalDateTime` instance\n\n```javascript\nvar dt = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\n\n// add/subtract 366 days\ndt.plusDays(366); // '2017-02-26T23:55:42.123'\ndt.minusDays(366); // '2015-02-25T23:55:42.123'\n\n// add/subtract 12 months\ndt.plusMonths(12); // '2017-02-26'\ndt.minusMonths(12); // '2015-02-26'\n\n// add/subtract 4 weeks\ndt.plusWeeks(4); // '2016-03-25T23:55:42.123'\ndt.minusWeeks(4); // '2016-01-29T23:55:42.123'\n\n// add/subtract 1 year to the parsed LocalDate and returns a new instance\ndt.plusYears(1); // '2017-02-26T23:55:42.123'\ndt.minusYears(1); // '2015-02-26T23:55:42.123'\n\n// add/subtract 30 years\ndt.plus(3, ChronoUnit.DECADES); // '2046-02-26T23:55:42.123'\ndt.minus(3, ChronoUnit.DECADES); // '1986-02-26T23:55:42.123'\n\n// add subtract a Period of 3 Months and 3 Days\ndt.plus(Period.ofMonths(3).plusDays(3)); // '2016-05-29T23:55:42.123'\ndt.minus(Period.ofMonths(3).plusDays(3)); // '2015-11-23T23:55:42.123'\n\n// add/subtract 12 hours\ndt.plusHours(12); // '2016-02-27T11:55:42.123'\ndt.minusHours(12); // '2016-02-26T11:55:42.123'\n\n// add/subtract 30 minutes\ndt.plusMinutes(30); // '2016-02-27T00:25:42.123'\ndt.minusMinutes(30); // '2016-02-26T23:25:42.123'\n\n// add/subtract 30 seconds\ndt.plusSeconds(30); // '2016-02-26T23:56:12.123'\ndt.minusSeconds(30); // '2016-02-26T23:55:12.123'\n\n// add/subtract 1 million nanoseconds (1 millisecond)\ndt.plusNanos(1000000); // '2016-02-26T23:55:42.124'\ndt.minusNanos(1000000); // '2016-02-26T23:55:42.122'\n\n// add/subtract a time-based unit\ndt.plus(1, ChronoUnit.MILLIS); // '2016-02-26T23:55:42.124'\ndt.plus(1, ChronoUnit.HALF_DAYS); // '2016-02-26T11:55:42.123'\n\n// add/subtract a duration of 30 hours and 45 minutes\ndt.plus(Duration.ofHours(30).plusMinutes(45)); // '2016-02-28T06:40:42.123'\ndt.minus(Duration.ofHours(30).plusMinutes(45)); // '2016-02-25T17:10:42.123'\n```\n\n### Alter specific fields of a `LocalDateTime` instance\n\n```javascript\nvar dt = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\n\n// set the hour of day to 1\ndt.withHour(1); // '2016-02-26T01:55:42.123'\n\n// set the minute of hour to 1\ndt.withMinute(1); // '2016-02-26T23:01:42.123'\n\n// set the second of minute to 1\ndt.withSecond(1); // '2016-02-26T23:55:01.123'\n\n// set the nanosecond of second to 1\ndt.withNano(0); // '2016-02-26T23:55:42'\n\n// set the millisecond of second to 51\ndt.with(ChronoField.MILLI_OF_SECOND, 51); // '2016-02-26T23:55:42.051'\n\n// set by a custom TemporalAdjuster that adjusts to the next even second\nvar nextEvenSecond = {\n  adjustInto: function(t) {\n    return t.second() % 2 === 0 ? t.plusSeconds(2) : t.plusSeconds(1);\n  }\n};\ndt.with(nextEvenSecond); // '2016-02-26T23:55:44.123'\ndt.plusSeconds(1).with(nextEvenSecond); // '2016-02-26T23:55:44.123'\n```\n\n### Truncate a `LocalDateTime` instance\n\n```javascript\nvar dt = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\n\ndt.truncatedTo(ChronoUnit.SECONDS); // '2016-02-26T23:55:42'\ndt.truncatedTo(ChronoUnit.MINUTES); // '2016-02-26T23:55:00'\ndt.truncatedTo(ChronoUnit.HOURS); // '2016-02-26T23:00'\ndt.truncatedTo(ChronoUnit.HALF_DAYS); // '2016-02-26T12:00'\ndt.truncatedTo(ChronoUnit.DAYS); // '2016-02-26T00:00'\n```\n\n### Compare `LocalDateTime` instances\n\n```javascript\nvar dt1 = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\nvar dt2 = dt1.plusHours(2);\n\ndt1.isAfter(dt2); // false\ndt1.isBefore(dt2); // true\n\ndt1.equals(dt1.plusHours(0)); // true\ndt1.equals(dt1.plusHours(1)); // false\n\ndt1.compareTo(dt1) === 0; // true\ndt1.compareTo(dt2) < 0; // true\ndt2.compareTo(dt1) > 0; // true\n\n// Warn! hashCode is equal if in instances are equal, but might be equal for unequal instances as well\ndt1.hashCode(); // -2036645668\ndt2.hashCode(); // 1459191821\ndt1.hashCode() !== dt2.hashCode(); // true\n```\n\n### Distance between two `LocalDateTime` instances\n\n```javascript\nvar dt1 = LocalDateTime.parse(\"2016-02-26T23:55:42.123\");\nvar dt2 = dt1\n  .plusYears(6)\n  .plusMonths(12)\n  .plusHours(2)\n  .plusMinutes(42)\n  .plusSeconds(12);\n\n// obtain the duration between the two dates\ndt1.until(dt2, ChronoUnit.YEARS); // 7\ndt1.until(dt2, ChronoUnit.MONTHS); // 84\ndt1.until(dt2, ChronoUnit.WEEKS); // 356\ndt1.until(dt2, ChronoUnit.DAYS); // 2557\ndt1.until(dt2, ChronoUnit.HOURS); // 61370\ndt1.until(dt2, ChronoUnit.MINUTES); // 3682242\ndt1.until(dt2, ChronoUnit.SECONDS); // 220934532\n```\n\n### Convert from a `moment` or JavaScript `Date`\n\n```javascript\n// obtain a LocalDateTime instance from a JavaScript Date\n\n// the manual way\nvar t = LocalDateTime.ofInstant(Instant.ofEpochMilli(new Date().getTime()));\n// the recommended way with the JavaScript temporal\nt = LocalDateTime.from(nativeJs(new Date()));\n// converting from a moment works the same way\nd = LocalDateTime.from(nativeJs(moment()));\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/ZonedDateTime.md",
    "name": "./esdoc/manual/ZonedDateTime.md",
    "content": "# ZonedDateTime\n\nA `ZonedDateTime` represents a date-time with a [time offset](https://en.wikipedia.org/wiki/UTC_offset) and/or a [time zone](https://en.wikipedia.org/wiki/Time_zone) in the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) calendar system.\n\nOn its own, `ZonedDateTime` only supports specifying **time offsets** such as `UTC` or `UTC+02:00`, plus the `SYSTEM` time zone ID.\n\n### The `SYSTEM` zone ID\n\nThe `SYSTEM` zone ID is a non-standard ID that is specific to `js-joda`. It represents the default time zone of the current JavaScript runtime. The JavaScript spec does not provide an API this; it only provides the system default time offset for a point in the timeline (`Date.prototype.getTimezoneOffset()`).\n\nYou should not exchange `ZonedDateTime` instances using the `SYSTEM` zone ID between JavaScript environments (e.g. between server and client, or between two servers). The time offset on another machine won't necessarily be the same as yours. Before sending a `ZonedDateTime` to someone else, convert it to a fixed offset:\n\n```javascript\n// current time with default `SYSTEM`\nZonedDateTime.now().toString(); // e.g. 2016-03-18T12:38:23.561+01:00[SYSTEM]\n\n// converted to a fixed time offset\nZonedDateTime.now()\n  .withFixedOffsetZone()\n  .toString(); // e.g. 2016-03-18T12:38:23.561+01:00\n```\n\n### Working with time zones\n\nA **time zone** and a **time offset** are [not the same thing](https://en.wikipedia.org/wiki/UTC_offset#Time_zones_and_time_offsets). Some timezones change from standard time to [daylight savings time](https://en.wikipedia.org/wiki/Daylight_saving_time) and back every year:\n\n- In the `Europe/Berlin` _time zone_, the _time offset_ is `UTC+2` during the summer, and `UTC+1` during the rest of the year.\n- In the `Africa/Lagos` _time zone_, on the other hand, the _time offset_ is `UTC+1` all year round.\n\nCalculations that might span time zones or daylight savings transitions need to reference the time zone, not just the offset.\n\nThe [@js-joda/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone) package provides bindings to the the [IANA tz database](https://www.iana.org/time-zones), making `joda-js`'s calculations time zone aware. The `tz` database uses zone names like `Africa/Bujumbura`, `America/New_York`, and `Europe/Lisbon` (see the [full list](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)).\n\nTo specify time zones using these names, you just need to `require` [@js-joda/timezone](//github.com/js-joda/js-joda/tree/main/packages/timezone).\n\n```javascript\nvar jsJoda = require(\"@js-joda/core\");\nrequire(\"@js-joda/timezone\");\n\nvar zdt = ZonedDateTime.now(ZoneId.of(\"Europe/Paris\"));\n```\n\n### Create a ZonedDateTime\n\n```javascript\n// get now with the default system time zone\nZonedDateTime.now().toString(); // e.g. 2016-03-18T12:38:23.561+01:00[SYSTEM]\n\n// get now with the UTC time zone\nZonedDateTime.now(ZoneOffset.UTC).toString(); // e.g. 2016-03-18T11:38:23.561Z\n\n// get now with a fixed offset time zone\nZonedDateTime.now(ZoneId.of(\"UTC-05:00\")).toString(); // e.g. 2016-03-18T06:38:23.561-05:00[UTC-05:00]\n\n// get now with a ZoneRegion (requires `@js-joda/timezone`)\nZonedDateTime.now(ZoneId.of(\"Europe/Paris\")).toString(); // e.g. 2017-02-04T17:01:15.846+01:00[Europe/Paris]\n\n// parse a date time with a time zone ISO String\nZonedDateTime.parse(\"2016-03-18T12:38:23.561+01:00[SYSTEM]\");\nZonedDateTime.parse(\"2016-03-18T12:38:23.561+01:00\");\nZonedDateTime.parse(\"2016-03-18T11:38:23.561Z\");\nZonedDateTime.parse(\"2016-03-18T06:38:23.561-05:00[UTC-05:00]\");\nZonedDateTime.parse(\"2017-02-04T17:01:15.846+01:00[Europe/Paris]\");\n\n// create from a LocalDate(Time) (requires `@js-joda/timezone`)\nLocalDate.parse(\"2012-06-06\")\n  .atStartOfDay()\n  .atZone(ZoneId.of(\"Europe/Paris\")); // 2012-06-06T00:00+02:00[Europe/Paris]\nZonedDateTime.of(\n  LocalDateTime.parse(\"2012-06-06T00:00\"),\n  ZoneId.of(\"Europe/Paris\")\n); // 2012-06-06T00:00+02:00[Europe/Paris]\nZonedDateTime.of(\n  LocalDate.parse(\"2012-06-06\"),\n  LocalTime.MIDNIGHT,\n  ZoneId.of(\"Europe/Paris\")\n); // 2012-06-06T00:00+02:00[Europe/Paris]\n\n// create from an Instant\nZonedDateTime.ofInstant(Instant.now(), ZoneId.SYSTEM); // current system time\n```\n\n### Switch time zones\n\n> These examples require `@js-joda/timezone`.\n\n```javascript\nvar d = LocalDate.of(2016, 3, 18);\nvar zdt = d.atTime(LocalTime.NOON).atZone(ZoneId.of(\"America/New_York\")); //2016-03-18T12:00-04:00[America/New_York]\n\n// switch time zone retaining the local date-time if possible\nzdt.withZoneSameLocal(ZoneId.of(\"Europe/Berlin\")); // 2016-03-18T12:00+01:00[Europe/Berlin]\n\n// switch time zone and retain the instant\nzdt.withZoneSameInstant(ZoneId.of(\"Europe/Berlin\")); // 2016-03-18T17:00+01:00[Europe/Berlin]\n```\n\n### Get and manipulate values from a `ZonedDateTime`\n\n`ZonedDateTime` implements the same methods as `LocalDateTime` for getting or setting values. See [the examples above](#get-values-from-localdatetime) for `LocalDateTime`.\n\n### Calculate values across daylight savings transitions\n\nWhen adding to or subtracting from a `ZonedDateTime` instance, the calculation is different depending on whether date or time units are passed.\n\n- Addition/subtraction of **date units** are made on the **local** timeline.\n- Addition/subtraction of **time units** are made on the **instant** timeline.\n\nThis example shows the difference for a daylight saving transition.\n\n```javascript\n// assume the system default time zone is CET; we define a time as 2016-03-18 at 17:00 local time\nvar zdt = ZonedDateTime.parse(\"2016-03-18T17:00+01:00[Europe/Berlin]\");\n\n// adding a date unit of 2 weeks, crossing a daylight saving transition\nzdt.plusWeeks(2); // 2016-04-01T17:00+02:00[Europe/Berlin] (still 17:00)\n\n// adding a time unit of 2 weeks (2 * 7 * 24)\nzdt.plusHours(2 * 7 * 24); // 2016-04-01T18:00+02:00[Europe/Berlin] (now 18:00)\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/Period.md",
    "name": "./esdoc/manual/Period.md",
    "content": "# Period\n\n`Period` is a **date-based** amount of time in the ISO-8601 calendar system, such as '2 years, 3 months and 4 days'.\n\n```javascript\n// parse and format ISO 8601 period strings\nPeriod.parse(\"P1Y10M\").toString(); // 'P1Y10M'\n\n// obtain a Period of 10 years, 5 month and 30 days\nPeriod.of(10, 5, 30).toString(); // 'P10Y5M30D'\n\n// 10 years\nPeriod.ofYears(10).toString(); // 'P10Y'\n\n// add 45 days to a Period\nPeriod.ofYears(10)\n  .plusDays(45)\n  .toString(); // 'P10Y45D'\n\n// normalize a Period of years and month\nPeriod.of(1, 37, 0)\n  .normalized()\n  .toString(); // 'P4Y1M'\n\n// add/subtract from a Period\nPeriod.ofYears(10)\n  .plusMonths(10)\n  .minusDays(42)\n  .toString(); // 'P10Y10M-42D'\n\n// add a Period to LocalDate\nvar p = Period.ofMonths(1);\nLocalDate.parse(\"2012-12-12\").plus(p); // '2013-01-12';\nLocalDate.parse(\"2012-01-31\").plus(p); // '2012-02-29';\nLocalDateTime.parse(\"2012-05-31T12:00\").plus(p); // '2012-06-30T12:00';\n\n// calculate the Period between two Dates\nPeriod.between(LocalDate.parse(\"2012-06-30\"), LocalDate.parse(\"2012-08-31\")); // 'P2M1D'\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/Duration.md",
    "name": "./esdoc/manual/Duration.md",
    "content": "# Duration\n\n`Duration` is a **time-based** amount of time, such as '34.5 seconds'.\n\n```javascript\n// obtain a Duration of 10 hours\nDuration.ofHours(10).toString(); // 'PT10H'\n\n// obtain a Duration of 10 days (10 x 24 hours)\nDuration.ofDays(10).toString(); // 'PT240H'\n\n// add/subtract a duration from a LocalDateTime\nvar dt = LocalDateTime.parse(\"2012-12-24T12:00\");\n\ndt.plus(Duration.ofHours(10).plusMinutes(30)).toString(); // '2012-12-24T22:30'\ndt.minus(Duration.ofHours(12).multipliedBy(10)).toString(); // '2012-12-19T12:00'\n\n// calculate the duration between two time-based values\nvar dt1 = LocalDateTime.parse(\"2012-12-24T12:00\");\n\nDuration.between(dt1, dt1.plusHours(10)).toString(); // 'PT10H'\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/Instant.md",
    "name": "./esdoc/manual/Instant.md",
    "content": "# Instant\n\nAn `Instant` is an instantaneous point on the time-line measured from the epoch of 1970-01-01T00:00:00Z in epoch-seconds and nanosecond-of-second.\n\n### Create an `Instant`\n\n```javascript\n// Obtain the current instant from the system clock\nInstant.now();\n\n// Obtain an instance of Instant using microseconds from the epoch of 1970-01-01T00:00:00Z. In this example, the Saturday, August 12, 2023 2:57:21 PM GMT\nInstant.ofEpochMicro(1691852241000000);\n\n// Obtain an instance of Instant using milliseconds from the epoch of 1970-01-01T00:00:00Z. In this example, the Saturday, August 12, 2023 2:57:21 PM GMT\nInstant.ofEpochMilli(1691852241000);\n\n// Obtain an instance of Instant using milliseconds from a JavaScript Date object\nInstant.ofEpochMilli(new Date().getTime());\n\n// Obtain an instance of Instant using milliseconds from the epoch of 1970-01-01T00:00:00Z\nInstant.ofEpochSecond(1691926326);\n\n// Obtain an instance of Instant from a text string such as 2007-12-03T10:15:30.000Z.\nInstant.parse('2007-12-03T10:15:30.000Z');\n```\n\n### Parsing and converting an `Instant`\n\n```javascript\nvar ins = Instant.parse('2007-12-03T10:15:30.000Z')\n\nins.toString(); // '2007-12-03T10:15:30Z'\nins.epochSecond();  // 1196676930\nins.toEpochMilli(); // 1196676930000\n\nins.atOffset(ZoneOffset.ofHours(1)); // '2007-12-03T11:15:30+01:00' returns an OffsetDateTime instance \nins.atZone(ZoneId.UTC); // '2007-12-03T10:15:30Z' returns a ZonedDateTime instance\n```\n\n### Adding to and subtracting from an `Instant`\n\nNote that each of these methods returns a new `Instant` instance.\n\n```javascript\nvar ins = Instant.parse('2007-12-03T10:15:30.000Z') // 1196676930 in epoch seconds\n\n// add/subtract seconds\nins.plusSeconds(1);  // 1196676931 or '2007-12-03T10:15:31.000Z'\nins.minusSeconds(1); // 1196676929 or '2007-12-03T10:15:29.000Z'\n\n// add/subtract milliseconds\nins.plusMillis(1);  // '2007-12-03T10:15:30.001Z'\nins.minusMillis(1); // '2007-12-03T10:15:29.999Z' \n\n// add/subtract microseconds\nins.plusMicros(1);  // '2007-12-03T10:15:30.000001Z'\nins.minusMicros(1); // '2007-12-03T10:15:29.999999Z'\n```\n\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/formatting.md",
    "name": "./esdoc/manual/formatting.md",
    "content": "# Formatting / Parsing\n\n## Formatting\n\nTo format a date and/or time, create a [`DateTimeFormatter`](https://js-joda.github.io/js-joda/class/packages/core/src/format/DateTimeFormatter.js~DateTimeFormatter.html) and pass it to the `.format` method of a `LocalDate`, `LocalTime`, `LocalDateTime`, or `ZonedDateTime` instance.\n\njs-joda built-in DateTimeFormatter parses and formats dates and times from /to ISO 8601 as specified in RFC 3339.\n\n\n```javascript\nconst d = LocalDateTime.parse('2018-04-28T12:34')\n\nd.format(DateTimeFormatter.ofPattern('M/d/yyyy')) // 4/28/2018\nd.format(DateTimeFormatter.ofPattern('HH:mm')) // 12:34\n```\n\n### Formatting with locales\n\nNon-numeric date and time formats need to know what language to use, for things like names of months and days of the week. For example, the format `eeee (d MMMM)` might return `Saturday (28 April)` in English, and `samedi (28 avril)` in French. If you try to use a locale-dependent format pattern without specifying the locale, you'll get this error message: \n\n```\nERROR: Pattern using (localized) text not implemented, use @js-joda/locale plugin!\n```\n\nTo specify a locale, you'll need to import the [`@js-joda/timezone`](//github.com/js-joda/js-joda/tree/main/packages/timezone) and [`@js-joda/locale`](//github.com/js-joda/js-joda/tree/main/packages/locale) plugins. The simplest way to use `@js-joda/locale` is to install one of the locale-specific builds from npm:\n\n- [@js-joda/locale_de](https://www.npmjs.com/package/@js-joda/locale_de)\n- [@js-joda/locale_de-de](https://www.npmjs.com/package/@js-joda/locale_de-de)\n- [@js-joda/locale_en](https://www.npmjs.com/package/@js-joda/locale_en)\n- [@js-joda/locale_en-us](https://www.npmjs.com/package/@js-joda/locale_en-us)\n- [@js-joda/locale_es](https://www.npmjs.com/package/@js-joda/locale_es)\n- [@js-joda/locale_fi](https://www.npmjs.com/package/@js-joda/locale_fi)\n- [@js-joda/locale_fi-fi](https://www.npmjs.com/package/@js-joda/locale_fi-fi)\n- [@js-joda/locale_fr](https://www.npmjs.com/package/@js-joda/locale_fr)\n- [@js-joda/locale_hi](https://www.npmjs.com/package/@js-joda/locale_hi)\n- [@js-joda/locale_it](https://www.npmjs.com/package/@js-joda/locale_it)\n- [@js-joda/locale_it-it](https://www.npmjs.com/package/@js-joda/locale_it-it)\n- [@js-joda/locale_zh](https://www.npmjs.com/package/@js-joda/locale_zh)\n\nYou can then use localized format strings as follows.\n\n```javascript\nimport '@js-joda/timezone' // Just needs to be imported; registers itself automatically\nimport { Locale } from '@js-joda/locale_fr' // Get `Locale` from the prebuilt package of your choice\nimport { DateTimeFormatter, LocalDateTime } from 'js-joda'\n\nconst d = LocalDateTime.parse('2018-04-28T12:34')\nconst formatter = DateTimeFormatter\n  .ofPattern('eeee (d MMMM)')\n  .withLocale(Locale.FRANCE)\nd.format(formatter) // samedi (28 avril)\n```\n\n**Note:** If internationalization is an important aspect of your application, you might consider using the standard [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) API instead. It is built into modern browsers, supports a comprehensive set of locales, and handles a lot of internationalization subtleties that go beyond the scope of this library. To do this, you would need to convert your `js-joda` dates and times to JavaScript `Date` objects just before outputting them:\n\n```javascript\nconst ldt = LocalDateTime.parse('2018-04-28T12:34')\n\nconst jsDate = convert(ldt).toDate() // Convert to JavaScript `Date` object\n\nvar options = { \n  weekday: 'long', \n  year: 'numeric', \n  month: 'long', \n  day: 'numeric', \n  hour: 'numeric', \n  minute: '2-digit' \n}\n\njsDate.toLocaleDateString('en-US', options) // Saturday, April 28, 2018, 12:34 PM \njsDate.toLocaleDateString('de-DE', options) // Samstag, 28. April 2018, 12:34\njsDate.toLocaleDateString('ar-EG', options) // السبت، ٢٨ أبريل ٢٠١٨ ١٢:٣٤ م\njsDate.toLocaleDateString('ko-KR', options) // 2018년 4월 28일 토요일 오후 12:34\n```\n\n\n### Format patterns\n\n\nDate and time formats are specified by date and time pattern strings using [Java SimpleDateFormat](https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html) codes.\n\n| Symbol | Meaning                    | Presentation | Examples                                       |\n| ------ | -------------------------- | ------------ | ---------------------------------------------- |\n| G      | era                        | number/text  | 1; 01; AD; Anno Domini                         |\n| u      | year                       | year         | 2004; 04                                       |\n| y      | year-of-era                | year         | 2004; 04                                       |\n| D      | day-of-year                | number       | 189                                            |\n| M      | month-of-year              | number/text  | 7; 07; Jul; July; J                            |\n| d      | day-of-month               | number       | 10                                             |\n| Q      | quarter-of-year            | number/text  | 3; 03; Q3                                      |\n| Y      | week-based-year            | year         | 1996; 96                                       |\n| w      | week-of-year               | number       | 27                                             |\n| W      | week-of-month              | number       | 27                                             |\n| e      | localized day-of-week      | number       | 2; Tue; Tuesday; T                             |\n| E      | day-of-week                | number/text  | 2; Tue; Tuesday; T                             |\n| F      | week-of-month              | number       | 3                                              |\n| a      | am-pm-of-day               | text         | PM                                             |\n| h      | clock-hour-of-am-pm (1-12) | number       | 12                                             |\n| K      | hour-of-am-pm (0-11)       | number       | 0                                              |\n| k      | clock-hour-of-am-pm (1-24) | number       | 0                                              |\n| H      | hour-of-day (0-23)         | number       | 0                                              |\n| m      | minute-of-hour             | number       | 30                                             |\n| s      | second-of-minute           | number       | 55                                             |\n| S      | fraction-of-second         | fraction     | 978                                            |\n| A      | milli-of-day               | number       | 1234                                           |\n| n      | nano-of-second             | number       | 987654321                                      |\n| N      | nano-of-day                | number       | 1234000000                                     |\n| V      | time-zone ID               | zone-id      | America/Los_Angeles; Z; -08:30                 |\n| z      | time-zone name             | zone-name    | Pacific Standard Time; PST                     |\n| X      | zone-offset 'Z' for zero   | offset-X     | Z; -08; -0830; -08:30; -083015; -08:30:15;     |\n| x      | zone-offset                | offset-x     | +0000; -08; -0830; -08:30; -083015; -08:30:15; |\n| Z      | zone-offset                | offset-Z     | +0000; -0800; -08:00;                          |\n| p      | pad next                   | pad modifier | 1                                              |\n| '      | escape for text            | delimiter    |\n| ''     | single quote               | literal      | '                                              |\n| [      | optional section start     |              |\n| ]      | optional section end       |              |\n| {}     | reserved for future use    |              |\n\n## Parsing\n\nParsing is similar to formatting, the same DateTimeFormatter pattern are used as for formatting.\n\nCustomized parser can be build with the `DateTimeFormatter`.\n\n### Simple parser example\n\n```javascript\nimport { DateTimeFormatter, LocalDate } from '@js-joda/core';\n\nconst formatter = DateTimeFormatter.ofPattern('M/d/yyyy');\nconst date = LocalDate.parse('4/28/2018', formatter);\nconsole.log(date.toString()); // 2018-04-28\n```\n\n### http date parser example\n\nExample for an HTTP dates formatter as specified in RFC 7321, \nlike returned by javascript native `Date` `toUTCString` method.\n\nThis formatter requires the `@js-joda/locale` package.\nThis formatter is built-in since @js-joda/locale@4.2.0 -> RFC_1123_DATE_TIME\n\n```javascript\nimport { DateTimeFormatter, ZonedDateTime } from '@js-joda/core';\nimport '@js-joda/timezone'\nimport { Locale } from '@js-joda/locale';\n\nconst df = DateTimeFormatter.ofPattern('EEE, dd MMM yyyy HH:mm:ss z').withLocale(Locale.ENGLISH);\nconst z = ZonedDateTime.parse('Tue, 05 Oct 2021 17:08:24 GMT', df);\nconsole.log(z.toString()); // 2021-10-05T17:08:24+01:00[GMT]\n```\n\n## Built-in DateTimeFormatter\n\n| Formatter             | Example                                   |\n| --------------------- |------------------------------------------ |\n| ISO_LOCAL_DATE        |  '2011-12-03' |\n| ISO_LOCAL_TIME        | '10:15:30' |\n| ISO_LOCAL_DATE_TIME   | '2011-12-03T10:15:30' |\n| ISO_INSTANT           | '2011-12-03T10:15:30Z' |\n| ISO_OFFSET_DATE_TIME  | '2011-12-03T10:15:30+01:00' |\n| ISO_ZONED_DATE_TIME   | '2011-12-03T10:15:30+01:00[Europe/Paris]' |\n| BASIC_ISO_DATE        | '20111203' |\n| ISO_OFFSET_DATE       | '2011-12-03+01:00' |\n| ISO_OFFSET_TIME       | '10:15:30+01:00' |\n| ISO_ORDINAL_DATE      | '2012-337' |   \n| ISO_WEEK_DATE         | '2012-W48-6' |\n| ISO_DATE              | '2011-12-03+01:00', '2011-12-03' |\n| ISO_TIME              | '10:15:30+01:00', '10:15:30' |\n| ISO_DATE_TIME         | '2011-12-03T10:15:30+01:00[Europe/Paris]' |\n| RFC_1123_DATE_TIME    | 'Tue, 05 Oct 2021 17:08:24 GMT'<br />requires @js-joda/locale |\n\nUsage example for a built-in DateTimeFormatter\n\n````javascript\nconst localDate = LocalDate.parse('2012-12-12', DateTimeFormatter.ISO_LOCAL_DATE);\nconst dateAsString = LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE);\n````\n\n## Hint\n\nWhenever you stumble over a `Cannot read property 'localeString' of null` error, \nits probably because the locale of the formatter is not set. \n\nIn that case add the `@js-joda/locale` package to your project and set the locale\nof the formatter, eg `DateTimeFormatter.ofPattern('eeee (d MMMM)').withLocale(Locale.FRANCE)`.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/Locale.md",
    "name": "./esdoc/manual/Locale.md",
    "content": "# Using locale package\n\n## Motivation\n\nImplementation of locale specific functionality for js-joda, providing function not implemented in js-joda core\n\nEspecially this implements patterns elements to print and parse locale specific dates.\n\n## Node\n\nIn a node environment, the best choice is to install `@js-joda/locale` and \nthe cldr data `cldr-data` separately. With that you have support for all locales defined in the cldr project.\nThe timezone package is required as soon as timezone locales come into play.\n\n```shell\n    npm install @js-joda/core\n    npm install @js-joda/timezone\n    npm install cldr-data\n    npm install cldrjs\n    npm install @js-joda/locale\n```\n\n## Browser\n\nIn a browser environment, to save space, the better choice is to install one of the pre-built packages\nfor a certain language. \nThe pre-built packages contain the implementation and all cldr data required for that specific locale.\n\nFor more information check the [README.md](https://github.com/js-joda/js-joda/blob/main/packages/locale/README.md)\nin the locale package.\n\n```shell\n    npm install @js-joda/locale_en\n    npm install @js-joda/timezone\n```\n\n## Usage\n\n```javascript\nconst {\n    DateTimeFormatter,\n    ZonedDateTime,\n    ZoneId,\n} = require('@js-joda/core');\nrequire('@js-joda/timezone');\n\nconst {\n    Locale,\n} = require('@js-joda/locale_en-us');\n\nvar zdt = ZonedDateTime.of(2016, 1, 1, 0, 0, 0, 0, ZoneId.of('Europe/Berlin'));\nconsole.log('en_US formatted string:', \n    zdt.format(\n        DateTimeFormatter\n            .ofPattern('eeee MMMM dd yyyy GGGG, hh:mm:ss a zzzz, \\'Week \\' ww, \\'Quarter \\' QQQ')\n            .withLocale(Locale.US)));\n```\n\nthis will output `en_US formatted string: Friday January 01 2016 Anno Domini, 12:00:00 AM Central European Time, Week  01, Quarter  Q1`\n\n## Links\n\nFor more information check the [README.md](https://github.com/js-joda/js-joda/blob/main/packages/locale/README.md)\nin the locale package.\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/customizing.md",
    "name": "./esdoc/manual/customizing.md",
    "content": "# Customizing js-joda\n\nThis package is extensible, allowing you to create your own custom temporal calculations. See the [temporal interface documentation](https://js-joda.github.io/js-joda/class/packages/core/src/temporal/Temporal.js~Temporal.html) for more information.\n\n### Custom temporal adjuster\n\n```javascript\n// implement a TemporalAdjuster that the next or same even day of month\nvar nextOrSameEvenDay = {\n  adjustInto: function(t) {\n    return t.dayOfMonth() % 2 === 0 ? t : t.plusDays(1);\n  }\n};\n\nLocalDateTime.parse(\"2012-12-23T12:00\").with(nextOrSameEvenDay); // '2012-12-24T12:00'\nLocalDate.parse(\"2012-12-24\").with(nextOrSameEvenDay); // '2012-12-24'\n```\n\n### Custom temporal fields and temporal units\n\nSee the source for [temporal/IsoFields](https://js-joda.github.io/js-joda/typedef/index.html#static-typedef-IsoFields) as an example how to implement custom fields and units. `IsoFields` implements fields and units for an ISO week-based year.\n\n### Custom formatter and queries\n\nThe following example implements a parser for a local date with an optional local time. It returns either a `LocalDate` or a `LocalDateTime`, depending on the parsed fields.\n\n```javascript\n// build a custom date time formatter where the time field is optional\nvar OPTIONAL_FORMATTER = DateTimeFormatter.ofPattern(\n  'yyyy-MM-dd['T'HH:mm[:ss]]'\n);\n\n// create a temporal query that create a new Temporal depending on the existing fields\ndateOrDateTimeQuery = {\n  queryFrom: function(temporal) {\n    var date = temporal.query(TemporalQueries.localDate());\n    var time = temporal.query(TemporalQueries.localTime());\n    if (time == null) return date;\n    else return date.atTime(time);\n  }\n};\n\nlocalDate = OPTIONAL_FORMATTER.parse('2012-12-24', dateOrDateTimeQuery);\nlocalDateTime = OPTIONAL_FORMATTER.parse(\n  '2012-12-24T23:59',\n  dateOrDateTimeQuery\n);\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/pithu/Projects/js-joda/js-joda-project/js-joda/esdoc/manual/convert-native.md",
    "name": "./esdoc/manual/convert-native.md",
    "content": "# Convert from/ to native js\n\n## Convert from Date to a js-joda temporal\n\nuse method `nativeJs` to convert from native javascript `Date` to a js-joda `ZonedDateTime`.\n\nHint: `nativeJs` accepts `moment` objects as well.\n\nBe aware of that a Date always represent a certain point in time _without_ a timezone.\nYou can provide one by passing it as a second argument.\nOtherwise, `ZoneId.systemDefault()` will be used.\n\n```javascript\nimport { ZonedDateTime, nativeJs } from '@js-joda/core';\n\nconst zonedDateTime = nativeJs(new Date());\n\n// or with momentjs object\nconst zonedDateTime = nativeJs(moment());\n```\n\n## Convert from js-joda temporal to a Date\n\nUse method `convert` to convert a `LocalDate` | `LocalDateTime` | `ZonedDateTime` | `Instant` \nto javascript `Date`.\n\n```javascript\nconst date = convert(Instant.now()).toDate();\n```\n",
    "static": true,
    "access": "public"
  }
]